/*! bg.js is part of the Webrecorder ArchiveWeb.page (https://archiveweb.page) Copyright (C) 2020-2024, Webrecorder Software. Licensed under the Affero General Public License v3. */ (() => {
    var e = {
        7526: (e, t) => {
          "use strict";
          (t.byteLength = function (e) {
            var t = o(e),
              r = t[0],
              i = t[1];
            return (3 * (r + i)) / 4 - i;
          }),
            (t.toByteArray = function (e) {
              var t,
                r,
                n = o(e),
                a = n[0],
                c = n[1],
                l = new s(
                  (function (e, t, r) {
                    return (3 * (t + r)) / 4 - r;
                  })(0, a, c)
                ),
                h = 0,
                u = c > 0 ? a - 4 : a;
              for (r = 0; r < u; r += 4)
                (t =
                  (i[e.charCodeAt(r)] << 18) |
                  (i[e.charCodeAt(r + 1)] << 12) |
                  (i[e.charCodeAt(r + 2)] << 6) |
                  i[e.charCodeAt(r + 3)]),
                  (l[h++] = (t >> 16) & 255),
                  (l[h++] = (t >> 8) & 255),
                  (l[h++] = 255 & t);
              2 === c &&
                ((t = (i[e.charCodeAt(r)] << 2) | (i[e.charCodeAt(r + 1)] >> 4)),
                (l[h++] = 255 & t));
              1 === c &&
                ((t =
                  (i[e.charCodeAt(r)] << 10) |
                  (i[e.charCodeAt(r + 1)] << 4) |
                  (i[e.charCodeAt(r + 2)] >> 2)),
                (l[h++] = (t >> 8) & 255),
                (l[h++] = 255 & t));
              return l;
            }),
            (t.fromByteArray = function (e) {
              for (
                var t,
                  i = e.length,
                  s = i % 3,
                  n = [],
                  a = 16383,
                  o = 0,
                  l = i - s;
                o < l;
                o += a
              )
                n.push(c(e, o, o + a > l ? l : o + a));
              1 === s
                ? ((t = e[i - 1]), n.push(r[t >> 2] + r[(t << 4) & 63] + "=="))
                : 2 === s &&
                  ((t = (e[i - 2] << 8) + e[i - 1]),
                  n.push(r[t >> 10] + r[(t >> 4) & 63] + r[(t << 2) & 63] + "="));
              return n.join("");
            });
          for (
            var r = [],
              i = [],
              s = "undefined" != typeof Uint8Array ? Uint8Array : Array,
              n =
                "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
              a = 0;
            a < 64;
            ++a
          )
            (r[a] = n[a]), (i[n.charCodeAt(a)] = a);
          function o(e) {
            var t = e.length;
            if (t % 4 > 0)
              throw new Error("Invalid string. Length must be a multiple of 4");
            var r = e.indexOf("=");
            return -1 === r && (r = t), [r, r === t ? 0 : 4 - (r % 4)];
          }
          function c(e, t, i) {
            for (var s, n, a = [], o = t; o < i; o += 3)
              (s =
                ((e[o] << 16) & 16711680) +
                ((e[o + 1] << 8) & 65280) +
                (255 & e[o + 2])),
                a.push(
                  r[((n = s) >> 18) & 63] +
                    r[(n >> 12) & 63] +
                    r[(n >> 6) & 63] +
                    r[63 & n]
                );
            return a.join("");
          }
          (i["-".charCodeAt(0)] = 62), (i["_".charCodeAt(0)] = 63);
        },
        6035: (e) => {
          var t = 4096,
            r = new Uint32Array([
              0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191,
              16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151,
              4194303, 8388607, 16777215,
            ]);
          function i(e) {
            (this.buf_ = new Uint8Array(8224)), (this.input_ = e), this.reset();
          }
          (i.READ_SIZE = t),
            (i.IBUF_MASK = 8191),
            (i.prototype.reset = function () {
              (this.buf_ptr_ = 0),
                (this.val_ = 0),
                (this.pos_ = 0),
                (this.bit_pos_ = 0),
                (this.bit_end_pos_ = 0),
                (this.eos_ = 0),
                this.readMoreInput();
              for (var e = 0; e < 4; e++)
                (this.val_ |= this.buf_[this.pos_] << (8 * e)), ++this.pos_;
              return this.bit_end_pos_ > 0;
            }),
            (i.prototype.readMoreInput = function () {
              if (!(this.bit_end_pos_ > 256))
                if (this.eos_) {
                  if (this.bit_pos_ > this.bit_end_pos_)
                    throw new Error(
                      "Unexpected end of input " +
                        this.bit_pos_ +
                        " " +
                        this.bit_end_pos_
                    );
                } else {
                  var e = this.buf_ptr_,
                    r = this.input_.read(this.buf_, e, t);
                  if (r < 0) throw new Error("Unexpected end of input");
                  if (r < t) {
                    this.eos_ = 1;
                    for (var i = 0; i < 32; i++) this.buf_[e + r + i] = 0;
                  }
                  if (0 === e) {
                    for (i = 0; i < 32; i++) this.buf_[8192 + i] = this.buf_[i];
                    this.buf_ptr_ = t;
                  } else this.buf_ptr_ = 0;
                  this.bit_end_pos_ += r << 3;
                }
            }),
            (i.prototype.fillBitWindow = function () {
              for (; this.bit_pos_ >= 8; )
                (this.val_ >>>= 8),
                  (this.val_ |= this.buf_[8191 & this.pos_] << 24),
                  ++this.pos_,
                  (this.bit_pos_ = (this.bit_pos_ - 8) >>> 0),
                  (this.bit_end_pos_ = (this.bit_end_pos_ - 8) >>> 0);
            }),
            (i.prototype.readBits = function (e) {
              32 - this.bit_pos_ < e && this.fillBitWindow();
              var t = (this.val_ >>> this.bit_pos_) & r[e];
              return (this.bit_pos_ += e), t;
            }),
            (e.exports = i);
        },
        2805: (e, t) => {
          (t.lookup = new Uint8Array([
            0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 12, 16, 12, 12, 20, 12, 16, 24, 28, 12,
            12, 32, 12, 36, 12, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 32, 32,
            24, 40, 28, 12, 12, 48, 52, 52, 52, 48, 52, 52, 52, 48, 52, 52, 52,
            52, 52, 48, 52, 52, 52, 52, 52, 48, 52, 52, 52, 52, 52, 24, 12, 28,
            12, 12, 12, 56, 60, 60, 60, 56, 60, 60, 60, 56, 60, 60, 60, 60, 60,
            56, 60, 60, 60, 60, 60, 56, 60, 60, 60, 60, 60, 24, 12, 28, 12, 0, 0,
            1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
            0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
            1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 2, 3, 2, 3, 2, 3,
            2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2,
            3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3,
            2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2,
            2, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 3,
            3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1,
            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
            3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
            3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
            3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
            5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 0, 8, 8, 8, 8,
            8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 16, 16, 16, 16, 16, 16, 16, 16, 16,
            16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
            16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
            16, 16, 16, 16, 16, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
            24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
            24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
            24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
            24, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
            32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
            32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
            32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 40, 40, 40,
            40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
            40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
            40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 48, 48, 48, 48, 48, 48,
            48, 48, 48, 48, 48, 48, 48, 48, 48, 56, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
            10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26,
            27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60,
            61, 62, 63, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
            17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33,
            34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50,
            51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 0, 1, 2, 3, 4, 5,
            6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
            24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
            41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57,
            58, 59, 60, 61, 62, 63, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,
            14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,
            31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
            48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 0, 0,
            0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 6,
            6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 11, 11,
            11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15,
            15, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19,
            20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23, 24,
            24, 24, 24, 25, 25, 25, 25, 26, 26, 26, 26, 27, 27, 27, 27, 28, 28,
            28, 28, 29, 29, 29, 29, 30, 30, 30, 30, 31, 31, 31, 31, 32, 32, 32,
            32, 33, 33, 33, 33, 34, 34, 34, 34, 35, 35, 35, 35, 36, 36, 36, 36,
            37, 37, 37, 37, 38, 38, 38, 38, 39, 39, 39, 39, 40, 40, 40, 40, 41,
            41, 41, 41, 42, 42, 42, 42, 43, 43, 43, 43, 44, 44, 44, 44, 45, 45,
            45, 45, 46, 46, 46, 46, 47, 47, 47, 47, 48, 48, 48, 48, 49, 49, 49,
            49, 50, 50, 50, 50, 51, 51, 51, 51, 52, 52, 52, 52, 53, 53, 53, 53,
            54, 54, 54, 54, 55, 55, 55, 55, 56, 56, 56, 56, 57, 57, 57, 57, 58,
            58, 58, 58, 59, 59, 59, 59, 60, 60, 60, 60, 61, 61, 61, 61, 62, 62,
            62, 62, 63, 63, 63, 63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          ])),
            (t.lookupOffsets = new Uint16Array([
              1024, 1536, 1280, 1536, 0, 256, 768, 512,
            ]));
        },
        9206: (e, t, r) => {
          var i = r(4927).z,
            s = r(4927).y,
            n = r(6035),
            a = r(8712),
            o = r(8171).z,
            c = r(8171).u,
            l = r(2805),
            h = r(7708),
            u = r(8270),
            d = 8,
            p = 16,
            f = 256,
            g = 704,
            m = 26,
            y = 6,
            A = 2,
            w = 8,
            E = 255,
            b = 1080,
            v = 18,
            I = new Uint8Array([
              1, 2, 3, 4, 0, 5, 17, 6, 16, 7, 8, 9, 10, 11, 12, 13, 14, 15,
            ]),
            S = 16,
            T = new Uint8Array([3, 2, 1, 0, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2]),
            _ = new Int8Array([
              0, 0, 0, 0, -1, 1, -2, 2, -3, 3, -1, 1, -2, 2, -3, 3,
            ]),
            C = new Uint16Array([
              256, 402, 436, 468, 500, 534, 566, 598, 630, 662, 694, 726, 758,
              790, 822, 854, 886, 920, 952, 984, 1016, 1048, 1080,
            ]);
          function x(e) {
            var t;
            return 0 === e.readBits(1)
              ? 16
              : (t = e.readBits(3)) > 0
              ? 17 + t
              : (t = e.readBits(3)) > 0
              ? 8 + t
              : 17;
          }
          function N(e) {
            if (e.readBits(1)) {
              var t = e.readBits(3);
              return 0 === t ? 1 : e.readBits(t) + (1 << t);
            }
            return 0;
          }
          function k() {
            (this.meta_block_length = 0),
              (this.input_end = 0),
              (this.is_uncompressed = 0),
              (this.is_metadata = !1);
          }
          function R(e) {
            var t,
              r,
              i,
              s = new k();
            if (((s.input_end = e.readBits(1)), s.input_end && e.readBits(1)))
              return s;
            if (7 === (t = e.readBits(2) + 4)) {
              if (((s.is_metadata = !0), 0 !== e.readBits(1)))
                throw new Error("Invalid reserved bit");
              if (0 === (r = e.readBits(2))) return s;
              for (i = 0; i < r; i++) {
                var n = e.readBits(8);
                if (i + 1 === r && r > 1 && 0 === n)
                  throw new Error("Invalid size byte");
                s.meta_block_length |= n << (8 * i);
              }
            } else
              for (i = 0; i < t; ++i) {
                var a = e.readBits(4);
                if (i + 1 === t && t > 4 && 0 === a)
                  throw new Error("Invalid size nibble");
                s.meta_block_length |= a << (4 * i);
              }
            return (
              ++s.meta_block_length,
              s.input_end || s.is_metadata || (s.is_uncompressed = e.readBits(1)),
              s
            );
          }
          function B(e, t, r) {
            var i;
            return (
              r.fillBitWindow(),
              (i = e[(t += (r.val_ >>> r.bit_pos_) & E)].bits - w) > 0 &&
                ((r.bit_pos_ += w),
                (t += e[t].value),
                (t += (r.val_ >>> r.bit_pos_) & ((1 << i) - 1))),
              (r.bit_pos_ += e[t].bits),
              e[t].value
            );
          }
          function D(e, t, r, i) {
            var s,
              n,
              a = new Uint8Array(e);
            if ((i.readMoreInput(), 1 === (n = i.readBits(2)))) {
              for (
                var l = e - 1,
                  h = 0,
                  u = new Int32Array(4),
                  f = i.readBits(2) + 1;
                l;
  
              )
                (l >>= 1), ++h;
              for (g = 0; g < f; ++g) (u[g] = i.readBits(h) % e), (a[u[g]] = 2);
              switch (((a[u[0]] = 1), f)) {
                case 1:
                  break;
                case 3:
                  if (u[0] === u[1] || u[0] === u[2] || u[1] === u[2])
                    throw new Error("[ReadHuffmanCode] invalid symbols");
                  break;
                case 2:
                  if (u[0] === u[1])
                    throw new Error("[ReadHuffmanCode] invalid symbols");
                  a[u[1]] = 1;
                  break;
                case 4:
                  if (
                    u[0] === u[1] ||
                    u[0] === u[2] ||
                    u[0] === u[3] ||
                    u[1] === u[2] ||
                    u[1] === u[3] ||
                    u[2] === u[3]
                  )
                    throw new Error("[ReadHuffmanCode] invalid symbols");
                  i.readBits(1) ? ((a[u[2]] = 3), (a[u[3]] = 3)) : (a[u[0]] = 2);
              }
            } else {
              var g,
                m = new Uint8Array(v),
                y = 32,
                A = 0,
                E = [
                  new o(2, 0),
                  new o(2, 4),
                  new o(2, 3),
                  new o(3, 2),
                  new o(2, 0),
                  new o(2, 4),
                  new o(2, 3),
                  new o(4, 1),
                  new o(2, 0),
                  new o(2, 4),
                  new o(2, 3),
                  new o(3, 2),
                  new o(2, 0),
                  new o(2, 4),
                  new o(2, 3),
                  new o(4, 5),
                ];
              for (g = n; g < v && y > 0; ++g) {
                var b,
                  S = I[g],
                  T = 0;
                i.fillBitWindow(),
                  (T += (i.val_ >>> i.bit_pos_) & 15),
                  (i.bit_pos_ += E[T].bits),
                  (b = E[T].value),
                  (m[S] = b),
                  0 !== b && ((y -= 32 >> b), ++A);
              }
              if (1 !== A && 0 !== y)
                throw new Error("[ReadHuffmanCode] invalid num_codes or space");
              !(function (e, t, r, i) {
                for (
                  var s = 0, n = d, a = 0, l = 0, h = 32768, u = [], f = 0;
                  f < 32;
                  f++
                )
                  u.push(new o(0, 0));
                for (c(u, 0, 5, e, v); s < t && h > 0; ) {
                  var g,
                    m = 0;
                  if (
                    (i.readMoreInput(),
                    i.fillBitWindow(),
                    (m += (i.val_ >>> i.bit_pos_) & 31),
                    (i.bit_pos_ += u[m].bits),
                    (g = 255 & u[m].value) < p)
                  )
                    (a = 0),
                      (r[s++] = g),
                      0 !== g && ((n = g), (h -= 32768 >> g));
                  else {
                    var y,
                      A,
                      w = g - 14,
                      E = 0;
                    if (
                      (g === p && (E = n),
                      l !== E && ((a = 0), (l = E)),
                      (y = a),
                      a > 0 && ((a -= 2), (a <<= w)),
                      s + (A = (a += i.readBits(w) + 3) - y) > t)
                    )
                      throw new Error(
                        "[ReadHuffmanCodeLengths] symbol + repeat_delta > num_symbols"
                      );
                    for (var b = 0; b < A; b++) r[s + b] = l;
                    (s += A), 0 !== l && (h -= A << (15 - l));
                  }
                }
                if (0 !== h)
                  throw new Error("[ReadHuffmanCodeLengths] space = " + h);
                for (; s < t; s++) r[s] = 0;
              })(m, e, a, i);
            }
            if (0 === (s = c(t, r, w, a, e)))
              throw new Error("[ReadHuffmanCode] BuildHuffmanTable failed: ");
            return s;
          }
          function O(e, t, r) {
            var i, s;
            return (
              (i = B(e, t, r)),
              (s = h.kBlockLengthPrefixCode[i].nbits),
              h.kBlockLengthPrefixCode[i].offset + r.readBits(s)
            );
          }
          function L(e, t, r) {
            var i;
            return (
              e < S ? ((r += T[e]), (i = t[(r &= 3)] + _[e])) : (i = e - S + 1), i
            );
          }
          function P(e, t) {
            for (var r = e[t], i = t; i; --i) e[i] = e[i - 1];
            e[0] = r;
          }
          function U(e, t) {
            (this.alphabet_size = e),
              (this.num_htrees = t),
              (this.codes = new Array(t + t * C[(e + 31) >>> 5])),
              (this.htrees = new Uint32Array(t));
          }
          function M(e, t) {
            var r,
              i,
              s = { num_htrees: null, context_map: null },
              n = 0;
            t.readMoreInput();
            var a = (s.num_htrees = N(t) + 1),
              c = (s.context_map = new Uint8Array(e));
            if (a <= 1) return s;
            for (
              t.readBits(1) && (n = t.readBits(4) + 1), r = [], i = 0;
              i < b;
              i++
            )
              r[i] = new o(0, 0);
            for (D(a + n, r, 0, t), i = 0; i < e; ) {
              var l;
              if ((t.readMoreInput(), 0 === (l = B(r, 0, t)))) (c[i] = 0), ++i;
              else if (l <= n)
                for (var h = 1 + (1 << l) + t.readBits(l); --h; ) {
                  if (i >= e)
                    throw new Error("[DecodeContextMap] i >= context_map_size");
                  (c[i] = 0), ++i;
                }
              else (c[i] = l - n), ++i;
            }
            return (
              t.readBits(1) &&
                (function (e, t) {
                  var r,
                    i = new Uint8Array(256);
                  for (r = 0; r < 256; ++r) i[r] = r;
                  for (r = 0; r < t; ++r) {
                    var s = e[r];
                    (e[r] = i[s]), s && P(i, s);
                  }
                })(c, e),
              s
            );
          }
          function F(e, t, r, i, s, n, a) {
            var o,
              c = 2 * r,
              l = r,
              h = B(t, r * b, a);
            (o =
              0 === h
                ? s[c + (1 & n[l])]
                : 1 === h
                ? s[c + ((n[l] - 1) & 1)] + 1
                : h - 2) >= e && (o -= e),
              (i[r] = o),
              (s[c + (1 & n[l])] = o),
              ++n[l];
          }
          function H(e, t, r, i, s, a) {
            var o,
              c = s + 1,
              l = r & s,
              h = a.pos_ & n.IBUF_MASK;
            if (t < 8 || a.bit_pos_ + (t << 3) < a.bit_end_pos_)
              for (; t-- > 0; )
                a.readMoreInput(),
                  (i[l++] = a.readBits(8)),
                  l === c && (e.write(i, c), (l = 0));
            else {
              if (a.bit_end_pos_ < 32)
                throw new Error(
                  "[CopyUncompressedBlockToOutput] br.bit_end_pos_ < 32"
                );
              for (; a.bit_pos_ < 32; )
                (i[l] = a.val_ >>> a.bit_pos_), (a.bit_pos_ += 8), ++l, --t;
              if (h + (o = (a.bit_end_pos_ - a.bit_pos_) >> 3) > n.IBUF_MASK) {
                for (var u = n.IBUF_MASK + 1 - h, d = 0; d < u; d++)
                  i[l + d] = a.buf_[h + d];
                (o -= u), (l += u), (t -= u), (h = 0);
              }
              for (d = 0; d < o; d++) i[l + d] = a.buf_[h + d];
              if (((t -= o), (l += o) >= c)) {
                e.write(i, c), (l -= c);
                for (d = 0; d < l; d++) i[d] = i[c + d];
              }
              for (; l + t >= c; ) {
                if (((o = c - l), a.input_.read(i, l, o) < o))
                  throw new Error(
                    "[CopyUncompressedBlockToOutput] not enough bytes"
                  );
                e.write(i, c), (t -= o), (l = 0);
              }
              if (a.input_.read(i, l, t) < t)
                throw new Error(
                  "[CopyUncompressedBlockToOutput] not enough bytes"
                );
              a.reset();
            }
          }
          function Q(e) {
            var t = (e.bit_pos_ + 7) & -8;
            return 0 == e.readBits(t - e.bit_pos_);
          }
          function V(e) {
            var t = new i(e),
              r = new n(t);
            return x(r), R(r).meta_block_length;
          }
          function z(e, t) {
            var r,
              i,
              s,
              c,
              d,
              p,
              w,
              E,
              v,
              I,
              T = 0,
              _ = 0,
              C = 0,
              k = [16, 15, 11, 4],
              P = 0,
              V = 0,
              z = 0,
              q = [new U(0, 0), new U(0, 0), new U(0, 0)],
              G = 128 + n.READ_SIZE;
            (s = (1 << (i = x((I = new n(e))))) - 16),
              (d = (c = 1 << i) - 1),
              (p = new Uint8Array(c + G + a.maxDictionaryWordLength)),
              (w = c),
              (E = []),
              (v = []);
            for (var j = 0; j < 3 * b; j++)
              (E[j] = new o(0, 0)), (v[j] = new o(0, 0));
            for (; !_; ) {
              var W,
                Y,
                X,
                K,
                J,
                Z,
                $,
                ee,
                te,
                re,
                ie,
                se = 0,
                ne = [1 << 28, 1 << 28, 1 << 28],
                ae = [0],
                oe = [1, 1, 1],
                ce = [0, 1, 0, 1, 0, 1],
                le = [0],
                he = null,
                ue = null,
                de = 0,
                pe = null,
                fe = 0,
                ge = 0,
                me = 0;
              for (r = 0; r < 3; ++r) (q[r].codes = null), (q[r].htrees = null);
              I.readMoreInput();
              var ye = R(I);
              if (T + (se = ye.meta_block_length) > t.buffer.length) {
                var Ae = new Uint8Array(T + se);
                Ae.set(t.buffer), (t.buffer = Ae);
              }
              if (((_ = ye.input_end), (W = ye.is_uncompressed), ye.is_metadata))
                for (Q(I); se > 0; --se) I.readMoreInput(), I.readBits(8);
              else if (0 !== se)
                if (W)
                  (I.bit_pos_ = (I.bit_pos_ + 7) & -8),
                    H(t, se, T, p, d, I),
                    (T += se);
                else {
                  for (r = 0; r < 3; ++r)
                    (oe[r] = N(I) + 1),
                      oe[r] >= 2 &&
                        (D(oe[r] + 2, E, r * b, I),
                        D(m, v, r * b, I),
                        (ne[r] = O(v, r * b, I)),
                        (le[r] = 1));
                  for (
                    I.readMoreInput(),
                      K = (1 << (Y = I.readBits(2))) - 1,
                      J = (X = S + (I.readBits(4) << Y)) + (48 << Y),
                      he = new Uint8Array(oe[0]),
                      r = 0;
                    r < oe[0];
                    ++r
                  )
                    I.readMoreInput(), (he[r] = I.readBits(2) << 1);
                  var we = M(oe[0] << y, I);
                  ($ = we.num_htrees), (Z = we.context_map);
                  var Ee = M(oe[2] << A, I);
                  for (
                    te = Ee.num_htrees,
                      ee = Ee.context_map,
                      q[0] = new U(f, $),
                      q[1] = new U(g, oe[1]),
                      q[2] = new U(J, te),
                      r = 0;
                    r < 3;
                    ++r
                  )
                    q[r].decode(I);
                  for (
                    ue = 0,
                      pe = 0,
                      re = he[ae[0]],
                      ge = l.lookupOffsets[re],
                      me = l.lookupOffsets[re + 1],
                      ie = q[1].htrees[0];
                    se > 0;
  
                  ) {
                    var be, ve, Ie, Se, Te, _e, Ce, xe, Ne, ke, Re, Be;
                    for (
                      I.readMoreInput(),
                        0 === ne[1] &&
                          (F(oe[1], E, 1, ae, ce, le, I),
                          (ne[1] = O(v, b, I)),
                          (ie = q[1].htrees[ae[1]])),
                        --ne[1],
                        (ve = (be = B(q[1].codes, ie, I)) >> 6) >= 2
                          ? ((ve -= 2), (Ce = -1))
                          : (Ce = 0),
                        Ie = h.kInsertRangeLut[ve] + ((be >> 3) & 7),
                        Se = h.kCopyRangeLut[ve] + (7 & be),
                        Te =
                          h.kInsertLengthPrefixCode[Ie].offset +
                          I.readBits(h.kInsertLengthPrefixCode[Ie].nbits),
                        _e =
                          h.kCopyLengthPrefixCode[Se].offset +
                          I.readBits(h.kCopyLengthPrefixCode[Se].nbits),
                        V = p[(T - 1) & d],
                        z = p[(T - 2) & d],
                        Ne = 0;
                      Ne < Te;
                      ++Ne
                    )
                      I.readMoreInput(),
                        0 === ne[0] &&
                          (F(oe[0], E, 0, ae, ce, le, I),
                          (ne[0] = O(v, 0, I)),
                          (ue = ae[0] << y),
                          (re = he[ae[0]]),
                          (ge = l.lookupOffsets[re]),
                          (me = l.lookupOffsets[re + 1])),
                        (de = Z[ue + (l.lookup[ge + V] | l.lookup[me + z])]),
                        --ne[0],
                        (z = V),
                        (V = B(q[0].codes, q[0].htrees[de], I)),
                        (p[T & d] = V),
                        (T & d) === d && t.write(p, c),
                        ++T;
                    if ((se -= Te) <= 0) break;
                    if (Ce < 0)
                      if (
                        (I.readMoreInput(),
                        0 === ne[2] &&
                          (F(oe[2], E, 2, ae, ce, le, I),
                          (ne[2] = O(v, 2 * b, I)),
                          (pe = ae[2] << A)),
                        --ne[2],
                        (fe = ee[pe + (255 & (_e > 4 ? 3 : _e - 2))]),
                        (Ce = B(q[2].codes, q[2].htrees[fe], I)) >= X)
                      )
                        (Be = (Ce -= X) & K),
                          (Ce =
                            X +
                            (((De =
                              ((2 + (1 & (Ce >>= Y))) << (Re = 1 + (Ce >> 1))) -
                              4) +
                              I.readBits(Re)) <<
                              Y) +
                            Be);
                    if ((xe = L(Ce, k, P)) < 0)
                      throw new Error("[BrotliDecompress] invalid distance");
                    if (((ke = T & d), xe > (C = T < s && C !== s ? T : s))) {
                      if (
                        !(
                          _e >= a.minDictionaryWordLength &&
                          _e <= a.maxDictionaryWordLength
                        )
                      )
                        throw new Error(
                          "Invalid backward reference. pos: " +
                            T +
                            " distance: " +
                            xe +
                            " len: " +
                            _e +
                            " bytes left: " +
                            se
                        );
                      var De = a.offsetsByLength[_e],
                        Oe = xe - C - 1,
                        Le = a.sizeBitsByLength[_e],
                        Pe = Oe >> Le;
                      if (
                        ((De += (Oe & ((1 << Le) - 1)) * _e),
                        !(Pe < u.kNumTransforms))
                      )
                        throw new Error(
                          "Invalid backward reference. pos: " +
                            T +
                            " distance: " +
                            xe +
                            " len: " +
                            _e +
                            " bytes left: " +
                            se
                        );
                      var Ue = u.transformDictionaryWord(p, ke, De, _e, Pe);
                      if (((T += Ue), (se -= Ue), (ke += Ue) >= w)) {
                        t.write(p, c);
                        for (var Me = 0; Me < ke - w; Me++) p[Me] = p[w + Me];
                      }
                    } else {
                      if ((Ce > 0 && ((k[3 & P] = xe), ++P), _e > se))
                        throw new Error(
                          "Invalid backward reference. pos: " +
                            T +
                            " distance: " +
                            xe +
                            " len: " +
                            _e +
                            " bytes left: " +
                            se
                        );
                      for (Ne = 0; Ne < _e; ++Ne)
                        (p[T & d] = p[(T - xe) & d]),
                          (T & d) === d && t.write(p, c),
                          ++T,
                          --se;
                    }
                    (V = p[(T - 1) & d]), (z = p[(T - 2) & d]);
                  }
                  T &= 1073741823;
                }
            }
            t.write(p, T & d);
          }
          (U.prototype.decode = function (e) {
            var t,
              r = 0;
            for (t = 0; t < this.num_htrees; ++t)
              (this.htrees[t] = r),
                (r += D(this.alphabet_size, this.codes, r, e));
          }),
            (t.BrotliDecompressBuffer = function (e, t) {
              var r = new i(e);
              null == t && (t = V(e));
              var n = new Uint8Array(t),
                a = new s(n);
              return (
                z(r, a),
                a.pos < a.buffer.length &&
                  (a.buffer = a.buffer.subarray(0, a.pos)),
                a.buffer
              );
            }),
            a.init();
        },
        9017: (e, t, r) => {
          var i = r(7526);
          t.init = function () {
            return (0, r(9206).BrotliDecompressBuffer)(i.toByteArray(r(7611)));
          };
        },
        7611: (e) => {
          e.exports =
            "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";
        },
        8712: (e, t, r) => {
          var i = r(9017);
          (t.init = function () {
            t.dictionary = i.init();
          }),
            (t.offsetsByLength = new Uint32Array([
              0, 0, 0, 0, 0, 4096, 9216, 21504, 35840, 44032, 53248, 63488, 74752,
              87040, 93696, 100864, 104704, 106752, 108928, 113536, 115968,
              118528, 119872, 121280, 122016,
            ])),
            (t.sizeBitsByLength = new Uint8Array([
              0, 0, 0, 0, 10, 10, 11, 11, 10, 10, 10, 10, 10, 9, 9, 8, 7, 7, 8, 7,
              7, 6, 6, 5, 5,
            ])),
            (t.minDictionaryWordLength = 4),
            (t.maxDictionaryWordLength = 24);
        },
        8171: (e, t) => {
          function r(e, t) {
            (this.bits = e), (this.value = t);
          }
          t.z = r;
          var i = 15;
          function s(e, t) {
            for (var r = 1 << (t - 1); e & r; ) r >>= 1;
            return (e & (r - 1)) + r;
          }
          function n(e, t, i, s, n) {
            do {
              e[t + (s -= i)] = new r(n.bits, n.value);
            } while (s > 0);
          }
          function a(e, t, r) {
            for (var s = 1 << (t - r); t < i && !((s -= e[t]) <= 0); )
              ++t, (s <<= 1);
            return t - r;
          }
          t.u = function (e, t, o, c, l) {
            var h,
              u,
              d,
              p,
              f,
              g,
              m,
              y,
              A,
              w,
              E = t,
              b = new Int32Array(16),
              v = new Int32Array(16);
            for (w = new Int32Array(l), u = 0; u < l; u++) b[c[u]]++;
            for (v[1] = 0, h = 1; h < i; h++) v[h + 1] = v[h] + b[h];
            for (u = 0; u < l; u++) 0 !== c[u] && (w[v[c[u]]++] = u);
            if (((A = y = 1 << (m = o)), 1 === v[15])) {
              for (d = 0; d < A; ++d) e[t + d] = new r(0, 65535 & w[0]);
              return A;
            }
            for (d = 0, u = 0, h = 1, p = 2; h <= o; ++h, p <<= 1)
              for (; b[h] > 0; --b[h])
                n(e, t + d, p, y, new r(255 & h, 65535 & w[u++])), (d = s(d, h));
            for (g = A - 1, f = -1, h = o + 1, p = 2; h <= i; ++h, p <<= 1)
              for (; b[h] > 0; --b[h])
                (d & g) !== f &&
                  ((t += y),
                  (A += y = 1 << (m = a(b, h, o))),
                  (e[E + (f = d & g)] = new r(
                    (m + o) & 255,
                    (t - E - f) & 65535
                  ))),
                  n(e, t + (d >> o), p, y, new r((h - o) & 255, 65535 & w[u++])),
                  (d = s(d, h));
            return A;
          };
        },
        7708: (e, t) => {
          function r(e, t) {
            (this.offset = e), (this.nbits = t);
          }
          (t.kBlockLengthPrefixCode = [
            new r(1, 2),
            new r(5, 2),
            new r(9, 2),
            new r(13, 2),
            new r(17, 3),
            new r(25, 3),
            new r(33, 3),
            new r(41, 3),
            new r(49, 4),
            new r(65, 4),
            new r(81, 4),
            new r(97, 4),
            new r(113, 5),
            new r(145, 5),
            new r(177, 5),
            new r(209, 5),
            new r(241, 6),
            new r(305, 6),
            new r(369, 7),
            new r(497, 8),
            new r(753, 9),
            new r(1265, 10),
            new r(2289, 11),
            new r(4337, 12),
            new r(8433, 13),
            new r(16625, 24),
          ]),
            (t.kInsertLengthPrefixCode = [
              new r(0, 0),
              new r(1, 0),
              new r(2, 0),
              new r(3, 0),
              new r(4, 0),
              new r(5, 0),
              new r(6, 1),
              new r(8, 1),
              new r(10, 2),
              new r(14, 2),
              new r(18, 3),
              new r(26, 3),
              new r(34, 4),
              new r(50, 4),
              new r(66, 5),
              new r(98, 5),
              new r(130, 6),
              new r(194, 7),
              new r(322, 8),
              new r(578, 9),
              new r(1090, 10),
              new r(2114, 12),
              new r(6210, 14),
              new r(22594, 24),
            ]),
            (t.kCopyLengthPrefixCode = [
              new r(2, 0),
              new r(3, 0),
              new r(4, 0),
              new r(5, 0),
              new r(6, 0),
              new r(7, 0),
              new r(8, 0),
              new r(9, 0),
              new r(10, 1),
              new r(12, 1),
              new r(14, 2),
              new r(18, 2),
              new r(22, 3),
              new r(30, 3),
              new r(38, 4),
              new r(54, 4),
              new r(70, 5),
              new r(102, 5),
              new r(134, 6),
              new r(198, 7),
              new r(326, 8),
              new r(582, 9),
              new r(1094, 10),
              new r(2118, 24),
            ]),
            (t.kInsertRangeLut = [0, 0, 8, 8, 0, 16, 8, 16, 16]),
            (t.kCopyRangeLut = [0, 8, 0, 8, 16, 0, 16, 8, 16]);
        },
        4927: (e, t) => {
          function r(e) {
            (this.buffer = e), (this.pos = 0);
          }
          function i(e) {
            (this.buffer = e), (this.pos = 0);
          }
          (r.prototype.read = function (e, t, r) {
            this.pos + r > this.buffer.length &&
              (r = this.buffer.length - this.pos);
            for (var i = 0; i < r; i++) e[t + i] = this.buffer[this.pos + i];
            return (this.pos += r), r;
          }),
            (t.z = r),
            (i.prototype.write = function (e, t) {
              if (this.pos + t > this.buffer.length)
                throw new Error("Output buffer is not large enough");
              return (
                this.buffer.set(e.subarray(0, t), this.pos), (this.pos += t), t
              );
            }),
            (t.y = i);
        },
        8270: (e, t, r) => {
          var i = r(8712),
            s = 10,
            n = 11;
          function a(e, t, r) {
            (this.prefix = new Uint8Array(e.length)),
              (this.transform = t),
              (this.suffix = new Uint8Array(r.length));
            for (var i = 0; i < e.length; i++) this.prefix[i] = e.charCodeAt(i);
            for (i = 0; i < r.length; i++) this.suffix[i] = r.charCodeAt(i);
          }
          var o = [
            new a("", 0, ""),
            new a("", 0, " "),
            new a(" ", 0, " "),
            new a("", 12, ""),
            new a("", s, " "),
            new a("", 0, " the "),
            new a(" ", 0, ""),
            new a("s ", 0, " "),
            new a("", 0, " of "),
            new a("", s, ""),
            new a("", 0, " and "),
            new a("", 13, ""),
            new a("", 1, ""),
            new a(", ", 0, " "),
            new a("", 0, ", "),
            new a(" ", s, " "),
            new a("", 0, " in "),
            new a("", 0, " to "),
            new a("e ", 0, " "),
            new a("", 0, '"'),
            new a("", 0, "."),
            new a("", 0, '">'),
            new a("", 0, "\n"),
            new a("", 3, ""),
            new a("", 0, "]"),
            new a("", 0, " for "),
            new a("", 14, ""),
            new a("", 2, ""),
            new a("", 0, " a "),
            new a("", 0, " that "),
            new a(" ", s, ""),
            new a("", 0, ". "),
            new a(".", 0, ""),
            new a(" ", 0, ", "),
            new a("", 15, ""),
            new a("", 0, " with "),
            new a("", 0, "'"),
            new a("", 0, " from "),
            new a("", 0, " by "),
            new a("", 16, ""),
            new a("", 17, ""),
            new a(" the ", 0, ""),
            new a("", 4, ""),
            new a("", 0, ". The "),
            new a("", n, ""),
            new a("", 0, " on "),
            new a("", 0, " as "),
            new a("", 0, " is "),
            new a("", 7, ""),
            new a("", 1, "ing "),
            new a("", 0, "\n\t"),
            new a("", 0, ":"),
            new a(" ", 0, ". "),
            new a("", 0, "ed "),
            new a("", 20, ""),
            new a("", 18, ""),
            new a("", 6, ""),
            new a("", 0, "("),
            new a("", s, ", "),
            new a("", 8, ""),
            new a("", 0, " at "),
            new a("", 0, "ly "),
            new a(" the ", 0, " of "),
            new a("", 5, ""),
            new a("", 9, ""),
            new a(" ", s, ", "),
            new a("", s, '"'),
            new a(".", 0, "("),
            new a("", n, " "),
            new a("", s, '">'),
            new a("", 0, '="'),
            new a(" ", 0, "."),
            new a(".com/", 0, ""),
            new a(" the ", 0, " of the "),
            new a("", s, "'"),
            new a("", 0, ". This "),
            new a("", 0, ","),
            new a(".", 0, " "),
            new a("", s, "("),
            new a("", s, "."),
            new a("", 0, " not "),
            new a(" ", 0, '="'),
            new a("", 0, "er "),
            new a(" ", n, " "),
            new a("", 0, "al "),
            new a(" ", n, ""),
            new a("", 0, "='"),
            new a("", n, '"'),
            new a("", s, ". "),
            new a(" ", 0, "("),
            new a("", 0, "ful "),
            new a(" ", s, ". "),
            new a("", 0, "ive "),
            new a("", 0, "less "),
            new a("", n, "'"),
            new a("", 0, "est "),
            new a(" ", s, "."),
            new a("", n, '">'),
            new a(" ", 0, "='"),
            new a("", s, ","),
            new a("", 0, "ize "),
            new a("", n, "."),
            new a("", 0, ""),
            new a(" ", 0, ","),
            new a("", s, '="'),
            new a("", n, '="'),
            new a("", 0, "ous "),
            new a("", n, ", "),
            new a("", s, "='"),
            new a(" ", s, ","),
            new a(" ", n, '="'),
            new a(" ", n, ", "),
            new a("", n, ","),
            new a("", n, "("),
            new a("", n, ". "),
            new a(" ", n, "."),
            new a("", n, "='"),
            new a(" ", n, ". "),
            new a(" ", s, '="'),
            new a(" ", n, "='"),
            new a(" ", s, "='"),
          ];
          function c(e, t) {
            return e[t] < 192
              ? (e[t] >= 97 && e[t] <= 122 && (e[t] ^= 32), 1)
              : e[t] < 224
              ? ((e[t + 1] ^= 32), 2)
              : ((e[t + 2] ^= 5), 3);
          }
          (t.kTransforms = o),
            (t.kNumTransforms = o.length),
            (t.transformDictionaryWord = function (e, t, r, a, l) {
              var h,
                u = o[l].prefix,
                d = o[l].suffix,
                p = o[l].transform,
                f = p < 12 ? 0 : p - 11,
                g = 0,
                m = t;
              f > a && (f = a);
              for (var y = 0; y < u.length; ) e[t++] = u[y++];
              for (r += f, a -= f, p <= 9 && (a -= p), g = 0; g < a; g++)
                e[t++] = i.dictionary[r + g];
              if (((h = t - a), p === s)) c(e, h);
              else if (p === n)
                for (; a > 0; ) {
                  var A = c(e, h);
                  (h += A), (a -= A);
                }
              for (var w = 0; w < d.length; ) e[t++] = d[w++];
              return t - m;
            });
        },
        4698: (e, t, r) => {
          e.exports = r(9206).BrotliDecompressBuffer;
        },
        8287: (e, t, r) => {
          "use strict";
          /*!
           * The buffer module from node.js, for the browser.
           *
           * @author   Feross Aboukhadijeh <https://feross.org>
           * @license  MIT
           */ const i = r(7526),
            s = r(251),
            n =
              "function" == typeof Symbol && "function" == typeof Symbol.for
                ? Symbol.for("nodejs.util.inspect.custom")
                : null;
          (t.Buffer = c),
            (t.SlowBuffer = function (e) {
              +e != e && (e = 0);
              return c.alloc(+e);
            }),
            (t.INSPECT_MAX_BYTES = 50);
          const a = 2147483647;
          function o(e) {
            if (e > a)
              throw new RangeError(
                'The value "' + e + '" is invalid for option "size"'
              );
            const t = new Uint8Array(e);
            return Object.setPrototypeOf(t, c.prototype), t;
          }
          function c(e, t, r) {
            if ("number" == typeof e) {
              if ("string" == typeof t)
                throw new TypeError(
                  'The "string" argument must be of type string. Received type number'
                );
              return u(e);
            }
            return l(e, t, r);
          }
          function l(e, t, r) {
            if ("string" == typeof e)
              return (function (e, t) {
                ("string" == typeof t && "" !== t) || (t = "utf8");
                if (!c.isEncoding(t))
                  throw new TypeError("Unknown encoding: " + t);
                const r = 0 | g(e, t);
                let i = o(r);
                const s = i.write(e, t);
                s !== r && (i = i.slice(0, s));
                return i;
              })(e, t);
            if (ArrayBuffer.isView(e))
              return (function (e) {
                if (X(e, Uint8Array)) {
                  const t = new Uint8Array(e);
                  return p(t.buffer, t.byteOffset, t.byteLength);
                }
                return d(e);
              })(e);
            if (null == e)
              throw new TypeError(
                "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
                  typeof e
              );
            if (X(e, ArrayBuffer) || (e && X(e.buffer, ArrayBuffer)))
              return p(e, t, r);
            if (
              "undefined" != typeof SharedArrayBuffer &&
              (X(e, SharedArrayBuffer) || (e && X(e.buffer, SharedArrayBuffer)))
            )
              return p(e, t, r);
            if ("number" == typeof e)
              throw new TypeError(
                'The "value" argument must not be of type number. Received type number'
              );
            const i = e.valueOf && e.valueOf();
            if (null != i && i !== e) return c.from(i, t, r);
            const s = (function (e) {
              if (c.isBuffer(e)) {
                const t = 0 | f(e.length),
                  r = o(t);
                return 0 === r.length || e.copy(r, 0, 0, t), r;
              }
              if (void 0 !== e.length)
                return "number" != typeof e.length || K(e.length) ? o(0) : d(e);
              if ("Buffer" === e.type && Array.isArray(e.data)) return d(e.data);
            })(e);
            if (s) return s;
            if (
              "undefined" != typeof Symbol &&
              null != Symbol.toPrimitive &&
              "function" == typeof e[Symbol.toPrimitive]
            )
              return c.from(e[Symbol.toPrimitive]("string"), t, r);
            throw new TypeError(
              "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
                typeof e
            );
          }
          function h(e) {
            if ("number" != typeof e)
              throw new TypeError('"size" argument must be of type number');
            if (e < 0)
              throw new RangeError(
                'The value "' + e + '" is invalid for option "size"'
              );
          }
          function u(e) {
            return h(e), o(e < 0 ? 0 : 0 | f(e));
          }
          function d(e) {
            const t = e.length < 0 ? 0 : 0 | f(e.length),
              r = o(t);
            for (let i = 0; i < t; i += 1) r[i] = 255 & e[i];
            return r;
          }
          function p(e, t, r) {
            if (t < 0 || e.byteLength < t)
              throw new RangeError('"offset" is outside of buffer bounds');
            if (e.byteLength < t + (r || 0))
              throw new RangeError('"length" is outside of buffer bounds');
            let i;
            return (
              (i =
                void 0 === t && void 0 === r
                  ? new Uint8Array(e)
                  : void 0 === r
                  ? new Uint8Array(e, t)
                  : new Uint8Array(e, t, r)),
              Object.setPrototypeOf(i, c.prototype),
              i
            );
          }
          function f(e) {
            if (e >= a)
              throw new RangeError(
                "Attempt to allocate Buffer larger than maximum size: 0x" +
                  a.toString(16) +
                  " bytes"
              );
            return 0 | e;
          }
          function g(e, t) {
            if (c.isBuffer(e)) return e.length;
            if (ArrayBuffer.isView(e) || X(e, ArrayBuffer)) return e.byteLength;
            if ("string" != typeof e)
              throw new TypeError(
                'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' +
                  typeof e
              );
            const r = e.length,
              i = arguments.length > 2 && !0 === arguments[2];
            if (!i && 0 === r) return 0;
            let s = !1;
            for (;;)
              switch (t) {
                case "ascii":
                case "latin1":
                case "binary":
                  return r;
                case "utf8":
                case "utf-8":
                  return j(e).length;
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return 2 * r;
                case "hex":
                  return r >>> 1;
                case "base64":
                  return W(e).length;
                default:
                  if (s) return i ? -1 : j(e).length;
                  (t = ("" + t).toLowerCase()), (s = !0);
              }
          }
          function m(e, t, r) {
            let i = !1;
            if (((void 0 === t || t < 0) && (t = 0), t > this.length)) return "";
            if (((void 0 === r || r > this.length) && (r = this.length), r <= 0))
              return "";
            if ((r >>>= 0) <= (t >>>= 0)) return "";
            for (e || (e = "utf8"); ; )
              switch (e) {
                case "hex":
                  return k(this, t, r);
                case "utf8":
                case "utf-8":
                  return _(this, t, r);
                case "ascii":
                  return x(this, t, r);
                case "latin1":
                case "binary":
                  return N(this, t, r);
                case "base64":
                  return T(this, t, r);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return R(this, t, r);
                default:
                  if (i) throw new TypeError("Unknown encoding: " + e);
                  (e = (e + "").toLowerCase()), (i = !0);
              }
          }
          function y(e, t, r) {
            const i = e[t];
            (e[t] = e[r]), (e[r] = i);
          }
          function A(e, t, r, i, s) {
            if (0 === e.length) return -1;
            if (
              ("string" == typeof r
                ? ((i = r), (r = 0))
                : r > 2147483647
                ? (r = 2147483647)
                : r < -2147483648 && (r = -2147483648),
              K((r = +r)) && (r = s ? 0 : e.length - 1),
              r < 0 && (r = e.length + r),
              r >= e.length)
            ) {
              if (s) return -1;
              r = e.length - 1;
            } else if (r < 0) {
              if (!s) return -1;
              r = 0;
            }
            if (("string" == typeof t && (t = c.from(t, i)), c.isBuffer(t)))
              return 0 === t.length ? -1 : w(e, t, r, i, s);
            if ("number" == typeof t)
              return (
                (t &= 255),
                "function" == typeof Uint8Array.prototype.indexOf
                  ? s
                    ? Uint8Array.prototype.indexOf.call(e, t, r)
                    : Uint8Array.prototype.lastIndexOf.call(e, t, r)
                  : w(e, [t], r, i, s)
              );
            throw new TypeError("val must be string, number or Buffer");
          }
          function w(e, t, r, i, s) {
            let n,
              a = 1,
              o = e.length,
              c = t.length;
            if (
              void 0 !== i &&
              ("ucs2" === (i = String(i).toLowerCase()) ||
                "ucs-2" === i ||
                "utf16le" === i ||
                "utf-16le" === i)
            ) {
              if (e.length < 2 || t.length < 2) return -1;
              (a = 2), (o /= 2), (c /= 2), (r /= 2);
            }
            function l(e, t) {
              return 1 === a ? e[t] : e.readUInt16BE(t * a);
            }
            if (s) {
              let i = -1;
              for (n = r; n < o; n++)
                if (l(e, n) === l(t, -1 === i ? 0 : n - i)) {
                  if ((-1 === i && (i = n), n - i + 1 === c)) return i * a;
                } else -1 !== i && (n -= n - i), (i = -1);
            } else
              for (r + c > o && (r = o - c), n = r; n >= 0; n--) {
                let r = !0;
                for (let i = 0; i < c; i++)
                  if (l(e, n + i) !== l(t, i)) {
                    r = !1;
                    break;
                  }
                if (r) return n;
              }
            return -1;
          }
          function E(e, t, r, i) {
            r = Number(r) || 0;
            const s = e.length - r;
            i ? (i = Number(i)) > s && (i = s) : (i = s);
            const n = t.length;
            let a;
            for (i > n / 2 && (i = n / 2), a = 0; a < i; ++a) {
              const i = parseInt(t.substr(2 * a, 2), 16);
              if (K(i)) return a;
              e[r + a] = i;
            }
            return a;
          }
          function b(e, t, r, i) {
            return Y(j(t, e.length - r), e, r, i);
          }
          function v(e, t, r, i) {
            return Y(
              (function (e) {
                const t = [];
                for (let r = 0; r < e.length; ++r) t.push(255 & e.charCodeAt(r));
                return t;
              })(t),
              e,
              r,
              i
            );
          }
          function I(e, t, r, i) {
            return Y(W(t), e, r, i);
          }
          function S(e, t, r, i) {
            return Y(
              (function (e, t) {
                let r, i, s;
                const n = [];
                for (let a = 0; a < e.length && !((t -= 2) < 0); ++a)
                  (r = e.charCodeAt(a)),
                    (i = r >> 8),
                    (s = r % 256),
                    n.push(s),
                    n.push(i);
                return n;
              })(t, e.length - r),
              e,
              r,
              i
            );
          }
          function T(e, t, r) {
            return 0 === t && r === e.length
              ? i.fromByteArray(e)
              : i.fromByteArray(e.slice(t, r));
          }
          function _(e, t, r) {
            r = Math.min(e.length, r);
            const i = [];
            let s = t;
            for (; s < r; ) {
              const t = e[s];
              let n = null,
                a = t > 239 ? 4 : t > 223 ? 3 : t > 191 ? 2 : 1;
              if (s + a <= r) {
                let r, i, o, c;
                switch (a) {
                  case 1:
                    t < 128 && (n = t);
                    break;
                  case 2:
                    (r = e[s + 1]),
                      128 == (192 & r) &&
                        ((c = ((31 & t) << 6) | (63 & r)), c > 127 && (n = c));
                    break;
                  case 3:
                    (r = e[s + 1]),
                      (i = e[s + 2]),
                      128 == (192 & r) &&
                        128 == (192 & i) &&
                        ((c = ((15 & t) << 12) | ((63 & r) << 6) | (63 & i)),
                        c > 2047 && (c < 55296 || c > 57343) && (n = c));
                    break;
                  case 4:
                    (r = e[s + 1]),
                      (i = e[s + 2]),
                      (o = e[s + 3]),
                      128 == (192 & r) &&
                        128 == (192 & i) &&
                        128 == (192 & o) &&
                        ((c =
                          ((15 & t) << 18) |
                          ((63 & r) << 12) |
                          ((63 & i) << 6) |
                          (63 & o)),
                        c > 65535 && c < 1114112 && (n = c));
                }
              }
              null === n
                ? ((n = 65533), (a = 1))
                : n > 65535 &&
                  ((n -= 65536),
                  i.push(((n >>> 10) & 1023) | 55296),
                  (n = 56320 | (1023 & n))),
                i.push(n),
                (s += a);
            }
            return (function (e) {
              const t = e.length;
              if (t <= C) return String.fromCharCode.apply(String, e);
              let r = "",
                i = 0;
              for (; i < t; )
                r += String.fromCharCode.apply(String, e.slice(i, (i += C)));
              return r;
            })(i);
          }
          (t.kMaxLength = a),
            (c.TYPED_ARRAY_SUPPORT = (function () {
              try {
                const e = new Uint8Array(1),
                  t = {
                    foo: function () {
                      return 42;
                    },
                  };
                return (
                  Object.setPrototypeOf(t, Uint8Array.prototype),
                  Object.setPrototypeOf(e, t),
                  42 === e.foo()
                );
              } catch (e) {
                return !1;
              }
            })()),
            c.TYPED_ARRAY_SUPPORT ||
              "undefined" == typeof console ||
              "function" != typeof console.error ||
              console.error(
                "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
              ),
            Object.defineProperty(c.prototype, "parent", {
              enumerable: !0,
              get: function () {
                if (c.isBuffer(this)) return this.buffer;
              },
            }),
            Object.defineProperty(c.prototype, "offset", {
              enumerable: !0,
              get: function () {
                if (c.isBuffer(this)) return this.byteOffset;
              },
            }),
            (c.poolSize = 8192),
            (c.from = function (e, t, r) {
              return l(e, t, r);
            }),
            Object.setPrototypeOf(c.prototype, Uint8Array.prototype),
            Object.setPrototypeOf(c, Uint8Array),
            (c.alloc = function (e, t, r) {
              return (function (e, t, r) {
                return (
                  h(e),
                  e <= 0
                    ? o(e)
                    : void 0 !== t
                    ? "string" == typeof r
                      ? o(e).fill(t, r)
                      : o(e).fill(t)
                    : o(e)
                );
              })(e, t, r);
            }),
            (c.allocUnsafe = function (e) {
              return u(e);
            }),
            (c.allocUnsafeSlow = function (e) {
              return u(e);
            }),
            (c.isBuffer = function (e) {
              return null != e && !0 === e._isBuffer && e !== c.prototype;
            }),
            (c.compare = function (e, t) {
              if (
                (X(e, Uint8Array) && (e = c.from(e, e.offset, e.byteLength)),
                X(t, Uint8Array) && (t = c.from(t, t.offset, t.byteLength)),
                !c.isBuffer(e) || !c.isBuffer(t))
              )
                throw new TypeError(
                  'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
                );
              if (e === t) return 0;
              let r = e.length,
                i = t.length;
              for (let s = 0, n = Math.min(r, i); s < n; ++s)
                if (e[s] !== t[s]) {
                  (r = e[s]), (i = t[s]);
                  break;
                }
              return r < i ? -1 : i < r ? 1 : 0;
            }),
            (c.isEncoding = function (e) {
              switch (String(e).toLowerCase()) {
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "latin1":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return !0;
                default:
                  return !1;
              }
            }),
            (c.concat = function (e, t) {
              if (!Array.isArray(e))
                throw new TypeError(
                  '"list" argument must be an Array of Buffers'
                );
              if (0 === e.length) return c.alloc(0);
              let r;
              if (void 0 === t)
                for (t = 0, r = 0; r < e.length; ++r) t += e[r].length;
              const i = c.allocUnsafe(t);
              let s = 0;
              for (r = 0; r < e.length; ++r) {
                let t = e[r];
                if (X(t, Uint8Array))
                  s + t.length > i.length
                    ? (c.isBuffer(t) || (t = c.from(t)), t.copy(i, s))
                    : Uint8Array.prototype.set.call(i, t, s);
                else {
                  if (!c.isBuffer(t))
                    throw new TypeError(
                      '"list" argument must be an Array of Buffers'
                    );
                  t.copy(i, s);
                }
                s += t.length;
              }
              return i;
            }),
            (c.byteLength = g),
            (c.prototype._isBuffer = !0),
            (c.prototype.swap16 = function () {
              const e = this.length;
              if (e % 2 != 0)
                throw new RangeError("Buffer size must be a multiple of 16-bits");
              for (let t = 0; t < e; t += 2) y(this, t, t + 1);
              return this;
            }),
            (c.prototype.swap32 = function () {
              const e = this.length;
              if (e % 4 != 0)
                throw new RangeError("Buffer size must be a multiple of 32-bits");
              for (let t = 0; t < e; t += 4)
                y(this, t, t + 3), y(this, t + 1, t + 2);
              return this;
            }),
            (c.prototype.swap64 = function () {
              const e = this.length;
              if (e % 8 != 0)
                throw new RangeError("Buffer size must be a multiple of 64-bits");
              for (let t = 0; t < e; t += 8)
                y(this, t, t + 7),
                  y(this, t + 1, t + 6),
                  y(this, t + 2, t + 5),
                  y(this, t + 3, t + 4);
              return this;
            }),
            (c.prototype.toString = function () {
              const e = this.length;
              return 0 === e
                ? ""
                : 0 === arguments.length
                ? _(this, 0, e)
                : m.apply(this, arguments);
            }),
            (c.prototype.toLocaleString = c.prototype.toString),
            (c.prototype.equals = function (e) {
              if (!c.isBuffer(e))
                throw new TypeError("Argument must be a Buffer");
              return this === e || 0 === c.compare(this, e);
            }),
            (c.prototype.inspect = function () {
              let e = "";
              const r = t.INSPECT_MAX_BYTES;
              return (
                (e = this.toString("hex", 0, r)
                  .replace(/(.{2})/g, "$1 ")
                  .trim()),
                this.length > r && (e += " ... "),
                "<Buffer " + e + ">"
              );
            }),
            n && (c.prototype[n] = c.prototype.inspect),
            (c.prototype.compare = function (e, t, r, i, s) {
              if (
                (X(e, Uint8Array) && (e = c.from(e, e.offset, e.byteLength)),
                !c.isBuffer(e))
              )
                throw new TypeError(
                  'The "target" argument must be one of type Buffer or Uint8Array. Received type ' +
                    typeof e
                );
              if (
                (void 0 === t && (t = 0),
                void 0 === r && (r = e ? e.length : 0),
                void 0 === i && (i = 0),
                void 0 === s && (s = this.length),
                t < 0 || r > e.length || i < 0 || s > this.length)
              )
                throw new RangeError("out of range index");
              if (i >= s && t >= r) return 0;
              if (i >= s) return -1;
              if (t >= r) return 1;
              if (this === e) return 0;
              let n = (s >>>= 0) - (i >>>= 0),
                a = (r >>>= 0) - (t >>>= 0);
              const o = Math.min(n, a),
                l = this.slice(i, s),
                h = e.slice(t, r);
              for (let e = 0; e < o; ++e)
                if (l[e] !== h[e]) {
                  (n = l[e]), (a = h[e]);
                  break;
                }
              return n < a ? -1 : a < n ? 1 : 0;
            }),
            (c.prototype.includes = function (e, t, r) {
              return -1 !== this.indexOf(e, t, r);
            }),
            (c.prototype.indexOf = function (e, t, r) {
              return A(this, e, t, r, !0);
            }),
            (c.prototype.lastIndexOf = function (e, t, r) {
              return A(this, e, t, r, !1);
            }),
            (c.prototype.write = function (e, t, r, i) {
              if (void 0 === t) (i = "utf8"), (r = this.length), (t = 0);
              else if (void 0 === r && "string" == typeof t)
                (i = t), (r = this.length), (t = 0);
              else {
                if (!isFinite(t))
                  throw new Error(
                    "Buffer.write(string, encoding, offset[, length]) is no longer supported"
                  );
                (t >>>= 0),
                  isFinite(r)
                    ? ((r >>>= 0), void 0 === i && (i = "utf8"))
                    : ((i = r), (r = void 0));
              }
              const s = this.length - t;
              if (
                ((void 0 === r || r > s) && (r = s),
                (e.length > 0 && (r < 0 || t < 0)) || t > this.length)
              )
                throw new RangeError("Attempt to write outside buffer bounds");
              i || (i = "utf8");
              let n = !1;
              for (;;)
                switch (i) {
                  case "hex":
                    return E(this, e, t, r);
                  case "utf8":
                  case "utf-8":
                    return b(this, e, t, r);
                  case "ascii":
                  case "latin1":
                  case "binary":
                    return v(this, e, t, r);
                  case "base64":
                    return I(this, e, t, r);
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return S(this, e, t, r);
                  default:
                    if (n) throw new TypeError("Unknown encoding: " + i);
                    (i = ("" + i).toLowerCase()), (n = !0);
                }
            }),
            (c.prototype.toJSON = function () {
              return {
                type: "Buffer",
                data: Array.prototype.slice.call(this._arr || this, 0),
              };
            });
          const C = 4096;
          function x(e, t, r) {
            let i = "";
            r = Math.min(e.length, r);
            for (let s = t; s < r; ++s) i += String.fromCharCode(127 & e[s]);
            return i;
          }
          function N(e, t, r) {
            let i = "";
            r = Math.min(e.length, r);
            for (let s = t; s < r; ++s) i += String.fromCharCode(e[s]);
            return i;
          }
          function k(e, t, r) {
            const i = e.length;
            (!t || t < 0) && (t = 0), (!r || r < 0 || r > i) && (r = i);
            let s = "";
            for (let i = t; i < r; ++i) s += J[e[i]];
            return s;
          }
          function R(e, t, r) {
            const i = e.slice(t, r);
            let s = "";
            for (let e = 0; e < i.length - 1; e += 2)
              s += String.fromCharCode(i[e] + 256 * i[e + 1]);
            return s;
          }
          function B(e, t, r) {
            if (e % 1 != 0 || e < 0) throw new RangeError("offset is not uint");
            if (e + t > r)
              throw new RangeError("Trying to access beyond buffer length");
          }
          function D(e, t, r, i, s, n) {
            if (!c.isBuffer(e))
              throw new TypeError('"buffer" argument must be a Buffer instance');
            if (t > s || t < n)
              throw new RangeError('"value" argument is out of bounds');
            if (r + i > e.length) throw new RangeError("Index out of range");
          }
          function O(e, t, r, i, s) {
            V(t, i, s, e, r, 7);
            let n = Number(t & BigInt(4294967295));
            (e[r++] = n),
              (n >>= 8),
              (e[r++] = n),
              (n >>= 8),
              (e[r++] = n),
              (n >>= 8),
              (e[r++] = n);
            let a = Number((t >> BigInt(32)) & BigInt(4294967295));
            return (
              (e[r++] = a),
              (a >>= 8),
              (e[r++] = a),
              (a >>= 8),
              (e[r++] = a),
              (a >>= 8),
              (e[r++] = a),
              r
            );
          }
          function L(e, t, r, i, s) {
            V(t, i, s, e, r, 7);
            let n = Number(t & BigInt(4294967295));
            (e[r + 7] = n),
              (n >>= 8),
              (e[r + 6] = n),
              (n >>= 8),
              (e[r + 5] = n),
              (n >>= 8),
              (e[r + 4] = n);
            let a = Number((t >> BigInt(32)) & BigInt(4294967295));
            return (
              (e[r + 3] = a),
              (a >>= 8),
              (e[r + 2] = a),
              (a >>= 8),
              (e[r + 1] = a),
              (a >>= 8),
              (e[r] = a),
              r + 8
            );
          }
          function P(e, t, r, i, s, n) {
            if (r + i > e.length) throw new RangeError("Index out of range");
            if (r < 0) throw new RangeError("Index out of range");
          }
          function U(e, t, r, i, n) {
            return (
              (t = +t),
              (r >>>= 0),
              n || P(e, 0, r, 4),
              s.write(e, t, r, i, 23, 4),
              r + 4
            );
          }
          function M(e, t, r, i, n) {
            return (
              (t = +t),
              (r >>>= 0),
              n || P(e, 0, r, 8),
              s.write(e, t, r, i, 52, 8),
              r + 8
            );
          }
          (c.prototype.slice = function (e, t) {
            const r = this.length;
            (e = ~~e) < 0 ? (e += r) < 0 && (e = 0) : e > r && (e = r),
              (t = void 0 === t ? r : ~~t) < 0
                ? (t += r) < 0 && (t = 0)
                : t > r && (t = r),
              t < e && (t = e);
            const i = this.subarray(e, t);
            return Object.setPrototypeOf(i, c.prototype), i;
          }),
            (c.prototype.readUintLE = c.prototype.readUIntLE =
              function (e, t, r) {
                (e >>>= 0), (t >>>= 0), r || B(e, t, this.length);
                let i = this[e],
                  s = 1,
                  n = 0;
                for (; ++n < t && (s *= 256); ) i += this[e + n] * s;
                return i;
              }),
            (c.prototype.readUintBE = c.prototype.readUIntBE =
              function (e, t, r) {
                (e >>>= 0), (t >>>= 0), r || B(e, t, this.length);
                let i = this[e + --t],
                  s = 1;
                for (; t > 0 && (s *= 256); ) i += this[e + --t] * s;
                return i;
              }),
            (c.prototype.readUint8 = c.prototype.readUInt8 =
              function (e, t) {
                return (e >>>= 0), t || B(e, 1, this.length), this[e];
              }),
            (c.prototype.readUint16LE = c.prototype.readUInt16LE =
              function (e, t) {
                return (
                  (e >>>= 0),
                  t || B(e, 2, this.length),
                  this[e] | (this[e + 1] << 8)
                );
              }),
            (c.prototype.readUint16BE = c.prototype.readUInt16BE =
              function (e, t) {
                return (
                  (e >>>= 0),
                  t || B(e, 2, this.length),
                  (this[e] << 8) | this[e + 1]
                );
              }),
            (c.prototype.readUint32LE = c.prototype.readUInt32LE =
              function (e, t) {
                return (
                  (e >>>= 0),
                  t || B(e, 4, this.length),
                  (this[e] | (this[e + 1] << 8) | (this[e + 2] << 16)) +
                    16777216 * this[e + 3]
                );
              }),
            (c.prototype.readUint32BE = c.prototype.readUInt32BE =
              function (e, t) {
                return (
                  (e >>>= 0),
                  t || B(e, 4, this.length),
                  16777216 * this[e] +
                    ((this[e + 1] << 16) | (this[e + 2] << 8) | this[e + 3])
                );
              }),
            (c.prototype.readBigUInt64LE = Z(function (e) {
              z((e >>>= 0), "offset");
              const t = this[e],
                r = this[e + 7];
              (void 0 !== t && void 0 !== r) || q(e, this.length - 8);
              const i =
                  t + 256 * this[++e] + 65536 * this[++e] + this[++e] * 2 ** 24,
                s = this[++e] + 256 * this[++e] + 65536 * this[++e] + r * 2 ** 24;
              return BigInt(i) + (BigInt(s) << BigInt(32));
            })),
            (c.prototype.readBigUInt64BE = Z(function (e) {
              z((e >>>= 0), "offset");
              const t = this[e],
                r = this[e + 7];
              (void 0 !== t && void 0 !== r) || q(e, this.length - 8);
              const i =
                  t * 2 ** 24 + 65536 * this[++e] + 256 * this[++e] + this[++e],
                s = this[++e] * 2 ** 24 + 65536 * this[++e] + 256 * this[++e] + r;
              return (BigInt(i) << BigInt(32)) + BigInt(s);
            })),
            (c.prototype.readIntLE = function (e, t, r) {
              (e >>>= 0), (t >>>= 0), r || B(e, t, this.length);
              let i = this[e],
                s = 1,
                n = 0;
              for (; ++n < t && (s *= 256); ) i += this[e + n] * s;
              return (s *= 128), i >= s && (i -= Math.pow(2, 8 * t)), i;
            }),
            (c.prototype.readIntBE = function (e, t, r) {
              (e >>>= 0), (t >>>= 0), r || B(e, t, this.length);
              let i = t,
                s = 1,
                n = this[e + --i];
              for (; i > 0 && (s *= 256); ) n += this[e + --i] * s;
              return (s *= 128), n >= s && (n -= Math.pow(2, 8 * t)), n;
            }),
            (c.prototype.readInt8 = function (e, t) {
              return (
                (e >>>= 0),
                t || B(e, 1, this.length),
                128 & this[e] ? -1 * (255 - this[e] + 1) : this[e]
              );
            }),
            (c.prototype.readInt16LE = function (e, t) {
              (e >>>= 0), t || B(e, 2, this.length);
              const r = this[e] | (this[e + 1] << 8);
              return 32768 & r ? 4294901760 | r : r;
            }),
            (c.prototype.readInt16BE = function (e, t) {
              (e >>>= 0), t || B(e, 2, this.length);
              const r = this[e + 1] | (this[e] << 8);
              return 32768 & r ? 4294901760 | r : r;
            }),
            (c.prototype.readInt32LE = function (e, t) {
              return (
                (e >>>= 0),
                t || B(e, 4, this.length),
                this[e] |
                  (this[e + 1] << 8) |
                  (this[e + 2] << 16) |
                  (this[e + 3] << 24)
              );
            }),
            (c.prototype.readInt32BE = function (e, t) {
              return (
                (e >>>= 0),
                t || B(e, 4, this.length),
                (this[e] << 24) |
                  (this[e + 1] << 16) |
                  (this[e + 2] << 8) |
                  this[e + 3]
              );
            }),
            (c.prototype.readBigInt64LE = Z(function (e) {
              z((e >>>= 0), "offset");
              const t = this[e],
                r = this[e + 7];
              (void 0 !== t && void 0 !== r) || q(e, this.length - 8);
              const i =
                this[e + 4] + 256 * this[e + 5] + 65536 * this[e + 6] + (r << 24);
              return (
                (BigInt(i) << BigInt(32)) +
                BigInt(
                  t + 256 * this[++e] + 65536 * this[++e] + this[++e] * 2 ** 24
                )
              );
            })),
            (c.prototype.readBigInt64BE = Z(function (e) {
              z((e >>>= 0), "offset");
              const t = this[e],
                r = this[e + 7];
              (void 0 !== t && void 0 !== r) || q(e, this.length - 8);
              const i =
                (t << 24) + 65536 * this[++e] + 256 * this[++e] + this[++e];
              return (
                (BigInt(i) << BigInt(32)) +
                BigInt(
                  this[++e] * 2 ** 24 + 65536 * this[++e] + 256 * this[++e] + r
                )
              );
            })),
            (c.prototype.readFloatLE = function (e, t) {
              return (
                (e >>>= 0), t || B(e, 4, this.length), s.read(this, e, !0, 23, 4)
              );
            }),
            (c.prototype.readFloatBE = function (e, t) {
              return (
                (e >>>= 0), t || B(e, 4, this.length), s.read(this, e, !1, 23, 4)
              );
            }),
            (c.prototype.readDoubleLE = function (e, t) {
              return (
                (e >>>= 0), t || B(e, 8, this.length), s.read(this, e, !0, 52, 8)
              );
            }),
            (c.prototype.readDoubleBE = function (e, t) {
              return (
                (e >>>= 0), t || B(e, 8, this.length), s.read(this, e, !1, 52, 8)
              );
            }),
            (c.prototype.writeUintLE = c.prototype.writeUIntLE =
              function (e, t, r, i) {
                if (((e = +e), (t >>>= 0), (r >>>= 0), !i)) {
                  D(this, e, t, r, Math.pow(2, 8 * r) - 1, 0);
                }
                let s = 1,
                  n = 0;
                for (this[t] = 255 & e; ++n < r && (s *= 256); )
                  this[t + n] = (e / s) & 255;
                return t + r;
              }),
            (c.prototype.writeUintBE = c.prototype.writeUIntBE =
              function (e, t, r, i) {
                if (((e = +e), (t >>>= 0), (r >>>= 0), !i)) {
                  D(this, e, t, r, Math.pow(2, 8 * r) - 1, 0);
                }
                let s = r - 1,
                  n = 1;
                for (this[t + s] = 255 & e; --s >= 0 && (n *= 256); )
                  this[t + s] = (e / n) & 255;
                return t + r;
              }),
            (c.prototype.writeUint8 = c.prototype.writeUInt8 =
              function (e, t, r) {
                return (
                  (e = +e),
                  (t >>>= 0),
                  r || D(this, e, t, 1, 255, 0),
                  (this[t] = 255 & e),
                  t + 1
                );
              }),
            (c.prototype.writeUint16LE = c.prototype.writeUInt16LE =
              function (e, t, r) {
                return (
                  (e = +e),
                  (t >>>= 0),
                  r || D(this, e, t, 2, 65535, 0),
                  (this[t] = 255 & e),
                  (this[t + 1] = e >>> 8),
                  t + 2
                );
              }),
            (c.prototype.writeUint16BE = c.prototype.writeUInt16BE =
              function (e, t, r) {
                return (
                  (e = +e),
                  (t >>>= 0),
                  r || D(this, e, t, 2, 65535, 0),
                  (this[t] = e >>> 8),
                  (this[t + 1] = 255 & e),
                  t + 2
                );
              }),
            (c.prototype.writeUint32LE = c.prototype.writeUInt32LE =
              function (e, t, r) {
                return (
                  (e = +e),
                  (t >>>= 0),
                  r || D(this, e, t, 4, 4294967295, 0),
                  (this[t + 3] = e >>> 24),
                  (this[t + 2] = e >>> 16),
                  (this[t + 1] = e >>> 8),
                  (this[t] = 255 & e),
                  t + 4
                );
              }),
            (c.prototype.writeUint32BE = c.prototype.writeUInt32BE =
              function (e, t, r) {
                return (
                  (e = +e),
                  (t >>>= 0),
                  r || D(this, e, t, 4, 4294967295, 0),
                  (this[t] = e >>> 24),
                  (this[t + 1] = e >>> 16),
                  (this[t + 2] = e >>> 8),
                  (this[t + 3] = 255 & e),
                  t + 4
                );
              }),
            (c.prototype.writeBigUInt64LE = Z(function (e, t = 0) {
              return O(this, e, t, BigInt(0), BigInt("0xffffffffffffffff"));
            })),
            (c.prototype.writeBigUInt64BE = Z(function (e, t = 0) {
              return L(this, e, t, BigInt(0), BigInt("0xffffffffffffffff"));
            })),
            (c.prototype.writeIntLE = function (e, t, r, i) {
              if (((e = +e), (t >>>= 0), !i)) {
                const i = Math.pow(2, 8 * r - 1);
                D(this, e, t, r, i - 1, -i);
              }
              let s = 0,
                n = 1,
                a = 0;
              for (this[t] = 255 & e; ++s < r && (n *= 256); )
                e < 0 && 0 === a && 0 !== this[t + s - 1] && (a = 1),
                  (this[t + s] = (((e / n) | 0) - a) & 255);
              return t + r;
            }),
            (c.prototype.writeIntBE = function (e, t, r, i) {
              if (((e = +e), (t >>>= 0), !i)) {
                const i = Math.pow(2, 8 * r - 1);
                D(this, e, t, r, i - 1, -i);
              }
              let s = r - 1,
                n = 1,
                a = 0;
              for (this[t + s] = 255 & e; --s >= 0 && (n *= 256); )
                e < 0 && 0 === a && 0 !== this[t + s + 1] && (a = 1),
                  (this[t + s] = (((e / n) | 0) - a) & 255);
              return t + r;
            }),
            (c.prototype.writeInt8 = function (e, t, r) {
              return (
                (e = +e),
                (t >>>= 0),
                r || D(this, e, t, 1, 127, -128),
                e < 0 && (e = 255 + e + 1),
                (this[t] = 255 & e),
                t + 1
              );
            }),
            (c.prototype.writeInt16LE = function (e, t, r) {
              return (
                (e = +e),
                (t >>>= 0),
                r || D(this, e, t, 2, 32767, -32768),
                (this[t] = 255 & e),
                (this[t + 1] = e >>> 8),
                t + 2
              );
            }),
            (c.prototype.writeInt16BE = function (e, t, r) {
              return (
                (e = +e),
                (t >>>= 0),
                r || D(this, e, t, 2, 32767, -32768),
                (this[t] = e >>> 8),
                (this[t + 1] = 255 & e),
                t + 2
              );
            }),
            (c.prototype.writeInt32LE = function (e, t, r) {
              return (
                (e = +e),
                (t >>>= 0),
                r || D(this, e, t, 4, 2147483647, -2147483648),
                (this[t] = 255 & e),
                (this[t + 1] = e >>> 8),
                (this[t + 2] = e >>> 16),
                (this[t + 3] = e >>> 24),
                t + 4
              );
            }),
            (c.prototype.writeInt32BE = function (e, t, r) {
              return (
                (e = +e),
                (t >>>= 0),
                r || D(this, e, t, 4, 2147483647, -2147483648),
                e < 0 && (e = 4294967295 + e + 1),
                (this[t] = e >>> 24),
                (this[t + 1] = e >>> 16),
                (this[t + 2] = e >>> 8),
                (this[t + 3] = 255 & e),
                t + 4
              );
            }),
            (c.prototype.writeBigInt64LE = Z(function (e, t = 0) {
              return O(
                this,
                e,
                t,
                -BigInt("0x8000000000000000"),
                BigInt("0x7fffffffffffffff")
              );
            })),
            (c.prototype.writeBigInt64BE = Z(function (e, t = 0) {
              return L(
                this,
                e,
                t,
                -BigInt("0x8000000000000000"),
                BigInt("0x7fffffffffffffff")
              );
            })),
            (c.prototype.writeFloatLE = function (e, t, r) {
              return U(this, e, t, !0, r);
            }),
            (c.prototype.writeFloatBE = function (e, t, r) {
              return U(this, e, t, !1, r);
            }),
            (c.prototype.writeDoubleLE = function (e, t, r) {
              return M(this, e, t, !0, r);
            }),
            (c.prototype.writeDoubleBE = function (e, t, r) {
              return M(this, e, t, !1, r);
            }),
            (c.prototype.copy = function (e, t, r, i) {
              if (!c.isBuffer(e))
                throw new TypeError("argument should be a Buffer");
              if (
                (r || (r = 0),
                i || 0 === i || (i = this.length),
                t >= e.length && (t = e.length),
                t || (t = 0),
                i > 0 && i < r && (i = r),
                i === r)
              )
                return 0;
              if (0 === e.length || 0 === this.length) return 0;
              if (t < 0) throw new RangeError("targetStart out of bounds");
              if (r < 0 || r >= this.length)
                throw new RangeError("Index out of range");
              if (i < 0) throw new RangeError("sourceEnd out of bounds");
              i > this.length && (i = this.length),
                e.length - t < i - r && (i = e.length - t + r);
              const s = i - r;
              return (
                this === e && "function" == typeof Uint8Array.prototype.copyWithin
                  ? this.copyWithin(t, r, i)
                  : Uint8Array.prototype.set.call(e, this.subarray(r, i), t),
                s
              );
            }),
            (c.prototype.fill = function (e, t, r, i) {
              if ("string" == typeof e) {
                if (
                  ("string" == typeof t
                    ? ((i = t), (t = 0), (r = this.length))
                    : "string" == typeof r && ((i = r), (r = this.length)),
                  void 0 !== i && "string" != typeof i)
                )
                  throw new TypeError("encoding must be a string");
                if ("string" == typeof i && !c.isEncoding(i))
                  throw new TypeError("Unknown encoding: " + i);
                if (1 === e.length) {
                  const t = e.charCodeAt(0);
                  (("utf8" === i && t < 128) || "latin1" === i) && (e = t);
                }
              } else
                "number" == typeof e
                  ? (e &= 255)
                  : "boolean" == typeof e && (e = Number(e));
              if (t < 0 || this.length < t || this.length < r)
                throw new RangeError("Out of range index");
              if (r <= t) return this;
              let s;
              if (
                ((t >>>= 0),
                (r = void 0 === r ? this.length : r >>> 0),
                e || (e = 0),
                "number" == typeof e)
              )
                for (s = t; s < r; ++s) this[s] = e;
              else {
                const n = c.isBuffer(e) ? e : c.from(e, i),
                  a = n.length;
                if (0 === a)
                  throw new TypeError(
                    'The value "' + e + '" is invalid for argument "value"'
                  );
                for (s = 0; s < r - t; ++s) this[s + t] = n[s % a];
              }
              return this;
            });
          const F = {};
          function H(e, t, r) {
            F[e] = class extends r {
              constructor() {
                super(),
                  Object.defineProperty(this, "message", {
                    value: t.apply(this, arguments),
                    writable: !0,
                    configurable: !0,
                  }),
                  (this.name = `${this.name} [${e}]`),
                  this.stack,
                  delete this.name;
              }
              get code() {
                return e;
              }
              set code(e) {
                Object.defineProperty(this, "code", {
                  configurable: !0,
                  enumerable: !0,
                  value: e,
                  writable: !0,
                });
              }
              toString() {
                return `${this.name} [${e}]: ${this.message}`;
              }
            };
          }
          function Q(e) {
            let t = "",
              r = e.length;
            const i = "-" === e[0] ? 1 : 0;
            for (; r >= i + 4; r -= 3) t = `_${e.slice(r - 3, r)}${t}`;
            return `${e.slice(0, r)}${t}`;
          }
          function V(e, t, r, i, s, n) {
            if (e > r || e < t) {
              const i = "bigint" == typeof t ? "n" : "";
              let s;
              throw (
                ((s =
                  n > 3
                    ? 0 === t || t === BigInt(0)
                      ? `>= 0${i} and < 2${i} ** ${8 * (n + 1)}${i}`
                      : `>= -(2${i} ** ${8 * (n + 1) - 1}${i}) and < 2 ** ${
                          8 * (n + 1) - 1
                        }${i}`
                    : `>= ${t}${i} and <= ${r}${i}`),
                new F.ERR_OUT_OF_RANGE("value", s, e))
              );
            }
            !(function (e, t, r) {
              z(t, "offset"),
                (void 0 !== e[t] && void 0 !== e[t + r]) ||
                  q(t, e.length - (r + 1));
            })(i, s, n);
          }
          function z(e, t) {
            if ("number" != typeof e)
              throw new F.ERR_INVALID_ARG_TYPE(t, "number", e);
          }
          function q(e, t, r) {
            if (Math.floor(e) !== e)
              throw (
                (z(e, r), new F.ERR_OUT_OF_RANGE(r || "offset", "an integer", e))
              );
            if (t < 0) throw new F.ERR_BUFFER_OUT_OF_BOUNDS();
            throw new F.ERR_OUT_OF_RANGE(
              r || "offset",
              `>= ${r ? 1 : 0} and <= ${t}`,
              e
            );
          }
          H(
            "ERR_BUFFER_OUT_OF_BOUNDS",
            function (e) {
              return e
                ? `${e} is outside of buffer bounds`
                : "Attempt to access memory outside buffer bounds";
            },
            RangeError
          ),
            H(
              "ERR_INVALID_ARG_TYPE",
              function (e, t) {
                return `The "${e}" argument must be of type number. Received type ${typeof t}`;
              },
              TypeError
            ),
            H(
              "ERR_OUT_OF_RANGE",
              function (e, t, r) {
                let i = `The value of "${e}" is out of range.`,
                  s = r;
                return (
                  Number.isInteger(r) && Math.abs(r) > 2 ** 32
                    ? (s = Q(String(r)))
                    : "bigint" == typeof r &&
                      ((s = String(r)),
                      (r > BigInt(2) ** BigInt(32) ||
                        r < -(BigInt(2) ** BigInt(32))) &&
                        (s = Q(s)),
                      (s += "n")),
                  (i += ` It must be ${t}. Received ${s}`),
                  i
                );
              },
              RangeError
            );
          const G = /[^+/0-9A-Za-z-_]/g;
          function j(e, t) {
            let r;
            t = t || 1 / 0;
            const i = e.length;
            let s = null;
            const n = [];
            for (let a = 0; a < i; ++a) {
              if (((r = e.charCodeAt(a)), r > 55295 && r < 57344)) {
                if (!s) {
                  if (r > 56319) {
                    (t -= 3) > -1 && n.push(239, 191, 189);
                    continue;
                  }
                  if (a + 1 === i) {
                    (t -= 3) > -1 && n.push(239, 191, 189);
                    continue;
                  }
                  s = r;
                  continue;
                }
                if (r < 56320) {
                  (t -= 3) > -1 && n.push(239, 191, 189), (s = r);
                  continue;
                }
                r = 65536 + (((s - 55296) << 10) | (r - 56320));
              } else s && (t -= 3) > -1 && n.push(239, 191, 189);
              if (((s = null), r < 128)) {
                if ((t -= 1) < 0) break;
                n.push(r);
              } else if (r < 2048) {
                if ((t -= 2) < 0) break;
                n.push((r >> 6) | 192, (63 & r) | 128);
              } else if (r < 65536) {
                if ((t -= 3) < 0) break;
                n.push((r >> 12) | 224, ((r >> 6) & 63) | 128, (63 & r) | 128);
              } else {
                if (!(r < 1114112)) throw new Error("Invalid code point");
                if ((t -= 4) < 0) break;
                n.push(
                  (r >> 18) | 240,
                  ((r >> 12) & 63) | 128,
                  ((r >> 6) & 63) | 128,
                  (63 & r) | 128
                );
              }
            }
            return n;
          }
          function W(e) {
            return i.toByteArray(
              (function (e) {
                if ((e = (e = e.split("=")[0]).trim().replace(G, "")).length < 2)
                  return "";
                for (; e.length % 4 != 0; ) e += "=";
                return e;
              })(e)
            );
          }
          function Y(e, t, r, i) {
            let s;
            for (s = 0; s < i && !(s + r >= t.length || s >= e.length); ++s)
              t[s + r] = e[s];
            return s;
          }
          function X(e, t) {
            return (
              e instanceof t ||
              (null != e &&
                null != e.constructor &&
                null != e.constructor.name &&
                e.constructor.name === t.name)
            );
          }
          function K(e) {
            return e != e;
          }
          const J = (function () {
            const e = "0123456789abcdef",
              t = new Array(256);
            for (let r = 0; r < 16; ++r) {
              const i = 16 * r;
              for (let s = 0; s < 16; ++s) t[i + s] = e[r] + e[s];
            }
            return t;
          })();
          function Z(e) {
            return "undefined" == typeof BigInt ? $ : e;
          }
          function $() {
            throw new Error("BigInt not supported");
          }
        },
        7007: (e) => {
          "use strict";
          var t,
            r = "object" == typeof Reflect ? Reflect : null,
            i =
              r && "function" == typeof r.apply
                ? r.apply
                : function (e, t, r) {
                    return Function.prototype.apply.call(e, t, r);
                  };
          t =
            r && "function" == typeof r.ownKeys
              ? r.ownKeys
              : Object.getOwnPropertySymbols
              ? function (e) {
                  return Object.getOwnPropertyNames(e).concat(
                    Object.getOwnPropertySymbols(e)
                  );
                }
              : function (e) {
                  return Object.getOwnPropertyNames(e);
                };
          var s =
            Number.isNaN ||
            function (e) {
              return e != e;
            };
          function n() {
            n.init.call(this);
          }
          (e.exports = n),
            (e.exports.once = function (e, t) {
              return new Promise(function (r, i) {
                function s(r) {
                  e.removeListener(t, n), i(r);
                }
                function n() {
                  "function" == typeof e.removeListener &&
                    e.removeListener("error", s),
                    r([].slice.call(arguments));
                }
                g(e, t, n, { once: !0 }),
                  "error" !== t &&
                    (function (e, t, r) {
                      "function" == typeof e.on && g(e, "error", t, r);
                    })(e, s, { once: !0 });
              });
            }),
            (n.EventEmitter = n),
            (n.prototype._events = void 0),
            (n.prototype._eventsCount = 0),
            (n.prototype._maxListeners = void 0);
          var a = 10;
          function o(e) {
            if ("function" != typeof e)
              throw new TypeError(
                'The "listener" argument must be of type Function. Received type ' +
                  typeof e
              );
          }
          function c(e) {
            return void 0 === e._maxListeners
              ? n.defaultMaxListeners
              : e._maxListeners;
          }
          function l(e, t, r, i) {
            var s, n, a, l;
            if (
              (o(r),
              void 0 === (n = e._events)
                ? ((n = e._events = Object.create(null)), (e._eventsCount = 0))
                : (void 0 !== n.newListener &&
                    (e.emit("newListener", t, r.listener ? r.listener : r),
                    (n = e._events)),
                  (a = n[t])),
              void 0 === a)
            )
              (a = n[t] = r), ++e._eventsCount;
            else if (
              ("function" == typeof a
                ? (a = n[t] = i ? [r, a] : [a, r])
                : i
                ? a.unshift(r)
                : a.push(r),
              (s = c(e)) > 0 && a.length > s && !a.warned)
            ) {
              a.warned = !0;
              var h = new Error(
                "Possible EventEmitter memory leak detected. " +
                  a.length +
                  " " +
                  String(t) +
                  " listeners added. Use emitter.setMaxListeners() to increase limit"
              );
              (h.name = "MaxListenersExceededWarning"),
                (h.emitter = e),
                (h.type = t),
                (h.count = a.length),
                (l = h),
                console && console.warn && console.warn(l);
            }
            return e;
          }
          function h() {
            if (!this.fired)
              return (
                this.target.removeListener(this.type, this.wrapFn),
                (this.fired = !0),
                0 === arguments.length
                  ? this.listener.call(this.target)
                  : this.listener.apply(this.target, arguments)
              );
          }
          function u(e, t, r) {
            var i = {
                fired: !1,
                wrapFn: void 0,
                target: e,
                type: t,
                listener: r,
              },
              s = h.bind(i);
            return (s.listener = r), (i.wrapFn = s), s;
          }
          function d(e, t, r) {
            var i = e._events;
            if (void 0 === i) return [];
            var s = i[t];
            return void 0 === s
              ? []
              : "function" == typeof s
              ? r
                ? [s.listener || s]
                : [s]
              : r
              ? (function (e) {
                  for (var t = new Array(e.length), r = 0; r < t.length; ++r)
                    t[r] = e[r].listener || e[r];
                  return t;
                })(s)
              : f(s, s.length);
          }
          function p(e) {
            var t = this._events;
            if (void 0 !== t) {
              var r = t[e];
              if ("function" == typeof r) return 1;
              if (void 0 !== r) return r.length;
            }
            return 0;
          }
          function f(e, t) {
            for (var r = new Array(t), i = 0; i < t; ++i) r[i] = e[i];
            return r;
          }
          function g(e, t, r, i) {
            if ("function" == typeof e.on) i.once ? e.once(t, r) : e.on(t, r);
            else {
              if ("function" != typeof e.addEventListener)
                throw new TypeError(
                  'The "emitter" argument must be of type EventEmitter. Received type ' +
                    typeof e
                );
              e.addEventListener(t, function s(n) {
                i.once && e.removeEventListener(t, s), r(n);
              });
            }
          }
          Object.defineProperty(n, "defaultMaxListeners", {
            enumerable: !0,
            get: function () {
              return a;
            },
            set: function (e) {
              if ("number" != typeof e || e < 0 || s(e))
                throw new RangeError(
                  'The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' +
                    e +
                    "."
                );
              a = e;
            },
          }),
            (n.init = function () {
              (void 0 !== this._events &&
                this._events !== Object.getPrototypeOf(this)._events) ||
                ((this._events = Object.create(null)), (this._eventsCount = 0)),
                (this._maxListeners = this._maxListeners || void 0);
            }),
            (n.prototype.setMaxListeners = function (e) {
              if ("number" != typeof e || e < 0 || s(e))
                throw new RangeError(
                  'The value of "n" is out of range. It must be a non-negative number. Received ' +
                    e +
                    "."
                );
              return (this._maxListeners = e), this;
            }),
            (n.prototype.getMaxListeners = function () {
              return c(this);
            }),
            (n.prototype.emit = function (e) {
              for (var t = [], r = 1; r < arguments.length; r++)
                t.push(arguments[r]);
              var s = "error" === e,
                n = this._events;
              if (void 0 !== n) s = s && void 0 === n.error;
              else if (!s) return !1;
              if (s) {
                var a;
                if ((t.length > 0 && (a = t[0]), a instanceof Error)) throw a;
                var o = new Error(
                  "Unhandled error." + (a ? " (" + a.message + ")" : "")
                );
                throw ((o.context = a), o);
              }
              var c = n[e];
              if (void 0 === c) return !1;
              if ("function" == typeof c) i(c, this, t);
              else {
                var l = c.length,
                  h = f(c, l);
                for (r = 0; r < l; ++r) i(h[r], this, t);
              }
              return !0;
            }),
            (n.prototype.addListener = function (e, t) {
              return l(this, e, t, !1);
            }),
            (n.prototype.on = n.prototype.addListener),
            (n.prototype.prependListener = function (e, t) {
              return l(this, e, t, !0);
            }),
            (n.prototype.once = function (e, t) {
              return o(t), this.on(e, u(this, e, t)), this;
            }),
            (n.prototype.prependOnceListener = function (e, t) {
              return o(t), this.prependListener(e, u(this, e, t)), this;
            }),
            (n.prototype.removeListener = function (e, t) {
              var r, i, s, n, a;
              if ((o(t), void 0 === (i = this._events))) return this;
              if (void 0 === (r = i[e])) return this;
              if (r === t || r.listener === t)
                0 == --this._eventsCount
                  ? (this._events = Object.create(null))
                  : (delete i[e],
                    i.removeListener &&
                      this.emit("removeListener", e, r.listener || t));
              else if ("function" != typeof r) {
                for (s = -1, n = r.length - 1; n >= 0; n--)
                  if (r[n] === t || r[n].listener === t) {
                    (a = r[n].listener), (s = n);
                    break;
                  }
                if (s < 0) return this;
                0 === s
                  ? r.shift()
                  : (function (e, t) {
                      for (; t + 1 < e.length; t++) e[t] = e[t + 1];
                      e.pop();
                    })(r, s),
                  1 === r.length && (i[e] = r[0]),
                  void 0 !== i.removeListener &&
                    this.emit("removeListener", e, a || t);
              }
              return this;
            }),
            (n.prototype.off = n.prototype.removeListener),
            (n.prototype.removeAllListeners = function (e) {
              var t, r, i;
              if (void 0 === (r = this._events)) return this;
              if (void 0 === r.removeListener)
                return (
                  0 === arguments.length
                    ? ((this._events = Object.create(null)),
                      (this._eventsCount = 0))
                    : void 0 !== r[e] &&
                      (0 == --this._eventsCount
                        ? (this._events = Object.create(null))
                        : delete r[e]),
                  this
                );
              if (0 === arguments.length) {
                var s,
                  n = Object.keys(r);
                for (i = 0; i < n.length; ++i)
                  "removeListener" !== (s = n[i]) && this.removeAllListeners(s);
                return (
                  this.removeAllListeners("removeListener"),
                  (this._events = Object.create(null)),
                  (this._eventsCount = 0),
                  this
                );
              }
              if ("function" == typeof (t = r[e])) this.removeListener(e, t);
              else if (void 0 !== t)
                for (i = t.length - 1; i >= 0; i--) this.removeListener(e, t[i]);
              return this;
            }),
            (n.prototype.listeners = function (e) {
              return d(this, e, !0);
            }),
            (n.prototype.rawListeners = function (e) {
              return d(this, e, !1);
            }),
            (n.listenerCount = function (e, t) {
              return "function" == typeof e.listenerCount
                ? e.listenerCount(t)
                : p.call(e, t);
            }),
            (n.prototype.listenerCount = p),
            (n.prototype.eventNames = function () {
              return this._eventsCount > 0 ? t(this._events) : [];
            });
        },
        6454: (e, t, r) => {
          "use strict";
          const i = r(3918),
            s = r(2923),
            n = r(8904);
          e.exports = { XMLParser: s, XMLValidator: i, XMLBuilder: n };
        },
        5334: (e, t) => {
          "use strict";
          const r =
              ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD",
            i =
              "[" +
              r +
              "][" +
              (r + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040") +
              "]*",
            s = new RegExp("^" + i + "$");
          (t.isExist = function (e) {
            return void 0 !== e;
          }),
            (t.isEmptyObject = function (e) {
              return 0 === Object.keys(e).length;
            }),
            (t.merge = function (e, t, r) {
              if (t) {
                const i = Object.keys(t),
                  s = i.length;
                for (let n = 0; n < s; n++)
                  e[i[n]] = "strict" === r ? [t[i[n]]] : t[i[n]];
              }
            }),
            (t.getValue = function (e) {
              return t.isExist(e) ? e : "";
            }),
            (t.isName = function (e) {
              const t = s.exec(e);
              return !(null == t);
            }),
            (t.getAllMatches = function (e, t) {
              const r = [];
              let i = t.exec(e);
              for (; i; ) {
                const s = [];
                s.startIndex = t.lastIndex - i[0].length;
                const n = i.length;
                for (let e = 0; e < n; e++) s.push(i[e]);
                r.push(s), (i = t.exec(e));
              }
              return r;
            }),
            (t.nameRegexp = i);
        },
        3918: (e, t, r) => {
          "use strict";
          const i = r(5334),
            s = { allowBooleanAttributes: !1, unpairedTags: [] };
          function n(e) {
            return " " === e || "\t" === e || "\n" === e || "\r" === e;
          }
          function a(e, t) {
            const r = t;
            for (; t < e.length; t++)
              if ("?" != e[t] && " " != e[t]);
              else {
                const i = e.substr(r, t - r);
                if (t > 5 && "xml" === i)
                  return f(
                    "InvalidXml",
                    "XML declaration allowed only at the start of the document.",
                    m(e, t)
                  );
                if ("?" == e[t] && ">" == e[t + 1]) {
                  t++;
                  break;
                }
              }
            return t;
          }
          function o(e, t) {
            if (e.length > t + 5 && "-" === e[t + 1] && "-" === e[t + 2]) {
              for (t += 3; t < e.length; t++)
                if ("-" === e[t] && "-" === e[t + 1] && ">" === e[t + 2]) {
                  t += 2;
                  break;
                }
            } else if (
              e.length > t + 8 &&
              "D" === e[t + 1] &&
              "O" === e[t + 2] &&
              "C" === e[t + 3] &&
              "T" === e[t + 4] &&
              "Y" === e[t + 5] &&
              "P" === e[t + 6] &&
              "E" === e[t + 7]
            ) {
              let r = 1;
              for (t += 8; t < e.length; t++)
                if ("<" === e[t]) r++;
                else if (">" === e[t] && (r--, 0 === r)) break;
            } else if (
              e.length > t + 9 &&
              "[" === e[t + 1] &&
              "C" === e[t + 2] &&
              "D" === e[t + 3] &&
              "A" === e[t + 4] &&
              "T" === e[t + 5] &&
              "A" === e[t + 6] &&
              "[" === e[t + 7]
            )
              for (t += 8; t < e.length; t++)
                if ("]" === e[t] && "]" === e[t + 1] && ">" === e[t + 2]) {
                  t += 2;
                  break;
                }
            return t;
          }
          t.validate = function (e, t) {
            t = Object.assign({}, s, t);
            const r = [];
            let c = !1,
              l = !1;
            "\ufeff" === e[0] && (e = e.substr(1));
            for (let s = 0; s < e.length; s++)
              if ("<" === e[s] && "?" === e[s + 1]) {
                if (((s += 2), (s = a(e, s)), s.err)) return s;
              } else {
                if ("<" !== e[s]) {
                  if (n(e[s])) continue;
                  return f(
                    "InvalidChar",
                    "char '" + e[s] + "' is not expected.",
                    m(e, s)
                  );
                }
                {
                  let g = s;
                  if ((s++, "!" === e[s])) {
                    s = o(e, s);
                    continue;
                  }
                  {
                    let y = !1;
                    "/" === e[s] && ((y = !0), s++);
                    let A = "";
                    for (
                      ;
                      s < e.length &&
                      ">" !== e[s] &&
                      " " !== e[s] &&
                      "\t" !== e[s] &&
                      "\n" !== e[s] &&
                      "\r" !== e[s];
                      s++
                    )
                      A += e[s];
                    if (
                      ((A = A.trim()),
                      "/" === A[A.length - 1] &&
                        ((A = A.substring(0, A.length - 1)), s--),
                      (u = A),
                      !i.isName(u))
                    ) {
                      let t;
                      return (
                        (t =
                          0 === A.trim().length
                            ? "Invalid space after '<'."
                            : "Tag '" + A + "' is an invalid name."),
                        f("InvalidTag", t, m(e, s))
                      );
                    }
                    const w = h(e, s);
                    if (!1 === w)
                      return f(
                        "InvalidAttr",
                        "Attributes for '" + A + "' have open quote.",
                        m(e, s)
                      );
                    let E = w.value;
                    if (((s = w.index), "/" === E[E.length - 1])) {
                      const r = s - E.length;
                      E = E.substring(0, E.length - 1);
                      const i = d(E, t);
                      if (!0 !== i)
                        return f(i.err.code, i.err.msg, m(e, r + i.err.line));
                      c = !0;
                    } else if (y) {
                      if (!w.tagClosed)
                        return f(
                          "InvalidTag",
                          "Closing tag '" + A + "' doesn't have proper closing.",
                          m(e, s)
                        );
                      if (E.trim().length > 0)
                        return f(
                          "InvalidTag",
                          "Closing tag '" +
                            A +
                            "' can't have attributes or invalid starting.",
                          m(e, g)
                        );
                      if (0 === r.length)
                        return f(
                          "InvalidTag",
                          "Closing tag '" + A + "' has not been opened.",
                          m(e, g)
                        );
                      {
                        const t = r.pop();
                        if (A !== t.tagName) {
                          let r = m(e, t.tagStartPos);
                          return f(
                            "InvalidTag",
                            "Expected closing tag '" +
                              t.tagName +
                              "' (opened in line " +
                              r.line +
                              ", col " +
                              r.col +
                              ") instead of closing tag '" +
                              A +
                              "'.",
                            m(e, g)
                          );
                        }
                        0 == r.length && (l = !0);
                      }
                    } else {
                      const i = d(E, t);
                      if (!0 !== i)
                        return f(
                          i.err.code,
                          i.err.msg,
                          m(e, s - E.length + i.err.line)
                        );
                      if (!0 === l)
                        return f(
                          "InvalidXml",
                          "Multiple possible root nodes found.",
                          m(e, s)
                        );
                      -1 !== t.unpairedTags.indexOf(A) ||
                        r.push({ tagName: A, tagStartPos: g }),
                        (c = !0);
                    }
                    for (s++; s < e.length; s++)
                      if ("<" === e[s]) {
                        if ("!" === e[s + 1]) {
                          s++, (s = o(e, s));
                          continue;
                        }
                        if ("?" !== e[s + 1]) break;
                        if (((s = a(e, ++s)), s.err)) return s;
                      } else if ("&" === e[s]) {
                        const t = p(e, s);
                        if (-1 == t)
                          return f(
                            "InvalidChar",
                            "char '&' is not expected.",
                            m(e, s)
                          );
                        s = t;
                      } else if (!0 === l && !n(e[s]))
                        return f("InvalidXml", "Extra text at the end", m(e, s));
                    "<" === e[s] && s--;
                  }
                }
              }
            var u;
            return c
              ? 1 == r.length
                ? f(
                    "InvalidTag",
                    "Unclosed tag '" + r[0].tagName + "'.",
                    m(e, r[0].tagStartPos)
                  )
                : !(r.length > 0) ||
                  f(
                    "InvalidXml",
                    "Invalid '" +
                      JSON.stringify(
                        r.map((e) => e.tagName),
                        null,
                        4
                      ).replace(/\r?\n/g, "") +
                      "' found.",
                    { line: 1, col: 1 }
                  )
              : f("InvalidXml", "Start tag expected.", 1);
          };
          const c = '"',
            l = "'";
          function h(e, t) {
            let r = "",
              i = "",
              s = !1;
            for (; t < e.length; t++) {
              if (e[t] === c || e[t] === l)
                "" === i ? (i = e[t]) : i !== e[t] || (i = "");
              else if (">" === e[t] && "" === i) {
                s = !0;
                break;
              }
              r += e[t];
            }
            return "" === i && { value: r, index: t, tagClosed: s };
          }
          const u = new RegExp(
            "(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['\"])(([\\s\\S])*?)\\5)?",
            "g"
          );
          function d(e, t) {
            const r = i.getAllMatches(e, u),
              s = {};
            for (let e = 0; e < r.length; e++) {
              if (0 === r[e][1].length)
                return f(
                  "InvalidAttr",
                  "Attribute '" + r[e][2] + "' has no space in starting.",
                  y(r[e])
                );
              if (void 0 !== r[e][3] && void 0 === r[e][4])
                return f(
                  "InvalidAttr",
                  "Attribute '" + r[e][2] + "' is without value.",
                  y(r[e])
                );
              if (void 0 === r[e][3] && !t.allowBooleanAttributes)
                return f(
                  "InvalidAttr",
                  "boolean attribute '" + r[e][2] + "' is not allowed.",
                  y(r[e])
                );
              const i = r[e][2];
              if (!g(i))
                return f(
                  "InvalidAttr",
                  "Attribute '" + i + "' is an invalid name.",
                  y(r[e])
                );
              if (s.hasOwnProperty(i))
                return f(
                  "InvalidAttr",
                  "Attribute '" + i + "' is repeated.",
                  y(r[e])
                );
              s[i] = 1;
            }
            return !0;
          }
          function p(e, t) {
            if (";" === e[++t]) return -1;
            if ("#" === e[t])
              return (function (e, t) {
                let r = /\d/;
                for (
                  "x" === e[t] && (t++, (r = /[\da-fA-F]/));
                  t < e.length;
                  t++
                ) {
                  if (";" === e[t]) return t;
                  if (!e[t].match(r)) break;
                }
                return -1;
              })(e, ++t);
            let r = 0;
            for (; t < e.length; t++, r++)
              if (!(e[t].match(/\w/) && r < 20)) {
                if (";" === e[t]) break;
                return -1;
              }
            return t;
          }
          function f(e, t, r) {
            return { err: { code: e, msg: t, line: r.line || r, col: r.col } };
          }
          function g(e) {
            return i.isName(e);
          }
          function m(e, t) {
            const r = e.substring(0, t).split(/\r?\n/);
            return { line: r.length, col: r[r.length - 1].length + 1 };
          }
          function y(e) {
            return e.startIndex + e[1].length;
          }
        },
        8904: (e, t, r) => {
          "use strict";
          const i = r(2788),
            s = {
              attributeNamePrefix: "@_",
              attributesGroupName: !1,
              textNodeName: "#text",
              ignoreAttributes: !0,
              cdataPropName: !1,
              format: !1,
              indentBy: "  ",
              suppressEmptyNode: !1,
              suppressUnpairedNode: !0,
              suppressBooleanAttributes: !0,
              tagValueProcessor: function (e, t) {
                return t;
              },
              attributeValueProcessor: function (e, t) {
                return t;
              },
              preserveOrder: !1,
              commentPropName: !1,
              unpairedTags: [],
              entities: [
                { regex: new RegExp("&", "g"), val: "&amp;" },
                { regex: new RegExp(">", "g"), val: "&gt;" },
                { regex: new RegExp("<", "g"), val: "&lt;" },
                { regex: new RegExp("'", "g"), val: "&apos;" },
                { regex: new RegExp('"', "g"), val: "&quot;" },
              ],
              processEntities: !0,
              stopNodes: [],
              oneListGroup: !1,
            };
          function n(e) {
            (this.options = Object.assign({}, s, e)),
              this.options.ignoreAttributes || this.options.attributesGroupName
                ? (this.isAttribute = function () {
                    return !1;
                  })
                : ((this.attrPrefixLen = this.options.attributeNamePrefix.length),
                  (this.isAttribute = c)),
              (this.processTextOrObjNode = a),
              this.options.format
                ? ((this.indentate = o),
                  (this.tagEndChar = ">\n"),
                  (this.newLine = "\n"))
                : ((this.indentate = function () {
                    return "";
                  }),
                  (this.tagEndChar = ">"),
                  (this.newLine = ""));
          }
          function a(e, t, r) {
            const i = this.j2x(e, r + 1);
            return void 0 !== e[this.options.textNodeName] &&
              1 === Object.keys(e).length
              ? this.buildTextValNode(
                  e[this.options.textNodeName],
                  t,
                  i.attrStr,
                  r
                )
              : this.buildObjectNode(i.val, t, i.attrStr, r);
          }
          function o(e) {
            return this.options.indentBy.repeat(e);
          }
          function c(e) {
            return (
              !(
                !e.startsWith(this.options.attributeNamePrefix) ||
                e === this.options.textNodeName
              ) && e.substr(this.attrPrefixLen)
            );
          }
          (n.prototype.build = function (e) {
            return this.options.preserveOrder
              ? i(e, this.options)
              : (Array.isArray(e) &&
                  this.options.arrayNodeName &&
                  this.options.arrayNodeName.length > 1 &&
                  (e = { [this.options.arrayNodeName]: e }),
                this.j2x(e, 0).val);
          }),
            (n.prototype.j2x = function (e, t) {
              let r = "",
                i = "";
              for (let s in e)
                if (Object.prototype.hasOwnProperty.call(e, s))
                  if (void 0 === e[s]) this.isAttribute(s) && (i += "");
                  else if (null === e[s])
                    this.isAttribute(s)
                      ? (i += "")
                      : "?" === s[0]
                      ? (i += this.indentate(t) + "<" + s + "?" + this.tagEndChar)
                      : (i +=
                          this.indentate(t) + "<" + s + "/" + this.tagEndChar);
                  else if (e[s] instanceof Date)
                    i += this.buildTextValNode(e[s], s, "", t);
                  else if ("object" != typeof e[s]) {
                    const n = this.isAttribute(s);
                    if (n) r += this.buildAttrPairStr(n, "" + e[s]);
                    else if (s === this.options.textNodeName) {
                      let t = this.options.tagValueProcessor(s, "" + e[s]);
                      i += this.replaceEntitiesValue(t);
                    } else i += this.buildTextValNode(e[s], s, "", t);
                  } else if (Array.isArray(e[s])) {
                    const r = e[s].length;
                    let n = "",
                      a = "";
                    for (let o = 0; o < r; o++) {
                      const r = e[s][o];
                      if (void 0 === r);
                      else if (null === r)
                        "?" === s[0]
                          ? (i +=
                              this.indentate(t) + "<" + s + "?" + this.tagEndChar)
                          : (i +=
                              this.indentate(t) +
                              "<" +
                              s +
                              "/" +
                              this.tagEndChar);
                      else if ("object" == typeof r)
                        if (this.options.oneListGroup) {
                          const e = this.j2x(r, t + 1);
                          (n += e.val),
                            this.options.attributesGroupName &&
                              r.hasOwnProperty(
                                this.options.attributesGroupName
                              ) &&
                              (a += e.attrStr);
                        } else n += this.processTextOrObjNode(r, s, t);
                      else if (this.options.oneListGroup) {
                        let e = this.options.tagValueProcessor(s, r);
                        (e = this.replaceEntitiesValue(e)), (n += e);
                      } else n += this.buildTextValNode(r, s, "", t);
                    }
                    this.options.oneListGroup &&
                      (n = this.buildObjectNode(n, s, a, t)),
                      (i += n);
                  } else if (
                    this.options.attributesGroupName &&
                    s === this.options.attributesGroupName
                  ) {
                    const t = Object.keys(e[s]),
                      i = t.length;
                    for (let n = 0; n < i; n++)
                      r += this.buildAttrPairStr(t[n], "" + e[s][t[n]]);
                  } else i += this.processTextOrObjNode(e[s], s, t);
              return { attrStr: r, val: i };
            }),
            (n.prototype.buildAttrPairStr = function (e, t) {
              return (
                (t = this.options.attributeValueProcessor(e, "" + t)),
                (t = this.replaceEntitiesValue(t)),
                this.options.suppressBooleanAttributes && "true" === t
                  ? " " + e
                  : " " + e + '="' + t + '"'
              );
            }),
            (n.prototype.buildObjectNode = function (e, t, r, i) {
              if ("" === e)
                return "?" === t[0]
                  ? this.indentate(i) + "<" + t + r + "?" + this.tagEndChar
                  : this.indentate(i) +
                      "<" +
                      t +
                      r +
                      this.closeTag(t) +
                      this.tagEndChar;
              {
                let s = "</" + t + this.tagEndChar,
                  n = "";
                return (
                  "?" === t[0] && ((n = "?"), (s = "")),
                  (!r && "" !== r) || -1 !== e.indexOf("<")
                    ? !1 !== this.options.commentPropName &&
                      t === this.options.commentPropName &&
                      0 === n.length
                      ? this.indentate(i) + `\x3c!--${e}--\x3e` + this.newLine
                      : this.indentate(i) +
                        "<" +
                        t +
                        r +
                        n +
                        this.tagEndChar +
                        e +
                        this.indentate(i) +
                        s
                    : this.indentate(i) + "<" + t + r + n + ">" + e + s
                );
              }
            }),
            (n.prototype.closeTag = function (e) {
              let t = "";
              return (
                -1 !== this.options.unpairedTags.indexOf(e)
                  ? this.options.suppressUnpairedNode || (t = "/")
                  : (t = this.options.suppressEmptyNode ? "/" : `></${e}`),
                t
              );
            }),
            (n.prototype.buildTextValNode = function (e, t, r, i) {
              if (
                !1 !== this.options.cdataPropName &&
                t === this.options.cdataPropName
              )
                return this.indentate(i) + `<![CDATA[${e}]]>` + this.newLine;
              if (
                !1 !== this.options.commentPropName &&
                t === this.options.commentPropName
              )
                return this.indentate(i) + `\x3c!--${e}--\x3e` + this.newLine;
              if ("?" === t[0])
                return this.indentate(i) + "<" + t + r + "?" + this.tagEndChar;
              {
                let s = this.options.tagValueProcessor(t, e);
                return (
                  (s = this.replaceEntitiesValue(s)),
                  "" === s
                    ? this.indentate(i) +
                      "<" +
                      t +
                      r +
                      this.closeTag(t) +
                      this.tagEndChar
                    : this.indentate(i) +
                      "<" +
                      t +
                      r +
                      ">" +
                      s +
                      "</" +
                      t +
                      this.tagEndChar
                );
              }
            }),
            (n.prototype.replaceEntitiesValue = function (e) {
              if (e && e.length > 0 && this.options.processEntities)
                for (let t = 0; t < this.options.entities.length; t++) {
                  const r = this.options.entities[t];
                  e = e.replace(r.regex, r.val);
                }
              return e;
            }),
            (e.exports = n);
        },
        2788: (e) => {
          function t(e, a, o, c) {
            let l = "",
              h = !1;
            for (let u = 0; u < e.length; u++) {
              const d = e[u],
                p = r(d);
              if (void 0 === p) continue;
              let f = "";
              if (
                ((f = 0 === o.length ? p : `${o}.${p}`), p === a.textNodeName)
              ) {
                let e = d[p];
                s(f, a) || ((e = a.tagValueProcessor(p, e)), (e = n(e, a))),
                  h && (l += c),
                  (l += e),
                  (h = !1);
                continue;
              }
              if (p === a.cdataPropName) {
                h && (l += c),
                  (l += `<![CDATA[${d[p][0][a.textNodeName]}]]>`),
                  (h = !1);
                continue;
              }
              if (p === a.commentPropName) {
                (l += c + `\x3c!--${d[p][0][a.textNodeName]}--\x3e`), (h = !0);
                continue;
              }
              if ("?" === p[0]) {
                const e = i(d[":@"], a),
                  t = "?xml" === p ? "" : c;
                let r = d[p][0][a.textNodeName];
                (r = 0 !== r.length ? " " + r : ""),
                  (l += t + `<${p}${r}${e}?>`),
                  (h = !0);
                continue;
              }
              let g = c;
              "" !== g && (g += a.indentBy);
              const m = c + `<${p}${i(d[":@"], a)}`,
                y = t(d[p], a, f, g);
              -1 !== a.unpairedTags.indexOf(p)
                ? a.suppressUnpairedNode
                  ? (l += m + ">")
                  : (l += m + "/>")
                : (y && 0 !== y.length) || !a.suppressEmptyNode
                ? y && y.endsWith(">")
                  ? (l += m + `>${y}${c}</${p}>`)
                  : ((l += m + ">"),
                    y && "" !== c && (y.includes("/>") || y.includes("</"))
                      ? (l += c + a.indentBy + y + c)
                      : (l += y),
                    (l += `</${p}>`))
                : (l += m + "/>"),
                (h = !0);
            }
            return l;
          }
          function r(e) {
            const t = Object.keys(e);
            for (let r = 0; r < t.length; r++) {
              const i = t[r];
              if (e.hasOwnProperty(i) && ":@" !== i) return i;
            }
          }
          function i(e, t) {
            let r = "";
            if (e && !t.ignoreAttributes)
              for (let i in e) {
                if (!e.hasOwnProperty(i)) continue;
                let s = t.attributeValueProcessor(i, e[i]);
                (s = n(s, t)),
                  !0 === s && t.suppressBooleanAttributes
                    ? (r += ` ${i.substr(t.attributeNamePrefix.length)}`)
                    : (r += ` ${i.substr(t.attributeNamePrefix.length)}="${s}"`);
              }
            return r;
          }
          function s(e, t) {
            let r = (e = e.substr(
              0,
              e.length - t.textNodeName.length - 1
            )).substr(e.lastIndexOf(".") + 1);
            for (let i in t.stopNodes)
              if (t.stopNodes[i] === e || t.stopNodes[i] === "*." + r) return !0;
            return !1;
          }
          function n(e, t) {
            if (e && e.length > 0 && t.processEntities)
              for (let r = 0; r < t.entities.length; r++) {
                const i = t.entities[r];
                e = e.replace(i.regex, i.val);
              }
            return e;
          }
          e.exports = function (e, r) {
            let i = "";
            return (
              r.format && r.indentBy.length > 0 && (i = "\n"), t(e, r, "", i)
            );
          };
        },
        9400: (e, t, r) => {
          const i = r(5334);
          function s(e, t) {
            let r = "";
            for (; t < e.length && "'" !== e[t] && '"' !== e[t]; t++) r += e[t];
            if (((r = r.trim()), -1 !== r.indexOf(" ")))
              throw new Error("External entites are not supported");
            const i = e[t++];
            let s = "";
            for (; t < e.length && e[t] !== i; t++) s += e[t];
            return [r, s, t];
          }
          function n(e, t) {
            return "!" === e[t + 1] && "-" === e[t + 2] && "-" === e[t + 3];
          }
          function a(e, t) {
            return (
              "!" === e[t + 1] &&
              "E" === e[t + 2] &&
              "N" === e[t + 3] &&
              "T" === e[t + 4] &&
              "I" === e[t + 5] &&
              "T" === e[t + 6] &&
              "Y" === e[t + 7]
            );
          }
          function o(e, t) {
            return (
              "!" === e[t + 1] &&
              "E" === e[t + 2] &&
              "L" === e[t + 3] &&
              "E" === e[t + 4] &&
              "M" === e[t + 5] &&
              "E" === e[t + 6] &&
              "N" === e[t + 7] &&
              "T" === e[t + 8]
            );
          }
          function c(e, t) {
            return (
              "!" === e[t + 1] &&
              "A" === e[t + 2] &&
              "T" === e[t + 3] &&
              "T" === e[t + 4] &&
              "L" === e[t + 5] &&
              "I" === e[t + 6] &&
              "S" === e[t + 7] &&
              "T" === e[t + 8]
            );
          }
          function l(e, t) {
            return (
              "!" === e[t + 1] &&
              "N" === e[t + 2] &&
              "O" === e[t + 3] &&
              "T" === e[t + 4] &&
              "A" === e[t + 5] &&
              "T" === e[t + 6] &&
              "I" === e[t + 7] &&
              "O" === e[t + 8] &&
              "N" === e[t + 9]
            );
          }
          function h(e) {
            if (i.isName(e)) return e;
            throw new Error(`Invalid entity name ${e}`);
          }
          e.exports = function (e, t) {
            const r = {};
            if (
              "O" !== e[t + 3] ||
              "C" !== e[t + 4] ||
              "T" !== e[t + 5] ||
              "Y" !== e[t + 6] ||
              "P" !== e[t + 7] ||
              "E" !== e[t + 8]
            )
              throw new Error("Invalid Tag instead of DOCTYPE");
            {
              t += 9;
              let i = 1,
                u = !1,
                d = !1,
                p = "";
              for (; t < e.length; t++)
                if ("<" !== e[t] || d)
                  if (">" === e[t]) {
                    if (
                      (d
                        ? "-" === e[t - 1] && "-" === e[t - 2] && ((d = !1), i--)
                        : i--,
                      0 === i)
                    )
                      break;
                  } else "[" === e[t] ? (u = !0) : (p += e[t]);
                else {
                  if (u && a(e, t))
                    (t += 7),
                      ([entityName, val, t] = s(e, t + 1)),
                      -1 === val.indexOf("&") &&
                        (r[h(entityName)] = {
                          regx: RegExp(`&${entityName};`, "g"),
                          val,
                        });
                  else if (u && o(e, t)) t += 8;
                  else if (u && c(e, t)) t += 8;
                  else if (u && l(e, t)) t += 9;
                  else {
                    if (!n) throw new Error("Invalid DOCTYPE");
                    d = !0;
                  }
                  i++, (p = "");
                }
              if (0 !== i) throw new Error("Unclosed DOCTYPE");
            }
            return { entities: r, i: t };
          };
        },
        460: (e, t) => {
          const r = {
            preserveOrder: !1,
            attributeNamePrefix: "@_",
            attributesGroupName: !1,
            textNodeName: "#text",
            ignoreAttributes: !0,
            removeNSPrefix: !1,
            allowBooleanAttributes: !1,
            parseTagValue: !0,
            parseAttributeValue: !1,
            trimValues: !0,
            cdataPropName: !1,
            numberParseOptions: { hex: !0, leadingZeros: !0, eNotation: !0 },
            tagValueProcessor: function (e, t) {
              return t;
            },
            attributeValueProcessor: function (e, t) {
              return t;
            },
            stopNodes: [],
            alwaysCreateTextNode: !1,
            isArray: () => !1,
            commentPropName: !1,
            unpairedTags: [],
            processEntities: !0,
            htmlEntities: !1,
            ignoreDeclaration: !1,
            ignorePiTags: !1,
            transformTagName: !1,
            transformAttributeName: !1,
            updateTag: function (e, t, r) {
              return e;
            },
          };
          (t.buildOptions = function (e) {
            return Object.assign({}, r, e);
          }),
            (t.defaultOptions = r);
        },
        7680: (e, t, r) => {
          "use strict";
          const i = r(5334),
            s = r(3832),
            n = r(9400),
            a = r(7983);
          function o(e) {
            const t = Object.keys(e);
            for (let r = 0; r < t.length; r++) {
              const i = t[r];
              this.lastEntities[i] = {
                regex: new RegExp("&" + i + ";", "g"),
                val: e[i],
              };
            }
          }
          function c(e, t, r, i, s, n, a) {
            if (
              void 0 !== e &&
              (this.options.trimValues && !i && (e = e.trim()), e.length > 0)
            ) {
              a || (e = this.replaceEntitiesValue(e));
              const i = this.options.tagValueProcessor(t, e, r, s, n);
              if (null == i) return e;
              if (typeof i != typeof e || i !== e) return i;
              if (this.options.trimValues)
                return E(
                  e,
                  this.options.parseTagValue,
                  this.options.numberParseOptions
                );
              return e.trim() === e
                ? E(
                    e,
                    this.options.parseTagValue,
                    this.options.numberParseOptions
                  )
                : e;
            }
          }
          function l(e) {
            if (this.options.removeNSPrefix) {
              const t = e.split(":"),
                r = "/" === e.charAt(0) ? "/" : "";
              if ("xmlns" === t[0]) return "";
              2 === t.length && (e = r + t[1]);
            }
            return e;
          }
          const h = new RegExp(
            "([^\\s=]+)\\s*(=\\s*(['\"])([\\s\\S]*?)\\3)?",
            "gm"
          );
          function u(e, t, r) {
            if (!this.options.ignoreAttributes && "string" == typeof e) {
              const r = i.getAllMatches(e, h),
                s = r.length,
                n = {};
              for (let e = 0; e < s; e++) {
                const i = this.resolveNameSpace(r[e][1]);
                let s = r[e][4],
                  a = this.options.attributeNamePrefix + i;
                if (i.length)
                  if (
                    (this.options.transformAttributeName &&
                      (a = this.options.transformAttributeName(a)),
                    "__proto__" === a && (a = "#__proto__"),
                    void 0 !== s)
                  ) {
                    this.options.trimValues && (s = s.trim()),
                      (s = this.replaceEntitiesValue(s));
                    const e = this.options.attributeValueProcessor(i, s, t);
                    n[a] =
                      null == e
                        ? s
                        : typeof e != typeof s || e !== s
                        ? e
                        : E(
                            s,
                            this.options.parseAttributeValue,
                            this.options.numberParseOptions
                          );
                  } else this.options.allowBooleanAttributes && (n[a] = !0);
              }
              if (!Object.keys(n).length) return;
              if (this.options.attributesGroupName) {
                const e = {};
                return (e[this.options.attributesGroupName] = n), e;
              }
              return n;
            }
          }
          const d = function (e) {
            e = e.replace(/\r\n?/g, "\n");
            const t = new s("!xml");
            let r = t,
              i = "",
              a = "";
            for (let o = 0; o < e.length; o++) {
              if ("<" === e[o])
                if ("/" === e[o + 1]) {
                  const t = y(e, ">", o, "Closing Tag is not closed.");
                  let s = e.substring(o + 2, t).trim();
                  if (this.options.removeNSPrefix) {
                    const e = s.indexOf(":");
                    -1 !== e && (s = s.substr(e + 1));
                  }
                  this.options.transformTagName &&
                    (s = this.options.transformTagName(s)),
                    r && (i = this.saveTextToParentTag(i, r, a));
                  const n = a.substring(a.lastIndexOf(".") + 1);
                  if (s && -1 !== this.options.unpairedTags.indexOf(s))
                    throw new Error(
                      `Unpaired tag can not be used as closing tag: </${s}>`
                    );
                  let c = 0;
                  n && -1 !== this.options.unpairedTags.indexOf(n)
                    ? ((c = a.lastIndexOf(".", a.lastIndexOf(".") - 1)),
                      this.tagsNodeStack.pop())
                    : (c = a.lastIndexOf(".")),
                    (a = a.substring(0, c)),
                    (r = this.tagsNodeStack.pop()),
                    (i = ""),
                    (o = t);
                } else if ("?" === e[o + 1]) {
                  let t = A(e, o, !1, "?>");
                  if (!t) throw new Error("Pi Tag is not closed.");
                  if (
                    ((i = this.saveTextToParentTag(i, r, a)),
                    (this.options.ignoreDeclaration && "?xml" === t.tagName) ||
                      this.options.ignorePiTags)
                  );
                  else {
                    const e = new s(t.tagName);
                    e.add(this.options.textNodeName, ""),
                      t.tagName !== t.tagExp &&
                        t.attrExpPresent &&
                        (e[":@"] = this.buildAttributesMap(
                          t.tagExp,
                          a,
                          t.tagName
                        )),
                      this.addChild(r, e, a);
                  }
                  o = t.closeIndex + 1;
                } else if ("!--" === e.substr(o + 1, 3)) {
                  const t = y(e, "--\x3e", o + 4, "Comment is not closed.");
                  if (this.options.commentPropName) {
                    const s = e.substring(o + 4, t - 2);
                    (i = this.saveTextToParentTag(i, r, a)),
                      r.add(this.options.commentPropName, [
                        { [this.options.textNodeName]: s },
                      ]);
                  }
                  o = t;
                } else if ("!D" === e.substr(o + 1, 2)) {
                  const t = n(e, o);
                  (this.docTypeEntities = t.entities), (o = t.i);
                } else if ("![" === e.substr(o + 1, 2)) {
                  const t = y(e, "]]>", o, "CDATA is not closed.") - 2,
                    s = e.substring(o + 9, t);
                  i = this.saveTextToParentTag(i, r, a);
                  let n = this.parseTextData(s, r.tagname, a, !0, !1, !0, !0);
                  null == n && (n = ""),
                    this.options.cdataPropName
                      ? r.add(this.options.cdataPropName, [
                          { [this.options.textNodeName]: s },
                        ])
                      : r.add(this.options.textNodeName, n),
                    (o = t + 2);
                } else {
                  let n = A(e, o, this.options.removeNSPrefix),
                    c = n.tagName;
                  const l = n.rawTagName;
                  let h = n.tagExp,
                    u = n.attrExpPresent,
                    d = n.closeIndex;
                  this.options.transformTagName &&
                    (c = this.options.transformTagName(c)),
                    r &&
                      i &&
                      "!xml" !== r.tagname &&
                      (i = this.saveTextToParentTag(i, r, a, !1));
                  const p = r;
                  if (
                    (p &&
                      -1 !== this.options.unpairedTags.indexOf(p.tagname) &&
                      ((r = this.tagsNodeStack.pop()),
                      (a = a.substring(0, a.lastIndexOf(".")))),
                    c !== t.tagname && (a += a ? "." + c : c),
                    this.isItStopNode(this.options.stopNodes, a, c))
                  ) {
                    let t = "";
                    if (h.length > 0 && h.lastIndexOf("/") === h.length - 1)
                      "/" === c[c.length - 1]
                        ? ((c = c.substr(0, c.length - 1)),
                          (a = a.substr(0, a.length - 1)),
                          (h = c))
                        : (h = h.substr(0, h.length - 1)),
                        (o = n.closeIndex);
                    else if (-1 !== this.options.unpairedTags.indexOf(c))
                      o = n.closeIndex;
                    else {
                      const r = this.readStopNodeData(e, l, d + 1);
                      if (!r) throw new Error(`Unexpected end of ${l}`);
                      (o = r.i), (t = r.tagContent);
                    }
                    const i = new s(c);
                    c !== h && u && (i[":@"] = this.buildAttributesMap(h, a, c)),
                      t && (t = this.parseTextData(t, c, a, !0, u, !0, !0)),
                      (a = a.substr(0, a.lastIndexOf("."))),
                      i.add(this.options.textNodeName, t),
                      this.addChild(r, i, a);
                  } else {
                    if (h.length > 0 && h.lastIndexOf("/") === h.length - 1) {
                      "/" === c[c.length - 1]
                        ? ((c = c.substr(0, c.length - 1)),
                          (a = a.substr(0, a.length - 1)),
                          (h = c))
                        : (h = h.substr(0, h.length - 1)),
                        this.options.transformTagName &&
                          (c = this.options.transformTagName(c));
                      const e = new s(c);
                      c !== h &&
                        u &&
                        (e[":@"] = this.buildAttributesMap(h, a, c)),
                        this.addChild(r, e, a),
                        (a = a.substr(0, a.lastIndexOf(".")));
                    } else {
                      const e = new s(c);
                      this.tagsNodeStack.push(r),
                        c !== h &&
                          u &&
                          (e[":@"] = this.buildAttributesMap(h, a, c)),
                        this.addChild(r, e, a),
                        (r = e);
                    }
                    (i = ""), (o = d);
                  }
                }
              else i += e[o];
            }
            return t.child;
          };
          function p(e, t, r) {
            const i = this.options.updateTag(t.tagname, r, t[":@"]);
            !1 === i ||
              ("string" == typeof i
                ? ((t.tagname = i), e.addChild(t))
                : e.addChild(t));
          }
          const f = function (e) {
            if (this.options.processEntities) {
              for (let t in this.docTypeEntities) {
                const r = this.docTypeEntities[t];
                e = e.replace(r.regx, r.val);
              }
              for (let t in this.lastEntities) {
                const r = this.lastEntities[t];
                e = e.replace(r.regex, r.val);
              }
              if (this.options.htmlEntities)
                for (let t in this.htmlEntities) {
                  const r = this.htmlEntities[t];
                  e = e.replace(r.regex, r.val);
                }
              e = e.replace(this.ampEntity.regex, this.ampEntity.val);
            }
            return e;
          };
          function g(e, t, r, i) {
            return (
              e &&
                (void 0 === i && (i = 0 === Object.keys(t.child).length),
                void 0 !==
                  (e = this.parseTextData(
                    e,
                    t.tagname,
                    r,
                    !1,
                    !!t[":@"] && 0 !== Object.keys(t[":@"]).length,
                    i
                  )) &&
                  "" !== e &&
                  t.add(this.options.textNodeName, e),
                (e = "")),
              e
            );
          }
          function m(e, t, r) {
            const i = "*." + r;
            for (const r in e) {
              const s = e[r];
              if (i === s || t === s) return !0;
            }
            return !1;
          }
          function y(e, t, r, i) {
            const s = e.indexOf(t, r);
            if (-1 === s) throw new Error(i);
            return s + t.length - 1;
          }
          function A(e, t, r, i = ">") {
            const s = (function (e, t, r = ">") {
              let i,
                s = "";
              for (let n = t; n < e.length; n++) {
                let t = e[n];
                if (i) t === i && (i = "");
                else if ('"' === t || "'" === t) i = t;
                else if (t === r[0]) {
                  if (!r[1]) return { data: s, index: n };
                  if (e[n + 1] === r[1]) return { data: s, index: n };
                } else "\t" === t && (t = " ");
                s += t;
              }
            })(e, t + 1, i);
            if (!s) return;
            let n = s.data;
            const a = s.index,
              o = n.search(/\s/);
            let c = n,
              l = !0;
            -1 !== o &&
              ((c = n.substring(0, o)), (n = n.substring(o + 1).trimStart()));
            const h = c;
            if (r) {
              const e = c.indexOf(":");
              -1 !== e &&
                ((c = c.substr(e + 1)), (l = c !== s.data.substr(e + 1)));
            }
            return {
              tagName: c,
              tagExp: n,
              closeIndex: a,
              attrExpPresent: l,
              rawTagName: h,
            };
          }
          function w(e, t, r) {
            const i = r;
            let s = 1;
            for (; r < e.length; r++)
              if ("<" === e[r])
                if ("/" === e[r + 1]) {
                  const n = y(e, ">", r, `${t} is not closed`);
                  if (e.substring(r + 2, n).trim() === t && (s--, 0 === s))
                    return { tagContent: e.substring(i, r), i: n };
                  r = n;
                } else if ("?" === e[r + 1]) {
                  r = y(e, "?>", r + 1, "StopNode is not closed.");
                } else if ("!--" === e.substr(r + 1, 3)) {
                  r = y(e, "--\x3e", r + 3, "StopNode is not closed.");
                } else if ("![" === e.substr(r + 1, 2)) {
                  r = y(e, "]]>", r, "StopNode is not closed.") - 2;
                } else {
                  const i = A(e, r, ">");
                  if (i) {
                    (i && i.tagName) === t &&
                      "/" !== i.tagExp[i.tagExp.length - 1] &&
                      s++,
                      (r = i.closeIndex);
                  }
                }
          }
          function E(e, t, r) {
            if (t && "string" == typeof e) {
              const t = e.trim();
              return "true" === t || ("false" !== t && a(e, r));
            }
            return i.isExist(e) ? e : "";
          }
          e.exports = class {
            constructor(e) {
              (this.options = e),
                (this.currentNode = null),
                (this.tagsNodeStack = []),
                (this.docTypeEntities = {}),
                (this.lastEntities = {
                  apos: { regex: /&(apos|#39|#x27);/g, val: "'" },
                  gt: { regex: /&(gt|#62|#x3E);/g, val: ">" },
                  lt: { regex: /&(lt|#60|#x3C);/g, val: "<" },
                  quot: { regex: /&(quot|#34|#x22);/g, val: '"' },
                }),
                (this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" }),
                (this.htmlEntities = {
                  space: { regex: /&(nbsp|#160);/g, val: " " },
                  cent: { regex: /&(cent|#162);/g, val: "" },
                  pound: { regex: /&(pound|#163);/g, val: "" },
                  yen: { regex: /&(yen|#165);/g, val: "" },
                  euro: { regex: /&(euro|#8364);/g, val: "" },
                  copyright: { regex: /&(copy|#169);/g, val: "" },
                  reg: { regex: /&(reg|#174);/g, val: "" },
                  inr: { regex: /&(inr|#8377);/g, val: "" },
                  num_dec: {
                    regex: /&#([0-9]{1,7});/g,
                    val: (e, t) => String.fromCharCode(Number.parseInt(t, 10)),
                  },
                  num_hex: {
                    regex: /&#x([0-9a-fA-F]{1,6});/g,
                    val: (e, t) => String.fromCharCode(Number.parseInt(t, 16)),
                  },
                }),
                (this.addExternalEntities = o),
                (this.parseXml = d),
                (this.parseTextData = c),
                (this.resolveNameSpace = l),
                (this.buildAttributesMap = u),
                (this.isItStopNode = m),
                (this.replaceEntitiesValue = f),
                (this.readStopNodeData = w),
                (this.saveTextToParentTag = g),
                (this.addChild = p);
            }
          };
        },
        2923: (e, t, r) => {
          const { buildOptions: i } = r(460),
            s = r(7680),
            { prettify: n } = r(5629),
            a = r(3918);
          e.exports = class {
            constructor(e) {
              (this.externalEntities = {}), (this.options = i(e));
            }
            parse(e, t) {
              if ("string" == typeof e);
              else {
                if (!e.toString)
                  throw new Error(
                    "XML data is accepted in String or Bytes[] form."
                  );
                e = e.toString();
              }
              if (t) {
                !0 === t && (t = {});
                const r = a.validate(e, t);
                if (!0 !== r)
                  throw Error(`${r.err.msg}:${r.err.line}:${r.err.col}`);
              }
              const r = new s(this.options);
              r.addExternalEntities(this.externalEntities);
              const i = r.parseXml(e);
              return this.options.preserveOrder || void 0 === i
                ? i
                : n(i, this.options);
            }
            addEntity(e, t) {
              if (-1 !== t.indexOf("&"))
                throw new Error("Entity value can't have '&'");
              if (-1 !== e.indexOf("&") || -1 !== e.indexOf(";"))
                throw new Error(
                  "An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'"
                );
              if ("&" === t)
                throw new Error("An entity with value '&' is not permitted");
              this.externalEntities[e] = t;
            }
          };
        },
        5629: (e, t) => {
          "use strict";
          function r(e, t, a) {
            let o;
            const c = {};
            for (let l = 0; l < e.length; l++) {
              const h = e[l],
                u = i(h);
              let d = "";
              if (((d = void 0 === a ? u : a + "." + u), u === t.textNodeName))
                void 0 === o ? (o = h[u]) : (o += "" + h[u]);
              else {
                if (void 0 === u) continue;
                if (h[u]) {
                  let e = r(h[u], t, d);
                  const i = n(e, t);
                  h[":@"]
                    ? s(e, h[":@"], d, t)
                    : 1 !== Object.keys(e).length ||
                      void 0 === e[t.textNodeName] ||
                      t.alwaysCreateTextNode
                    ? 0 === Object.keys(e).length &&
                      (t.alwaysCreateTextNode
                        ? (e[t.textNodeName] = "")
                        : (e = ""))
                    : (e = e[t.textNodeName]),
                    void 0 !== c[u] && c.hasOwnProperty(u)
                      ? (Array.isArray(c[u]) || (c[u] = [c[u]]), c[u].push(e))
                      : t.isArray(u, d, i)
                      ? (c[u] = [e])
                      : (c[u] = e);
                }
              }
            }
            return (
              "string" == typeof o
                ? o.length > 0 && (c[t.textNodeName] = o)
                : void 0 !== o && (c[t.textNodeName] = o),
              c
            );
          }
          function i(e) {
            const t = Object.keys(e);
            for (let e = 0; e < t.length; e++) {
              const r = t[e];
              if (":@" !== r) return r;
            }
          }
          function s(e, t, r, i) {
            if (t) {
              const s = Object.keys(t),
                n = s.length;
              for (let a = 0; a < n; a++) {
                const n = s[a];
                i.isArray(n, r + "." + n, !0, !0)
                  ? (e[n] = [t[n]])
                  : (e[n] = t[n]);
              }
            }
          }
          function n(e, t) {
            const { textNodeName: r } = t,
              i = Object.keys(e).length;
            return (
              0 === i ||
              !(1 !== i || (!e[r] && "boolean" != typeof e[r] && 0 !== e[r]))
            );
          }
          t.prettify = function (e, t) {
            return r(e, t);
          };
        },
        3832: (e) => {
          "use strict";
          e.exports = class {
            constructor(e) {
              (this.tagname = e), (this.child = []), (this[":@"] = {});
            }
            add(e, t) {
              "__proto__" === e && (e = "#__proto__"),
                this.child.push({ [e]: t });
            }
            addChild(e) {
              "__proto__" === e.tagname && (e.tagname = "#__proto__"),
                e[":@"] && Object.keys(e[":@"]).length > 0
                  ? this.child.push({ [e.tagname]: e.child, ":@": e[":@"] })
                  : this.child.push({ [e.tagname]: e.child });
            }
          };
        },
        2384: (e, t, r) => {
          "use strict";
          var i = r(8287).Buffer,
            s = /^utf-?8|ascii|utf-?16-?le|ucs-?2|base-?64|latin-?1$/i,
            n = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
            a = /\s|\uFEFF|\xA0/,
            o = /\r?\n[\x20\x09]+/g,
            c = /[;,"]/,
            l = /[;,"]|\s/,
            h = /^[!#$%&'*+\-\.^_`|~\da-zA-Z]+$/,
            u = 1,
            d = 2,
            p = 4;
          function f(e) {
            return e.replace(n, "");
          }
          function g(e) {
            return a.test(e);
          }
          function m(e, t) {
            for (; g(e[t]); ) t++;
            return t;
          }
          function y(e) {
            return l.test(e) || !h.test(e);
          }
          class A {
            constructor(e) {
              (this.refs = []), e && this.parse(e);
            }
            rel(e) {
              for (
                var t = [], r = e.toLowerCase(), i = 0;
                i < this.refs.length;
                i++
              )
                "string" == typeof this.refs[i].rel &&
                  this.refs[i].rel.toLowerCase() === r &&
                  t.push(this.refs[i]);
              return t;
            }
            get(e, t) {
              (e = e.toLowerCase()), (t = t.toLowerCase());
              for (var r = [], i = 0; i < this.refs.length; i++)
                "string" == typeof this.refs[i][e] &&
                  this.refs[i][e].toLowerCase() === t &&
                  r.push(this.refs[i]);
              return r;
            }
            set(e) {
              return this.refs.push(e), this;
            }
            setUnique(e) {
              return (
                this.refs.some((t) => {
                  return (
                    (r = t),
                    (i = e),
                    Object.keys(r).length === Object.keys(i).length &&
                      Object.keys(r).every((e) => e in i && r[e] === i[e])
                  );
                  var r, i;
                }) || this.refs.push(e),
                this
              );
            }
            has(e, t) {
              (e = e.toLowerCase()), (t = t.toLowerCase());
              for (var r = 0; r < this.refs.length; r++)
                if (
                  "string" == typeof this.refs[r][e] &&
                  this.refs[r][e].toLowerCase() === t
                )
                  return !0;
              return !1;
            }
            parse(e, t) {
              e = f((e = (t = t || 0) ? e.slice(t) : e)).replace(o, "");
              for (var r = u, i = e.length, s = ((t = 0), null); t < i; )
                if (r === u) {
                  if (g(e[t])) {
                    t++;
                    continue;
                  }
                  if ("<" !== e[t])
                    throw new Error(
                      'Unexpected character "' + e[t] + '" at offset ' + t
                    );
                  if (
                    (null != s &&
                      (null != s.rel
                        ? this.refs.push(...A.expandRelations(s))
                        : this.refs.push(s)),
                    -1 === (l = e.indexOf(">", t)))
                  )
                    throw new Error(
                      "Expected end of URI delimiter at offset " + t
                    );
                  (s = { uri: e.slice(t + 1, l) }), (t = l), (r = d), t++;
                } else if (r === d) {
                  if (g(e[t])) {
                    t++;
                    continue;
                  }
                  if (";" === e[t]) (r = p), t++;
                  else {
                    if ("," !== e[t])
                      throw new Error(
                        'Unexpected character "' + e[t] + '" at offset ' + t
                      );
                    (r = u), t++;
                  }
                } else {
                  if (r !== p)
                    throw new Error('Unknown parser state "' + r + '"');
                  if (";" === e[t] || g(e[t])) {
                    t++;
                    continue;
                  }
                  -1 === (l = e.indexOf("=", t)) && (l = e.indexOf(";", t)),
                    -1 === l && (l = e.length);
                  var n = f(e.slice(t, l)).toLowerCase(),
                    a = "";
                  if ('"' === e[(t = m(e, (t = l + 1)))])
                    for (t++; t < i; ) {
                      if ('"' === e[t]) {
                        t++;
                        break;
                      }
                      "\\" === e[t] && t++, (a += e[t]), t++;
                    }
                  else {
                    for (var l = t + 1; !c.test(e[l]) && l < i; ) l++;
                    (a = e.slice(t, l)), (t = l);
                  }
                  switch (
                    ((s[n] && A.isSingleOccurenceAttr(n)) ||
                      ("*" === n[n.length - 1]
                        ? (s[n] = A.parseExtendedValue(a))
                        : ((a = "type" === n ? a.toLowerCase() : a),
                          null != s[n]
                            ? Array.isArray(s[n])
                              ? s[n].push(a)
                              : (s[n] = [s[n], a])
                            : (s[n] = a))),
                    e[t])
                  ) {
                    case ",":
                      r = u;
                      break;
                    case ";":
                      r = p;
                  }
                  t++;
                }
              return (
                null != s &&
                  (null != s.rel
                    ? this.refs.push(...A.expandRelations(s))
                    : this.refs.push(s)),
                (s = null),
                this
              );
            }
            toString() {
              for (var e = [], t = "", r = null, i = 0; i < this.refs.length; i++)
                (r = this.refs[i]),
                  (t = Object.keys(this.refs[i]).reduce(function (e, t) {
                    return "uri" === t
                      ? e
                      : e + "; " + A.formatAttribute(t, r[t]);
                  }, "<" + r.uri + ">")),
                  e.push(t);
              return e.join(", ");
            }
          }
          (A.isCompatibleEncoding = function (e) {
            return s.test(e);
          }),
            (A.parse = function (e, t) {
              return new A().parse(e, t);
            }),
            (A.isSingleOccurenceAttr = function (e) {
              return (
                "rel" === e ||
                "type" === e ||
                "media" === e ||
                "title" === e ||
                "title*" === e
              );
            }),
            (A.isTokenAttr = function (e) {
              return "rel" === e || "type" === e || "anchor" === e;
            }),
            (A.escapeQuotes = function (e) {
              return e.replace(/"/g, '\\"');
            }),
            (A.expandRelations = function (e) {
              return e.rel.split(" ").map(function (t) {
                var r = Object.assign({}, e);
                return (r.rel = t), r;
              });
            }),
            (A.parseExtendedValue = function (e) {
              var t = /([^']+)?(?:'([^']*)')?(.+)/.exec(e);
              return {
                language: t[2].toLowerCase(),
                encoding: A.isCompatibleEncoding(t[1])
                  ? null
                  : t[1].toLowerCase(),
                value: A.isCompatibleEncoding(t[1])
                  ? decodeURIComponent(t[3])
                  : t[3],
              };
            }),
            (A.formatExtendedAttribute = function (e, t) {
              var r = (t.encoding || "utf-8").toUpperCase();
              return (
                e +
                "=" +
                r +
                "'" +
                (t.language || "en") +
                "'" +
                (i.isBuffer(t.value) && A.isCompatibleEncoding(r)
                  ? t.value.toString(r)
                  : i.isBuffer(t.value)
                  ? t.value.toString("hex").replace(/[0-9a-f]{2}/gi, "%$1")
                  : encodeURIComponent(t.value))
              );
            }),
            (A.formatAttribute = function (e, t) {
              return Array.isArray(t)
                ? t.map((t) => A.formatAttribute(e, t)).join("; ")
                : "*" === e[e.length - 1] || "string" != typeof t
                ? A.formatExtendedAttribute(e, t)
                : (A.isTokenAttr(e)
                    ? (t = y(t)
                        ? '"' + A.escapeQuotes(t) + '"'
                        : A.escapeQuotes(t))
                    : y(t) &&
                      (t =
                        '"' +
                        (t = (t = encodeURIComponent(t))
                          .replace(/%20/g, " ")
                          .replace(/%2C/g, ",")
                          .replace(/%3B/g, ";")) +
                        '"'),
                  e + "=" + t);
            }),
            (e.exports = A);
        },
        251: (e, t) => {
          /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
          (t.read = function (e, t, r, i, s) {
            var n,
              a,
              o = 8 * s - i - 1,
              c = (1 << o) - 1,
              l = c >> 1,
              h = -7,
              u = r ? s - 1 : 0,
              d = r ? -1 : 1,
              p = e[t + u];
            for (
              u += d, n = p & ((1 << -h) - 1), p >>= -h, h += o;
              h > 0;
              n = 256 * n + e[t + u], u += d, h -= 8
            );
            for (
              a = n & ((1 << -h) - 1), n >>= -h, h += i;
              h > 0;
              a = 256 * a + e[t + u], u += d, h -= 8
            );
            if (0 === n) n = 1 - l;
            else {
              if (n === c) return a ? NaN : (1 / 0) * (p ? -1 : 1);
              (a += Math.pow(2, i)), (n -= l);
            }
            return (p ? -1 : 1) * a * Math.pow(2, n - i);
          }),
            (t.write = function (e, t, r, i, s, n) {
              var a,
                o,
                c,
                l = 8 * n - s - 1,
                h = (1 << l) - 1,
                u = h >> 1,
                d = 23 === s ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
                p = i ? 0 : n - 1,
                f = i ? 1 : -1,
                g = t < 0 || (0 === t && 1 / t < 0) ? 1 : 0;
              for (
                t = Math.abs(t),
                  isNaN(t) || t === 1 / 0
                    ? ((o = isNaN(t) ? 1 : 0), (a = h))
                    : ((a = Math.floor(Math.log(t) / Math.LN2)),
                      t * (c = Math.pow(2, -a)) < 1 && (a--, (c *= 2)),
                      (t += a + u >= 1 ? d / c : d * Math.pow(2, 1 - u)) * c >=
                        2 && (a++, (c /= 2)),
                      a + u >= h
                        ? ((o = 0), (a = h))
                        : a + u >= 1
                        ? ((o = (t * c - 1) * Math.pow(2, s)), (a += u))
                        : ((o = t * Math.pow(2, u - 1) * Math.pow(2, s)),
                          (a = 0)));
                s >= 8;
                e[r + p] = 255 & o, p += f, o /= 256, s -= 8
              );
              for (
                a = (a << s) | o, l += s;
                l > 0;
                e[r + p] = 255 & a, p += f, a /= 256, l -= 8
              );
              e[r + p - f] |= 128 * g;
            });
        },
        6698: (e) => {
          "function" == typeof Object.create
            ? (e.exports = function (e, t) {
                t &&
                  ((e.super_ = t),
                  (e.prototype = Object.create(t.prototype, {
                    constructor: {
                      value: e,
                      enumerable: !1,
                      writable: !0,
                      configurable: !0,
                    },
                  })));
              })
            : (e.exports = function (e, t) {
                if (t) {
                  e.super_ = t;
                  var r = function () {};
                  (r.prototype = t.prototype),
                    (e.prototype = new r()),
                    (e.prototype.constructor = e);
                }
              });
        },
        640: function (e) {
          !(function (t) {
            "use strict";
            const r = "(0?\\d+|0x[a-f0-9]+)",
              i = {
                fourOctet: new RegExp(`^${r}\\.${r}\\.${r}\\.${r}$`, "i"),
                threeOctet: new RegExp(`^${r}\\.${r}\\.${r}$`, "i"),
                twoOctet: new RegExp(`^${r}\\.${r}$`, "i"),
                longValue: new RegExp(`^${r}$`, "i"),
              },
              s = new RegExp("^0[0-7]+$", "i"),
              n = new RegExp("^0x[a-f0-9]+$", "i"),
              a = "%[0-9a-z]{1,}",
              o = "(?:[0-9a-f]+::?)+",
              c = {
                zoneIndex: new RegExp(a, "i"),
                native: new RegExp(`^(::)?(${o})?([0-9a-f]+)?(::)?(${a})?$`, "i"),
                deprecatedTransitional: new RegExp(
                  `^(?:::)(${r}\\.${r}\\.${r}\\.${r}(${a})?)$`,
                  "i"
                ),
                transitional: new RegExp(
                  `^((?:${o})|(?:::)(?:${o})?)${r}\\.${r}\\.${r}\\.${r}(${a})?$`,
                  "i"
                ),
              };
            function l(e, t) {
              if (e.indexOf("::") !== e.lastIndexOf("::")) return null;
              let r,
                i,
                s = 0,
                n = -1,
                a = (e.match(c.zoneIndex) || [])[0];
              for (
                a && ((a = a.substring(1)), (e = e.replace(/%.+$/, "")));
                (n = e.indexOf(":", n + 1)) >= 0;
  
              )
                s++;
              if (
                ("::" === e.substr(0, 2) && s--,
                "::" === e.substr(-2, 2) && s--,
                s > t)
              )
                return null;
              for (i = t - s, r = ":"; i--; ) r += "0:";
              return (
                ":" === (e = e.replace("::", r))[0] && (e = e.slice(1)),
                ":" === e[e.length - 1] && (e = e.slice(0, -1)),
                (t = (function () {
                  const t = e.split(":"),
                    r = [];
                  for (let e = 0; e < t.length; e++) r.push(parseInt(t[e], 16));
                  return r;
                })()),
                { parts: t, zoneId: a }
              );
            }
            function h(e, t, r, i) {
              if (e.length !== t.length)
                throw new Error(
                  "ipaddr: cannot match CIDR for objects with different lengths"
                );
              let s,
                n = 0;
              for (; i > 0; ) {
                if (((s = r - i), s < 0 && (s = 0), e[n] >> s != t[n] >> s))
                  return !1;
                (i -= r), (n += 1);
              }
              return !0;
            }
            function u(e) {
              if (n.test(e)) return parseInt(e, 16);
              if ("0" === e[0] && !isNaN(parseInt(e[1], 10))) {
                if (s.test(e)) return parseInt(e, 8);
                throw new Error(`ipaddr: cannot parse ${e} as octal`);
              }
              return parseInt(e, 10);
            }
            function d(e, t) {
              for (; e.length < t; ) e = `0${e}`;
              return e;
            }
            const p = {};
            (p.IPv4 = (function () {
              function e(e) {
                if (4 !== e.length)
                  throw new Error("ipaddr: ipv4 octet count should be 4");
                let t, r;
                for (t = 0; t < e.length; t++)
                  if (((r = e[t]), !(0 <= r && r <= 255)))
                    throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
                this.octets = e;
              }
              return (
                (e.prototype.SpecialRanges = {
                  unspecified: [[new e([0, 0, 0, 0]), 8]],
                  broadcast: [[new e([255, 255, 255, 255]), 32]],
                  multicast: [[new e([224, 0, 0, 0]), 4]],
                  linkLocal: [[new e([169, 254, 0, 0]), 16]],
                  loopback: [[new e([127, 0, 0, 0]), 8]],
                  carrierGradeNat: [[new e([100, 64, 0, 0]), 10]],
                  private: [
                    [new e([10, 0, 0, 0]), 8],
                    [new e([172, 16, 0, 0]), 12],
                    [new e([192, 168, 0, 0]), 16],
                  ],
                  reserved: [
                    [new e([192, 0, 0, 0]), 24],
                    [new e([192, 0, 2, 0]), 24],
                    [new e([192, 88, 99, 0]), 24],
                    [new e([198, 18, 0, 0]), 15],
                    [new e([198, 51, 100, 0]), 24],
                    [new e([203, 0, 113, 0]), 24],
                    [new e([240, 0, 0, 0]), 4],
                  ],
                  as112: [
                    [new e([192, 175, 48, 0]), 24],
                    [new e([192, 31, 196, 0]), 24],
                  ],
                  amt: [[new e([192, 52, 193, 0]), 24]],
                }),
                (e.prototype.kind = function () {
                  return "ipv4";
                }),
                (e.prototype.match = function (e, t) {
                  let r;
                  if (
                    (void 0 === t && ((r = e), (e = r[0]), (t = r[1])),
                    "ipv4" !== e.kind())
                  )
                    throw new Error(
                      "ipaddr: cannot match ipv4 address with non-ipv4 one"
                    );
                  return h(this.octets, e.octets, 8, t);
                }),
                (e.prototype.prefixLengthFromSubnetMask = function () {
                  let e = 0,
                    t = !1;
                  const r = {
                    0: 8,
                    128: 7,
                    192: 6,
                    224: 5,
                    240: 4,
                    248: 3,
                    252: 2,
                    254: 1,
                    255: 0,
                  };
                  let i, s, n;
                  for (i = 3; i >= 0; i -= 1) {
                    if (((s = this.octets[i]), !(s in r))) return null;
                    if (((n = r[s]), t && 0 !== n)) return null;
                    8 !== n && (t = !0), (e += n);
                  }
                  return 32 - e;
                }),
                (e.prototype.range = function () {
                  return p.subnetMatch(this, this.SpecialRanges);
                }),
                (e.prototype.toByteArray = function () {
                  return this.octets.slice(0);
                }),
                (e.prototype.toIPv4MappedAddress = function () {
                  return p.IPv6.parse(`::ffff:${this.toString()}`);
                }),
                (e.prototype.toNormalizedString = function () {
                  return this.toString();
                }),
                (e.prototype.toString = function () {
                  return this.octets.join(".");
                }),
                e
              );
            })()),
              (p.IPv4.broadcastAddressFromCIDR = function (e) {
                try {
                  const t = this.parseCIDR(e),
                    r = t[0].toByteArray(),
                    i = this.subnetMaskFromPrefixLength(t[1]).toByteArray(),
                    s = [];
                  let n = 0;
                  for (; n < 4; )
                    s.push(parseInt(r[n], 10) | (255 ^ parseInt(i[n], 10))), n++;
                  return new this(s);
                } catch (e) {
                  throw new Error(
                    "ipaddr: the address does not have IPv4 CIDR format"
                  );
                }
              }),
              (p.IPv4.isIPv4 = function (e) {
                return null !== this.parser(e);
              }),
              (p.IPv4.isValid = function (e) {
                try {
                  return new this(this.parser(e)), !0;
                } catch (e) {
                  return !1;
                }
              }),
              (p.IPv4.isValidCIDR = function (e) {
                try {
                  return this.parseCIDR(e), !0;
                } catch (e) {
                  return !1;
                }
              }),
              (p.IPv4.isValidFourPartDecimal = function (e) {
                return !(
                  !p.IPv4.isValid(e) ||
                  !e.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)
                );
              }),
              (p.IPv4.networkAddressFromCIDR = function (e) {
                let t, r, i, s, n;
                try {
                  for (
                    t = this.parseCIDR(e),
                      i = t[0].toByteArray(),
                      n = this.subnetMaskFromPrefixLength(t[1]).toByteArray(),
                      s = [],
                      r = 0;
                    r < 4;
  
                  )
                    s.push(parseInt(i[r], 10) & parseInt(n[r], 10)), r++;
                  return new this(s);
                } catch (e) {
                  throw new Error(
                    "ipaddr: the address does not have IPv4 CIDR format"
                  );
                }
              }),
              (p.IPv4.parse = function (e) {
                const t = this.parser(e);
                if (null === t)
                  throw new Error(
                    "ipaddr: string is not formatted like an IPv4 Address"
                  );
                return new this(t);
              }),
              (p.IPv4.parseCIDR = function (e) {
                let t;
                if ((t = e.match(/^(.+)\/(\d+)$/))) {
                  const e = parseInt(t[2]);
                  if (e >= 0 && e <= 32) {
                    const r = [this.parse(t[1]), e];
                    return (
                      Object.defineProperty(r, "toString", {
                        value: function () {
                          return this.join("/");
                        },
                      }),
                      r
                    );
                  }
                }
                throw new Error(
                  "ipaddr: string is not formatted like an IPv4 CIDR range"
                );
              }),
              (p.IPv4.parser = function (e) {
                let t, r, s;
                if ((t = e.match(i.fourOctet)))
                  return (function () {
                    const e = t.slice(1, 6),
                      i = [];
                    for (let t = 0; t < e.length; t++) (r = e[t]), i.push(u(r));
                    return i;
                  })();
                if ((t = e.match(i.longValue))) {
                  if (((s = u(t[1])), s > 4294967295 || s < 0))
                    throw new Error("ipaddr: address outside defined range");
                  return (function () {
                    const e = [];
                    let t;
                    for (t = 0; t <= 24; t += 8) e.push((s >> t) & 255);
                    return e;
                  })().reverse();
                }
                return (t = e.match(i.twoOctet))
                  ? (function () {
                      const e = t.slice(1, 4),
                        r = [];
                      if (((s = u(e[1])), s > 16777215 || s < 0))
                        throw new Error("ipaddr: address outside defined range");
                      return (
                        r.push(u(e[0])),
                        r.push((s >> 16) & 255),
                        r.push((s >> 8) & 255),
                        r.push(255 & s),
                        r
                      );
                    })()
                  : (t = e.match(i.threeOctet))
                  ? (function () {
                      const e = t.slice(1, 5),
                        r = [];
                      if (((s = u(e[2])), s > 65535 || s < 0))
                        throw new Error("ipaddr: address outside defined range");
                      return (
                        r.push(u(e[0])),
                        r.push(u(e[1])),
                        r.push((s >> 8) & 255),
                        r.push(255 & s),
                        r
                      );
                    })()
                  : null;
              }),
              (p.IPv4.subnetMaskFromPrefixLength = function (e) {
                if ((e = parseInt(e)) < 0 || e > 32)
                  throw new Error("ipaddr: invalid IPv4 prefix length");
                const t = [0, 0, 0, 0];
                let r = 0;
                const i = Math.floor(e / 8);
                for (; r < i; ) (t[r] = 255), r++;
                return (
                  i < 4 && (t[i] = (Math.pow(2, e % 8) - 1) << (8 - (e % 8))),
                  new this(t)
                );
              }),
              (p.IPv6 = (function () {
                function e(e, t) {
                  let r, i;
                  if (16 === e.length)
                    for (this.parts = [], r = 0; r <= 14; r += 2)
                      this.parts.push((e[r] << 8) | e[r + 1]);
                  else {
                    if (8 !== e.length)
                      throw new Error(
                        "ipaddr: ipv6 part count should be 8 or 16"
                      );
                    this.parts = e;
                  }
                  for (r = 0; r < this.parts.length; r++)
                    if (((i = this.parts[r]), !(0 <= i && i <= 65535)))
                      throw new Error("ipaddr: ipv6 part should fit in 16 bits");
                  t && (this.zoneId = t);
                }
                return (
                  (e.prototype.SpecialRanges = {
                    unspecified: [new e([0, 0, 0, 0, 0, 0, 0, 0]), 128],
                    linkLocal: [new e([65152, 0, 0, 0, 0, 0, 0, 0]), 10],
                    multicast: [new e([65280, 0, 0, 0, 0, 0, 0, 0]), 8],
                    loopback: [new e([0, 0, 0, 0, 0, 0, 0, 1]), 128],
                    uniqueLocal: [new e([64512, 0, 0, 0, 0, 0, 0, 0]), 7],
                    ipv4Mapped: [new e([0, 0, 0, 0, 0, 65535, 0, 0]), 96],
                    discard: [new e([256, 0, 0, 0, 0, 0, 0, 0]), 64],
                    rfc6145: [new e([0, 0, 0, 0, 65535, 0, 0, 0]), 96],
                    rfc6052: [new e([100, 65435, 0, 0, 0, 0, 0, 0]), 96],
                    "6to4": [new e([8194, 0, 0, 0, 0, 0, 0, 0]), 16],
                    teredo: [new e([8193, 0, 0, 0, 0, 0, 0, 0]), 32],
                    benchmarking: [new e([8193, 2, 0, 0, 0, 0, 0, 0]), 48],
                    amt: [new e([8193, 3, 0, 0, 0, 0, 0, 0]), 32],
                    as112v6: [
                      [new e([8193, 4, 274, 0, 0, 0, 0, 0]), 48],
                      [new e([9760, 79, 32768, 0, 0, 0, 0, 0]), 48],
                    ],
                    deprecated: [new e([8193, 16, 0, 0, 0, 0, 0, 0]), 28],
                    orchid2: [new e([8193, 32, 0, 0, 0, 0, 0, 0]), 28],
                    droneRemoteIdProtocolEntityTags: [
                      new e([8193, 48, 0, 0, 0, 0, 0, 0]),
                      28,
                    ],
                    reserved: [
                      [new e([8193, 0, 0, 0, 0, 0, 0, 0]), 23],
                      [new e([8193, 3512, 0, 0, 0, 0, 0, 0]), 32],
                    ],
                  }),
                  (e.prototype.isIPv4MappedAddress = function () {
                    return "ipv4Mapped" === this.range();
                  }),
                  (e.prototype.kind = function () {
                    return "ipv6";
                  }),
                  (e.prototype.match = function (e, t) {
                    let r;
                    if (
                      (void 0 === t && ((r = e), (e = r[0]), (t = r[1])),
                      "ipv6" !== e.kind())
                    )
                      throw new Error(
                        "ipaddr: cannot match ipv6 address with non-ipv6 one"
                      );
                    return h(this.parts, e.parts, 16, t);
                  }),
                  (e.prototype.prefixLengthFromSubnetMask = function () {
                    let e = 0,
                      t = !1;
                    const r = {
                      0: 16,
                      32768: 15,
                      49152: 14,
                      57344: 13,
                      61440: 12,
                      63488: 11,
                      64512: 10,
                      65024: 9,
                      65280: 8,
                      65408: 7,
                      65472: 6,
                      65504: 5,
                      65520: 4,
                      65528: 3,
                      65532: 2,
                      65534: 1,
                      65535: 0,
                    };
                    let i, s;
                    for (let n = 7; n >= 0; n -= 1) {
                      if (((i = this.parts[n]), !(i in r))) return null;
                      if (((s = r[i]), t && 0 !== s)) return null;
                      16 !== s && (t = !0), (e += s);
                    }
                    return 128 - e;
                  }),
                  (e.prototype.range = function () {
                    return p.subnetMatch(this, this.SpecialRanges);
                  }),
                  (e.prototype.toByteArray = function () {
                    let e;
                    const t = [],
                      r = this.parts;
                    for (let i = 0; i < r.length; i++)
                      (e = r[i]), t.push(e >> 8), t.push(255 & e);
                    return t;
                  }),
                  (e.prototype.toFixedLengthString = function () {
                    const e = function () {
                      const e = [];
                      for (let t = 0; t < this.parts.length; t++)
                        e.push(d(this.parts[t].toString(16), 4));
                      return e;
                    }
                      .call(this)
                      .join(":");
                    let t = "";
                    return this.zoneId && (t = `%${this.zoneId}`), e + t;
                  }),
                  (e.prototype.toIPv4Address = function () {
                    if (!this.isIPv4MappedAddress())
                      throw new Error(
                        "ipaddr: trying to convert a generic ipv6 address to ipv4"
                      );
                    const e = this.parts.slice(-2),
                      t = e[0],
                      r = e[1];
                    return new p.IPv4([t >> 8, 255 & t, r >> 8, 255 & r]);
                  }),
                  (e.prototype.toNormalizedString = function () {
                    const e = function () {
                      const e = [];
                      for (let t = 0; t < this.parts.length; t++)
                        e.push(this.parts[t].toString(16));
                      return e;
                    }
                      .call(this)
                      .join(":");
                    let t = "";
                    return this.zoneId && (t = `%${this.zoneId}`), e + t;
                  }),
                  (e.prototype.toRFC5952String = function () {
                    const e = /((^|:)(0(:|$)){2,})/g,
                      t = this.toNormalizedString();
                    let r,
                      i = 0,
                      s = -1;
                    for (; (r = e.exec(t)); )
                      r[0].length > s && ((i = r.index), (s = r[0].length));
                    return s < 0
                      ? t
                      : `${t.substring(0, i)}::${t.substring(i + s)}`;
                  }),
                  (e.prototype.toString = function () {
                    return this.toRFC5952String();
                  }),
                  e
                );
              })()),
              (p.IPv6.broadcastAddressFromCIDR = function (e) {
                try {
                  const t = this.parseCIDR(e),
                    r = t[0].toByteArray(),
                    i = this.subnetMaskFromPrefixLength(t[1]).toByteArray(),
                    s = [];
                  let n = 0;
                  for (; n < 16; )
                    s.push(parseInt(r[n], 10) | (255 ^ parseInt(i[n], 10))), n++;
                  return new this(s);
                } catch (e) {
                  throw new Error(
                    `ipaddr: the address does not have IPv6 CIDR format (${e})`
                  );
                }
              }),
              (p.IPv6.isIPv6 = function (e) {
                return null !== this.parser(e);
              }),
              (p.IPv6.isValid = function (e) {
                if ("string" == typeof e && -1 === e.indexOf(":")) return !1;
                try {
                  const t = this.parser(e);
                  return new this(t.parts, t.zoneId), !0;
                } catch (e) {
                  return !1;
                }
              }),
              (p.IPv6.isValidCIDR = function (e) {
                if ("string" == typeof e && -1 === e.indexOf(":")) return !1;
                try {
                  return this.parseCIDR(e), !0;
                } catch (e) {
                  return !1;
                }
              }),
              (p.IPv6.networkAddressFromCIDR = function (e) {
                let t, r, i, s, n;
                try {
                  for (
                    t = this.parseCIDR(e),
                      i = t[0].toByteArray(),
                      n = this.subnetMaskFromPrefixLength(t[1]).toByteArray(),
                      s = [],
                      r = 0;
                    r < 16;
  
                  )
                    s.push(parseInt(i[r], 10) & parseInt(n[r], 10)), r++;
                  return new this(s);
                } catch (e) {
                  throw new Error(
                    `ipaddr: the address does not have IPv6 CIDR format (${e})`
                  );
                }
              }),
              (p.IPv6.parse = function (e) {
                const t = this.parser(e);
                if (null === t.parts)
                  throw new Error(
                    "ipaddr: string is not formatted like an IPv6 Address"
                  );
                return new this(t.parts, t.zoneId);
              }),
              (p.IPv6.parseCIDR = function (e) {
                let t, r, i;
                if (
                  (r = e.match(/^(.+)\/(\d+)$/)) &&
                  ((t = parseInt(r[2])), t >= 0 && t <= 128)
                )
                  return (
                    (i = [this.parse(r[1]), t]),
                    Object.defineProperty(i, "toString", {
                      value: function () {
                        return this.join("/");
                      },
                    }),
                    i
                  );
                throw new Error(
                  "ipaddr: string is not formatted like an IPv6 CIDR range"
                );
              }),
              (p.IPv6.parser = function (e) {
                let t, r, i, s, n, a;
                if ((i = e.match(c.deprecatedTransitional)))
                  return this.parser(`::ffff:${i[1]}`);
                if (c.native.test(e)) return l(e, 8);
                if (
                  (i = e.match(c.transitional)) &&
                  ((a = i[6] || ""),
                  (t = i[1]),
                  i[1].endsWith("::") || (t = t.slice(0, -1)),
                  (t = l(t + a, 6)),
                  t.parts)
                ) {
                  for (
                    n = [
                      parseInt(i[2]),
                      parseInt(i[3]),
                      parseInt(i[4]),
                      parseInt(i[5]),
                    ],
                      r = 0;
                    r < n.length;
                    r++
                  )
                    if (((s = n[r]), !(0 <= s && s <= 255))) return null;
                  return (
                    t.parts.push((n[0] << 8) | n[1]),
                    t.parts.push((n[2] << 8) | n[3]),
                    { parts: t.parts, zoneId: t.zoneId }
                  );
                }
                return null;
              }),
              (p.IPv6.subnetMaskFromPrefixLength = function (e) {
                if ((e = parseInt(e)) < 0 || e > 128)
                  throw new Error("ipaddr: invalid IPv6 prefix length");
                const t = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                let r = 0;
                const i = Math.floor(e / 8);
                for (; r < i; ) (t[r] = 255), r++;
                return (
                  i < 16 && (t[i] = (Math.pow(2, e % 8) - 1) << (8 - (e % 8))),
                  new this(t)
                );
              }),
              (p.fromByteArray = function (e) {
                const t = e.length;
                if (4 === t) return new p.IPv4(e);
                if (16 === t) return new p.IPv6(e);
                throw new Error(
                  "ipaddr: the binary input is neither an IPv6 nor IPv4 address"
                );
              }),
              (p.isValid = function (e) {
                return p.IPv6.isValid(e) || p.IPv4.isValid(e);
              }),
              (p.isValidCIDR = function (e) {
                return p.IPv6.isValidCIDR(e) || p.IPv4.isValidCIDR(e);
              }),
              (p.parse = function (e) {
                if (p.IPv6.isValid(e)) return p.IPv6.parse(e);
                if (p.IPv4.isValid(e)) return p.IPv4.parse(e);
                throw new Error(
                  "ipaddr: the address has neither IPv6 nor IPv4 format"
                );
              }),
              (p.parseCIDR = function (e) {
                try {
                  return p.IPv6.parseCIDR(e);
                } catch (t) {
                  try {
                    return p.IPv4.parseCIDR(e);
                  } catch (e) {
                    throw new Error(
                      "ipaddr: the address has neither IPv6 nor IPv4 CIDR format"
                    );
                  }
                }
              }),
              (p.process = function (e) {
                const t = this.parse(e);
                return "ipv6" === t.kind() && t.isIPv4MappedAddress()
                  ? t.toIPv4Address()
                  : t;
              }),
              (p.subnetMatch = function (e, t, r) {
                let i, s, n, a;
                for (s in (null == r && (r = "unicast"), t))
                  if (Object.prototype.hasOwnProperty.call(t, s))
                    for (
                      n = t[s],
                        !n[0] || n[0] instanceof Array || (n = [n]),
                        i = 0;
                      i < n.length;
                      i++
                    )
                      if (
                        ((a = n[i]),
                        e.kind() === a[0].kind() && e.match.apply(e, a))
                      )
                        return s;
                return r;
              }),
              e.exports ? (e.exports = p) : (t.ipaddr = p);
          })(this);
        },
        4668: (e) => {
          "use strict";
          e.exports = (function () {
            function e(e, t, r, i, s) {
              return e < t || r < t
                ? e > r
                  ? r + 1
                  : e + 1
                : i === s
                ? t
                : t + 1;
            }
            return function (t, r) {
              if (t === r) return 0;
              if (t.length > r.length) {
                var i = t;
                (t = r), (r = i);
              }
              for (
                var s = t.length, n = r.length;
                s > 0 && t.charCodeAt(s - 1) === r.charCodeAt(n - 1);
  
              )
                s--, n--;
              for (var a = 0; a < s && t.charCodeAt(a) === r.charCodeAt(a); ) a++;
              if (((n -= a), 0 === (s -= a) || n < 3)) return n;
              var o,
                c,
                l,
                h,
                u,
                d,
                p,
                f,
                g,
                m,
                y,
                A,
                w = 0,
                E = [];
              for (o = 0; o < s; o++) E.push(o + 1), E.push(t.charCodeAt(a + o));
              for (var b = E.length - 1; w < n - 3; )
                for (
                  g = r.charCodeAt(a + (c = w)),
                    m = r.charCodeAt(a + (l = w + 1)),
                    y = r.charCodeAt(a + (h = w + 2)),
                    A = r.charCodeAt(a + (u = w + 3)),
                    d = w += 4,
                    o = 0;
                  o < b;
                  o += 2
                )
                  (c = e((p = E[o]), c, l, g, (f = E[o + 1]))),
                    (l = e(c, l, h, m, f)),
                    (h = e(l, h, u, y, f)),
                    (d = e(h, u, d, A, f)),
                    (E[o] = d),
                    (u = h),
                    (h = l),
                    (l = c),
                    (c = p);
              for (; w < n; )
                for (g = r.charCodeAt(a + (c = w)), d = ++w, o = 0; o < b; o += 2)
                  (p = E[o]), (E[o] = d = e(p, c, d, g, E[o + 1])), (c = p);
              return d;
            };
          })();
        },
        1668: (e, t, r) => {
          "use strict";
          var i = {};
          (0, r(9805).assign)(i, r(3303), r(7083), r(9681)), (e.exports = i);
        },
        3303: (e, t, r) => {
          "use strict";
          var i = r(8411),
            s = r(9805),
            n = r(1996),
            a = r(4674),
            o = r(4442),
            c = Object.prototype.toString,
            l = 0,
            h = -1,
            u = 0,
            d = 8;
          function p(e) {
            if (!(this instanceof p)) return new p(e);
            this.options = s.assign(
              {
                level: h,
                method: d,
                chunkSize: 16384,
                windowBits: 15,
                memLevel: 8,
                strategy: u,
                to: "",
              },
              e || {}
            );
            var t = this.options;
            t.raw && t.windowBits > 0
              ? (t.windowBits = -t.windowBits)
              : t.gzip &&
                t.windowBits > 0 &&
                t.windowBits < 16 &&
                (t.windowBits += 16),
              (this.err = 0),
              (this.msg = ""),
              (this.ended = !1),
              (this.chunks = []),
              (this.strm = new o()),
              (this.strm.avail_out = 0);
            var r = i.deflateInit2(
              this.strm,
              t.level,
              t.method,
              t.windowBits,
              t.memLevel,
              t.strategy
            );
            if (r !== l) throw new Error(a[r]);
            if (
              (t.header && i.deflateSetHeader(this.strm, t.header), t.dictionary)
            ) {
              var f;
              if (
                ((f =
                  "string" == typeof t.dictionary
                    ? n.string2buf(t.dictionary)
                    : "[object ArrayBuffer]" === c.call(t.dictionary)
                    ? new Uint8Array(t.dictionary)
                    : t.dictionary),
                (r = i.deflateSetDictionary(this.strm, f)) !== l)
              )
                throw new Error(a[r]);
              this._dict_set = !0;
            }
          }
          function f(e, t) {
            var r = new p(t);
            if ((r.push(e, !0), r.err)) throw r.msg || a[r.err];
            return r.result;
          }
          (p.prototype.push = function (e, t) {
            var r,
              a,
              o = this.strm,
              h = this.options.chunkSize;
            if (this.ended) return !1;
            (a = t === ~~t ? t : !0 === t ? 4 : 0),
              "string" == typeof e
                ? (o.input = n.string2buf(e))
                : "[object ArrayBuffer]" === c.call(e)
                ? (o.input = new Uint8Array(e))
                : (o.input = e),
              (o.next_in = 0),
              (o.avail_in = o.input.length);
            do {
              if (
                (0 === o.avail_out &&
                  ((o.output = new s.Buf8(h)),
                  (o.next_out = 0),
                  (o.avail_out = h)),
                1 !== (r = i.deflate(o, a)) && r !== l)
              )
                return this.onEnd(r), (this.ended = !0), !1;
              (0 !== o.avail_out && (0 !== o.avail_in || (4 !== a && 2 !== a))) ||
                ("string" === this.options.to
                  ? this.onData(
                      n.buf2binstring(s.shrinkBuf(o.output, o.next_out))
                    )
                  : this.onData(s.shrinkBuf(o.output, o.next_out)));
            } while ((o.avail_in > 0 || 0 === o.avail_out) && 1 !== r);
            return 4 === a
              ? ((r = i.deflateEnd(this.strm)),
                this.onEnd(r),
                (this.ended = !0),
                r === l)
              : 2 !== a || (this.onEnd(l), (o.avail_out = 0), !0);
          }),
            (p.prototype.onData = function (e) {
              this.chunks.push(e);
            }),
            (p.prototype.onEnd = function (e) {
              e === l &&
                ("string" === this.options.to
                  ? (this.result = this.chunks.join(""))
                  : (this.result = s.flattenChunks(this.chunks))),
                (this.chunks = []),
                (this.err = e),
                (this.msg = this.strm.msg);
            }),
            (t.Deflate = p),
            (t.deflate = f),
            (t.deflateRaw = function (e, t) {
              return ((t = t || {}).raw = !0), f(e, t);
            }),
            (t.gzip = function (e, t) {
              return ((t = t || {}).gzip = !0), f(e, t);
            });
        },
        7083: (e, t, r) => {
          "use strict";
          var i = r(1447),
            s = r(9805),
            n = r(1996),
            a = r(9681),
            o = r(4674),
            c = r(4442),
            l = r(7414),
            h = Object.prototype.toString;
          function u(e) {
            if (!(this instanceof u)) return new u(e);
            this.options = s.assign(
              { chunkSize: 16384, windowBits: 0, to: "" },
              e || {}
            );
            var t = this.options;
            t.raw &&
              t.windowBits >= 0 &&
              t.windowBits < 16 &&
              ((t.windowBits = -t.windowBits),
              0 === t.windowBits && (t.windowBits = -15)),
              !(t.windowBits >= 0 && t.windowBits < 16) ||
                (e && e.windowBits) ||
                (t.windowBits += 32),
              t.windowBits > 15 &&
                t.windowBits < 48 &&
                (15 & t.windowBits || (t.windowBits |= 15)),
              (this.err = 0),
              (this.msg = ""),
              (this.ended = !1),
              (this.chunks = []),
              (this.strm = new c()),
              (this.strm.avail_out = 0);
            var r = i.inflateInit2(this.strm, t.windowBits);
            if (r !== a.Z_OK) throw new Error(o[r]);
            if (
              ((this.header = new l()),
              i.inflateGetHeader(this.strm, this.header),
              t.dictionary &&
                ("string" == typeof t.dictionary
                  ? (t.dictionary = n.string2buf(t.dictionary))
                  : "[object ArrayBuffer]" === h.call(t.dictionary) &&
                    (t.dictionary = new Uint8Array(t.dictionary)),
                t.raw &&
                  (r = i.inflateSetDictionary(this.strm, t.dictionary)) !==
                    a.Z_OK))
            )
              throw new Error(o[r]);
          }
          function d(e, t) {
            var r = new u(t);
            if ((r.push(e, !0), r.err)) throw r.msg || o[r.err];
            return r.result;
          }
          (u.prototype.push = function (e, t) {
            var r,
              o,
              c,
              l,
              u,
              d = this.strm,
              p = this.options.chunkSize,
              f = this.options.dictionary,
              g = !1;
            if (this.ended) return !1;
            (o = t === ~~t ? t : !0 === t ? a.Z_FINISH : a.Z_NO_FLUSH),
              "string" == typeof e
                ? (d.input = n.binstring2buf(e))
                : "[object ArrayBuffer]" === h.call(e)
                ? (d.input = new Uint8Array(e))
                : (d.input = e),
              (d.next_in = 0),
              (d.avail_in = d.input.length);
            do {
              if (
                (0 === d.avail_out &&
                  ((d.output = new s.Buf8(p)),
                  (d.next_out = 0),
                  (d.avail_out = p)),
                (r = i.inflate(d, a.Z_NO_FLUSH)) === a.Z_NEED_DICT &&
                  f &&
                  (r = i.inflateSetDictionary(this.strm, f)),
                r === a.Z_BUF_ERROR && !0 === g && ((r = a.Z_OK), (g = !1)),
                r !== a.Z_STREAM_END && r !== a.Z_OK)
              )
                return this.onEnd(r), (this.ended = !0), !1;
              d.next_out &&
                ((0 !== d.avail_out &&
                  r !== a.Z_STREAM_END &&
                  (0 !== d.avail_in ||
                    (o !== a.Z_FINISH && o !== a.Z_SYNC_FLUSH))) ||
                  ("string" === this.options.to
                    ? ((c = n.utf8border(d.output, d.next_out)),
                      (l = d.next_out - c),
                      (u = n.buf2string(d.output, c)),
                      (d.next_out = l),
                      (d.avail_out = p - l),
                      l && s.arraySet(d.output, d.output, c, l, 0),
                      this.onData(u))
                    : this.onData(s.shrinkBuf(d.output, d.next_out)))),
                0 === d.avail_in && 0 === d.avail_out && (g = !0);
            } while (
              (d.avail_in > 0 || 0 === d.avail_out) &&
              r !== a.Z_STREAM_END
            );
            return (
              r === a.Z_STREAM_END && (o = a.Z_FINISH),
              o === a.Z_FINISH
                ? ((r = i.inflateEnd(this.strm)),
                  this.onEnd(r),
                  (this.ended = !0),
                  r === a.Z_OK)
                : o !== a.Z_SYNC_FLUSH ||
                  (this.onEnd(a.Z_OK), (d.avail_out = 0), !0)
            );
          }),
            (u.prototype.onData = function (e) {
              this.chunks.push(e);
            }),
            (u.prototype.onEnd = function (e) {
              e === a.Z_OK &&
                ("string" === this.options.to
                  ? (this.result = this.chunks.join(""))
                  : (this.result = s.flattenChunks(this.chunks))),
                (this.chunks = []),
                (this.err = e),
                (this.msg = this.strm.msg);
            }),
            (t.Inflate = u),
            (t.inflate = d),
            (t.inflateRaw = function (e, t) {
              return ((t = t || {}).raw = !0), d(e, t);
            }),
            (t.ungzip = d);
        },
        9805: (e, t) => {
          "use strict";
          var r =
            "undefined" != typeof Uint8Array &&
            "undefined" != typeof Uint16Array &&
            "undefined" != typeof Int32Array;
          function i(e, t) {
            return Object.prototype.hasOwnProperty.call(e, t);
          }
          (t.assign = function (e) {
            for (var t = Array.prototype.slice.call(arguments, 1); t.length; ) {
              var r = t.shift();
              if (r) {
                if ("object" != typeof r)
                  throw new TypeError(r + "must be non-object");
                for (var s in r) i(r, s) && (e[s] = r[s]);
              }
            }
            return e;
          }),
            (t.shrinkBuf = function (e, t) {
              return e.length === t
                ? e
                : e.subarray
                ? e.subarray(0, t)
                : ((e.length = t), e);
            });
          var s = {
              arraySet: function (e, t, r, i, s) {
                if (t.subarray && e.subarray) e.set(t.subarray(r, r + i), s);
                else for (var n = 0; n < i; n++) e[s + n] = t[r + n];
              },
              flattenChunks: function (e) {
                var t, r, i, s, n, a;
                for (i = 0, t = 0, r = e.length; t < r; t++) i += e[t].length;
                for (
                  a = new Uint8Array(i), s = 0, t = 0, r = e.length;
                  t < r;
                  t++
                )
                  (n = e[t]), a.set(n, s), (s += n.length);
                return a;
              },
            },
            n = {
              arraySet: function (e, t, r, i, s) {
                for (var n = 0; n < i; n++) e[s + n] = t[r + n];
              },
              flattenChunks: function (e) {
                return [].concat.apply([], e);
              },
            };
          (t.setTyped = function (e) {
            e
              ? ((t.Buf8 = Uint8Array),
                (t.Buf16 = Uint16Array),
                (t.Buf32 = Int32Array),
                t.assign(t, s))
              : ((t.Buf8 = Array),
                (t.Buf16 = Array),
                (t.Buf32 = Array),
                t.assign(t, n));
          }),
            t.setTyped(r);
        },
        1996: (e, t, r) => {
          "use strict";
          var i = r(9805),
            s = !0,
            n = !0;
          try {
            String.fromCharCode.apply(null, [0]);
          } catch (e) {
            s = !1;
          }
          try {
            String.fromCharCode.apply(null, new Uint8Array(1));
          } catch (e) {
            n = !1;
          }
          for (var a = new i.Buf8(256), o = 0; o < 256; o++)
            a[o] =
              o >= 252
                ? 6
                : o >= 248
                ? 5
                : o >= 240
                ? 4
                : o >= 224
                ? 3
                : o >= 192
                ? 2
                : 1;
          function c(e, t) {
            if (t < 65534 && ((e.subarray && n) || (!e.subarray && s)))
              return String.fromCharCode.apply(null, i.shrinkBuf(e, t));
            for (var r = "", a = 0; a < t; a++) r += String.fromCharCode(e[a]);
            return r;
          }
          (a[254] = a[254] = 1),
            (t.string2buf = function (e) {
              var t,
                r,
                s,
                n,
                a,
                o = e.length,
                c = 0;
              for (n = 0; n < o; n++)
                55296 == (64512 & (r = e.charCodeAt(n))) &&
                  n + 1 < o &&
                  56320 == (64512 & (s = e.charCodeAt(n + 1))) &&
                  ((r = 65536 + ((r - 55296) << 10) + (s - 56320)), n++),
                  (c += r < 128 ? 1 : r < 2048 ? 2 : r < 65536 ? 3 : 4);
              for (t = new i.Buf8(c), a = 0, n = 0; a < c; n++)
                55296 == (64512 & (r = e.charCodeAt(n))) &&
                  n + 1 < o &&
                  56320 == (64512 & (s = e.charCodeAt(n + 1))) &&
                  ((r = 65536 + ((r - 55296) << 10) + (s - 56320)), n++),
                  r < 128
                    ? (t[a++] = r)
                    : r < 2048
                    ? ((t[a++] = 192 | (r >>> 6)), (t[a++] = 128 | (63 & r)))
                    : r < 65536
                    ? ((t[a++] = 224 | (r >>> 12)),
                      (t[a++] = 128 | ((r >>> 6) & 63)),
                      (t[a++] = 128 | (63 & r)))
                    : ((t[a++] = 240 | (r >>> 18)),
                      (t[a++] = 128 | ((r >>> 12) & 63)),
                      (t[a++] = 128 | ((r >>> 6) & 63)),
                      (t[a++] = 128 | (63 & r)));
              return t;
            }),
            (t.buf2binstring = function (e) {
              return c(e, e.length);
            }),
            (t.binstring2buf = function (e) {
              for (var t = new i.Buf8(e.length), r = 0, s = t.length; r < s; r++)
                t[r] = e.charCodeAt(r);
              return t;
            }),
            (t.buf2string = function (e, t) {
              var r,
                i,
                s,
                n,
                o = t || e.length,
                l = new Array(2 * o);
              for (i = 0, r = 0; r < o; )
                if ((s = e[r++]) < 128) l[i++] = s;
                else if ((n = a[s]) > 4) (l[i++] = 65533), (r += n - 1);
                else {
                  for (s &= 2 === n ? 31 : 3 === n ? 15 : 7; n > 1 && r < o; )
                    (s = (s << 6) | (63 & e[r++])), n--;
                  n > 1
                    ? (l[i++] = 65533)
                    : s < 65536
                    ? (l[i++] = s)
                    : ((s -= 65536),
                      (l[i++] = 55296 | ((s >> 10) & 1023)),
                      (l[i++] = 56320 | (1023 & s)));
                }
              return c(l, i);
            }),
            (t.utf8border = function (e, t) {
              var r;
              for (
                (t = t || e.length) > e.length && (t = e.length), r = t - 1;
                r >= 0 && 128 == (192 & e[r]);
  
              )
                r--;
              return r < 0 || 0 === r ? t : r + a[e[r]] > t ? r : t;
            });
        },
        3269: (e) => {
          "use strict";
          e.exports = function (e, t, r, i) {
            for (var s = 65535 & e, n = (e >>> 16) & 65535, a = 0; 0 !== r; ) {
              r -= a = r > 2e3 ? 2e3 : r;
              do {
                n = (n + (s = (s + t[i++]) | 0)) | 0;
              } while (--a);
              (s %= 65521), (n %= 65521);
            }
            return s | (n << 16);
          };
        },
        9681: (e) => {
          "use strict";
          e.exports = {
            Z_NO_FLUSH: 0,
            Z_PARTIAL_FLUSH: 1,
            Z_SYNC_FLUSH: 2,
            Z_FULL_FLUSH: 3,
            Z_FINISH: 4,
            Z_BLOCK: 5,
            Z_TREES: 6,
            Z_OK: 0,
            Z_STREAM_END: 1,
            Z_NEED_DICT: 2,
            Z_ERRNO: -1,
            Z_STREAM_ERROR: -2,
            Z_DATA_ERROR: -3,
            Z_BUF_ERROR: -5,
            Z_NO_COMPRESSION: 0,
            Z_BEST_SPEED: 1,
            Z_BEST_COMPRESSION: 9,
            Z_DEFAULT_COMPRESSION: -1,
            Z_FILTERED: 1,
            Z_HUFFMAN_ONLY: 2,
            Z_RLE: 3,
            Z_FIXED: 4,
            Z_DEFAULT_STRATEGY: 0,
            Z_BINARY: 0,
            Z_TEXT: 1,
            Z_UNKNOWN: 2,
            Z_DEFLATED: 8,
          };
        },
        4823: (e) => {
          "use strict";
          var t = (function () {
            for (var e, t = [], r = 0; r < 256; r++) {
              e = r;
              for (var i = 0; i < 8; i++)
                e = 1 & e ? 3988292384 ^ (e >>> 1) : e >>> 1;
              t[r] = e;
            }
            return t;
          })();
          e.exports = function (e, r, i, s) {
            var n = t,
              a = s + i;
            e ^= -1;
            for (var o = s; o < a; o++) e = (e >>> 8) ^ n[255 & (e ^ r[o])];
            return ~e;
          };
        },
        8411: (e, t, r) => {
          "use strict";
          var i,
            s = r(9805),
            n = r(3665),
            a = r(3269),
            o = r(4823),
            c = r(4674),
            l = 0,
            h = 4,
            u = 0,
            d = -2,
            p = -1,
            f = 4,
            g = 2,
            m = 8,
            y = 9,
            A = 286,
            w = 30,
            E = 19,
            b = 2 * A + 1,
            v = 15,
            I = 3,
            S = 258,
            T = S + I + 1,
            _ = 42,
            C = 103,
            x = 113,
            N = 666,
            k = 1,
            R = 2,
            B = 3,
            D = 4;
          function O(e, t) {
            return (e.msg = c[t]), t;
          }
          function L(e) {
            return (e << 1) - (e > 4 ? 9 : 0);
          }
          function P(e) {
            for (var t = e.length; --t >= 0; ) e[t] = 0;
          }
          function U(e) {
            var t = e.state,
              r = t.pending;
            r > e.avail_out && (r = e.avail_out),
              0 !== r &&
                (s.arraySet(
                  e.output,
                  t.pending_buf,
                  t.pending_out,
                  r,
                  e.next_out
                ),
                (e.next_out += r),
                (t.pending_out += r),
                (e.total_out += r),
                (e.avail_out -= r),
                (t.pending -= r),
                0 === t.pending && (t.pending_out = 0));
          }
          function M(e, t) {
            n._tr_flush_block(
              e,
              e.block_start >= 0 ? e.block_start : -1,
              e.strstart - e.block_start,
              t
            ),
              (e.block_start = e.strstart),
              U(e.strm);
          }
          function F(e, t) {
            e.pending_buf[e.pending++] = t;
          }
          function H(e, t) {
            (e.pending_buf[e.pending++] = (t >>> 8) & 255),
              (e.pending_buf[e.pending++] = 255 & t);
          }
          function Q(e, t) {
            var r,
              i,
              s = e.max_chain_length,
              n = e.strstart,
              a = e.prev_length,
              o = e.nice_match,
              c = e.strstart > e.w_size - T ? e.strstart - (e.w_size - T) : 0,
              l = e.window,
              h = e.w_mask,
              u = e.prev,
              d = e.strstart + S,
              p = l[n + a - 1],
              f = l[n + a];
            e.prev_length >= e.good_match && (s >>= 2),
              o > e.lookahead && (o = e.lookahead);
            do {
              if (
                l[(r = t) + a] === f &&
                l[r + a - 1] === p &&
                l[r] === l[n] &&
                l[++r] === l[n + 1]
              ) {
                (n += 2), r++;
                do {} while (
                  l[++n] === l[++r] &&
                  l[++n] === l[++r] &&
                  l[++n] === l[++r] &&
                  l[++n] === l[++r] &&
                  l[++n] === l[++r] &&
                  l[++n] === l[++r] &&
                  l[++n] === l[++r] &&
                  l[++n] === l[++r] &&
                  n < d
                );
                if (((i = S - (d - n)), (n = d - S), i > a)) {
                  if (((e.match_start = t), (a = i), i >= o)) break;
                  (p = l[n + a - 1]), (f = l[n + a]);
                }
              }
            } while ((t = u[t & h]) > c && 0 != --s);
            return a <= e.lookahead ? a : e.lookahead;
          }
          function V(e) {
            var t,
              r,
              i,
              n,
              c,
              l,
              h,
              u,
              d,
              p,
              f = e.w_size;
            do {
              if (
                ((n = e.window_size - e.lookahead - e.strstart),
                e.strstart >= f + (f - T))
              ) {
                s.arraySet(e.window, e.window, f, f, 0),
                  (e.match_start -= f),
                  (e.strstart -= f),
                  (e.block_start -= f),
                  (t = r = e.hash_size);
                do {
                  (i = e.head[--t]), (e.head[t] = i >= f ? i - f : 0);
                } while (--r);
                t = r = f;
                do {
                  (i = e.prev[--t]), (e.prev[t] = i >= f ? i - f : 0);
                } while (--r);
                n += f;
              }
              if (0 === e.strm.avail_in) break;
              if (
                ((l = e.strm),
                (h = e.window),
                (u = e.strstart + e.lookahead),
                (d = n),
                (p = void 0),
                (p = l.avail_in) > d && (p = d),
                (r =
                  0 === p
                    ? 0
                    : ((l.avail_in -= p),
                      s.arraySet(h, l.input, l.next_in, p, u),
                      1 === l.state.wrap
                        ? (l.adler = a(l.adler, h, p, u))
                        : 2 === l.state.wrap && (l.adler = o(l.adler, h, p, u)),
                      (l.next_in += p),
                      (l.total_in += p),
                      p)),
                (e.lookahead += r),
                e.lookahead + e.insert >= I)
              )
                for (
                  c = e.strstart - e.insert,
                    e.ins_h = e.window[c],
                    e.ins_h =
                      ((e.ins_h << e.hash_shift) ^ e.window[c + 1]) & e.hash_mask;
                  e.insert &&
                  ((e.ins_h =
                    ((e.ins_h << e.hash_shift) ^ e.window[c + I - 1]) &
                    e.hash_mask),
                  (e.prev[c & e.w_mask] = e.head[e.ins_h]),
                  (e.head[e.ins_h] = c),
                  c++,
                  e.insert--,
                  !(e.lookahead + e.insert < I));
  
                );
            } while (e.lookahead < T && 0 !== e.strm.avail_in);
          }
          function z(e, t) {
            for (var r, i; ; ) {
              if (e.lookahead < T) {
                if ((V(e), e.lookahead < T && t === l)) return k;
                if (0 === e.lookahead) break;
              }
              if (
                ((r = 0),
                e.lookahead >= I &&
                  ((e.ins_h =
                    ((e.ins_h << e.hash_shift) ^ e.window[e.strstart + I - 1]) &
                    e.hash_mask),
                  (r = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h]),
                  (e.head[e.ins_h] = e.strstart)),
                0 !== r &&
                  e.strstart - r <= e.w_size - T &&
                  (e.match_length = Q(e, r)),
                e.match_length >= I)
              )
                if (
                  ((i = n._tr_tally(
                    e,
                    e.strstart - e.match_start,
                    e.match_length - I
                  )),
                  (e.lookahead -= e.match_length),
                  e.match_length <= e.max_lazy_match && e.lookahead >= I)
                ) {
                  e.match_length--;
                  do {
                    e.strstart++,
                      (e.ins_h =
                        ((e.ins_h << e.hash_shift) ^
                          e.window[e.strstart + I - 1]) &
                        e.hash_mask),
                      (r = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h]),
                      (e.head[e.ins_h] = e.strstart);
                  } while (0 != --e.match_length);
                  e.strstart++;
                } else
                  (e.strstart += e.match_length),
                    (e.match_length = 0),
                    (e.ins_h = e.window[e.strstart]),
                    (e.ins_h =
                      ((e.ins_h << e.hash_shift) ^ e.window[e.strstart + 1]) &
                      e.hash_mask);
              else
                (i = n._tr_tally(e, 0, e.window[e.strstart])),
                  e.lookahead--,
                  e.strstart++;
              if (i && (M(e, !1), 0 === e.strm.avail_out)) return k;
            }
            return (
              (e.insert = e.strstart < I - 1 ? e.strstart : I - 1),
              t === h
                ? (M(e, !0), 0 === e.strm.avail_out ? B : D)
                : e.last_lit && (M(e, !1), 0 === e.strm.avail_out)
                ? k
                : R
            );
          }
          function q(e, t) {
            for (var r, i, s; ; ) {
              if (e.lookahead < T) {
                if ((V(e), e.lookahead < T && t === l)) return k;
                if (0 === e.lookahead) break;
              }
              if (
                ((r = 0),
                e.lookahead >= I &&
                  ((e.ins_h =
                    ((e.ins_h << e.hash_shift) ^ e.window[e.strstart + I - 1]) &
                    e.hash_mask),
                  (r = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h]),
                  (e.head[e.ins_h] = e.strstart)),
                (e.prev_length = e.match_length),
                (e.prev_match = e.match_start),
                (e.match_length = I - 1),
                0 !== r &&
                  e.prev_length < e.max_lazy_match &&
                  e.strstart - r <= e.w_size - T &&
                  ((e.match_length = Q(e, r)),
                  e.match_length <= 5 &&
                    (1 === e.strategy ||
                      (e.match_length === I &&
                        e.strstart - e.match_start > 4096)) &&
                    (e.match_length = I - 1)),
                e.prev_length >= I && e.match_length <= e.prev_length)
              ) {
                (s = e.strstart + e.lookahead - I),
                  (i = n._tr_tally(
                    e,
                    e.strstart - 1 - e.prev_match,
                    e.prev_length - I
                  )),
                  (e.lookahead -= e.prev_length - 1),
                  (e.prev_length -= 2);
                do {
                  ++e.strstart <= s &&
                    ((e.ins_h =
                      ((e.ins_h << e.hash_shift) ^ e.window[e.strstart + I - 1]) &
                      e.hash_mask),
                    (r = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h]),
                    (e.head[e.ins_h] = e.strstart));
                } while (0 != --e.prev_length);
                if (
                  ((e.match_available = 0),
                  (e.match_length = I - 1),
                  e.strstart++,
                  i && (M(e, !1), 0 === e.strm.avail_out))
                )
                  return k;
              } else if (e.match_available) {
                if (
                  ((i = n._tr_tally(e, 0, e.window[e.strstart - 1])) && M(e, !1),
                  e.strstart++,
                  e.lookahead--,
                  0 === e.strm.avail_out)
                )
                  return k;
              } else (e.match_available = 1), e.strstart++, e.lookahead--;
            }
            return (
              e.match_available &&
                ((i = n._tr_tally(e, 0, e.window[e.strstart - 1])),
                (e.match_available = 0)),
              (e.insert = e.strstart < I - 1 ? e.strstart : I - 1),
              t === h
                ? (M(e, !0), 0 === e.strm.avail_out ? B : D)
                : e.last_lit && (M(e, !1), 0 === e.strm.avail_out)
                ? k
                : R
            );
          }
          function G(e, t, r, i, s) {
            (this.good_length = e),
              (this.max_lazy = t),
              (this.nice_length = r),
              (this.max_chain = i),
              (this.func = s);
          }
          function j() {
            (this.strm = null),
              (this.status = 0),
              (this.pending_buf = null),
              (this.pending_buf_size = 0),
              (this.pending_out = 0),
              (this.pending = 0),
              (this.wrap = 0),
              (this.gzhead = null),
              (this.gzindex = 0),
              (this.method = m),
              (this.last_flush = -1),
              (this.w_size = 0),
              (this.w_bits = 0),
              (this.w_mask = 0),
              (this.window = null),
              (this.window_size = 0),
              (this.prev = null),
              (this.head = null),
              (this.ins_h = 0),
              (this.hash_size = 0),
              (this.hash_bits = 0),
              (this.hash_mask = 0),
              (this.hash_shift = 0),
              (this.block_start = 0),
              (this.match_length = 0),
              (this.prev_match = 0),
              (this.match_available = 0),
              (this.strstart = 0),
              (this.match_start = 0),
              (this.lookahead = 0),
              (this.prev_length = 0),
              (this.max_chain_length = 0),
              (this.max_lazy_match = 0),
              (this.level = 0),
              (this.strategy = 0),
              (this.good_match = 0),
              (this.nice_match = 0),
              (this.dyn_ltree = new s.Buf16(2 * b)),
              (this.dyn_dtree = new s.Buf16(2 * (2 * w + 1))),
              (this.bl_tree = new s.Buf16(2 * (2 * E + 1))),
              P(this.dyn_ltree),
              P(this.dyn_dtree),
              P(this.bl_tree),
              (this.l_desc = null),
              (this.d_desc = null),
              (this.bl_desc = null),
              (this.bl_count = new s.Buf16(v + 1)),
              (this.heap = new s.Buf16(2 * A + 1)),
              P(this.heap),
              (this.heap_len = 0),
              (this.heap_max = 0),
              (this.depth = new s.Buf16(2 * A + 1)),
              P(this.depth),
              (this.l_buf = 0),
              (this.lit_bufsize = 0),
              (this.last_lit = 0),
              (this.d_buf = 0),
              (this.opt_len = 0),
              (this.static_len = 0),
              (this.matches = 0),
              (this.insert = 0),
              (this.bi_buf = 0),
              (this.bi_valid = 0);
          }
          function W(e) {
            var t;
            return e && e.state
              ? ((e.total_in = e.total_out = 0),
                (e.data_type = g),
                ((t = e.state).pending = 0),
                (t.pending_out = 0),
                t.wrap < 0 && (t.wrap = -t.wrap),
                (t.status = t.wrap ? _ : x),
                (e.adler = 2 === t.wrap ? 0 : 1),
                (t.last_flush = l),
                n._tr_init(t),
                u)
              : O(e, d);
          }
          function Y(e) {
            var t,
              r = W(e);
            return (
              r === u &&
                (((t = e.state).window_size = 2 * t.w_size),
                P(t.head),
                (t.max_lazy_match = i[t.level].max_lazy),
                (t.good_match = i[t.level].good_length),
                (t.nice_match = i[t.level].nice_length),
                (t.max_chain_length = i[t.level].max_chain),
                (t.strstart = 0),
                (t.block_start = 0),
                (t.lookahead = 0),
                (t.insert = 0),
                (t.match_length = t.prev_length = I - 1),
                (t.match_available = 0),
                (t.ins_h = 0)),
              r
            );
          }
          function X(e, t, r, i, n, a) {
            if (!e) return d;
            var o = 1;
            if (
              (t === p && (t = 6),
              i < 0 ? ((o = 0), (i = -i)) : i > 15 && ((o = 2), (i -= 16)),
              n < 1 ||
                n > y ||
                r !== m ||
                i < 8 ||
                i > 15 ||
                t < 0 ||
                t > 9 ||
                a < 0 ||
                a > f)
            )
              return O(e, d);
            8 === i && (i = 9);
            var c = new j();
            return (
              (e.state = c),
              (c.strm = e),
              (c.wrap = o),
              (c.gzhead = null),
              (c.w_bits = i),
              (c.w_size = 1 << c.w_bits),
              (c.w_mask = c.w_size - 1),
              (c.hash_bits = n + 7),
              (c.hash_size = 1 << c.hash_bits),
              (c.hash_mask = c.hash_size - 1),
              (c.hash_shift = ~~((c.hash_bits + I - 1) / I)),
              (c.window = new s.Buf8(2 * c.w_size)),
              (c.head = new s.Buf16(c.hash_size)),
              (c.prev = new s.Buf16(c.w_size)),
              (c.lit_bufsize = 1 << (n + 6)),
              (c.pending_buf_size = 4 * c.lit_bufsize),
              (c.pending_buf = new s.Buf8(c.pending_buf_size)),
              (c.d_buf = 1 * c.lit_bufsize),
              (c.l_buf = 3 * c.lit_bufsize),
              (c.level = t),
              (c.strategy = a),
              (c.method = r),
              Y(e)
            );
          }
          (i = [
            new G(0, 0, 0, 0, function (e, t) {
              var r = 65535;
              for (
                r > e.pending_buf_size - 5 && (r = e.pending_buf_size - 5);
                ;
  
              ) {
                if (e.lookahead <= 1) {
                  if ((V(e), 0 === e.lookahead && t === l)) return k;
                  if (0 === e.lookahead) break;
                }
                (e.strstart += e.lookahead), (e.lookahead = 0);
                var i = e.block_start + r;
                if (
                  (0 === e.strstart || e.strstart >= i) &&
                  ((e.lookahead = e.strstart - i),
                  (e.strstart = i),
                  M(e, !1),
                  0 === e.strm.avail_out)
                )
                  return k;
                if (
                  e.strstart - e.block_start >= e.w_size - T &&
                  (M(e, !1), 0 === e.strm.avail_out)
                )
                  return k;
              }
              return (
                (e.insert = 0),
                t === h
                  ? (M(e, !0), 0 === e.strm.avail_out ? B : D)
                  : (e.strstart > e.block_start && (M(e, !1), e.strm.avail_out),
                    k)
              );
            }),
            new G(4, 4, 8, 4, z),
            new G(4, 5, 16, 8, z),
            new G(4, 6, 32, 32, z),
            new G(4, 4, 16, 16, q),
            new G(8, 16, 32, 32, q),
            new G(8, 16, 128, 128, q),
            new G(8, 32, 128, 256, q),
            new G(32, 128, 258, 1024, q),
            new G(32, 258, 258, 4096, q),
          ]),
            (t.deflateInit = function (e, t) {
              return X(e, t, m, 15, 8, 0);
            }),
            (t.deflateInit2 = X),
            (t.deflateReset = Y),
            (t.deflateResetKeep = W),
            (t.deflateSetHeader = function (e, t) {
              return e && e.state
                ? 2 !== e.state.wrap
                  ? d
                  : ((e.state.gzhead = t), u)
                : d;
            }),
            (t.deflate = function (e, t) {
              var r, s, a, c;
              if (!e || !e.state || t > 5 || t < 0) return e ? O(e, d) : d;
              if (
                ((s = e.state),
                !e.output ||
                  (!e.input && 0 !== e.avail_in) ||
                  (s.status === N && t !== h))
              )
                return O(e, 0 === e.avail_out ? -5 : d);
              if (
                ((s.strm = e),
                (r = s.last_flush),
                (s.last_flush = t),
                s.status === _)
              )
                if (2 === s.wrap)
                  (e.adler = 0),
                    F(s, 31),
                    F(s, 139),
                    F(s, 8),
                    s.gzhead
                      ? (F(
                          s,
                          (s.gzhead.text ? 1 : 0) +
                            (s.gzhead.hcrc ? 2 : 0) +
                            (s.gzhead.extra ? 4 : 0) +
                            (s.gzhead.name ? 8 : 0) +
                            (s.gzhead.comment ? 16 : 0)
                        ),
                        F(s, 255 & s.gzhead.time),
                        F(s, (s.gzhead.time >> 8) & 255),
                        F(s, (s.gzhead.time >> 16) & 255),
                        F(s, (s.gzhead.time >> 24) & 255),
                        F(
                          s,
                          9 === s.level
                            ? 2
                            : s.strategy >= 2 || s.level < 2
                            ? 4
                            : 0
                        ),
                        F(s, 255 & s.gzhead.os),
                        s.gzhead.extra &&
                          s.gzhead.extra.length &&
                          (F(s, 255 & s.gzhead.extra.length),
                          F(s, (s.gzhead.extra.length >> 8) & 255)),
                        s.gzhead.hcrc &&
                          (e.adler = o(e.adler, s.pending_buf, s.pending, 0)),
                        (s.gzindex = 0),
                        (s.status = 69))
                      : (F(s, 0),
                        F(s, 0),
                        F(s, 0),
                        F(s, 0),
                        F(s, 0),
                        F(
                          s,
                          9 === s.level
                            ? 2
                            : s.strategy >= 2 || s.level < 2
                            ? 4
                            : 0
                        ),
                        F(s, 3),
                        (s.status = x));
                else {
                  var p = (m + ((s.w_bits - 8) << 4)) << 8;
                  (p |=
                    (s.strategy >= 2 || s.level < 2
                      ? 0
                      : s.level < 6
                      ? 1
                      : 6 === s.level
                      ? 2
                      : 3) << 6),
                    0 !== s.strstart && (p |= 32),
                    (p += 31 - (p % 31)),
                    (s.status = x),
                    H(s, p),
                    0 !== s.strstart &&
                      (H(s, e.adler >>> 16), H(s, 65535 & e.adler)),
                    (e.adler = 1);
                }
              if (69 === s.status)
                if (s.gzhead.extra) {
                  for (
                    a = s.pending;
                    s.gzindex < (65535 & s.gzhead.extra.length) &&
                    (s.pending !== s.pending_buf_size ||
                      (s.gzhead.hcrc &&
                        s.pending > a &&
                        (e.adler = o(e.adler, s.pending_buf, s.pending - a, a)),
                      U(e),
                      (a = s.pending),
                      s.pending !== s.pending_buf_size));
  
                  )
                    F(s, 255 & s.gzhead.extra[s.gzindex]), s.gzindex++;
                  s.gzhead.hcrc &&
                    s.pending > a &&
                    (e.adler = o(e.adler, s.pending_buf, s.pending - a, a)),
                    s.gzindex === s.gzhead.extra.length &&
                      ((s.gzindex = 0), (s.status = 73));
                } else s.status = 73;
              if (73 === s.status)
                if (s.gzhead.name) {
                  a = s.pending;
                  do {
                    if (
                      s.pending === s.pending_buf_size &&
                      (s.gzhead.hcrc &&
                        s.pending > a &&
                        (e.adler = o(e.adler, s.pending_buf, s.pending - a, a)),
                      U(e),
                      (a = s.pending),
                      s.pending === s.pending_buf_size)
                    ) {
                      c = 1;
                      break;
                    }
                    (c =
                      s.gzindex < s.gzhead.name.length
                        ? 255 & s.gzhead.name.charCodeAt(s.gzindex++)
                        : 0),
                      F(s, c);
                  } while (0 !== c);
                  s.gzhead.hcrc &&
                    s.pending > a &&
                    (e.adler = o(e.adler, s.pending_buf, s.pending - a, a)),
                    0 === c && ((s.gzindex = 0), (s.status = 91));
                } else s.status = 91;
              if (91 === s.status)
                if (s.gzhead.comment) {
                  a = s.pending;
                  do {
                    if (
                      s.pending === s.pending_buf_size &&
                      (s.gzhead.hcrc &&
                        s.pending > a &&
                        (e.adler = o(e.adler, s.pending_buf, s.pending - a, a)),
                      U(e),
                      (a = s.pending),
                      s.pending === s.pending_buf_size)
                    ) {
                      c = 1;
                      break;
                    }
                    (c =
                      s.gzindex < s.gzhead.comment.length
                        ? 255 & s.gzhead.comment.charCodeAt(s.gzindex++)
                        : 0),
                      F(s, c);
                  } while (0 !== c);
                  s.gzhead.hcrc &&
                    s.pending > a &&
                    (e.adler = o(e.adler, s.pending_buf, s.pending - a, a)),
                    0 === c && (s.status = C);
                } else s.status = C;
              if (
                (s.status === C &&
                  (s.gzhead.hcrc
                    ? (s.pending + 2 > s.pending_buf_size && U(e),
                      s.pending + 2 <= s.pending_buf_size &&
                        (F(s, 255 & e.adler),
                        F(s, (e.adler >> 8) & 255),
                        (e.adler = 0),
                        (s.status = x)))
                    : (s.status = x)),
                0 !== s.pending)
              ) {
                if ((U(e), 0 === e.avail_out)) return (s.last_flush = -1), u;
              } else if (0 === e.avail_in && L(t) <= L(r) && t !== h)
                return O(e, -5);
              if (s.status === N && 0 !== e.avail_in) return O(e, -5);
              if (
                0 !== e.avail_in ||
                0 !== s.lookahead ||
                (t !== l && s.status !== N)
              ) {
                var f =
                  2 === s.strategy
                    ? (function (e, t) {
                        for (var r; ; ) {
                          if (0 === e.lookahead && (V(e), 0 === e.lookahead)) {
                            if (t === l) return k;
                            break;
                          }
                          if (
                            ((e.match_length = 0),
                            (r = n._tr_tally(e, 0, e.window[e.strstart])),
                            e.lookahead--,
                            e.strstart++,
                            r && (M(e, !1), 0 === e.strm.avail_out))
                          )
                            return k;
                        }
                        return (
                          (e.insert = 0),
                          t === h
                            ? (M(e, !0), 0 === e.strm.avail_out ? B : D)
                            : e.last_lit && (M(e, !1), 0 === e.strm.avail_out)
                            ? k
                            : R
                        );
                      })(s, t)
                    : 3 === s.strategy
                    ? (function (e, t) {
                        for (var r, i, s, a, o = e.window; ; ) {
                          if (e.lookahead <= S) {
                            if ((V(e), e.lookahead <= S && t === l)) return k;
                            if (0 === e.lookahead) break;
                          }
                          if (
                            ((e.match_length = 0),
                            e.lookahead >= I &&
                              e.strstart > 0 &&
                              (i = o[(s = e.strstart - 1)]) === o[++s] &&
                              i === o[++s] &&
                              i === o[++s])
                          ) {
                            a = e.strstart + S;
                            do {} while (
                              i === o[++s] &&
                              i === o[++s] &&
                              i === o[++s] &&
                              i === o[++s] &&
                              i === o[++s] &&
                              i === o[++s] &&
                              i === o[++s] &&
                              i === o[++s] &&
                              s < a
                            );
                            (e.match_length = S - (a - s)),
                              e.match_length > e.lookahead &&
                                (e.match_length = e.lookahead);
                          }
                          if (
                            (e.match_length >= I
                              ? ((r = n._tr_tally(e, 1, e.match_length - I)),
                                (e.lookahead -= e.match_length),
                                (e.strstart += e.match_length),
                                (e.match_length = 0))
                              : ((r = n._tr_tally(e, 0, e.window[e.strstart])),
                                e.lookahead--,
                                e.strstart++),
                            r && (M(e, !1), 0 === e.strm.avail_out))
                          )
                            return k;
                        }
                        return (
                          (e.insert = 0),
                          t === h
                            ? (M(e, !0), 0 === e.strm.avail_out ? B : D)
                            : e.last_lit && (M(e, !1), 0 === e.strm.avail_out)
                            ? k
                            : R
                        );
                      })(s, t)
                    : i[s.level].func(s, t);
                if (((f !== B && f !== D) || (s.status = N), f === k || f === B))
                  return 0 === e.avail_out && (s.last_flush = -1), u;
                if (
                  f === R &&
                  (1 === t
                    ? n._tr_align(s)
                    : 5 !== t &&
                      (n._tr_stored_block(s, 0, 0, !1),
                      3 === t &&
                        (P(s.head),
                        0 === s.lookahead &&
                          ((s.strstart = 0),
                          (s.block_start = 0),
                          (s.insert = 0)))),
                  U(e),
                  0 === e.avail_out)
                )
                  return (s.last_flush = -1), u;
              }
              return t !== h
                ? u
                : s.wrap <= 0
                ? 1
                : (2 === s.wrap
                    ? (F(s, 255 & e.adler),
                      F(s, (e.adler >> 8) & 255),
                      F(s, (e.adler >> 16) & 255),
                      F(s, (e.adler >> 24) & 255),
                      F(s, 255 & e.total_in),
                      F(s, (e.total_in >> 8) & 255),
                      F(s, (e.total_in >> 16) & 255),
                      F(s, (e.total_in >> 24) & 255))
                    : (H(s, e.adler >>> 16), H(s, 65535 & e.adler)),
                  U(e),
                  s.wrap > 0 && (s.wrap = -s.wrap),
                  0 !== s.pending ? u : 1);
            }),
            (t.deflateEnd = function (e) {
              var t;
              return e && e.state
                ? (t = e.state.status) !== _ &&
                  69 !== t &&
                  73 !== t &&
                  91 !== t &&
                  t !== C &&
                  t !== x &&
                  t !== N
                  ? O(e, d)
                  : ((e.state = null), t === x ? O(e, -3) : u)
                : d;
            }),
            (t.deflateSetDictionary = function (e, t) {
              var r,
                i,
                n,
                o,
                c,
                l,
                h,
                p,
                f = t.length;
              if (!e || !e.state) return d;
              if (
                2 === (o = (r = e.state).wrap) ||
                (1 === o && r.status !== _) ||
                r.lookahead
              )
                return d;
              for (
                1 === o && (e.adler = a(e.adler, t, f, 0)),
                  r.wrap = 0,
                  f >= r.w_size &&
                    (0 === o &&
                      (P(r.head),
                      (r.strstart = 0),
                      (r.block_start = 0),
                      (r.insert = 0)),
                    (p = new s.Buf8(r.w_size)),
                    s.arraySet(p, t, f - r.w_size, r.w_size, 0),
                    (t = p),
                    (f = r.w_size)),
                  c = e.avail_in,
                  l = e.next_in,
                  h = e.input,
                  e.avail_in = f,
                  e.next_in = 0,
                  e.input = t,
                  V(r);
                r.lookahead >= I;
  
              ) {
                (i = r.strstart), (n = r.lookahead - (I - 1));
                do {
                  (r.ins_h =
                    ((r.ins_h << r.hash_shift) ^ r.window[i + I - 1]) &
                    r.hash_mask),
                    (r.prev[i & r.w_mask] = r.head[r.ins_h]),
                    (r.head[r.ins_h] = i),
                    i++;
                } while (--n);
                (r.strstart = i), (r.lookahead = I - 1), V(r);
              }
              return (
                (r.strstart += r.lookahead),
                (r.block_start = r.strstart),
                (r.insert = r.lookahead),
                (r.lookahead = 0),
                (r.match_length = r.prev_length = I - 1),
                (r.match_available = 0),
                (e.next_in = l),
                (e.input = h),
                (e.avail_in = c),
                (r.wrap = o),
                u
              );
            }),
            (t.deflateInfo = "pako deflate (from Nodeca project)");
        },
        7414: (e) => {
          "use strict";
          e.exports = function () {
            (this.text = 0),
              (this.time = 0),
              (this.xflags = 0),
              (this.os = 0),
              (this.extra = null),
              (this.extra_len = 0),
              (this.name = ""),
              (this.comment = ""),
              (this.hcrc = 0),
              (this.done = !1);
          };
        },
        7293: (e) => {
          "use strict";
          e.exports = function (e, t) {
            var r,
              i,
              s,
              n,
              a,
              o,
              c,
              l,
              h,
              u,
              d,
              p,
              f,
              g,
              m,
              y,
              A,
              w,
              E,
              b,
              v,
              I,
              S,
              T,
              _;
            (r = e.state),
              (i = e.next_in),
              (T = e.input),
              (s = i + (e.avail_in - 5)),
              (n = e.next_out),
              (_ = e.output),
              (a = n - (t - e.avail_out)),
              (o = n + (e.avail_out - 257)),
              (c = r.dmax),
              (l = r.wsize),
              (h = r.whave),
              (u = r.wnext),
              (d = r.window),
              (p = r.hold),
              (f = r.bits),
              (g = r.lencode),
              (m = r.distcode),
              (y = (1 << r.lenbits) - 1),
              (A = (1 << r.distbits) - 1);
            e: do {
              f < 15 &&
                ((p += T[i++] << f), (f += 8), (p += T[i++] << f), (f += 8)),
                (w = g[p & y]);
              t: for (;;) {
                if (
                  ((p >>>= E = w >>> 24), (f -= E), 0 === (E = (w >>> 16) & 255))
                )
                  _[n++] = 65535 & w;
                else {
                  if (!(16 & E)) {
                    if (64 & E) {
                      if (32 & E) {
                        r.mode = 12;
                        break e;
                      }
                      (e.msg = "invalid literal/length code"), (r.mode = 30);
                      break e;
                    }
                    w = g[(65535 & w) + (p & ((1 << E) - 1))];
                    continue t;
                  }
                  for (
                    b = 65535 & w,
                      (E &= 15) &&
                        (f < E && ((p += T[i++] << f), (f += 8)),
                        (b += p & ((1 << E) - 1)),
                        (p >>>= E),
                        (f -= E)),
                      f < 15 &&
                        ((p += T[i++] << f),
                        (f += 8),
                        (p += T[i++] << f),
                        (f += 8)),
                      w = m[p & A];
                    ;
  
                  ) {
                    if (
                      ((p >>>= E = w >>> 24),
                      (f -= E),
                      16 & (E = (w >>> 16) & 255))
                    ) {
                      if (
                        ((v = 65535 & w),
                        f < (E &= 15) &&
                          ((p += T[i++] << f),
                          (f += 8) < E && ((p += T[i++] << f), (f += 8))),
                        (v += p & ((1 << E) - 1)) > c)
                      ) {
                        (e.msg = "invalid distance too far back"), (r.mode = 30);
                        break e;
                      }
                      if (((p >>>= E), (f -= E), v > (E = n - a))) {
                        if ((E = v - E) > h && r.sane) {
                          (e.msg = "invalid distance too far back"),
                            (r.mode = 30);
                          break e;
                        }
                        if (((I = 0), (S = d), 0 === u)) {
                          if (((I += l - E), E < b)) {
                            b -= E;
                            do {
                              _[n++] = d[I++];
                            } while (--E);
                            (I = n - v), (S = _);
                          }
                        } else if (u < E) {
                          if (((I += l + u - E), (E -= u) < b)) {
                            b -= E;
                            do {
                              _[n++] = d[I++];
                            } while (--E);
                            if (((I = 0), u < b)) {
                              b -= E = u;
                              do {
                                _[n++] = d[I++];
                              } while (--E);
                              (I = n - v), (S = _);
                            }
                          }
                        } else if (((I += u - E), E < b)) {
                          b -= E;
                          do {
                            _[n++] = d[I++];
                          } while (--E);
                          (I = n - v), (S = _);
                        }
                        for (; b > 2; )
                          (_[n++] = S[I++]),
                            (_[n++] = S[I++]),
                            (_[n++] = S[I++]),
                            (b -= 3);
                        b && ((_[n++] = S[I++]), b > 1 && (_[n++] = S[I++]));
                      } else {
                        I = n - v;
                        do {
                          (_[n++] = _[I++]),
                            (_[n++] = _[I++]),
                            (_[n++] = _[I++]),
                            (b -= 3);
                        } while (b > 2);
                        b && ((_[n++] = _[I++]), b > 1 && (_[n++] = _[I++]));
                      }
                      break;
                    }
                    if (64 & E) {
                      (e.msg = "invalid distance code"), (r.mode = 30);
                      break e;
                    }
                    w = m[(65535 & w) + (p & ((1 << E) - 1))];
                  }
                }
                break;
              }
            } while (i < s && n < o);
            (i -= b = f >> 3),
              (p &= (1 << (f -= b << 3)) - 1),
              (e.next_in = i),
              (e.next_out = n),
              (e.avail_in = i < s ? s - i + 5 : 5 - (i - s)),
              (e.avail_out = n < o ? o - n + 257 : 257 - (n - o)),
              (r.hold = p),
              (r.bits = f);
          };
        },
        1447: (e, t, r) => {
          "use strict";
          var i = r(9805),
            s = r(3269),
            n = r(4823),
            a = r(7293),
            o = r(1998),
            c = 1,
            l = 2,
            h = 0,
            u = -2,
            d = 1,
            p = 12,
            f = 30,
            g = 852,
            m = 592;
          function y(e) {
            return (
              ((e >>> 24) & 255) +
              ((e >>> 8) & 65280) +
              ((65280 & e) << 8) +
              ((255 & e) << 24)
            );
          }
          function A() {
            (this.mode = 0),
              (this.last = !1),
              (this.wrap = 0),
              (this.havedict = !1),
              (this.flags = 0),
              (this.dmax = 0),
              (this.check = 0),
              (this.total = 0),
              (this.head = null),
              (this.wbits = 0),
              (this.wsize = 0),
              (this.whave = 0),
              (this.wnext = 0),
              (this.window = null),
              (this.hold = 0),
              (this.bits = 0),
              (this.length = 0),
              (this.offset = 0),
              (this.extra = 0),
              (this.lencode = null),
              (this.distcode = null),
              (this.lenbits = 0),
              (this.distbits = 0),
              (this.ncode = 0),
              (this.nlen = 0),
              (this.ndist = 0),
              (this.have = 0),
              (this.next = null),
              (this.lens = new i.Buf16(320)),
              (this.work = new i.Buf16(288)),
              (this.lendyn = null),
              (this.distdyn = null),
              (this.sane = 0),
              (this.back = 0),
              (this.was = 0);
          }
          function w(e) {
            var t;
            return e && e.state
              ? ((t = e.state),
                (e.total_in = e.total_out = t.total = 0),
                (e.msg = ""),
                t.wrap && (e.adler = 1 & t.wrap),
                (t.mode = d),
                (t.last = 0),
                (t.havedict = 0),
                (t.dmax = 32768),
                (t.head = null),
                (t.hold = 0),
                (t.bits = 0),
                (t.lencode = t.lendyn = new i.Buf32(g)),
                (t.distcode = t.distdyn = new i.Buf32(m)),
                (t.sane = 1),
                (t.back = -1),
                h)
              : u;
          }
          function E(e) {
            var t;
            return e && e.state
              ? (((t = e.state).wsize = 0), (t.whave = 0), (t.wnext = 0), w(e))
              : u;
          }
          function b(e, t) {
            var r, i;
            return e && e.state
              ? ((i = e.state),
                t < 0
                  ? ((r = 0), (t = -t))
                  : ((r = 1 + (t >> 4)), t < 48 && (t &= 15)),
                t && (t < 8 || t > 15)
                  ? u
                  : (null !== i.window && i.wbits !== t && (i.window = null),
                    (i.wrap = r),
                    (i.wbits = t),
                    E(e)))
              : u;
          }
          function v(e, t) {
            var r, i;
            return e
              ? ((i = new A()),
                (e.state = i),
                (i.window = null),
                (r = b(e, t)) !== h && (e.state = null),
                r)
              : u;
          }
          var I,
            S,
            T = !0;
          function _(e) {
            if (T) {
              var t;
              for (I = new i.Buf32(512), S = new i.Buf32(32), t = 0; t < 144; )
                e.lens[t++] = 8;
              for (; t < 256; ) e.lens[t++] = 9;
              for (; t < 280; ) e.lens[t++] = 7;
              for (; t < 288; ) e.lens[t++] = 8;
              for (
                o(c, e.lens, 0, 288, I, 0, e.work, { bits: 9 }), t = 0;
                t < 32;
  
              )
                e.lens[t++] = 5;
              o(l, e.lens, 0, 32, S, 0, e.work, { bits: 5 }), (T = !1);
            }
            (e.lencode = I), (e.lenbits = 9), (e.distcode = S), (e.distbits = 5);
          }
          function C(e, t, r, s) {
            var n,
              a = e.state;
            return (
              null === a.window &&
                ((a.wsize = 1 << a.wbits),
                (a.wnext = 0),
                (a.whave = 0),
                (a.window = new i.Buf8(a.wsize))),
              s >= a.wsize
                ? (i.arraySet(a.window, t, r - a.wsize, a.wsize, 0),
                  (a.wnext = 0),
                  (a.whave = a.wsize))
                : ((n = a.wsize - a.wnext) > s && (n = s),
                  i.arraySet(a.window, t, r - s, n, a.wnext),
                  (s -= n)
                    ? (i.arraySet(a.window, t, r - s, s, 0),
                      (a.wnext = s),
                      (a.whave = a.wsize))
                    : ((a.wnext += n),
                      a.wnext === a.wsize && (a.wnext = 0),
                      a.whave < a.wsize && (a.whave += n))),
              0
            );
          }
          (t.inflateReset = E),
            (t.inflateReset2 = b),
            (t.inflateResetKeep = w),
            (t.inflateInit = function (e) {
              return v(e, 15);
            }),
            (t.inflateInit2 = v),
            (t.inflate = function (e, t) {
              var r,
                g,
                m,
                A,
                w,
                E,
                b,
                v,
                I,
                S,
                T,
                x,
                N,
                k,
                R,
                B,
                D,
                O,
                L,
                P,
                U,
                M,
                F,
                H,
                Q = 0,
                V = new i.Buf8(4),
                z = [
                  16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1,
                  15,
                ];
              if (!e || !e.state || !e.output || (!e.input && 0 !== e.avail_in))
                return u;
              (r = e.state).mode === p && (r.mode = 13),
                (w = e.next_out),
                (m = e.output),
                (b = e.avail_out),
                (A = e.next_in),
                (g = e.input),
                (E = e.avail_in),
                (v = r.hold),
                (I = r.bits),
                (S = E),
                (T = b),
                (M = h);
              e: for (;;)
                switch (r.mode) {
                  case d:
                    if (0 === r.wrap) {
                      r.mode = 13;
                      break;
                    }
                    for (; I < 16; ) {
                      if (0 === E) break e;
                      E--, (v += g[A++] << I), (I += 8);
                    }
                    if (2 & r.wrap && 35615 === v) {
                      (r.check = 0),
                        (V[0] = 255 & v),
                        (V[1] = (v >>> 8) & 255),
                        (r.check = n(r.check, V, 2, 0)),
                        (v = 0),
                        (I = 0),
                        (r.mode = 2);
                      break;
                    }
                    if (
                      ((r.flags = 0),
                      r.head && (r.head.done = !1),
                      !(1 & r.wrap) || (((255 & v) << 8) + (v >> 8)) % 31)
                    ) {
                      (e.msg = "incorrect header check"), (r.mode = f);
                      break;
                    }
                    if (8 != (15 & v)) {
                      (e.msg = "unknown compression method"), (r.mode = f);
                      break;
                    }
                    if (((I -= 4), (U = 8 + (15 & (v >>>= 4))), 0 === r.wbits))
                      r.wbits = U;
                    else if (U > r.wbits) {
                      (e.msg = "invalid window size"), (r.mode = f);
                      break;
                    }
                    (r.dmax = 1 << U),
                      (e.adler = r.check = 1),
                      (r.mode = 512 & v ? 10 : p),
                      (v = 0),
                      (I = 0);
                    break;
                  case 2:
                    for (; I < 16; ) {
                      if (0 === E) break e;
                      E--, (v += g[A++] << I), (I += 8);
                    }
                    if (((r.flags = v), 8 != (255 & r.flags))) {
                      (e.msg = "unknown compression method"), (r.mode = f);
                      break;
                    }
                    if (57344 & r.flags) {
                      (e.msg = "unknown header flags set"), (r.mode = f);
                      break;
                    }
                    r.head && (r.head.text = (v >> 8) & 1),
                      512 & r.flags &&
                        ((V[0] = 255 & v),
                        (V[1] = (v >>> 8) & 255),
                        (r.check = n(r.check, V, 2, 0))),
                      (v = 0),
                      (I = 0),
                      (r.mode = 3);
                  case 3:
                    for (; I < 32; ) {
                      if (0 === E) break e;
                      E--, (v += g[A++] << I), (I += 8);
                    }
                    r.head && (r.head.time = v),
                      512 & r.flags &&
                        ((V[0] = 255 & v),
                        (V[1] = (v >>> 8) & 255),
                        (V[2] = (v >>> 16) & 255),
                        (V[3] = (v >>> 24) & 255),
                        (r.check = n(r.check, V, 4, 0))),
                      (v = 0),
                      (I = 0),
                      (r.mode = 4);
                  case 4:
                    for (; I < 16; ) {
                      if (0 === E) break e;
                      E--, (v += g[A++] << I), (I += 8);
                    }
                    r.head && ((r.head.xflags = 255 & v), (r.head.os = v >> 8)),
                      512 & r.flags &&
                        ((V[0] = 255 & v),
                        (V[1] = (v >>> 8) & 255),
                        (r.check = n(r.check, V, 2, 0))),
                      (v = 0),
                      (I = 0),
                      (r.mode = 5);
                  case 5:
                    if (1024 & r.flags) {
                      for (; I < 16; ) {
                        if (0 === E) break e;
                        E--, (v += g[A++] << I), (I += 8);
                      }
                      (r.length = v),
                        r.head && (r.head.extra_len = v),
                        512 & r.flags &&
                          ((V[0] = 255 & v),
                          (V[1] = (v >>> 8) & 255),
                          (r.check = n(r.check, V, 2, 0))),
                        (v = 0),
                        (I = 0);
                    } else r.head && (r.head.extra = null);
                    r.mode = 6;
                  case 6:
                    if (
                      1024 & r.flags &&
                      ((x = r.length) > E && (x = E),
                      x &&
                        (r.head &&
                          ((U = r.head.extra_len - r.length),
                          r.head.extra ||
                            (r.head.extra = new Array(r.head.extra_len)),
                          i.arraySet(r.head.extra, g, A, x, U)),
                        512 & r.flags && (r.check = n(r.check, g, x, A)),
                        (E -= x),
                        (A += x),
                        (r.length -= x)),
                      r.length)
                    )
                      break e;
                    (r.length = 0), (r.mode = 7);
                  case 7:
                    if (2048 & r.flags) {
                      if (0 === E) break e;
                      x = 0;
                      do {
                        (U = g[A + x++]),
                          r.head &&
                            U &&
                            r.length < 65536 &&
                            (r.head.name += String.fromCharCode(U));
                      } while (U && x < E);
                      if (
                        (512 & r.flags && (r.check = n(r.check, g, x, A)),
                        (E -= x),
                        (A += x),
                        U)
                      )
                        break e;
                    } else r.head && (r.head.name = null);
                    (r.length = 0), (r.mode = 8);
                  case 8:
                    if (4096 & r.flags) {
                      if (0 === E) break e;
                      x = 0;
                      do {
                        (U = g[A + x++]),
                          r.head &&
                            U &&
                            r.length < 65536 &&
                            (r.head.comment += String.fromCharCode(U));
                      } while (U && x < E);
                      if (
                        (512 & r.flags && (r.check = n(r.check, g, x, A)),
                        (E -= x),
                        (A += x),
                        U)
                      )
                        break e;
                    } else r.head && (r.head.comment = null);
                    r.mode = 9;
                  case 9:
                    if (512 & r.flags) {
                      for (; I < 16; ) {
                        if (0 === E) break e;
                        E--, (v += g[A++] << I), (I += 8);
                      }
                      if (v !== (65535 & r.check)) {
                        (e.msg = "header crc mismatch"), (r.mode = f);
                        break;
                      }
                      (v = 0), (I = 0);
                    }
                    r.head &&
                      ((r.head.hcrc = (r.flags >> 9) & 1), (r.head.done = !0)),
                      (e.adler = r.check = 0),
                      (r.mode = p);
                    break;
                  case 10:
                    for (; I < 32; ) {
                      if (0 === E) break e;
                      E--, (v += g[A++] << I), (I += 8);
                    }
                    (e.adler = r.check = y(v)), (v = 0), (I = 0), (r.mode = 11);
                  case 11:
                    if (0 === r.havedict)
                      return (
                        (e.next_out = w),
                        (e.avail_out = b),
                        (e.next_in = A),
                        (e.avail_in = E),
                        (r.hold = v),
                        (r.bits = I),
                        2
                      );
                    (e.adler = r.check = 1), (r.mode = p);
                  case p:
                    if (5 === t || 6 === t) break e;
                  case 13:
                    if (r.last) {
                      (v >>>= 7 & I), (I -= 7 & I), (r.mode = 27);
                      break;
                    }
                    for (; I < 3; ) {
                      if (0 === E) break e;
                      E--, (v += g[A++] << I), (I += 8);
                    }
                    switch (((r.last = 1 & v), (I -= 1), 3 & (v >>>= 1))) {
                      case 0:
                        r.mode = 14;
                        break;
                      case 1:
                        if ((_(r), (r.mode = 20), 6 === t)) {
                          (v >>>= 2), (I -= 2);
                          break e;
                        }
                        break;
                      case 2:
                        r.mode = 17;
                        break;
                      case 3:
                        (e.msg = "invalid block type"), (r.mode = f);
                    }
                    (v >>>= 2), (I -= 2);
                    break;
                  case 14:
                    for (v >>>= 7 & I, I -= 7 & I; I < 32; ) {
                      if (0 === E) break e;
                      E--, (v += g[A++] << I), (I += 8);
                    }
                    if ((65535 & v) != ((v >>> 16) ^ 65535)) {
                      (e.msg = "invalid stored block lengths"), (r.mode = f);
                      break;
                    }
                    if (
                      ((r.length = 65535 & v),
                      (v = 0),
                      (I = 0),
                      (r.mode = 15),
                      6 === t)
                    )
                      break e;
                  case 15:
                    r.mode = 16;
                  case 16:
                    if ((x = r.length)) {
                      if ((x > E && (x = E), x > b && (x = b), 0 === x)) break e;
                      i.arraySet(m, g, A, x, w),
                        (E -= x),
                        (A += x),
                        (b -= x),
                        (w += x),
                        (r.length -= x);
                      break;
                    }
                    r.mode = p;
                    break;
                  case 17:
                    for (; I < 14; ) {
                      if (0 === E) break e;
                      E--, (v += g[A++] << I), (I += 8);
                    }
                    if (
                      ((r.nlen = 257 + (31 & v)),
                      (v >>>= 5),
                      (I -= 5),
                      (r.ndist = 1 + (31 & v)),
                      (v >>>= 5),
                      (I -= 5),
                      (r.ncode = 4 + (15 & v)),
                      (v >>>= 4),
                      (I -= 4),
                      r.nlen > 286 || r.ndist > 30)
                    ) {
                      (e.msg = "too many length or distance symbols"),
                        (r.mode = f);
                      break;
                    }
                    (r.have = 0), (r.mode = 18);
                  case 18:
                    for (; r.have < r.ncode; ) {
                      for (; I < 3; ) {
                        if (0 === E) break e;
                        E--, (v += g[A++] << I), (I += 8);
                      }
                      (r.lens[z[r.have++]] = 7 & v), (v >>>= 3), (I -= 3);
                    }
                    for (; r.have < 19; ) r.lens[z[r.have++]] = 0;
                    if (
                      ((r.lencode = r.lendyn),
                      (r.lenbits = 7),
                      (F = { bits: r.lenbits }),
                      (M = o(0, r.lens, 0, 19, r.lencode, 0, r.work, F)),
                      (r.lenbits = F.bits),
                      M)
                    ) {
                      (e.msg = "invalid code lengths set"), (r.mode = f);
                      break;
                    }
                    (r.have = 0), (r.mode = 19);
                  case 19:
                    for (; r.have < r.nlen + r.ndist; ) {
                      for (
                        ;
                        (B =
                          ((Q = r.lencode[v & ((1 << r.lenbits) - 1)]) >>> 16) &
                          255),
                          (D = 65535 & Q),
                          !((R = Q >>> 24) <= I);
  
                      ) {
                        if (0 === E) break e;
                        E--, (v += g[A++] << I), (I += 8);
                      }
                      if (D < 16) (v >>>= R), (I -= R), (r.lens[r.have++] = D);
                      else {
                        if (16 === D) {
                          for (H = R + 2; I < H; ) {
                            if (0 === E) break e;
                            E--, (v += g[A++] << I), (I += 8);
                          }
                          if (((v >>>= R), (I -= R), 0 === r.have)) {
                            (e.msg = "invalid bit length repeat"), (r.mode = f);
                            break;
                          }
                          (U = r.lens[r.have - 1]),
                            (x = 3 + (3 & v)),
                            (v >>>= 2),
                            (I -= 2);
                        } else if (17 === D) {
                          for (H = R + 3; I < H; ) {
                            if (0 === E) break e;
                            E--, (v += g[A++] << I), (I += 8);
                          }
                          (I -= R),
                            (U = 0),
                            (x = 3 + (7 & (v >>>= R))),
                            (v >>>= 3),
                            (I -= 3);
                        } else {
                          for (H = R + 7; I < H; ) {
                            if (0 === E) break e;
                            E--, (v += g[A++] << I), (I += 8);
                          }
                          (I -= R),
                            (U = 0),
                            (x = 11 + (127 & (v >>>= R))),
                            (v >>>= 7),
                            (I -= 7);
                        }
                        if (r.have + x > r.nlen + r.ndist) {
                          (e.msg = "invalid bit length repeat"), (r.mode = f);
                          break;
                        }
                        for (; x--; ) r.lens[r.have++] = U;
                      }
                    }
                    if (r.mode === f) break;
                    if (0 === r.lens[256]) {
                      (e.msg = "invalid code -- missing end-of-block"),
                        (r.mode = f);
                      break;
                    }
                    if (
                      ((r.lenbits = 9),
                      (F = { bits: r.lenbits }),
                      (M = o(c, r.lens, 0, r.nlen, r.lencode, 0, r.work, F)),
                      (r.lenbits = F.bits),
                      M)
                    ) {
                      (e.msg = "invalid literal/lengths set"), (r.mode = f);
                      break;
                    }
                    if (
                      ((r.distbits = 6),
                      (r.distcode = r.distdyn),
                      (F = { bits: r.distbits }),
                      (M = o(
                        l,
                        r.lens,
                        r.nlen,
                        r.ndist,
                        r.distcode,
                        0,
                        r.work,
                        F
                      )),
                      (r.distbits = F.bits),
                      M)
                    ) {
                      (e.msg = "invalid distances set"), (r.mode = f);
                      break;
                    }
                    if (((r.mode = 20), 6 === t)) break e;
                  case 20:
                    r.mode = 21;
                  case 21:
                    if (E >= 6 && b >= 258) {
                      (e.next_out = w),
                        (e.avail_out = b),
                        (e.next_in = A),
                        (e.avail_in = E),
                        (r.hold = v),
                        (r.bits = I),
                        a(e, T),
                        (w = e.next_out),
                        (m = e.output),
                        (b = e.avail_out),
                        (A = e.next_in),
                        (g = e.input),
                        (E = e.avail_in),
                        (v = r.hold),
                        (I = r.bits),
                        r.mode === p && (r.back = -1);
                      break;
                    }
                    for (
                      r.back = 0;
                      (B =
                        ((Q = r.lencode[v & ((1 << r.lenbits) - 1)]) >>> 16) &
                        255),
                        (D = 65535 & Q),
                        !((R = Q >>> 24) <= I);
  
                    ) {
                      if (0 === E) break e;
                      E--, (v += g[A++] << I), (I += 8);
                    }
                    if (B && !(240 & B)) {
                      for (
                        O = R, L = B, P = D;
                        (B =
                          ((Q =
                            r.lencode[P + ((v & ((1 << (O + L)) - 1)) >> O)]) >>>
                            16) &
                          255),
                          (D = 65535 & Q),
                          !(O + (R = Q >>> 24) <= I);
  
                      ) {
                        if (0 === E) break e;
                        E--, (v += g[A++] << I), (I += 8);
                      }
                      (v >>>= O), (I -= O), (r.back += O);
                    }
                    if (
                      ((v >>>= R),
                      (I -= R),
                      (r.back += R),
                      (r.length = D),
                      0 === B)
                    ) {
                      r.mode = 26;
                      break;
                    }
                    if (32 & B) {
                      (r.back = -1), (r.mode = p);
                      break;
                    }
                    if (64 & B) {
                      (e.msg = "invalid literal/length code"), (r.mode = f);
                      break;
                    }
                    (r.extra = 15 & B), (r.mode = 22);
                  case 22:
                    if (r.extra) {
                      for (H = r.extra; I < H; ) {
                        if (0 === E) break e;
                        E--, (v += g[A++] << I), (I += 8);
                      }
                      (r.length += v & ((1 << r.extra) - 1)),
                        (v >>>= r.extra),
                        (I -= r.extra),
                        (r.back += r.extra);
                    }
                    (r.was = r.length), (r.mode = 23);
                  case 23:
                    for (
                      ;
                      (B =
                        ((Q = r.distcode[v & ((1 << r.distbits) - 1)]) >>> 16) &
                        255),
                        (D = 65535 & Q),
                        !((R = Q >>> 24) <= I);
  
                    ) {
                      if (0 === E) break e;
                      E--, (v += g[A++] << I), (I += 8);
                    }
                    if (!(240 & B)) {
                      for (
                        O = R, L = B, P = D;
                        (B =
                          ((Q =
                            r.distcode[P + ((v & ((1 << (O + L)) - 1)) >> O)]) >>>
                            16) &
                          255),
                          (D = 65535 & Q),
                          !(O + (R = Q >>> 24) <= I);
  
                      ) {
                        if (0 === E) break e;
                        E--, (v += g[A++] << I), (I += 8);
                      }
                      (v >>>= O), (I -= O), (r.back += O);
                    }
                    if (((v >>>= R), (I -= R), (r.back += R), 64 & B)) {
                      (e.msg = "invalid distance code"), (r.mode = f);
                      break;
                    }
                    (r.offset = D), (r.extra = 15 & B), (r.mode = 24);
                  case 24:
                    if (r.extra) {
                      for (H = r.extra; I < H; ) {
                        if (0 === E) break e;
                        E--, (v += g[A++] << I), (I += 8);
                      }
                      (r.offset += v & ((1 << r.extra) - 1)),
                        (v >>>= r.extra),
                        (I -= r.extra),
                        (r.back += r.extra);
                    }
                    if (r.offset > r.dmax) {
                      (e.msg = "invalid distance too far back"), (r.mode = f);
                      break;
                    }
                    r.mode = 25;
                  case 25:
                    if (0 === b) break e;
                    if (((x = T - b), r.offset > x)) {
                      if ((x = r.offset - x) > r.whave && r.sane) {
                        (e.msg = "invalid distance too far back"), (r.mode = f);
                        break;
                      }
                      x > r.wnext
                        ? ((x -= r.wnext), (N = r.wsize - x))
                        : (N = r.wnext - x),
                        x > r.length && (x = r.length),
                        (k = r.window);
                    } else (k = m), (N = w - r.offset), (x = r.length);
                    x > b && (x = b), (b -= x), (r.length -= x);
                    do {
                      m[w++] = k[N++];
                    } while (--x);
                    0 === r.length && (r.mode = 21);
                    break;
                  case 26:
                    if (0 === b) break e;
                    (m[w++] = r.length), b--, (r.mode = 21);
                    break;
                  case 27:
                    if (r.wrap) {
                      for (; I < 32; ) {
                        if (0 === E) break e;
                        E--, (v |= g[A++] << I), (I += 8);
                      }
                      if (
                        ((T -= b),
                        (e.total_out += T),
                        (r.total += T),
                        T &&
                          (e.adler = r.check =
                            r.flags
                              ? n(r.check, m, T, w - T)
                              : s(r.check, m, T, w - T)),
                        (T = b),
                        (r.flags ? v : y(v)) !== r.check)
                      ) {
                        (e.msg = "incorrect data check"), (r.mode = f);
                        break;
                      }
                      (v = 0), (I = 0);
                    }
                    r.mode = 28;
                  case 28:
                    if (r.wrap && r.flags) {
                      for (; I < 32; ) {
                        if (0 === E) break e;
                        E--, (v += g[A++] << I), (I += 8);
                      }
                      if (v !== (4294967295 & r.total)) {
                        (e.msg = "incorrect length check"), (r.mode = f);
                        break;
                      }
                      (v = 0), (I = 0);
                    }
                    r.mode = 29;
                  case 29:
                    M = 1;
                    break e;
                  case f:
                    M = -3;
                    break e;
                  case 31:
                    return -4;
                  default:
                    return u;
                }
              return (
                (e.next_out = w),
                (e.avail_out = b),
                (e.next_in = A),
                (e.avail_in = E),
                (r.hold = v),
                (r.bits = I),
                (r.wsize ||
                  (T !== e.avail_out &&
                    r.mode < f &&
                    (r.mode < 27 || 4 !== t))) &&
                C(e, e.output, e.next_out, T - e.avail_out)
                  ? ((r.mode = 31), -4)
                  : ((S -= e.avail_in),
                    (T -= e.avail_out),
                    (e.total_in += S),
                    (e.total_out += T),
                    (r.total += T),
                    r.wrap &&
                      T &&
                      (e.adler = r.check =
                        r.flags
                          ? n(r.check, m, T, e.next_out - T)
                          : s(r.check, m, T, e.next_out - T)),
                    (e.data_type =
                      r.bits +
                      (r.last ? 64 : 0) +
                      (r.mode === p ? 128 : 0) +
                      (20 === r.mode || 15 === r.mode ? 256 : 0)),
                    ((0 === S && 0 === T) || 4 === t) && M === h && (M = -5),
                    M)
              );
            }),
            (t.inflateEnd = function (e) {
              if (!e || !e.state) return u;
              var t = e.state;
              return t.window && (t.window = null), (e.state = null), h;
            }),
            (t.inflateGetHeader = function (e, t) {
              var r;
              return e && e.state && 2 & (r = e.state).wrap
                ? ((r.head = t), (t.done = !1), h)
                : u;
            }),
            (t.inflateSetDictionary = function (e, t) {
              var r,
                i = t.length;
              return e && e.state
                ? 0 !== (r = e.state).wrap && 11 !== r.mode
                  ? u
                  : 11 === r.mode && s(1, t, i, 0) !== r.check
                  ? -3
                  : C(e, t, i, i)
                  ? ((r.mode = 31), -4)
                  : ((r.havedict = 1), h)
                : u;
            }),
            (t.inflateInfo = "pako inflate (from Nodeca project)");
        },
        1998: (e, t, r) => {
          "use strict";
          var i = r(9805),
            s = 15,
            n = [
              3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51,
              59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0,
            ],
            a = [
              16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19,
              19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78,
            ],
            o = [
              1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385,
              513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385,
              24577, 0, 0,
            ],
            c = [
              16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23,
              23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64,
            ];
          e.exports = function (e, t, r, l, h, u, d, p) {
            var f,
              g,
              m,
              y,
              A,
              w,
              E,
              b,
              v,
              I = p.bits,
              S = 0,
              T = 0,
              _ = 0,
              C = 0,
              x = 0,
              N = 0,
              k = 0,
              R = 0,
              B = 0,
              D = 0,
              O = null,
              L = 0,
              P = new i.Buf16(16),
              U = new i.Buf16(16),
              M = null,
              F = 0;
            for (S = 0; S <= s; S++) P[S] = 0;
            for (T = 0; T < l; T++) P[t[r + T]]++;
            for (x = I, C = s; C >= 1 && 0 === P[C]; C--);
            if ((x > C && (x = C), 0 === C))
              return (h[u++] = 20971520), (h[u++] = 20971520), (p.bits = 1), 0;
            for (_ = 1; _ < C && 0 === P[_]; _++);
            for (x < _ && (x = _), R = 1, S = 1; S <= s; S++)
              if (((R <<= 1), (R -= P[S]) < 0)) return -1;
            if (R > 0 && (0 === e || 1 !== C)) return -1;
            for (U[1] = 0, S = 1; S < s; S++) U[S + 1] = U[S] + P[S];
            for (T = 0; T < l; T++) 0 !== t[r + T] && (d[U[t[r + T]]++] = T);
            if (
              (0 === e
                ? ((O = M = d), (w = 19))
                : 1 === e
                ? ((O = n), (L -= 257), (M = a), (F -= 257), (w = 256))
                : ((O = o), (M = c), (w = -1)),
              (D = 0),
              (T = 0),
              (S = _),
              (A = u),
              (N = x),
              (k = 0),
              (m = -1),
              (y = (B = 1 << x) - 1),
              (1 === e && B > 852) || (2 === e && B > 592))
            )
              return 1;
            for (;;) {
              (E = S - k),
                d[T] < w
                  ? ((b = 0), (v = d[T]))
                  : d[T] > w
                  ? ((b = M[F + d[T]]), (v = O[L + d[T]]))
                  : ((b = 96), (v = 0)),
                (f = 1 << (S - k)),
                (_ = g = 1 << N);
              do {
                h[A + (D >> k) + (g -= f)] = (E << 24) | (b << 16) | v;
              } while (0 !== g);
              for (f = 1 << (S - 1); D & f; ) f >>= 1;
              if (
                (0 !== f ? ((D &= f - 1), (D += f)) : (D = 0), T++, 0 == --P[S])
              ) {
                if (S === C) break;
                S = t[r + d[T]];
              }
              if (S > x && (D & y) !== m) {
                for (
                  0 === k && (k = x), A += _, R = 1 << (N = S - k);
                  N + k < C && !((R -= P[N + k]) <= 0);
  
                )
                  N++, (R <<= 1);
                if (((B += 1 << N), (1 === e && B > 852) || (2 === e && B > 592)))
                  return 1;
                h[(m = D & y)] = (x << 24) | (N << 16) | (A - u);
              }
            }
            return (
              0 !== D && (h[A + D] = ((S - k) << 24) | (64 << 16)),
              (p.bits = x),
              0
            );
          };
        },
        4674: (e) => {
          "use strict";
          e.exports = {
            2: "need dictionary",
            1: "stream end",
            0: "",
            "-1": "file error",
            "-2": "stream error",
            "-3": "data error",
            "-4": "insufficient memory",
            "-5": "buffer error",
            "-6": "incompatible version",
          };
        },
        3665: (e, t, r) => {
          "use strict";
          var i = r(9805),
            s = 0,
            n = 1;
          function a(e) {
            for (var t = e.length; --t >= 0; ) e[t] = 0;
          }
          var o = 0,
            c = 29,
            l = 256,
            h = l + 1 + c,
            u = 30,
            d = 19,
            p = 2 * h + 1,
            f = 15,
            g = 16,
            m = 7,
            y = 256,
            A = 16,
            w = 17,
            E = 18,
            b = [
              0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4,
              4, 5, 5, 5, 5, 0,
            ],
            v = [
              0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9,
              10, 10, 11, 11, 12, 12, 13, 13,
            ],
            I = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7],
            S = [
              16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,
            ],
            T = new Array(2 * (h + 2));
          a(T);
          var _ = new Array(2 * u);
          a(_);
          var C = new Array(512);
          a(C);
          var x = new Array(256);
          a(x);
          var N = new Array(c);
          a(N);
          var k,
            R,
            B,
            D = new Array(u);
          function O(e, t, r, i, s) {
            (this.static_tree = e),
              (this.extra_bits = t),
              (this.extra_base = r),
              (this.elems = i),
              (this.max_length = s),
              (this.has_stree = e && e.length);
          }
          function L(e, t) {
            (this.dyn_tree = e), (this.max_code = 0), (this.stat_desc = t);
          }
          function P(e) {
            return e < 256 ? C[e] : C[256 + (e >>> 7)];
          }
          function U(e, t) {
            (e.pending_buf[e.pending++] = 255 & t),
              (e.pending_buf[e.pending++] = (t >>> 8) & 255);
          }
          function M(e, t, r) {
            e.bi_valid > g - r
              ? ((e.bi_buf |= (t << e.bi_valid) & 65535),
                U(e, e.bi_buf),
                (e.bi_buf = t >> (g - e.bi_valid)),
                (e.bi_valid += r - g))
              : ((e.bi_buf |= (t << e.bi_valid) & 65535), (e.bi_valid += r));
          }
          function F(e, t, r) {
            M(e, r[2 * t], r[2 * t + 1]);
          }
          function H(e, t) {
            var r = 0;
            do {
              (r |= 1 & e), (e >>>= 1), (r <<= 1);
            } while (--t > 0);
            return r >>> 1;
          }
          function Q(e, t, r) {
            var i,
              s,
              n = new Array(f + 1),
              a = 0;
            for (i = 1; i <= f; i++) n[i] = a = (a + r[i - 1]) << 1;
            for (s = 0; s <= t; s++) {
              var o = e[2 * s + 1];
              0 !== o && (e[2 * s] = H(n[o]++, o));
            }
          }
          function V(e) {
            var t;
            for (t = 0; t < h; t++) e.dyn_ltree[2 * t] = 0;
            for (t = 0; t < u; t++) e.dyn_dtree[2 * t] = 0;
            for (t = 0; t < d; t++) e.bl_tree[2 * t] = 0;
            (e.dyn_ltree[2 * y] = 1),
              (e.opt_len = e.static_len = 0),
              (e.last_lit = e.matches = 0);
          }
          function z(e) {
            e.bi_valid > 8
              ? U(e, e.bi_buf)
              : e.bi_valid > 0 && (e.pending_buf[e.pending++] = e.bi_buf),
              (e.bi_buf = 0),
              (e.bi_valid = 0);
          }
          function q(e, t, r, i) {
            var s = 2 * t,
              n = 2 * r;
            return e[s] < e[n] || (e[s] === e[n] && i[t] <= i[r]);
          }
          function G(e, t, r) {
            for (
              var i = e.heap[r], s = r << 1;
              s <= e.heap_len &&
              (s < e.heap_len && q(t, e.heap[s + 1], e.heap[s], e.depth) && s++,
              !q(t, i, e.heap[s], e.depth));
  
            )
              (e.heap[r] = e.heap[s]), (r = s), (s <<= 1);
            e.heap[r] = i;
          }
          function j(e, t, r) {
            var i,
              s,
              n,
              a,
              o = 0;
            if (0 !== e.last_lit)
              do {
                (i =
                  (e.pending_buf[e.d_buf + 2 * o] << 8) |
                  e.pending_buf[e.d_buf + 2 * o + 1]),
                  (s = e.pending_buf[e.l_buf + o]),
                  o++,
                  0 === i
                    ? F(e, s, t)
                    : (F(e, (n = x[s]) + l + 1, t),
                      0 !== (a = b[n]) && M(e, (s -= N[n]), a),
                      F(e, (n = P(--i)), r),
                      0 !== (a = v[n]) && M(e, (i -= D[n]), a));
              } while (o < e.last_lit);
            F(e, y, t);
          }
          function W(e, t) {
            var r,
              i,
              s,
              n = t.dyn_tree,
              a = t.stat_desc.static_tree,
              o = t.stat_desc.has_stree,
              c = t.stat_desc.elems,
              l = -1;
            for (e.heap_len = 0, e.heap_max = p, r = 0; r < c; r++)
              0 !== n[2 * r]
                ? ((e.heap[++e.heap_len] = l = r), (e.depth[r] = 0))
                : (n[2 * r + 1] = 0);
            for (; e.heap_len < 2; )
              (n[2 * (s = e.heap[++e.heap_len] = l < 2 ? ++l : 0)] = 1),
                (e.depth[s] = 0),
                e.opt_len--,
                o && (e.static_len -= a[2 * s + 1]);
            for (t.max_code = l, r = e.heap_len >> 1; r >= 1; r--) G(e, n, r);
            s = c;
            do {
              (r = e.heap[1]),
                (e.heap[1] = e.heap[e.heap_len--]),
                G(e, n, 1),
                (i = e.heap[1]),
                (e.heap[--e.heap_max] = r),
                (e.heap[--e.heap_max] = i),
                (n[2 * s] = n[2 * r] + n[2 * i]),
                (e.depth[s] =
                  (e.depth[r] >= e.depth[i] ? e.depth[r] : e.depth[i]) + 1),
                (n[2 * r + 1] = n[2 * i + 1] = s),
                (e.heap[1] = s++),
                G(e, n, 1);
            } while (e.heap_len >= 2);
            (e.heap[--e.heap_max] = e.heap[1]),
              (function (e, t) {
                var r,
                  i,
                  s,
                  n,
                  a,
                  o,
                  c = t.dyn_tree,
                  l = t.max_code,
                  h = t.stat_desc.static_tree,
                  u = t.stat_desc.has_stree,
                  d = t.stat_desc.extra_bits,
                  g = t.stat_desc.extra_base,
                  m = t.stat_desc.max_length,
                  y = 0;
                for (n = 0; n <= f; n++) e.bl_count[n] = 0;
                for (
                  c[2 * e.heap[e.heap_max] + 1] = 0, r = e.heap_max + 1;
                  r < p;
                  r++
                )
                  (n = c[2 * c[2 * (i = e.heap[r]) + 1] + 1] + 1) > m &&
                    ((n = m), y++),
                    (c[2 * i + 1] = n),
                    i > l ||
                      (e.bl_count[n]++,
                      (a = 0),
                      i >= g && (a = d[i - g]),
                      (o = c[2 * i]),
                      (e.opt_len += o * (n + a)),
                      u && (e.static_len += o * (h[2 * i + 1] + a)));
                if (0 !== y) {
                  do {
                    for (n = m - 1; 0 === e.bl_count[n]; ) n--;
                    e.bl_count[n]--,
                      (e.bl_count[n + 1] += 2),
                      e.bl_count[m]--,
                      (y -= 2);
                  } while (y > 0);
                  for (n = m; 0 !== n; n--)
                    for (i = e.bl_count[n]; 0 !== i; )
                      (s = e.heap[--r]) > l ||
                        (c[2 * s + 1] !== n &&
                          ((e.opt_len += (n - c[2 * s + 1]) * c[2 * s]),
                          (c[2 * s + 1] = n)),
                        i--);
                }
              })(e, t),
              Q(n, l, e.bl_count);
          }
          function Y(e, t, r) {
            var i,
              s,
              n = -1,
              a = t[1],
              o = 0,
              c = 7,
              l = 4;
            for (
              0 === a && ((c = 138), (l = 3)), t[2 * (r + 1) + 1] = 65535, i = 0;
              i <= r;
              i++
            )
              (s = a),
                (a = t[2 * (i + 1) + 1]),
                (++o < c && s === a) ||
                  (o < l
                    ? (e.bl_tree[2 * s] += o)
                    : 0 !== s
                    ? (s !== n && e.bl_tree[2 * s]++, e.bl_tree[2 * A]++)
                    : o <= 10
                    ? e.bl_tree[2 * w]++
                    : e.bl_tree[2 * E]++,
                  (o = 0),
                  (n = s),
                  0 === a
                    ? ((c = 138), (l = 3))
                    : s === a
                    ? ((c = 6), (l = 3))
                    : ((c = 7), (l = 4)));
          }
          function X(e, t, r) {
            var i,
              s,
              n = -1,
              a = t[1],
              o = 0,
              c = 7,
              l = 4;
            for (0 === a && ((c = 138), (l = 3)), i = 0; i <= r; i++)
              if (((s = a), (a = t[2 * (i + 1) + 1]), !(++o < c && s === a))) {
                if (o < l)
                  do {
                    F(e, s, e.bl_tree);
                  } while (0 != --o);
                else
                  0 !== s
                    ? (s !== n && (F(e, s, e.bl_tree), o--),
                      F(e, A, e.bl_tree),
                      M(e, o - 3, 2))
                    : o <= 10
                    ? (F(e, w, e.bl_tree), M(e, o - 3, 3))
                    : (F(e, E, e.bl_tree), M(e, o - 11, 7));
                (o = 0),
                  (n = s),
                  0 === a
                    ? ((c = 138), (l = 3))
                    : s === a
                    ? ((c = 6), (l = 3))
                    : ((c = 7), (l = 4));
              }
          }
          a(D);
          var K = !1;
          function J(e, t, r, s) {
            M(e, (o << 1) + (s ? 1 : 0), 3),
              (function (e, t, r, s) {
                z(e),
                  s && (U(e, r), U(e, ~r)),
                  i.arraySet(e.pending_buf, e.window, t, r, e.pending),
                  (e.pending += r);
              })(e, t, r, !0);
          }
          (t._tr_init = function (e) {
            K ||
              (!(function () {
                var e,
                  t,
                  r,
                  i,
                  s,
                  n = new Array(f + 1);
                for (r = 0, i = 0; i < c - 1; i++)
                  for (N[i] = r, e = 0; e < 1 << b[i]; e++) x[r++] = i;
                for (x[r - 1] = i, s = 0, i = 0; i < 16; i++)
                  for (D[i] = s, e = 0; e < 1 << v[i]; e++) C[s++] = i;
                for (s >>= 7; i < u; i++)
                  for (D[i] = s << 7, e = 0; e < 1 << (v[i] - 7); e++)
                    C[256 + s++] = i;
                for (t = 0; t <= f; t++) n[t] = 0;
                for (e = 0; e <= 143; ) (T[2 * e + 1] = 8), e++, n[8]++;
                for (; e <= 255; ) (T[2 * e + 1] = 9), e++, n[9]++;
                for (; e <= 279; ) (T[2 * e + 1] = 7), e++, n[7]++;
                for (; e <= 287; ) (T[2 * e + 1] = 8), e++, n[8]++;
                for (Q(T, h + 1, n), e = 0; e < u; e++)
                  (_[2 * e + 1] = 5), (_[2 * e] = H(e, 5));
                (k = new O(T, b, l + 1, h, f)),
                  (R = new O(_, v, 0, u, f)),
                  (B = new O(new Array(0), I, 0, d, m));
              })(),
              (K = !0)),
              (e.l_desc = new L(e.dyn_ltree, k)),
              (e.d_desc = new L(e.dyn_dtree, R)),
              (e.bl_desc = new L(e.bl_tree, B)),
              (e.bi_buf = 0),
              (e.bi_valid = 0),
              V(e);
          }),
            (t._tr_stored_block = J),
            (t._tr_flush_block = function (e, t, r, i) {
              var a,
                o,
                c = 0;
              e.level > 0
                ? (2 === e.strm.data_type &&
                    (e.strm.data_type = (function (e) {
                      var t,
                        r = 4093624447;
                      for (t = 0; t <= 31; t++, r >>>= 1)
                        if (1 & r && 0 !== e.dyn_ltree[2 * t]) return s;
                      if (
                        0 !== e.dyn_ltree[18] ||
                        0 !== e.dyn_ltree[20] ||
                        0 !== e.dyn_ltree[26]
                      )
                        return n;
                      for (t = 32; t < l; t++)
                        if (0 !== e.dyn_ltree[2 * t]) return n;
                      return s;
                    })(e)),
                  W(e, e.l_desc),
                  W(e, e.d_desc),
                  (c = (function (e) {
                    var t;
                    for (
                      Y(e, e.dyn_ltree, e.l_desc.max_code),
                        Y(e, e.dyn_dtree, e.d_desc.max_code),
                        W(e, e.bl_desc),
                        t = d - 1;
                      t >= 3 && 0 === e.bl_tree[2 * S[t] + 1];
                      t--
                    );
                    return (e.opt_len += 3 * (t + 1) + 5 + 5 + 4), t;
                  })(e)),
                  (a = (e.opt_len + 3 + 7) >>> 3),
                  (o = (e.static_len + 3 + 7) >>> 3) <= a && (a = o))
                : (a = o = r + 5),
                r + 4 <= a && -1 !== t
                  ? J(e, t, r, i)
                  : 4 === e.strategy || o === a
                  ? (M(e, 2 + (i ? 1 : 0), 3), j(e, T, _))
                  : (M(e, 4 + (i ? 1 : 0), 3),
                    (function (e, t, r, i) {
                      var s;
                      for (
                        M(e, t - 257, 5), M(e, r - 1, 5), M(e, i - 4, 4), s = 0;
                        s < i;
                        s++
                      )
                        M(e, e.bl_tree[2 * S[s] + 1], 3);
                      X(e, e.dyn_ltree, t - 1), X(e, e.dyn_dtree, r - 1);
                    })(e, e.l_desc.max_code + 1, e.d_desc.max_code + 1, c + 1),
                    j(e, e.dyn_ltree, e.dyn_dtree)),
                V(e),
                i && z(e);
            }),
            (t._tr_tally = function (e, t, r) {
              return (
                (e.pending_buf[e.d_buf + 2 * e.last_lit] = (t >>> 8) & 255),
                (e.pending_buf[e.d_buf + 2 * e.last_lit + 1] = 255 & t),
                (e.pending_buf[e.l_buf + e.last_lit] = 255 & r),
                e.last_lit++,
                0 === t
                  ? e.dyn_ltree[2 * r]++
                  : (e.matches++,
                    t--,
                    e.dyn_ltree[2 * (x[r] + l + 1)]++,
                    e.dyn_dtree[2 * P(t)]++),
                e.last_lit === e.lit_bufsize - 1
              );
            }),
            (t._tr_align = function (e) {
              M(e, 2, 3),
                F(e, y, T),
                (function (e) {
                  16 === e.bi_valid
                    ? (U(e, e.bi_buf), (e.bi_buf = 0), (e.bi_valid = 0))
                    : e.bi_valid >= 8 &&
                      ((e.pending_buf[e.pending++] = 255 & e.bi_buf),
                      (e.bi_buf >>= 8),
                      (e.bi_valid -= 8));
                })(e);
            });
        },
        4442: (e) => {
          "use strict";
          e.exports = function () {
            (this.input = null),
              (this.next_in = 0),
              (this.avail_in = 0),
              (this.total_in = 0),
              (this.output = null),
              (this.next_out = 0),
              (this.avail_out = 0),
              (this.total_out = 0),
              (this.msg = ""),
              (this.state = null),
              (this.data_type = 2),
              (this.adler = 0);
          };
        },
        5606: (e) => {
          var t,
            r,
            i = (e.exports = {});
          function s() {
            throw new Error("setTimeout has not been defined");
          }
          function n() {
            throw new Error("clearTimeout has not been defined");
          }
          function a(e) {
            if (t === setTimeout) return setTimeout(e, 0);
            if ((t === s || !t) && setTimeout)
              return (t = setTimeout), setTimeout(e, 0);
            try {
              return t(e, 0);
            } catch (r) {
              try {
                return t.call(null, e, 0);
              } catch (r) {
                return t.call(this, e, 0);
              }
            }
          }
          !(function () {
            try {
              t = "function" == typeof setTimeout ? setTimeout : s;
            } catch (e) {
              t = s;
            }
            try {
              r = "function" == typeof clearTimeout ? clearTimeout : n;
            } catch (e) {
              r = n;
            }
          })();
          var o,
            c = [],
            l = !1,
            h = -1;
          function u() {
            l &&
              o &&
              ((l = !1),
              o.length ? (c = o.concat(c)) : (h = -1),
              c.length && d());
          }
          function d() {
            if (!l) {
              var e = a(u);
              l = !0;
              for (var t = c.length; t; ) {
                for (o = c, c = []; ++h < t; ) o && o[h].run();
                (h = -1), (t = c.length);
              }
              (o = null),
                (l = !1),
                (function (e) {
                  if (r === clearTimeout) return clearTimeout(e);
                  if ((r === n || !r) && clearTimeout)
                    return (r = clearTimeout), clearTimeout(e);
                  try {
                    return r(e);
                  } catch (t) {
                    try {
                      return r.call(null, e);
                    } catch (t) {
                      return r.call(this, e);
                    }
                  }
                })(e);
            }
          }
          function p(e, t) {
            (this.fun = e), (this.array = t);
          }
          function f() {}
          (i.nextTick = function (e) {
            var t = new Array(arguments.length - 1);
            if (arguments.length > 1)
              for (var r = 1; r < arguments.length; r++) t[r - 1] = arguments[r];
            c.push(new p(e, t)), 1 !== c.length || l || a(d);
          }),
            (p.prototype.run = function () {
              this.fun.apply(null, this.array);
            }),
            (i.title = "browser"),
            (i.browser = !0),
            (i.env = {}),
            (i.argv = []),
            (i.version = ""),
            (i.versions = {}),
            (i.on = f),
            (i.addListener = f),
            (i.once = f),
            (i.off = f),
            (i.removeListener = f),
            (i.removeAllListeners = f),
            (i.emit = f),
            (i.prependListener = f),
            (i.prependOnceListener = f),
            (i.listeners = function (e) {
              return [];
            }),
            (i.binding = function (e) {
              throw new Error("process.binding is not supported");
            }),
            (i.cwd = function () {
              return "/";
            }),
            (i.chdir = function (e) {
              throw new Error("process.chdir is not supported");
            }),
            (i.umask = function () {
              return 0;
            });
        },
        152: (e, t, r) => {
          "use strict";
          var i = r(8287).Buffer;
          class s {
            static isArrayBuffer(e) {
              return "[object ArrayBuffer]" === Object.prototype.toString.call(e);
            }
            static toArrayBuffer(e) {
              return this.isArrayBuffer(e)
                ? e
                : e.byteLength === e.buffer.byteLength ||
                  (0 === e.byteOffset && e.byteLength === e.buffer.byteLength)
                ? e.buffer
                : this.toUint8Array(e.buffer).slice(
                    e.byteOffset,
                    e.byteOffset + e.byteLength
                  ).buffer;
            }
            static toUint8Array(e) {
              return this.toView(e, Uint8Array);
            }
            static toView(e, t) {
              if (e.constructor === t) return e;
              if (this.isArrayBuffer(e)) return new t(e);
              if (this.isArrayBufferView(e))
                return new t(e.buffer, e.byteOffset, e.byteLength);
              throw new TypeError(
                "The provided value is not of type '(ArrayBuffer or ArrayBufferView)'"
              );
            }
            static isBufferSource(e) {
              return this.isArrayBufferView(e) || this.isArrayBuffer(e);
            }
            static isArrayBufferView(e) {
              return ArrayBuffer.isView(e) || (e && this.isArrayBuffer(e.buffer));
            }
            static isEqual(e, t) {
              const r = s.toUint8Array(e),
                i = s.toUint8Array(t);
              if (r.length !== i.byteLength) return !1;
              for (let e = 0; e < r.length; e++) if (r[e] !== i[e]) return !1;
              return !0;
            }
            static concat(...e) {
              let t;
              t =
                !Array.isArray(e[0]) || e[1] instanceof Function
                  ? Array.isArray(e[0]) && e[1] instanceof Function
                    ? e[0]
                    : e[e.length - 1] instanceof Function
                    ? e.slice(0, e.length - 1)
                    : e
                  : e[0];
              let r = 0;
              for (const e of t) r += e.byteLength;
              const i = new Uint8Array(r);
              let s = 0;
              for (const e of t) {
                const t = this.toUint8Array(e);
                i.set(t, s), (s += t.length);
              }
              return e[e.length - 1] instanceof Function
                ? this.toView(i, e[e.length - 1])
                : i.buffer;
            }
          }
          const n = "string",
            a = /^[0-9a-f]+$/i,
            o =
              /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/,
            c = /^[a-zA-Z0-9-_]+$/;
          class l {
            static fromString(e) {
              const t = unescape(encodeURIComponent(e)),
                r = new Uint8Array(t.length);
              for (let e = 0; e < t.length; e++) r[e] = t.charCodeAt(e);
              return r.buffer;
            }
            static toString(e) {
              const t = s.toUint8Array(e);
              let r = "";
              for (let e = 0; e < t.length; e++) r += String.fromCharCode(t[e]);
              return decodeURIComponent(escape(r));
            }
          }
          class h {
            static toString(e, t = !1) {
              const r = s.toArrayBuffer(e),
                i = new DataView(r);
              let n = "";
              for (let e = 0; e < r.byteLength; e += 2) {
                const r = i.getUint16(e, t);
                n += String.fromCharCode(r);
              }
              return n;
            }
            static fromString(e, t = !1) {
              const r = new ArrayBuffer(2 * e.length),
                i = new DataView(r);
              for (let r = 0; r < e.length; r++)
                i.setUint16(2 * r, e.charCodeAt(r), t);
              return r;
            }
          }
          class u {
            static isHex(e) {
              return typeof e === n && a.test(e);
            }
            static isBase64(e) {
              return typeof e === n && o.test(e);
            }
            static isBase64Url(e) {
              return typeof e === n && c.test(e);
            }
            static ToString(e, t = "utf8") {
              const r = s.toUint8Array(e);
              switch (t.toLowerCase()) {
                case "utf8":
                  return this.ToUtf8String(r);
                case "binary":
                  return this.ToBinary(r);
                case "hex":
                  return this.ToHex(r);
                case "base64":
                  return this.ToBase64(r);
                case "base64url":
                  return this.ToBase64Url(r);
                case "utf16le":
                  return h.toString(r, !0);
                case "utf16":
                case "utf16be":
                  return h.toString(r);
                default:
                  throw new Error(`Unknown type of encoding '${t}'`);
              }
            }
            static FromString(e, t = "utf8") {
              if (!e) return new ArrayBuffer(0);
              switch (t.toLowerCase()) {
                case "utf8":
                  return this.FromUtf8String(e);
                case "binary":
                  return this.FromBinary(e);
                case "hex":
                  return this.FromHex(e);
                case "base64":
                  return this.FromBase64(e);
                case "base64url":
                  return this.FromBase64Url(e);
                case "utf16le":
                  return h.fromString(e, !0);
                case "utf16":
                case "utf16be":
                  return h.fromString(e);
                default:
                  throw new Error(`Unknown type of encoding '${t}'`);
              }
            }
            static ToBase64(e) {
              const t = s.toUint8Array(e);
              if ("undefined" != typeof btoa) {
                const e = this.ToString(t, "binary");
                return btoa(e);
              }
              return i.from(t).toString("base64");
            }
            static FromBase64(e) {
              const t = this.formatString(e);
              if (!t) return new ArrayBuffer(0);
              if (!u.isBase64(t))
                throw new TypeError(
                  "Argument 'base64Text' is not Base64 encoded"
                );
              return "undefined" != typeof atob
                ? this.FromBinary(atob(t))
                : new Uint8Array(i.from(t, "base64")).buffer;
            }
            static FromBase64Url(e) {
              const t = this.formatString(e);
              if (!t) return new ArrayBuffer(0);
              if (!u.isBase64Url(t))
                throw new TypeError(
                  "Argument 'base64url' is not Base64Url encoded"
                );
              return this.FromBase64(
                this.Base64Padding(t.replace(/\-/g, "+").replace(/\_/g, "/"))
              );
            }
            static ToBase64Url(e) {
              return this.ToBase64(e)
                .replace(/\+/g, "-")
                .replace(/\//g, "_")
                .replace(/\=/g, "");
            }
            static FromUtf8String(e, t = u.DEFAULT_UTF8_ENCODING) {
              switch (t) {
                case "ascii":
                  return this.FromBinary(e);
                case "utf8":
                  return l.fromString(e);
                case "utf16":
                case "utf16be":
                  return h.fromString(e);
                case "utf16le":
                case "usc2":
                  return h.fromString(e, !0);
                default:
                  throw new Error(`Unknown type of encoding '${t}'`);
              }
            }
            static ToUtf8String(e, t = u.DEFAULT_UTF8_ENCODING) {
              switch (t) {
                case "ascii":
                  return this.ToBinary(e);
                case "utf8":
                  return l.toString(e);
                case "utf16":
                case "utf16be":
                  return h.toString(e);
                case "utf16le":
                case "usc2":
                  return h.toString(e, !0);
                default:
                  throw new Error(`Unknown type of encoding '${t}'`);
              }
            }
            static FromBinary(e) {
              const t = e.length,
                r = new Uint8Array(t);
              for (let i = 0; i < t; i++) r[i] = e.charCodeAt(i);
              return r.buffer;
            }
            static ToBinary(e) {
              const t = s.toUint8Array(e);
              let r = "";
              for (let e = 0; e < t.length; e++) r += String.fromCharCode(t[e]);
              return r;
            }
            static ToHex(e) {
              const t = s.toUint8Array(e);
              let r = "";
              const i = t.length;
              for (let e = 0; e < i; e++) {
                const i = t[e];
                i < 16 && (r += "0"), (r += i.toString(16));
              }
              return r;
            }
            static FromHex(e) {
              let t = this.formatString(e);
              if (!t) return new ArrayBuffer(0);
              if (!u.isHex(t))
                throw new TypeError("Argument 'hexString' is not HEX encoded");
              t.length % 2 && (t = `0${t}`);
              const r = new Uint8Array(t.length / 2);
              for (let e = 0; e < t.length; e += 2) {
                const i = t.slice(e, e + 2);
                r[e / 2] = parseInt(i, 16);
              }
              return r.buffer;
            }
            static ToUtf16String(e, t = !1) {
              return h.toString(e, t);
            }
            static FromUtf16String(e, t = !1) {
              return h.fromString(e, t);
            }
            static Base64Padding(e) {
              const t = 4 - (e.length % 4);
              if (t < 4) for (let r = 0; r < t; r++) e += "=";
              return e;
            }
            static formatString(e) {
              return (null == e ? void 0 : e.replace(/[\n\r\t ]/g, "")) || "";
            }
          }
          (u.DEFAULT_UTF8_ENCODING = "utf8"),
            (t._H = s),
            (t.U$ = u),
            (t.kg = function (...e) {
              const t = e.map((e) => e.byteLength).reduce((e, t) => e + t),
                r = new Uint8Array(t);
              let i = 0;
              return (
                e
                  .map((e) => new Uint8Array(e))
                  .forEach((e) => {
                    for (const t of e) r[i++] = t;
                  }),
                r.buffer
              );
            }),
            (t.n4 = function (e, t) {
              if (!e || !t) return !1;
              if (e.byteLength !== t.byteLength) return !1;
              const r = new Uint8Array(e),
                i = new Uint8Array(t);
              for (let t = 0; t < e.byteLength; t++) if (r[t] !== i[t]) return !1;
              return !0;
            });
        },
        6048: (e) => {
          "use strict";
          var t = {};
          function r(e, r, i) {
            i || (i = Error);
            var s = (function (e) {
              var t, i;
              function s(t, i, s) {
                return (
                  e.call(
                    this,
                    (function (e, t, i) {
                      return "string" == typeof r ? r : r(e, t, i);
                    })(t, i, s)
                  ) || this
                );
              }
              return (
                (i = e),
                ((t = s).prototype = Object.create(i.prototype)),
                (t.prototype.constructor = t),
                (t.__proto__ = i),
                s
              );
            })(i);
            (s.prototype.name = i.name), (s.prototype.code = e), (t[e] = s);
          }
          function i(e, t) {
            if (Array.isArray(e)) {
              var r = e.length;
              return (
                (e = e.map(function (e) {
                  return String(e);
                })),
                r > 2
                  ? "one of "
                      .concat(t, " ")
                      .concat(e.slice(0, r - 1).join(", "), ", or ") + e[r - 1]
                  : 2 === r
                  ? "one of ".concat(t, " ").concat(e[0], " or ").concat(e[1])
                  : "of ".concat(t, " ").concat(e[0])
              );
            }
            return "of ".concat(t, " ").concat(String(e));
          }
          r(
            "ERR_INVALID_OPT_VALUE",
            function (e, t) {
              return 'The value "' + t + '" is invalid for option "' + e + '"';
            },
            TypeError
          ),
            r(
              "ERR_INVALID_ARG_TYPE",
              function (e, t, r) {
                var s, n, a, o;
                if (
                  ("string" == typeof t &&
                  ((n = "not "), t.substr(!a || a < 0 ? 0 : +a, n.length) === n)
                    ? ((s = "must not be"), (t = t.replace(/^not /, "")))
                    : (s = "must be"),
                  (function (e, t, r) {
                    return (
                      (void 0 === r || r > e.length) && (r = e.length),
                      e.substring(r - t.length, r) === t
                    );
                  })(e, " argument"))
                )
                  o = "The ".concat(e, " ").concat(s, " ").concat(i(t, "type"));
                else {
                  var c = (function (e, t, r) {
                    return (
                      "number" != typeof r && (r = 0),
                      !(r + t.length > e.length) && -1 !== e.indexOf(t, r)
                    );
                  })(e, ".")
                    ? "property"
                    : "argument";
                  o = 'The "'
                    .concat(e, '" ')
                    .concat(c, " ")
                    .concat(s, " ")
                    .concat(i(t, "type"));
                }
                return (o += ". Received type ".concat(typeof r));
              },
              TypeError
            ),
            r("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"),
            r("ERR_METHOD_NOT_IMPLEMENTED", function (e) {
              return "The " + e + " method is not implemented";
            }),
            r("ERR_STREAM_PREMATURE_CLOSE", "Premature close"),
            r("ERR_STREAM_DESTROYED", function (e) {
              return "Cannot call " + e + " after a stream was destroyed";
            }),
            r("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"),
            r("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"),
            r("ERR_STREAM_WRITE_AFTER_END", "write after end"),
            r(
              "ERR_STREAM_NULL_VALUES",
              "May not write null values to stream",
              TypeError
            ),
            r(
              "ERR_UNKNOWN_ENCODING",
              function (e) {
                return "Unknown encoding: " + e;
              },
              TypeError
            ),
            r(
              "ERR_STREAM_UNSHIFT_AFTER_END_EVENT",
              "stream.unshift() after end event"
            ),
            (e.exports.F = t);
        },
        5382: (e, t, r) => {
          "use strict";
          var i = r(5606),
            s =
              Object.keys ||
              function (e) {
                var t = [];
                for (var r in e) t.push(r);
                return t;
              };
          e.exports = h;
          var n = r(5412),
            a = r(6708);
          r(6698)(h, n);
          for (var o = s(a.prototype), c = 0; c < o.length; c++) {
            var l = o[c];
            h.prototype[l] || (h.prototype[l] = a.prototype[l]);
          }
          function h(e) {
            if (!(this instanceof h)) return new h(e);
            n.call(this, e),
              a.call(this, e),
              (this.allowHalfOpen = !0),
              e &&
                (!1 === e.readable && (this.readable = !1),
                !1 === e.writable && (this.writable = !1),
                !1 === e.allowHalfOpen &&
                  ((this.allowHalfOpen = !1), this.once("end", u)));
          }
          function u() {
            this._writableState.ended || i.nextTick(d, this);
          }
          function d(e) {
            e.end();
          }
          Object.defineProperty(h.prototype, "writableHighWaterMark", {
            enumerable: !1,
            get: function () {
              return this._writableState.highWaterMark;
            },
          }),
            Object.defineProperty(h.prototype, "writableBuffer", {
              enumerable: !1,
              get: function () {
                return this._writableState && this._writableState.getBuffer();
              },
            }),
            Object.defineProperty(h.prototype, "writableLength", {
              enumerable: !1,
              get: function () {
                return this._writableState.length;
              },
            }),
            Object.defineProperty(h.prototype, "destroyed", {
              enumerable: !1,
              get: function () {
                return (
                  void 0 !== this._readableState &&
                  void 0 !== this._writableState &&
                  this._readableState.destroyed &&
                  this._writableState.destroyed
                );
              },
              set: function (e) {
                void 0 !== this._readableState &&
                  void 0 !== this._writableState &&
                  ((this._readableState.destroyed = e),
                  (this._writableState.destroyed = e));
              },
            });
        },
        3600: (e, t, r) => {
          "use strict";
          e.exports = s;
          var i = r(4610);
          function s(e) {
            if (!(this instanceof s)) return new s(e);
            i.call(this, e);
          }
          r(6698)(s, i),
            (s.prototype._transform = function (e, t, r) {
              r(null, e);
            });
        },
        5412: (e, t, r) => {
          "use strict";
          var i,
            s = r(5606);
          (e.exports = T), (T.ReadableState = S);
          r(7007).EventEmitter;
          var n = function (e, t) {
              return e.listeners(t).length;
            },
            a = r(345),
            o = r(8287).Buffer,
            c =
              (void 0 !== r.g
                ? r.g
                : "undefined" != typeof window
                ? window
                : "undefined" != typeof self
                ? self
                : {}
              ).Uint8Array || function () {};
          var l,
            h = r(9838);
          l = h && h.debuglog ? h.debuglog("stream") : function () {};
          var u,
            d,
            p,
            f = r(2726),
            g = r(5896),
            m = r(5291).getHighWaterMark,
            y = r(6048).F,
            A = y.ERR_INVALID_ARG_TYPE,
            w = y.ERR_STREAM_PUSH_AFTER_EOF,
            E = y.ERR_METHOD_NOT_IMPLEMENTED,
            b = y.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
          r(6698)(T, a);
          var v = g.errorOrDestroy,
            I = ["error", "close", "destroy", "pause", "resume"];
          function S(e, t, s) {
            (i = i || r(5382)),
              (e = e || {}),
              "boolean" != typeof s && (s = t instanceof i),
              (this.objectMode = !!e.objectMode),
              s && (this.objectMode = this.objectMode || !!e.readableObjectMode),
              (this.highWaterMark = m(this, e, "readableHighWaterMark", s)),
              (this.buffer = new f()),
              (this.length = 0),
              (this.pipes = null),
              (this.pipesCount = 0),
              (this.flowing = null),
              (this.ended = !1),
              (this.endEmitted = !1),
              (this.reading = !1),
              (this.sync = !0),
              (this.needReadable = !1),
              (this.emittedReadable = !1),
              (this.readableListening = !1),
              (this.resumeScheduled = !1),
              (this.paused = !0),
              (this.emitClose = !1 !== e.emitClose),
              (this.autoDestroy = !!e.autoDestroy),
              (this.destroyed = !1),
              (this.defaultEncoding = e.defaultEncoding || "utf8"),
              (this.awaitDrain = 0),
              (this.readingMore = !1),
              (this.decoder = null),
              (this.encoding = null),
              e.encoding &&
                (u || (u = r(3141).I),
                (this.decoder = new u(e.encoding)),
                (this.encoding = e.encoding));
          }
          function T(e) {
            if (((i = i || r(5382)), !(this instanceof T))) return new T(e);
            var t = this instanceof i;
            (this._readableState = new S(e, this, t)),
              (this.readable = !0),
              e &&
                ("function" == typeof e.read && (this._read = e.read),
                "function" == typeof e.destroy && (this._destroy = e.destroy)),
              a.call(this);
          }
          function _(e, t, r, i, s) {
            l("readableAddChunk", t);
            var n,
              a = e._readableState;
            if (null === t)
              (a.reading = !1),
                (function (e, t) {
                  if ((l("onEofChunk"), t.ended)) return;
                  if (t.decoder) {
                    var r = t.decoder.end();
                    r &&
                      r.length &&
                      (t.buffer.push(r),
                      (t.length += t.objectMode ? 1 : r.length));
                  }
                  (t.ended = !0),
                    t.sync
                      ? k(e)
                      : ((t.needReadable = !1),
                        t.emittedReadable || ((t.emittedReadable = !0), R(e)));
                })(e, a);
            else if (
              (s ||
                (n = (function (e, t) {
                  var r;
                  (i = t),
                    o.isBuffer(i) ||
                      i instanceof c ||
                      "string" == typeof t ||
                      void 0 === t ||
                      e.objectMode ||
                      (r = new A("chunk", ["string", "Buffer", "Uint8Array"], t));
                  var i;
                  return r;
                })(a, t)),
              n)
            )
              v(e, n);
            else if (a.objectMode || (t && t.length > 0))
              if (
                ("string" == typeof t ||
                  a.objectMode ||
                  Object.getPrototypeOf(t) === o.prototype ||
                  (t = (function (e) {
                    return o.from(e);
                  })(t)),
                i)
              )
                a.endEmitted ? v(e, new b()) : C(e, a, t, !0);
              else if (a.ended) v(e, new w());
              else {
                if (a.destroyed) return !1;
                (a.reading = !1),
                  a.decoder && !r
                    ? ((t = a.decoder.write(t)),
                      a.objectMode || 0 !== t.length ? C(e, a, t, !1) : B(e, a))
                    : C(e, a, t, !1);
              }
            else i || ((a.reading = !1), B(e, a));
            return !a.ended && (a.length < a.highWaterMark || 0 === a.length);
          }
          function C(e, t, r, i) {
            t.flowing && 0 === t.length && !t.sync
              ? ((t.awaitDrain = 0), e.emit("data", r))
              : ((t.length += t.objectMode ? 1 : r.length),
                i ? t.buffer.unshift(r) : t.buffer.push(r),
                t.needReadable && k(e)),
              B(e, t);
          }
          Object.defineProperty(T.prototype, "destroyed", {
            enumerable: !1,
            get: function () {
              return (
                void 0 !== this._readableState && this._readableState.destroyed
              );
            },
            set: function (e) {
              this._readableState && (this._readableState.destroyed = e);
            },
          }),
            (T.prototype.destroy = g.destroy),
            (T.prototype._undestroy = g.undestroy),
            (T.prototype._destroy = function (e, t) {
              t(e);
            }),
            (T.prototype.push = function (e, t) {
              var r,
                i = this._readableState;
              return (
                i.objectMode
                  ? (r = !0)
                  : "string" == typeof e &&
                    ((t = t || i.defaultEncoding) !== i.encoding &&
                      ((e = o.from(e, t)), (t = "")),
                    (r = !0)),
                _(this, e, t, !1, r)
              );
            }),
            (T.prototype.unshift = function (e) {
              return _(this, e, null, !0, !1);
            }),
            (T.prototype.isPaused = function () {
              return !1 === this._readableState.flowing;
            }),
            (T.prototype.setEncoding = function (e) {
              u || (u = r(3141).I);
              var t = new u(e);
              (this._readableState.decoder = t),
                (this._readableState.encoding =
                  this._readableState.decoder.encoding);
              for (var i = this._readableState.buffer.head, s = ""; null !== i; )
                (s += t.write(i.data)), (i = i.next);
              return (
                this._readableState.buffer.clear(),
                "" !== s && this._readableState.buffer.push(s),
                (this._readableState.length = s.length),
                this
              );
            });
          var x = 1073741824;
          function N(e, t) {
            return e <= 0 || (0 === t.length && t.ended)
              ? 0
              : t.objectMode
              ? 1
              : e != e
              ? t.flowing && t.length
                ? t.buffer.head.data.length
                : t.length
              : (e > t.highWaterMark &&
                  (t.highWaterMark = (function (e) {
                    return (
                      e >= x
                        ? (e = x)
                        : (e--,
                          (e |= e >>> 1),
                          (e |= e >>> 2),
                          (e |= e >>> 4),
                          (e |= e >>> 8),
                          (e |= e >>> 16),
                          e++),
                      e
                    );
                  })(e)),
                e <= t.length
                  ? e
                  : t.ended
                  ? t.length
                  : ((t.needReadable = !0), 0));
          }
          function k(e) {
            var t = e._readableState;
            l("emitReadable", t.needReadable, t.emittedReadable),
              (t.needReadable = !1),
              t.emittedReadable ||
                (l("emitReadable", t.flowing),
                (t.emittedReadable = !0),
                s.nextTick(R, e));
          }
          function R(e) {
            var t = e._readableState;
            l("emitReadable_", t.destroyed, t.length, t.ended),
              t.destroyed ||
                (!t.length && !t.ended) ||
                (e.emit("readable"), (t.emittedReadable = !1)),
              (t.needReadable =
                !t.flowing && !t.ended && t.length <= t.highWaterMark),
              U(e);
          }
          function B(e, t) {
            t.readingMore || ((t.readingMore = !0), s.nextTick(D, e, t));
          }
          function D(e, t) {
            for (
              ;
              !t.reading &&
              !t.ended &&
              (t.length < t.highWaterMark || (t.flowing && 0 === t.length));
  
            ) {
              var r = t.length;
              if ((l("maybeReadMore read 0"), e.read(0), r === t.length)) break;
            }
            t.readingMore = !1;
          }
          function O(e) {
            var t = e._readableState;
            (t.readableListening = e.listenerCount("readable") > 0),
              t.resumeScheduled && !t.paused
                ? (t.flowing = !0)
                : e.listenerCount("data") > 0 && e.resume();
          }
          function L(e) {
            l("readable nexttick read 0"), e.read(0);
          }
          function P(e, t) {
            l("resume", t.reading),
              t.reading || e.read(0),
              (t.resumeScheduled = !1),
              e.emit("resume"),
              U(e),
              t.flowing && !t.reading && e.read(0);
          }
          function U(e) {
            var t = e._readableState;
            for (l("flow", t.flowing); t.flowing && null !== e.read(); );
          }
          function M(e, t) {
            return 0 === t.length
              ? null
              : (t.objectMode
                  ? (r = t.buffer.shift())
                  : !e || e >= t.length
                  ? ((r = t.decoder
                      ? t.buffer.join("")
                      : 1 === t.buffer.length
                      ? t.buffer.first()
                      : t.buffer.concat(t.length)),
                    t.buffer.clear())
                  : (r = t.buffer.consume(e, t.decoder)),
                r);
            var r;
          }
          function F(e) {
            var t = e._readableState;
            l("endReadable", t.endEmitted),
              t.endEmitted || ((t.ended = !0), s.nextTick(H, t, e));
          }
          function H(e, t) {
            if (
              (l("endReadableNT", e.endEmitted, e.length),
              !e.endEmitted &&
                0 === e.length &&
                ((e.endEmitted = !0),
                (t.readable = !1),
                t.emit("end"),
                e.autoDestroy))
            ) {
              var r = t._writableState;
              (!r || (r.autoDestroy && r.finished)) && t.destroy();
            }
          }
          function Q(e, t) {
            for (var r = 0, i = e.length; r < i; r++) if (e[r] === t) return r;
            return -1;
          }
          (T.prototype.read = function (e) {
            l("read", e), (e = parseInt(e, 10));
            var t = this._readableState,
              r = e;
            if (
              (0 !== e && (t.emittedReadable = !1),
              0 === e &&
                t.needReadable &&
                ((0 !== t.highWaterMark
                  ? t.length >= t.highWaterMark
                  : t.length > 0) ||
                  t.ended))
            )
              return (
                l("read: emitReadable", t.length, t.ended),
                0 === t.length && t.ended ? F(this) : k(this),
                null
              );
            if (0 === (e = N(e, t)) && t.ended)
              return 0 === t.length && F(this), null;
            var i,
              s = t.needReadable;
            return (
              l("need readable", s),
              (0 === t.length || t.length - e < t.highWaterMark) &&
                l("length less than watermark", (s = !0)),
              t.ended || t.reading
                ? l("reading or ended", (s = !1))
                : s &&
                  (l("do read"),
                  (t.reading = !0),
                  (t.sync = !0),
                  0 === t.length && (t.needReadable = !0),
                  this._read(t.highWaterMark),
                  (t.sync = !1),
                  t.reading || (e = N(r, t))),
              null === (i = e > 0 ? M(e, t) : null)
                ? ((t.needReadable = t.length <= t.highWaterMark), (e = 0))
                : ((t.length -= e), (t.awaitDrain = 0)),
              0 === t.length &&
                (t.ended || (t.needReadable = !0), r !== e && t.ended && F(this)),
              null !== i && this.emit("data", i),
              i
            );
          }),
            (T.prototype._read = function (e) {
              v(this, new E("_read()"));
            }),
            (T.prototype.pipe = function (e, t) {
              var r = this,
                i = this._readableState;
              switch (i.pipesCount) {
                case 0:
                  i.pipes = e;
                  break;
                case 1:
                  i.pipes = [i.pipes, e];
                  break;
                default:
                  i.pipes.push(e);
              }
              (i.pipesCount += 1), l("pipe count=%d opts=%j", i.pipesCount, t);
              var a =
                (!t || !1 !== t.end) && e !== s.stdout && e !== s.stderr ? c : m;
              function o(t, s) {
                l("onunpipe"),
                  t === r &&
                    s &&
                    !1 === s.hasUnpiped &&
                    ((s.hasUnpiped = !0),
                    l("cleanup"),
                    e.removeListener("close", f),
                    e.removeListener("finish", g),
                    e.removeListener("drain", h),
                    e.removeListener("error", p),
                    e.removeListener("unpipe", o),
                    r.removeListener("end", c),
                    r.removeListener("end", m),
                    r.removeListener("data", d),
                    (u = !0),
                    !i.awaitDrain ||
                      (e._writableState && !e._writableState.needDrain) ||
                      h());
              }
              function c() {
                l("onend"), e.end();
              }
              i.endEmitted ? s.nextTick(a) : r.once("end", a), e.on("unpipe", o);
              var h = (function (e) {
                return function () {
                  var t = e._readableState;
                  l("pipeOnDrain", t.awaitDrain),
                    t.awaitDrain && t.awaitDrain--,
                    0 === t.awaitDrain &&
                      n(e, "data") &&
                      ((t.flowing = !0), U(e));
                };
              })(r);
              e.on("drain", h);
              var u = !1;
              function d(t) {
                l("ondata");
                var s = e.write(t);
                l("dest.write", s),
                  !1 === s &&
                    (((1 === i.pipesCount && i.pipes === e) ||
                      (i.pipesCount > 1 && -1 !== Q(i.pipes, e))) &&
                      !u &&
                      (l("false write response, pause", i.awaitDrain),
                      i.awaitDrain++),
                    r.pause());
              }
              function p(t) {
                l("onerror", t),
                  m(),
                  e.removeListener("error", p),
                  0 === n(e, "error") && v(e, t);
              }
              function f() {
                e.removeListener("finish", g), m();
              }
              function g() {
                l("onfinish"), e.removeListener("close", f), m();
              }
              function m() {
                l("unpipe"), r.unpipe(e);
              }
              return (
                r.on("data", d),
                (function (e, t, r) {
                  if ("function" == typeof e.prependListener)
                    return e.prependListener(t, r);
                  e._events && e._events[t]
                    ? Array.isArray(e._events[t])
                      ? e._events[t].unshift(r)
                      : (e._events[t] = [r, e._events[t]])
                    : e.on(t, r);
                })(e, "error", p),
                e.once("close", f),
                e.once("finish", g),
                e.emit("pipe", r),
                i.flowing || (l("pipe resume"), r.resume()),
                e
              );
            }),
            (T.prototype.unpipe = function (e) {
              var t = this._readableState,
                r = { hasUnpiped: !1 };
              if (0 === t.pipesCount) return this;
              if (1 === t.pipesCount)
                return (
                  (e && e !== t.pipes) ||
                    (e || (e = t.pipes),
                    (t.pipes = null),
                    (t.pipesCount = 0),
                    (t.flowing = !1),
                    e && e.emit("unpipe", this, r)),
                  this
                );
              if (!e) {
                var i = t.pipes,
                  s = t.pipesCount;
                (t.pipes = null), (t.pipesCount = 0), (t.flowing = !1);
                for (var n = 0; n < s; n++)
                  i[n].emit("unpipe", this, { hasUnpiped: !1 });
                return this;
              }
              var a = Q(t.pipes, e);
              return (
                -1 === a ||
                  (t.pipes.splice(a, 1),
                  (t.pipesCount -= 1),
                  1 === t.pipesCount && (t.pipes = t.pipes[0]),
                  e.emit("unpipe", this, r)),
                this
              );
            }),
            (T.prototype.on = function (e, t) {
              var r = a.prototype.on.call(this, e, t),
                i = this._readableState;
              return (
                "data" === e
                  ? ((i.readableListening = this.listenerCount("readable") > 0),
                    !1 !== i.flowing && this.resume())
                  : "readable" === e &&
                    (i.endEmitted ||
                      i.readableListening ||
                      ((i.readableListening = i.needReadable = !0),
                      (i.flowing = !1),
                      (i.emittedReadable = !1),
                      l("on readable", i.length, i.reading),
                      i.length ? k(this) : i.reading || s.nextTick(L, this))),
                r
              );
            }),
            (T.prototype.addListener = T.prototype.on),
            (T.prototype.removeListener = function (e, t) {
              var r = a.prototype.removeListener.call(this, e, t);
              return "readable" === e && s.nextTick(O, this), r;
            }),
            (T.prototype.removeAllListeners = function (e) {
              var t = a.prototype.removeAllListeners.apply(this, arguments);
              return ("readable" !== e && void 0 !== e) || s.nextTick(O, this), t;
            }),
            (T.prototype.resume = function () {
              var e = this._readableState;
              return (
                e.flowing ||
                  (l("resume"),
                  (e.flowing = !e.readableListening),
                  (function (e, t) {
                    t.resumeScheduled ||
                      ((t.resumeScheduled = !0), s.nextTick(P, e, t));
                  })(this, e)),
                (e.paused = !1),
                this
              );
            }),
            (T.prototype.pause = function () {
              return (
                l("call pause flowing=%j", this._readableState.flowing),
                !1 !== this._readableState.flowing &&
                  (l("pause"),
                  (this._readableState.flowing = !1),
                  this.emit("pause")),
                (this._readableState.paused = !0),
                this
              );
            }),
            (T.prototype.wrap = function (e) {
              var t = this,
                r = this._readableState,
                i = !1;
              for (var s in (e.on("end", function () {
                if ((l("wrapped end"), r.decoder && !r.ended)) {
                  var e = r.decoder.end();
                  e && e.length && t.push(e);
                }
                t.push(null);
              }),
              e.on("data", function (s) {
                (l("wrapped data"),
                r.decoder && (s = r.decoder.write(s)),
                r.objectMode && null == s) ||
                  ((r.objectMode || (s && s.length)) &&
                    (t.push(s) || ((i = !0), e.pause())));
              }),
              e))
                void 0 === this[s] &&
                  "function" == typeof e[s] &&
                  (this[s] = (function (t) {
                    return function () {
                      return e[t].apply(e, arguments);
                    };
                  })(s));
              for (var n = 0; n < I.length; n++)
                e.on(I[n], this.emit.bind(this, I[n]));
              return (
                (this._read = function (t) {
                  l("wrapped _read", t), i && ((i = !1), e.resume());
                }),
                this
              );
            }),
            "function" == typeof Symbol &&
              (T.prototype[Symbol.asyncIterator] = function () {
                return void 0 === d && (d = r(2955)), d(this);
              }),
            Object.defineProperty(T.prototype, "readableHighWaterMark", {
              enumerable: !1,
              get: function () {
                return this._readableState.highWaterMark;
              },
            }),
            Object.defineProperty(T.prototype, "readableBuffer", {
              enumerable: !1,
              get: function () {
                return this._readableState && this._readableState.buffer;
              },
            }),
            Object.defineProperty(T.prototype, "readableFlowing", {
              enumerable: !1,
              get: function () {
                return this._readableState.flowing;
              },
              set: function (e) {
                this._readableState && (this._readableState.flowing = e);
              },
            }),
            (T._fromList = M),
            Object.defineProperty(T.prototype, "readableLength", {
              enumerable: !1,
              get: function () {
                return this._readableState.length;
              },
            }),
            "function" == typeof Symbol &&
              (T.from = function (e, t) {
                return void 0 === p && (p = r(5157)), p(T, e, t);
              });
        },
        4610: (e, t, r) => {
          "use strict";
          e.exports = h;
          var i = r(6048).F,
            s = i.ERR_METHOD_NOT_IMPLEMENTED,
            n = i.ERR_MULTIPLE_CALLBACK,
            a = i.ERR_TRANSFORM_ALREADY_TRANSFORMING,
            o = i.ERR_TRANSFORM_WITH_LENGTH_0,
            c = r(5382);
          function l(e, t) {
            var r = this._transformState;
            r.transforming = !1;
            var i = r.writecb;
            if (null === i) return this.emit("error", new n());
            (r.writechunk = null),
              (r.writecb = null),
              null != t && this.push(t),
              i(e);
            var s = this._readableState;
            (s.reading = !1),
              (s.needReadable || s.length < s.highWaterMark) &&
                this._read(s.highWaterMark);
          }
          function h(e) {
            if (!(this instanceof h)) return new h(e);
            c.call(this, e),
              (this._transformState = {
                afterTransform: l.bind(this),
                needTransform: !1,
                transforming: !1,
                writecb: null,
                writechunk: null,
                writeencoding: null,
              }),
              (this._readableState.needReadable = !0),
              (this._readableState.sync = !1),
              e &&
                ("function" == typeof e.transform &&
                  (this._transform = e.transform),
                "function" == typeof e.flush && (this._flush = e.flush)),
              this.on("prefinish", u);
          }
          function u() {
            var e = this;
            "function" != typeof this._flush || this._readableState.destroyed
              ? d(this, null, null)
              : this._flush(function (t, r) {
                  d(e, t, r);
                });
          }
          function d(e, t, r) {
            if (t) return e.emit("error", t);
            if ((null != r && e.push(r), e._writableState.length)) throw new o();
            if (e._transformState.transforming) throw new a();
            return e.push(null);
          }
          r(6698)(h, c),
            (h.prototype.push = function (e, t) {
              return (
                (this._transformState.needTransform = !1),
                c.prototype.push.call(this, e, t)
              );
            }),
            (h.prototype._transform = function (e, t, r) {
              r(new s("_transform()"));
            }),
            (h.prototype._write = function (e, t, r) {
              var i = this._transformState;
              if (
                ((i.writecb = r),
                (i.writechunk = e),
                (i.writeencoding = t),
                !i.transforming)
              ) {
                var s = this._readableState;
                (i.needTransform ||
                  s.needReadable ||
                  s.length < s.highWaterMark) &&
                  this._read(s.highWaterMark);
              }
            }),
            (h.prototype._read = function (e) {
              var t = this._transformState;
              null === t.writechunk || t.transforming
                ? (t.needTransform = !0)
                : ((t.transforming = !0),
                  this._transform(
                    t.writechunk,
                    t.writeencoding,
                    t.afterTransform
                  ));
            }),
            (h.prototype._destroy = function (e, t) {
              c.prototype._destroy.call(this, e, function (e) {
                t(e);
              });
            });
        },
        6708: (e, t, r) => {
          "use strict";
          var i,
            s = r(5606);
          function n(e) {
            var t = this;
            (this.next = null),
              (this.entry = null),
              (this.finish = function () {
                !(function (e, t, r) {
                  var i = e.entry;
                  e.entry = null;
                  for (; i; ) {
                    var s = i.callback;
                    t.pendingcb--, s(r), (i = i.next);
                  }
                  t.corkedRequestsFree.next = e;
                })(t, e);
              });
          }
          (e.exports = T), (T.WritableState = S);
          var a = { deprecate: r(4643) },
            o = r(345),
            c = r(8287).Buffer,
            l =
              (void 0 !== r.g
                ? r.g
                : "undefined" != typeof window
                ? window
                : "undefined" != typeof self
                ? self
                : {}
              ).Uint8Array || function () {};
          var h,
            u = r(5896),
            d = r(5291).getHighWaterMark,
            p = r(6048).F,
            f = p.ERR_INVALID_ARG_TYPE,
            g = p.ERR_METHOD_NOT_IMPLEMENTED,
            m = p.ERR_MULTIPLE_CALLBACK,
            y = p.ERR_STREAM_CANNOT_PIPE,
            A = p.ERR_STREAM_DESTROYED,
            w = p.ERR_STREAM_NULL_VALUES,
            E = p.ERR_STREAM_WRITE_AFTER_END,
            b = p.ERR_UNKNOWN_ENCODING,
            v = u.errorOrDestroy;
          function I() {}
          function S(e, t, a) {
            (i = i || r(5382)),
              (e = e || {}),
              "boolean" != typeof a && (a = t instanceof i),
              (this.objectMode = !!e.objectMode),
              a && (this.objectMode = this.objectMode || !!e.writableObjectMode),
              (this.highWaterMark = d(this, e, "writableHighWaterMark", a)),
              (this.finalCalled = !1),
              (this.needDrain = !1),
              (this.ending = !1),
              (this.ended = !1),
              (this.finished = !1),
              (this.destroyed = !1);
            var o = !1 === e.decodeStrings;
            (this.decodeStrings = !o),
              (this.defaultEncoding = e.defaultEncoding || "utf8"),
              (this.length = 0),
              (this.writing = !1),
              (this.corked = 0),
              (this.sync = !0),
              (this.bufferProcessing = !1),
              (this.onwrite = function (e) {
                !(function (e, t) {
                  var r = e._writableState,
                    i = r.sync,
                    n = r.writecb;
                  if ("function" != typeof n) throw new m();
                  if (
                    ((function (e) {
                      (e.writing = !1),
                        (e.writecb = null),
                        (e.length -= e.writelen),
                        (e.writelen = 0);
                    })(r),
                    t)
                  )
                    !(function (e, t, r, i, n) {
                      --t.pendingcb,
                        r
                          ? (s.nextTick(n, i),
                            s.nextTick(R, e, t),
                            (e._writableState.errorEmitted = !0),
                            v(e, i))
                          : (n(i),
                            (e._writableState.errorEmitted = !0),
                            v(e, i),
                            R(e, t));
                    })(e, r, i, t, n);
                  else {
                    var a = N(r) || e.destroyed;
                    a ||
                      r.corked ||
                      r.bufferProcessing ||
                      !r.bufferedRequest ||
                      x(e, r),
                      i ? s.nextTick(C, e, r, a, n) : C(e, r, a, n);
                  }
                })(t, e);
              }),
              (this.writecb = null),
              (this.writelen = 0),
              (this.bufferedRequest = null),
              (this.lastBufferedRequest = null),
              (this.pendingcb = 0),
              (this.prefinished = !1),
              (this.errorEmitted = !1),
              (this.emitClose = !1 !== e.emitClose),
              (this.autoDestroy = !!e.autoDestroy),
              (this.bufferedRequestCount = 0),
              (this.corkedRequestsFree = new n(this));
          }
          function T(e) {
            var t = this instanceof (i = i || r(5382));
            if (!t && !h.call(T, this)) return new T(e);
            (this._writableState = new S(e, this, t)),
              (this.writable = !0),
              e &&
                ("function" == typeof e.write && (this._write = e.write),
                "function" == typeof e.writev && (this._writev = e.writev),
                "function" == typeof e.destroy && (this._destroy = e.destroy),
                "function" == typeof e.final && (this._final = e.final)),
              o.call(this);
          }
          function _(e, t, r, i, s, n, a) {
            (t.writelen = i),
              (t.writecb = a),
              (t.writing = !0),
              (t.sync = !0),
              t.destroyed
                ? t.onwrite(new A("write"))
                : r
                ? e._writev(s, t.onwrite)
                : e._write(s, n, t.onwrite),
              (t.sync = !1);
          }
          function C(e, t, r, i) {
            r ||
              (function (e, t) {
                0 === t.length &&
                  t.needDrain &&
                  ((t.needDrain = !1), e.emit("drain"));
              })(e, t),
              t.pendingcb--,
              i(),
              R(e, t);
          }
          function x(e, t) {
            t.bufferProcessing = !0;
            var r = t.bufferedRequest;
            if (e._writev && r && r.next) {
              var i = t.bufferedRequestCount,
                s = new Array(i),
                a = t.corkedRequestsFree;
              a.entry = r;
              for (var o = 0, c = !0; r; )
                (s[o] = r), r.isBuf || (c = !1), (r = r.next), (o += 1);
              (s.allBuffers = c),
                _(e, t, !0, t.length, s, "", a.finish),
                t.pendingcb++,
                (t.lastBufferedRequest = null),
                a.next
                  ? ((t.corkedRequestsFree = a.next), (a.next = null))
                  : (t.corkedRequestsFree = new n(t)),
                (t.bufferedRequestCount = 0);
            } else {
              for (; r; ) {
                var l = r.chunk,
                  h = r.encoding,
                  u = r.callback;
                if (
                  (_(e, t, !1, t.objectMode ? 1 : l.length, l, h, u),
                  (r = r.next),
                  t.bufferedRequestCount--,
                  t.writing)
                )
                  break;
              }
              null === r && (t.lastBufferedRequest = null);
            }
            (t.bufferedRequest = r), (t.bufferProcessing = !1);
          }
          function N(e) {
            return (
              e.ending &&
              0 === e.length &&
              null === e.bufferedRequest &&
              !e.finished &&
              !e.writing
            );
          }
          function k(e, t) {
            e._final(function (r) {
              t.pendingcb--,
                r && v(e, r),
                (t.prefinished = !0),
                e.emit("prefinish"),
                R(e, t);
            });
          }
          function R(e, t) {
            var r = N(t);
            if (
              r &&
              ((function (e, t) {
                t.prefinished ||
                  t.finalCalled ||
                  ("function" != typeof e._final || t.destroyed
                    ? ((t.prefinished = !0), e.emit("prefinish"))
                    : (t.pendingcb++, (t.finalCalled = !0), s.nextTick(k, e, t)));
              })(e, t),
              0 === t.pendingcb &&
                ((t.finished = !0), e.emit("finish"), t.autoDestroy))
            ) {
              var i = e._readableState;
              (!i || (i.autoDestroy && i.endEmitted)) && e.destroy();
            }
            return r;
          }
          r(6698)(T, o),
            (S.prototype.getBuffer = function () {
              for (var e = this.bufferedRequest, t = []; e; )
                t.push(e), (e = e.next);
              return t;
            }),
            (function () {
              try {
                Object.defineProperty(S.prototype, "buffer", {
                  get: a.deprecate(
                    function () {
                      return this.getBuffer();
                    },
                    "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.",
                    "DEP0003"
                  ),
                });
              } catch (e) {}
            })(),
            "function" == typeof Symbol &&
            Symbol.hasInstance &&
            "function" == typeof Function.prototype[Symbol.hasInstance]
              ? ((h = Function.prototype[Symbol.hasInstance]),
                Object.defineProperty(T, Symbol.hasInstance, {
                  value: function (e) {
                    return (
                      !!h.call(this, e) ||
                      (this === T && e && e._writableState instanceof S)
                    );
                  },
                }))
              : (h = function (e) {
                  return e instanceof this;
                }),
            (T.prototype.pipe = function () {
              v(this, new y());
            }),
            (T.prototype.write = function (e, t, r) {
              var i,
                n = this._writableState,
                a = !1,
                o = !n.objectMode && ((i = e), c.isBuffer(i) || i instanceof l);
              return (
                o &&
                  !c.isBuffer(e) &&
                  (e = (function (e) {
                    return c.from(e);
                  })(e)),
                "function" == typeof t && ((r = t), (t = null)),
                o ? (t = "buffer") : t || (t = n.defaultEncoding),
                "function" != typeof r && (r = I),
                n.ending
                  ? (function (e, t) {
                      var r = new E();
                      v(e, r), s.nextTick(t, r);
                    })(this, r)
                  : (o ||
                      (function (e, t, r, i) {
                        var n;
                        return (
                          null === r
                            ? (n = new w())
                            : "string" == typeof r ||
                              t.objectMode ||
                              (n = new f("chunk", ["string", "Buffer"], r)),
                          !n || (v(e, n), s.nextTick(i, n), !1)
                        );
                      })(this, n, e, r)) &&
                    (n.pendingcb++,
                    (a = (function (e, t, r, i, s, n) {
                      if (!r) {
                        var a = (function (e, t, r) {
                          e.objectMode ||
                            !1 === e.decodeStrings ||
                            "string" != typeof t ||
                            (t = c.from(t, r));
                          return t;
                        })(t, i, s);
                        i !== a && ((r = !0), (s = "buffer"), (i = a));
                      }
                      var o = t.objectMode ? 1 : i.length;
                      t.length += o;
                      var l = t.length < t.highWaterMark;
                      l || (t.needDrain = !0);
                      if (t.writing || t.corked) {
                        var h = t.lastBufferedRequest;
                        (t.lastBufferedRequest = {
                          chunk: i,
                          encoding: s,
                          isBuf: r,
                          callback: n,
                          next: null,
                        }),
                          h
                            ? (h.next = t.lastBufferedRequest)
                            : (t.bufferedRequest = t.lastBufferedRequest),
                          (t.bufferedRequestCount += 1);
                      } else _(e, t, !1, o, i, s, n);
                      return l;
                    })(this, n, o, e, t, r))),
                a
              );
            }),
            (T.prototype.cork = function () {
              this._writableState.corked++;
            }),
            (T.prototype.uncork = function () {
              var e = this._writableState;
              e.corked &&
                (e.corked--,
                e.writing ||
                  e.corked ||
                  e.bufferProcessing ||
                  !e.bufferedRequest ||
                  x(this, e));
            }),
            (T.prototype.setDefaultEncoding = function (e) {
              if (
                ("string" == typeof e && (e = e.toLowerCase()),
                !(
                  [
                    "hex",
                    "utf8",
                    "utf-8",
                    "ascii",
                    "binary",
                    "base64",
                    "ucs2",
                    "ucs-2",
                    "utf16le",
                    "utf-16le",
                    "raw",
                  ].indexOf((e + "").toLowerCase()) > -1
                ))
              )
                throw new b(e);
              return (this._writableState.defaultEncoding = e), this;
            }),
            Object.defineProperty(T.prototype, "writableBuffer", {
              enumerable: !1,
              get: function () {
                return this._writableState && this._writableState.getBuffer();
              },
            }),
            Object.defineProperty(T.prototype, "writableHighWaterMark", {
              enumerable: !1,
              get: function () {
                return this._writableState.highWaterMark;
              },
            }),
            (T.prototype._write = function (e, t, r) {
              r(new g("_write()"));
            }),
            (T.prototype._writev = null),
            (T.prototype.end = function (e, t, r) {
              var i = this._writableState;
              return (
                "function" == typeof e
                  ? ((r = e), (e = null), (t = null))
                  : "function" == typeof t && ((r = t), (t = null)),
                null != e && this.write(e, t),
                i.corked && ((i.corked = 1), this.uncork()),
                i.ending ||
                  (function (e, t, r) {
                    (t.ending = !0),
                      R(e, t),
                      r && (t.finished ? s.nextTick(r) : e.once("finish", r));
                    (t.ended = !0), (e.writable = !1);
                  })(this, i, r),
                this
              );
            }),
            Object.defineProperty(T.prototype, "writableLength", {
              enumerable: !1,
              get: function () {
                return this._writableState.length;
              },
            }),
            Object.defineProperty(T.prototype, "destroyed", {
              enumerable: !1,
              get: function () {
                return (
                  void 0 !== this._writableState && this._writableState.destroyed
                );
              },
              set: function (e) {
                this._writableState && (this._writableState.destroyed = e);
              },
            }),
            (T.prototype.destroy = u.destroy),
            (T.prototype._undestroy = u.undestroy),
            (T.prototype._destroy = function (e, t) {
              t(e);
            });
        },
        2955: (e, t, r) => {
          "use strict";
          var i,
            s = r(5606);
          function n(e, t, r) {
            return (
              (t = (function (e) {
                var t = (function (e, t) {
                  if ("object" != typeof e || null === e) return e;
                  var r = e[Symbol.toPrimitive];
                  if (void 0 !== r) {
                    var i = r.call(e, t || "default");
                    if ("object" != typeof i) return i;
                    throw new TypeError(
                      "@@toPrimitive must return a primitive value."
                    );
                  }
                  return ("string" === t ? String : Number)(e);
                })(e, "string");
                return "symbol" == typeof t ? t : String(t);
              })(t)) in e
                ? Object.defineProperty(e, t, {
                    value: r,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                  })
                : (e[t] = r),
              e
            );
          }
          var a = r(6238),
            o = Symbol("lastResolve"),
            c = Symbol("lastReject"),
            l = Symbol("error"),
            h = Symbol("ended"),
            u = Symbol("lastPromise"),
            d = Symbol("handlePromise"),
            p = Symbol("stream");
          function f(e, t) {
            return { value: e, done: t };
          }
          function g(e) {
            var t = e[o];
            if (null !== t) {
              var r = e[p].read();
              null !== r &&
                ((e[u] = null), (e[o] = null), (e[c] = null), t(f(r, !1)));
            }
          }
          function m(e) {
            s.nextTick(g, e);
          }
          var y = Object.getPrototypeOf(function () {}),
            A = Object.setPrototypeOf(
              (n(
                (i = {
                  get stream() {
                    return this[p];
                  },
                  next: function () {
                    var e = this,
                      t = this[l];
                    if (null !== t) return Promise.reject(t);
                    if (this[h]) return Promise.resolve(f(void 0, !0));
                    if (this[p].destroyed)
                      return new Promise(function (t, r) {
                        s.nextTick(function () {
                          e[l] ? r(e[l]) : t(f(void 0, !0));
                        });
                      });
                    var r,
                      i = this[u];
                    if (i)
                      r = new Promise(
                        (function (e, t) {
                          return function (r, i) {
                            e.then(function () {
                              t[h] ? r(f(void 0, !0)) : t[d](r, i);
                            }, i);
                          };
                        })(i, this)
                      );
                    else {
                      var n = this[p].read();
                      if (null !== n) return Promise.resolve(f(n, !1));
                      r = new Promise(this[d]);
                    }
                    return (this[u] = r), r;
                  },
                }),
                Symbol.asyncIterator,
                function () {
                  return this;
                }
              ),
              n(i, "return", function () {
                var e = this;
                return new Promise(function (t, r) {
                  e[p].destroy(null, function (e) {
                    e ? r(e) : t(f(void 0, !0));
                  });
                });
              }),
              i),
              y
            );
          e.exports = function (e) {
            var t,
              r = Object.create(
                A,
                (n((t = {}), p, { value: e, writable: !0 }),
                n(t, o, { value: null, writable: !0 }),
                n(t, c, { value: null, writable: !0 }),
                n(t, l, { value: null, writable: !0 }),
                n(t, h, { value: e._readableState.endEmitted, writable: !0 }),
                n(t, d, {
                  value: function (e, t) {
                    var i = r[p].read();
                    i
                      ? ((r[u] = null), (r[o] = null), (r[c] = null), e(f(i, !1)))
                      : ((r[o] = e), (r[c] = t));
                  },
                  writable: !0,
                }),
                t)
              );
            return (
              (r[u] = null),
              a(e, function (e) {
                if (e && "ERR_STREAM_PREMATURE_CLOSE" !== e.code) {
                  var t = r[c];
                  return (
                    null !== t &&
                      ((r[u] = null), (r[o] = null), (r[c] = null), t(e)),
                    void (r[l] = e)
                  );
                }
                var i = r[o];
                null !== i &&
                  ((r[u] = null), (r[o] = null), (r[c] = null), i(f(void 0, !0))),
                  (r[h] = !0);
              }),
              e.on("readable", m.bind(null, r)),
              r
            );
          };
        },
        2726: (e, t, r) => {
          "use strict";
          function i(e, t) {
            var r = Object.keys(e);
            if (Object.getOwnPropertySymbols) {
              var i = Object.getOwnPropertySymbols(e);
              t &&
                (i = i.filter(function (t) {
                  return Object.getOwnPropertyDescriptor(e, t).enumerable;
                })),
                r.push.apply(r, i);
            }
            return r;
          }
          function s(e) {
            for (var t = 1; t < arguments.length; t++) {
              var r = null != arguments[t] ? arguments[t] : {};
              t % 2
                ? i(Object(r), !0).forEach(function (t) {
                    n(e, t, r[t]);
                  })
                : Object.getOwnPropertyDescriptors
                ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
                : i(Object(r)).forEach(function (t) {
                    Object.defineProperty(
                      e,
                      t,
                      Object.getOwnPropertyDescriptor(r, t)
                    );
                  });
            }
            return e;
          }
          function n(e, t, r) {
            return (
              (t = o(t)) in e
                ? Object.defineProperty(e, t, {
                    value: r,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                  })
                : (e[t] = r),
              e
            );
          }
          function a(e, t) {
            for (var r = 0; r < t.length; r++) {
              var i = t[r];
              (i.enumerable = i.enumerable || !1),
                (i.configurable = !0),
                "value" in i && (i.writable = !0),
                Object.defineProperty(e, o(i.key), i);
            }
          }
          function o(e) {
            var t = (function (e, t) {
              if ("object" != typeof e || null === e) return e;
              var r = e[Symbol.toPrimitive];
              if (void 0 !== r) {
                var i = r.call(e, t || "default");
                if ("object" != typeof i) return i;
                throw new TypeError(
                  "@@toPrimitive must return a primitive value."
                );
              }
              return ("string" === t ? String : Number)(e);
            })(e, "string");
            return "symbol" == typeof t ? t : String(t);
          }
          var c = r(8287).Buffer,
            l = r(5340).inspect,
            h = (l && l.custom) || "inspect";
          e.exports = (function () {
            function e() {
              !(function (e, t) {
                if (!(e instanceof t))
                  throw new TypeError("Cannot call a class as a function");
              })(this, e),
                (this.head = null),
                (this.tail = null),
                (this.length = 0);
            }
            var t, r, i;
            return (
              (t = e),
              (r = [
                {
                  key: "push",
                  value: function (e) {
                    var t = { data: e, next: null };
                    this.length > 0 ? (this.tail.next = t) : (this.head = t),
                      (this.tail = t),
                      ++this.length;
                  },
                },
                {
                  key: "unshift",
                  value: function (e) {
                    var t = { data: e, next: this.head };
                    0 === this.length && (this.tail = t),
                      (this.head = t),
                      ++this.length;
                  },
                },
                {
                  key: "shift",
                  value: function () {
                    if (0 !== this.length) {
                      var e = this.head.data;
                      return (
                        1 === this.length
                          ? (this.head = this.tail = null)
                          : (this.head = this.head.next),
                        --this.length,
                        e
                      );
                    }
                  },
                },
                {
                  key: "clear",
                  value: function () {
                    (this.head = this.tail = null), (this.length = 0);
                  },
                },
                {
                  key: "join",
                  value: function (e) {
                    if (0 === this.length) return "";
                    for (var t = this.head, r = "" + t.data; (t = t.next); )
                      r += e + t.data;
                    return r;
                  },
                },
                {
                  key: "concat",
                  value: function (e) {
                    if (0 === this.length) return c.alloc(0);
                    for (
                      var t,
                        r,
                        i,
                        s = c.allocUnsafe(e >>> 0),
                        n = this.head,
                        a = 0;
                      n;
  
                    )
                      (t = n.data),
                        (r = s),
                        (i = a),
                        c.prototype.copy.call(t, r, i),
                        (a += n.data.length),
                        (n = n.next);
                    return s;
                  },
                },
                {
                  key: "consume",
                  value: function (e, t) {
                    var r;
                    return (
                      e < this.head.data.length
                        ? ((r = this.head.data.slice(0, e)),
                          (this.head.data = this.head.data.slice(e)))
                        : (r =
                            e === this.head.data.length
                              ? this.shift()
                              : t
                              ? this._getString(e)
                              : this._getBuffer(e)),
                      r
                    );
                  },
                },
                {
                  key: "first",
                  value: function () {
                    return this.head.data;
                  },
                },
                {
                  key: "_getString",
                  value: function (e) {
                    var t = this.head,
                      r = 1,
                      i = t.data;
                    for (e -= i.length; (t = t.next); ) {
                      var s = t.data,
                        n = e > s.length ? s.length : e;
                      if (
                        (n === s.length ? (i += s) : (i += s.slice(0, e)),
                        0 == (e -= n))
                      ) {
                        n === s.length
                          ? (++r,
                            t.next
                              ? (this.head = t.next)
                              : (this.head = this.tail = null))
                          : ((this.head = t), (t.data = s.slice(n)));
                        break;
                      }
                      ++r;
                    }
                    return (this.length -= r), i;
                  },
                },
                {
                  key: "_getBuffer",
                  value: function (e) {
                    var t = c.allocUnsafe(e),
                      r = this.head,
                      i = 1;
                    for (r.data.copy(t), e -= r.data.length; (r = r.next); ) {
                      var s = r.data,
                        n = e > s.length ? s.length : e;
                      if ((s.copy(t, t.length - e, 0, n), 0 == (e -= n))) {
                        n === s.length
                          ? (++i,
                            r.next
                              ? (this.head = r.next)
                              : (this.head = this.tail = null))
                          : ((this.head = r), (r.data = s.slice(n)));
                        break;
                      }
                      ++i;
                    }
                    return (this.length -= i), t;
                  },
                },
                {
                  key: h,
                  value: function (e, t) {
                    return l(
                      this,
                      s(s({}, t), {}, { depth: 0, customInspect: !1 })
                    );
                  },
                },
              ]),
              r && a(t.prototype, r),
              i && a(t, i),
              Object.defineProperty(t, "prototype", { writable: !1 }),
              e
            );
          })();
        },
        5896: (e, t, r) => {
          "use strict";
          var i = r(5606);
          function s(e, t) {
            a(e, t), n(e);
          }
          function n(e) {
            (e._writableState && !e._writableState.emitClose) ||
              (e._readableState && !e._readableState.emitClose) ||
              e.emit("close");
          }
          function a(e, t) {
            e.emit("error", t);
          }
          e.exports = {
            destroy: function (e, t) {
              var r = this,
                o = this._readableState && this._readableState.destroyed,
                c = this._writableState && this._writableState.destroyed;
              return o || c
                ? (t
                    ? t(e)
                    : e &&
                      (this._writableState
                        ? this._writableState.errorEmitted ||
                          ((this._writableState.errorEmitted = !0),
                          i.nextTick(a, this, e))
                        : i.nextTick(a, this, e)),
                  this)
                : (this._readableState && (this._readableState.destroyed = !0),
                  this._writableState && (this._writableState.destroyed = !0),
                  this._destroy(e || null, function (e) {
                    !t && e
                      ? r._writableState
                        ? r._writableState.errorEmitted
                          ? i.nextTick(n, r)
                          : ((r._writableState.errorEmitted = !0),
                            i.nextTick(s, r, e))
                        : i.nextTick(s, r, e)
                      : t
                      ? (i.nextTick(n, r), t(e))
                      : i.nextTick(n, r);
                  }),
                  this);
            },
            undestroy: function () {
              this._readableState &&
                ((this._readableState.destroyed = !1),
                (this._readableState.reading = !1),
                (this._readableState.ended = !1),
                (this._readableState.endEmitted = !1)),
                this._writableState &&
                  ((this._writableState.destroyed = !1),
                  (this._writableState.ended = !1),
                  (this._writableState.ending = !1),
                  (this._writableState.finalCalled = !1),
                  (this._writableState.prefinished = !1),
                  (this._writableState.finished = !1),
                  (this._writableState.errorEmitted = !1));
            },
            errorOrDestroy: function (e, t) {
              var r = e._readableState,
                i = e._writableState;
              (r && r.autoDestroy) || (i && i.autoDestroy)
                ? e.destroy(t)
                : e.emit("error", t);
            },
          };
        },
        6238: (e, t, r) => {
          "use strict";
          var i = r(6048).F.ERR_STREAM_PREMATURE_CLOSE;
          function s() {}
          e.exports = function e(t, r, n) {
            if ("function" == typeof r) return e(t, null, r);
            r || (r = {}),
              (n = (function (e) {
                var t = !1;
                return function () {
                  if (!t) {
                    t = !0;
                    for (
                      var r = arguments.length, i = new Array(r), s = 0;
                      s < r;
                      s++
                    )
                      i[s] = arguments[s];
                    e.apply(this, i);
                  }
                };
              })(n || s));
            var a = r.readable || (!1 !== r.readable && t.readable),
              o = r.writable || (!1 !== r.writable && t.writable),
              c = function () {
                t.writable || h();
              },
              l = t._writableState && t._writableState.finished,
              h = function () {
                (o = !1), (l = !0), a || n.call(t);
              },
              u = t._readableState && t._readableState.endEmitted,
              d = function () {
                (a = !1), (u = !0), o || n.call(t);
              },
              p = function (e) {
                n.call(t, e);
              },
              f = function () {
                var e;
                return a && !u
                  ? ((t._readableState && t._readableState.ended) ||
                      (e = new i()),
                    n.call(t, e))
                  : o && !l
                  ? ((t._writableState && t._writableState.ended) ||
                      (e = new i()),
                    n.call(t, e))
                  : void 0;
              },
              g = function () {
                t.req.on("finish", h);
              };
            return (
              !(function (e) {
                return e.setHeader && "function" == typeof e.abort;
              })(t)
                ? o && !t._writableState && (t.on("end", c), t.on("close", c))
                : (t.on("complete", h),
                  t.on("abort", f),
                  t.req ? g() : t.on("request", g)),
              t.on("end", d),
              t.on("finish", h),
              !1 !== r.error && t.on("error", p),
              t.on("close", f),
              function () {
                t.removeListener("complete", h),
                  t.removeListener("abort", f),
                  t.removeListener("request", g),
                  t.req && t.req.removeListener("finish", h),
                  t.removeListener("end", c),
                  t.removeListener("close", c),
                  t.removeListener("finish", h),
                  t.removeListener("end", d),
                  t.removeListener("error", p),
                  t.removeListener("close", f);
              }
            );
          };
        },
        5157: (e) => {
          e.exports = function () {
            throw new Error("Readable.from is not available in the browser");
          };
        },
        7758: (e, t, r) => {
          "use strict";
          var i;
          var s = r(6048).F,
            n = s.ERR_MISSING_ARGS,
            a = s.ERR_STREAM_DESTROYED;
          function o(e) {
            if (e) throw e;
          }
          function c(e) {
            e();
          }
          function l(e, t) {
            return e.pipe(t);
          }
          e.exports = function () {
            for (var e = arguments.length, t = new Array(e), s = 0; s < e; s++)
              t[s] = arguments[s];
            var h,
              u = (function (e) {
                return e.length
                  ? "function" != typeof e[e.length - 1]
                    ? o
                    : e.pop()
                  : o;
              })(t);
            if ((Array.isArray(t[0]) && (t = t[0]), t.length < 2))
              throw new n("streams");
            var d = t.map(function (e, s) {
              var n = s < t.length - 1;
              return (function (e, t, s, n) {
                n = (function (e) {
                  var t = !1;
                  return function () {
                    t || ((t = !0), e.apply(void 0, arguments));
                  };
                })(n);
                var o = !1;
                e.on("close", function () {
                  o = !0;
                }),
                  void 0 === i && (i = r(6238)),
                  i(e, { readable: t, writable: s }, function (e) {
                    if (e) return n(e);
                    (o = !0), n();
                  });
                var c = !1;
                return function (t) {
                  if (!o && !c)
                    return (
                      (c = !0),
                      (function (e) {
                        return e.setHeader && "function" == typeof e.abort;
                      })(e)
                        ? e.abort()
                        : "function" == typeof e.destroy
                        ? e.destroy()
                        : void n(t || new a("pipe"))
                    );
                };
              })(e, n, s > 0, function (e) {
                h || (h = e), e && d.forEach(c), n || (d.forEach(c), u(h));
              });
            });
            return t.reduce(l);
          };
        },
        5291: (e, t, r) => {
          "use strict";
          var i = r(6048).F.ERR_INVALID_OPT_VALUE;
          e.exports = {
            getHighWaterMark: function (e, t, r, s) {
              var n = (function (e, t, r) {
                return null != e.highWaterMark
                  ? e.highWaterMark
                  : t
                  ? e[r]
                  : null;
              })(t, s, r);
              if (null != n) {
                if (!isFinite(n) || Math.floor(n) !== n || n < 0)
                  throw new i(s ? r : "highWaterMark", n);
                return Math.floor(n);
              }
              return e.objectMode ? 16 : 16384;
            },
          };
        },
        345: (e, t, r) => {
          e.exports = r(7007).EventEmitter;
        },
        2861: (e, t, r) => {
          /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
          var i = r(8287),
            s = i.Buffer;
          function n(e, t) {
            for (var r in e) t[r] = e[r];
          }
          function a(e, t, r) {
            return s(e, t, r);
          }
          s.from && s.alloc && s.allocUnsafe && s.allocUnsafeSlow
            ? (e.exports = i)
            : (n(i, t), (t.Buffer = a)),
            (a.prototype = Object.create(s.prototype)),
            n(s, a),
            (a.from = function (e, t, r) {
              if ("number" == typeof e)
                throw new TypeError("Argument must not be a number");
              return s(e, t, r);
            }),
            (a.alloc = function (e, t, r) {
              if ("number" != typeof e)
                throw new TypeError("Argument must be a number");
              var i = s(e);
              return (
                void 0 !== t
                  ? "string" == typeof r
                    ? i.fill(t, r)
                    : i.fill(t)
                  : i.fill(0),
                i
              );
            }),
            (a.allocUnsafe = function (e) {
              if ("number" != typeof e)
                throw new TypeError("Argument must be a number");
              return s(e);
            }),
            (a.allocUnsafeSlow = function (e) {
              if ("number" != typeof e)
                throw new TypeError("Argument must be a number");
              return i.SlowBuffer(e);
            });
        },
        8310: (e, t, r) => {
          e.exports = s;
          var i = r(7007).EventEmitter;
          function s() {
            i.call(this);
          }
          r(6698)(s, i),
            (s.Readable = r(5412)),
            (s.Writable = r(6708)),
            (s.Duplex = r(5382)),
            (s.Transform = r(4610)),
            (s.PassThrough = r(3600)),
            (s.finished = r(6238)),
            (s.pipeline = r(7758)),
            (s.Stream = s),
            (s.prototype.pipe = function (e, t) {
              var r = this;
              function s(t) {
                e.writable && !1 === e.write(t) && r.pause && r.pause();
              }
              function n() {
                r.readable && r.resume && r.resume();
              }
              r.on("data", s),
                e.on("drain", n),
                e._isStdio ||
                  (t && !1 === t.end) ||
                  (r.on("end", o), r.on("close", c));
              var a = !1;
              function o() {
                a || ((a = !0), e.end());
              }
              function c() {
                a || ((a = !0), "function" == typeof e.destroy && e.destroy());
              }
              function l(e) {
                if ((h(), 0 === i.listenerCount(this, "error"))) throw e;
              }
              function h() {
                r.removeListener("data", s),
                  e.removeListener("drain", n),
                  r.removeListener("end", o),
                  r.removeListener("close", c),
                  r.removeListener("error", l),
                  e.removeListener("error", l),
                  r.removeListener("end", h),
                  r.removeListener("close", h),
                  e.removeListener("close", h);
              }
              return (
                r.on("error", l),
                e.on("error", l),
                r.on("end", h),
                r.on("close", h),
                e.on("close", h),
                e.emit("pipe", r),
                e
              );
            });
        },
        3141: (e, t, r) => {
          "use strict";
          var i = r(2861).Buffer,
            s =
              i.isEncoding ||
              function (e) {
                switch ((e = "" + e) && e.toLowerCase()) {
                  case "hex":
                  case "utf8":
                  case "utf-8":
                  case "ascii":
                  case "binary":
                  case "base64":
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                  case "raw":
                    return !0;
                  default:
                    return !1;
                }
              };
          function n(e) {
            var t;
            switch (
              ((this.encoding = (function (e) {
                var t = (function (e) {
                  if (!e) return "utf8";
                  for (var t; ; )
                    switch (e) {
                      case "utf8":
                      case "utf-8":
                        return "utf8";
                      case "ucs2":
                      case "ucs-2":
                      case "utf16le":
                      case "utf-16le":
                        return "utf16le";
                      case "latin1":
                      case "binary":
                        return "latin1";
                      case "base64":
                      case "ascii":
                      case "hex":
                        return e;
                      default:
                        if (t) return;
                        (e = ("" + e).toLowerCase()), (t = !0);
                    }
                })(e);
                if ("string" != typeof t && (i.isEncoding === s || !s(e)))
                  throw new Error("Unknown encoding: " + e);
                return t || e;
              })(e)),
              this.encoding)
            ) {
              case "utf16le":
                (this.text = c), (this.end = l), (t = 4);
                break;
              case "utf8":
                (this.fillLast = o), (t = 4);
                break;
              case "base64":
                (this.text = h), (this.end = u), (t = 3);
                break;
              default:
                return (this.write = d), void (this.end = p);
            }
            (this.lastNeed = 0),
              (this.lastTotal = 0),
              (this.lastChar = i.allocUnsafe(t));
          }
          function a(e) {
            return e <= 127
              ? 0
              : e >> 5 == 6
              ? 2
              : e >> 4 == 14
              ? 3
              : e >> 3 == 30
              ? 4
              : e >> 6 == 2
              ? -1
              : -2;
          }
          function o(e) {
            var t = this.lastTotal - this.lastNeed,
              r = (function (e, t, r) {
                if (128 != (192 & t[0])) return (e.lastNeed = 0), "";
                if (e.lastNeed > 1 && t.length > 1) {
                  if (128 != (192 & t[1])) return (e.lastNeed = 1), "";
                  if (e.lastNeed > 2 && t.length > 2 && 128 != (192 & t[2]))
                    return (e.lastNeed = 2), "";
                }
              })(this, e);
            return void 0 !== r
              ? r
              : this.lastNeed <= e.length
              ? (e.copy(this.lastChar, t, 0, this.lastNeed),
                this.lastChar.toString(this.encoding, 0, this.lastTotal))
              : (e.copy(this.lastChar, t, 0, e.length),
                void (this.lastNeed -= e.length));
          }
          function c(e, t) {
            if ((e.length - t) % 2 == 0) {
              var r = e.toString("utf16le", t);
              if (r) {
                var i = r.charCodeAt(r.length - 1);
                if (i >= 55296 && i <= 56319)
                  return (
                    (this.lastNeed = 2),
                    (this.lastTotal = 4),
                    (this.lastChar[0] = e[e.length - 2]),
                    (this.lastChar[1] = e[e.length - 1]),
                    r.slice(0, -1)
                  );
              }
              return r;
            }
            return (
              (this.lastNeed = 1),
              (this.lastTotal = 2),
              (this.lastChar[0] = e[e.length - 1]),
              e.toString("utf16le", t, e.length - 1)
            );
          }
          function l(e) {
            var t = e && e.length ? this.write(e) : "";
            if (this.lastNeed) {
              var r = this.lastTotal - this.lastNeed;
              return t + this.lastChar.toString("utf16le", 0, r);
            }
            return t;
          }
          function h(e, t) {
            var r = (e.length - t) % 3;
            return 0 === r
              ? e.toString("base64", t)
              : ((this.lastNeed = 3 - r),
                (this.lastTotal = 3),
                1 === r
                  ? (this.lastChar[0] = e[e.length - 1])
                  : ((this.lastChar[0] = e[e.length - 2]),
                    (this.lastChar[1] = e[e.length - 1])),
                e.toString("base64", t, e.length - r));
          }
          function u(e) {
            var t = e && e.length ? this.write(e) : "";
            return this.lastNeed
              ? t + this.lastChar.toString("base64", 0, 3 - this.lastNeed)
              : t;
          }
          function d(e) {
            return e.toString(this.encoding);
          }
          function p(e) {
            return e && e.length ? this.write(e) : "";
          }
          (t.I = n),
            (n.prototype.write = function (e) {
              if (0 === e.length) return "";
              var t, r;
              if (this.lastNeed) {
                if (void 0 === (t = this.fillLast(e))) return "";
                (r = this.lastNeed), (this.lastNeed = 0);
              } else r = 0;
              return r < e.length
                ? t
                  ? t + this.text(e, r)
                  : this.text(e, r)
                : t || "";
            }),
            (n.prototype.end = function (e) {
              var t = e && e.length ? this.write(e) : "";
              return this.lastNeed ? t + "" : t;
            }),
            (n.prototype.text = function (e, t) {
              var r = (function (e, t, r) {
                var i = t.length - 1;
                if (i < r) return 0;
                var s = a(t[i]);
                if (s >= 0) return s > 0 && (e.lastNeed = s - 1), s;
                if (--i < r || -2 === s) return 0;
                if (((s = a(t[i])), s >= 0))
                  return s > 0 && (e.lastNeed = s - 2), s;
                if (--i < r || -2 === s) return 0;
                if (((s = a(t[i])), s >= 0))
                  return s > 0 && (2 === s ? (s = 0) : (e.lastNeed = s - 3)), s;
                return 0;
              })(this, e, t);
              if (!this.lastNeed) return e.toString("utf8", t);
              this.lastTotal = r;
              var i = e.length - (r - this.lastNeed);
              return e.copy(this.lastChar, 0, i), e.toString("utf8", t, i);
            }),
            (n.prototype.fillLast = function (e) {
              if (this.lastNeed <= e.length)
                return (
                  e.copy(
                    this.lastChar,
                    this.lastTotal - this.lastNeed,
                    0,
                    this.lastNeed
                  ),
                  this.lastChar.toString(this.encoding, 0, this.lastTotal)
                );
              e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e.length),
                (this.lastNeed -= e.length);
            });
        },
        7983: (e) => {
          const t = /^[-+]?0x[a-fA-F0-9]+$/,
            r =
              /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
          !Number.parseInt &&
            window.parseInt &&
            (Number.parseInt = window.parseInt),
            !Number.parseFloat &&
              window.parseFloat &&
              (Number.parseFloat = window.parseFloat);
          const i = {
            hex: !0,
            leadingZeros: !0,
            decimalPoint: ".",
            eNotation: !0,
          };
          e.exports = function (e, s = {}) {
            if (((s = Object.assign({}, i, s)), !e || "string" != typeof e))
              return e;
            let n = e.trim();
            if (void 0 !== s.skipLike && s.skipLike.test(n)) return e;
            if (s.hex && t.test(n)) return Number.parseInt(n, 16);
            {
              const t = r.exec(n);
              if (t) {
                const r = t[1],
                  i = t[2];
                let a = (function (e) {
                  if (e && -1 !== e.indexOf("."))
                    return (
                      "." === (e = e.replace(/0+$/, ""))
                        ? (e = "0")
                        : "." === e[0]
                        ? (e = "0" + e)
                        : "." === e[e.length - 1] &&
                          (e = e.substr(0, e.length - 1)),
                      e
                    );
                  return e;
                })(t[3]);
                const o = t[4] || t[6];
                if (!s.leadingZeros && i.length > 0 && r && "." !== n[2])
                  return e;
                if (!s.leadingZeros && i.length > 0 && !r && "." !== n[1])
                  return e;
                {
                  const t = Number(n),
                    c = "" + t;
                  return -1 !== c.search(/[eE]/) || o
                    ? s.eNotation
                      ? t
                      : e
                    : -1 !== n.indexOf(".")
                    ? ("0" === c && "" === a) || c === a || (r && c === "-" + a)
                      ? t
                      : e
                    : i
                    ? a === c || r + a === c
                      ? t
                      : e
                    : n === c || n === r + c
                    ? t
                    : e;
                }
              }
              return e;
            }
          };
        },
        4643: (e, t, r) => {
          function i(e) {
            try {
              if (!r.g.localStorage) return !1;
            } catch (e) {
              return !1;
            }
            var t = r.g.localStorage[e];
            return null != t && "true" === String(t).toLowerCase();
          }
          e.exports = function (e, t) {
            if (i("noDeprecation")) return e;
            var r = !1;
            return function () {
              if (!r) {
                if (i("throwDeprecation")) throw new Error(t);
                i("traceDeprecation") ? console.trace(t) : console.warn(t),
                  (r = !0);
              }
              return e.apply(this, arguments);
            };
          };
        },
        4342: (e, t, r) => {
          "use strict";
          !(function () {
            var t,
              i,
              s,
              n = 0,
              a = [];
            for (i = 0; i < 256; i++) a[i] = (i + 256).toString(16).substr(1);
            function o() {
              var e,
                r =
                  ((e = 16),
                  (!t || n + e > c.BUFFER_SIZE) &&
                    ((n = 0), (t = c.randomBytes(c.BUFFER_SIZE))),
                  t.slice(n, (n += e)));
              return (r[6] = (15 & r[6]) | 64), (r[8] = (63 & r[8]) | 128), r;
            }
            function c() {
              var e = o();
              return (
                a[e[0]] +
                a[e[1]] +
                a[e[2]] +
                a[e[3]] +
                "-" +
                a[e[4]] +
                a[e[5]] +
                "-" +
                a[e[6]] +
                a[e[7]] +
                "-" +
                a[e[8]] +
                a[e[9]] +
                "-" +
                a[e[10]] +
                a[e[11]] +
                a[e[12]] +
                a[e[13]] +
                a[e[14]] +
                a[e[15]]
              );
            }
            (c.BUFFER_SIZE = 4096),
              (c.bin = o),
              (c.clearBuffer = function () {
                (t = null), (n = 0);
              }),
              (c.test = function (e) {
                return (
                  "string" == typeof e &&
                  /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(
                    e
                  )
                );
              }),
              "undefined" != typeof crypto
                ? (s = crypto)
                : "undefined" != typeof window &&
                  void 0 !== window.msCrypto &&
                  (s = window.msCrypto),
              (s = s || r(575)),
              (e.exports = c),
              (c.randomBytes = (function () {
                if (s) {
                  if (s.randomBytes) return s.randomBytes;
                  if (s.getRandomValues)
                    return "function" != typeof Uint8Array.prototype.slice
                      ? function (e) {
                          var t = new Uint8Array(e);
                          return s.getRandomValues(t), Array.from(t);
                        }
                      : function (e) {
                          var t = new Uint8Array(e);
                          return s.getRandomValues(t), t;
                        };
                }
                return function (e) {
                  var t,
                    r = [];
                  for (t = 0; t < e; t++) r.push(Math.floor(256 * Math.random()));
                  return r;
                };
              })());
          })();
        },
        5340: () => {},
        9838: () => {},
        575: () => {},
        8630: (e, t, r) => {
          /*! *****************************************************************************
  Copyright (C) Microsoft. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */
          var i;
          !(function (e) {
            !(function (t) {
              var i =
                  "object" == typeof globalThis
                    ? globalThis
                    : "object" == typeof r.g
                    ? r.g
                    : "object" == typeof self
                    ? self
                    : "object" == typeof this
                    ? this
                    : (function () {
                        try {
                          return Function("return this;")();
                        } catch (e) {}
                      })() ||
                      (function () {
                        try {
                          return (0, eval)("(function() { return this; })()");
                        } catch (e) {}
                      })(),
                s = n(e);
              function n(e, t) {
                return function (r, i) {
                  Object.defineProperty(e, r, {
                    configurable: !0,
                    writable: !0,
                    value: i,
                  }),
                    t && t(r, i);
                };
              }
              void 0 !== i.Reflect && (s = n(i.Reflect, s)),
                (function (e, t) {
                  var r = Object.prototype.hasOwnProperty,
                    i = "function" == typeof Symbol,
                    s =
                      i && void 0 !== Symbol.toPrimitive
                        ? Symbol.toPrimitive
                        : "@@toPrimitive",
                    n =
                      i && void 0 !== Symbol.iterator
                        ? Symbol.iterator
                        : "@@iterator",
                    a = "function" == typeof Object.create,
                    o = { __proto__: [] } instanceof Array,
                    c = !a && !o,
                    l = {
                      create: a
                        ? function () {
                            return ue(Object.create(null));
                          }
                        : o
                        ? function () {
                            return ue({ __proto__: null });
                          }
                        : function () {
                            return ue({});
                          },
                      has: c
                        ? function (e, t) {
                            return r.call(e, t);
                          }
                        : function (e, t) {
                            return t in e;
                          },
                      get: c
                        ? function (e, t) {
                            return r.call(e, t) ? e[t] : void 0;
                          }
                        : function (e, t) {
                            return e[t];
                          },
                    },
                    h = Object.getPrototypeOf(Function),
                    u =
                      "function" == typeof Map &&
                      "function" == typeof Map.prototype.entries
                        ? Map
                        : ce(),
                    d =
                      "function" == typeof Set &&
                      "function" == typeof Set.prototype.entries
                        ? Set
                        : le(),
                    p = "function" == typeof WeakMap ? WeakMap : he(),
                    f = i ? Symbol.for("@reflect-metadata:registry") : void 0,
                    g = se(),
                    m = ne(g);
                  function y(e, t, r, i) {
                    if (U(r)) {
                      if (!j(e)) throw new TypeError();
                      if (!Y(t)) throw new TypeError();
                      return C(e, t);
                    }
                    if (!j(e)) throw new TypeError();
                    if (!H(t)) throw new TypeError();
                    if (!H(i) && !U(i) && !M(i)) throw new TypeError();
                    return M(i) && (i = void 0), x(e, t, (r = G(r)), i);
                  }
                  function A(e, t) {
                    function r(r, i) {
                      if (!H(r)) throw new TypeError();
                      if (!U(i) && !X(i)) throw new TypeError();
                      D(e, t, r, i);
                    }
                    return r;
                  }
                  function w(e, t, r, i) {
                    if (!H(r)) throw new TypeError();
                    return U(i) || (i = G(i)), D(e, t, r, i);
                  }
                  function E(e, t, r) {
                    if (!H(t)) throw new TypeError();
                    return U(r) || (r = G(r)), N(e, t, r);
                  }
                  function b(e, t, r) {
                    if (!H(t)) throw new TypeError();
                    return U(r) || (r = G(r)), k(e, t, r);
                  }
                  function v(e, t, r) {
                    if (!H(t)) throw new TypeError();
                    return U(r) || (r = G(r)), R(e, t, r);
                  }
                  function I(e, t, r) {
                    if (!H(t)) throw new TypeError();
                    return U(r) || (r = G(r)), B(e, t, r);
                  }
                  function S(e, t) {
                    if (!H(e)) throw new TypeError();
                    return U(t) || (t = G(t)), O(e, t);
                  }
                  function T(e, t) {
                    if (!H(e)) throw new TypeError();
                    return U(t) || (t = G(t)), L(e, t);
                  }
                  function _(e, t, r) {
                    if (!H(t)) throw new TypeError();
                    if ((U(r) || (r = G(r)), !H(t))) throw new TypeError();
                    U(r) || (r = G(r));
                    var i = oe(t, r, !1);
                    return !U(i) && i.OrdinaryDeleteMetadata(e, t, r);
                  }
                  function C(e, t) {
                    for (var r = e.length - 1; r >= 0; --r) {
                      var i = (0, e[r])(t);
                      if (!U(i) && !M(i)) {
                        if (!Y(i)) throw new TypeError();
                        t = i;
                      }
                    }
                    return t;
                  }
                  function x(e, t, r, i) {
                    for (var s = e.length - 1; s >= 0; --s) {
                      var n = (0, e[s])(t, r, i);
                      if (!U(n) && !M(n)) {
                        if (!H(n)) throw new TypeError();
                        i = n;
                      }
                    }
                    return i;
                  }
                  function N(e, t, r) {
                    if (k(e, t, r)) return !0;
                    var i = re(t);
                    return !M(i) && N(e, i, r);
                  }
                  function k(e, t, r) {
                    var i = oe(t, r, !1);
                    return !U(i) && z(i.OrdinaryHasOwnMetadata(e, t, r));
                  }
                  function R(e, t, r) {
                    if (k(e, t, r)) return B(e, t, r);
                    var i = re(t);
                    return M(i) ? void 0 : R(e, i, r);
                  }
                  function B(e, t, r) {
                    var i = oe(t, r, !1);
                    if (!U(i)) return i.OrdinaryGetOwnMetadata(e, t, r);
                  }
                  function D(e, t, r, i) {
                    oe(r, i, !0).OrdinaryDefineOwnMetadata(e, t, r, i);
                  }
                  function O(e, t) {
                    var r = L(e, t),
                      i = re(e);
                    if (null === i) return r;
                    var s = O(i, t);
                    if (s.length <= 0) return r;
                    if (r.length <= 0) return s;
                    for (
                      var n = new d(), a = [], o = 0, c = r;
                      o < c.length;
                      o++
                    ) {
                      var l = c[o];
                      n.has(l) || (n.add(l), a.push(l));
                    }
                    for (var h = 0, u = s; h < u.length; h++) {
                      l = u[h];
                      n.has(l) || (n.add(l), a.push(l));
                    }
                    return a;
                  }
                  function L(e, t) {
                    var r = oe(e, t, !1);
                    return r ? r.OrdinaryOwnMetadataKeys(e, t) : [];
                  }
                  function P(e) {
                    if (null === e) return 1;
                    switch (typeof e) {
                      case "undefined":
                        return 0;
                      case "boolean":
                        return 2;
                      case "string":
                        return 3;
                      case "symbol":
                        return 4;
                      case "number":
                        return 5;
                      case "object":
                        return null === e ? 1 : 6;
                      default:
                        return 6;
                    }
                  }
                  function U(e) {
                    return void 0 === e;
                  }
                  function M(e) {
                    return null === e;
                  }
                  function F(e) {
                    return "symbol" == typeof e;
                  }
                  function H(e) {
                    return "object" == typeof e
                      ? null !== e
                      : "function" == typeof e;
                  }
                  function Q(e, t) {
                    switch (P(e)) {
                      case 0:
                      case 1:
                      case 2:
                      case 3:
                      case 4:
                      case 5:
                        return e;
                    }
                    var r = 3 === t ? "string" : 5 === t ? "number" : "default",
                      i = J(e, s);
                    if (void 0 !== i) {
                      var n = i.call(e, r);
                      if (H(n)) throw new TypeError();
                      return n;
                    }
                    return V(e, "default" === r ? "number" : r);
                  }
                  function V(e, t) {
                    if ("string" === t) {
                      var r = e.toString;
                      if (W(r)) if (!H((s = r.call(e)))) return s;
                      if (W((i = e.valueOf))) if (!H((s = i.call(e)))) return s;
                    } else {
                      var i;
                      if (W((i = e.valueOf))) if (!H((s = i.call(e)))) return s;
                      var s,
                        n = e.toString;
                      if (W(n)) if (!H((s = n.call(e)))) return s;
                    }
                    throw new TypeError();
                  }
                  function z(e) {
                    return !!e;
                  }
                  function q(e) {
                    return "" + e;
                  }
                  function G(e) {
                    var t = Q(e, 3);
                    return F(t) ? t : q(t);
                  }
                  function j(e) {
                    return Array.isArray
                      ? Array.isArray(e)
                      : e instanceof Object
                      ? e instanceof Array
                      : "[object Array]" === Object.prototype.toString.call(e);
                  }
                  function W(e) {
                    return "function" == typeof e;
                  }
                  function Y(e) {
                    return "function" == typeof e;
                  }
                  function X(e) {
                    switch (P(e)) {
                      case 3:
                      case 4:
                        return !0;
                      default:
                        return !1;
                    }
                  }
                  function K(e, t) {
                    return e === t || (e != e && t != t);
                  }
                  function J(e, t) {
                    var r = e[t];
                    if (null != r) {
                      if (!W(r)) throw new TypeError();
                      return r;
                    }
                  }
                  function Z(e) {
                    var t = J(e, n);
                    if (!W(t)) throw new TypeError();
                    var r = t.call(e);
                    if (!H(r)) throw new TypeError();
                    return r;
                  }
                  function $(e) {
                    return e.value;
                  }
                  function ee(e) {
                    var t = e.next();
                    return !t.done && t;
                  }
                  function te(e) {
                    var t = e.return;
                    t && t.call(e);
                  }
                  function re(e) {
                    var t = Object.getPrototypeOf(e);
                    if ("function" != typeof e || e === h) return t;
                    if (t !== h) return t;
                    var r = e.prototype,
                      i = r && Object.getPrototypeOf(r);
                    if (null == i || i === Object.prototype) return t;
                    var s = i.constructor;
                    return "function" != typeof s || s === e ? t : s;
                  }
                  function ie() {
                    var e, r, i, s;
                    U(f) ||
                      void 0 === t.Reflect ||
                      f in t.Reflect ||
                      "function" != typeof t.Reflect.defineMetadata ||
                      (e = ae(t.Reflect));
                    var n = new p(),
                      a = { registerProvider: o, getProvider: l, setProvider: g };
                    return a;
                    function o(t) {
                      if (!Object.isExtensible(a))
                        throw new Error(
                          "Cannot add provider to a frozen registry."
                        );
                      switch (!0) {
                        case e === t:
                          break;
                        case U(r):
                          r = t;
                          break;
                        case r === t:
                          break;
                        case U(i):
                          i = t;
                          break;
                        case i === t:
                          break;
                        default:
                          void 0 === s && (s = new d()), s.add(t);
                      }
                    }
                    function c(t, n) {
                      if (!U(r)) {
                        if (r.isProviderFor(t, n)) return r;
                        if (!U(i)) {
                          if (i.isProviderFor(t, n)) return r;
                          if (!U(s))
                            for (var a = Z(s); ; ) {
                              var o = ee(a);
                              if (!o) return;
                              var c = $(o);
                              if (c.isProviderFor(t, n)) return te(a), c;
                            }
                        }
                      }
                      if (!U(e) && e.isProviderFor(t, n)) return e;
                    }
                    function l(e, t) {
                      var r,
                        i = n.get(e);
                      return (
                        U(i) || (r = i.get(t)),
                        U(r)
                          ? (U((r = c(e, t))) ||
                              (U(i) && ((i = new u()), n.set(e, i)), i.set(t, r)),
                            r)
                          : r
                      );
                    }
                    function h(e) {
                      if (U(e)) throw new TypeError();
                      return r === e || i === e || (!U(s) && s.has(e));
                    }
                    function g(e, t, r) {
                      if (!h(r))
                        throw new Error("Metadata provider not registered.");
                      var i = l(e, t);
                      if (i !== r) {
                        if (!U(i)) return !1;
                        var s = n.get(e);
                        U(s) && ((s = new u()), n.set(e, s)), s.set(t, r);
                      }
                      return !0;
                    }
                  }
                  function se() {
                    var e;
                    return (
                      !U(f) &&
                        H(t.Reflect) &&
                        Object.isExtensible(t.Reflect) &&
                        (e = t.Reflect[f]),
                      U(e) && (e = ie()),
                      !U(f) &&
                        H(t.Reflect) &&
                        Object.isExtensible(t.Reflect) &&
                        Object.defineProperty(t.Reflect, f, {
                          enumerable: !1,
                          configurable: !1,
                          writable: !1,
                          value: e,
                        }),
                      e
                    );
                  }
                  function ne(e) {
                    var t = new p(),
                      r = {
                        isProviderFor: function (e, r) {
                          var i = t.get(e);
                          return !U(i) && i.has(r);
                        },
                        OrdinaryDefineOwnMetadata: a,
                        OrdinaryHasOwnMetadata: s,
                        OrdinaryGetOwnMetadata: n,
                        OrdinaryOwnMetadataKeys: o,
                        OrdinaryDeleteMetadata: c,
                      };
                    return g.registerProvider(r), r;
                    function i(i, s, n) {
                      var a = t.get(i),
                        o = !1;
                      if (U(a)) {
                        if (!n) return;
                        (a = new u()), t.set(i, a), (o = !0);
                      }
                      var c = a.get(s);
                      if (U(c)) {
                        if (!n) return;
                        if (((c = new u()), a.set(s, c), !e.setProvider(i, s, r)))
                          throw (
                            (a.delete(s),
                            o && t.delete(i),
                            new Error("Wrong provider for target."))
                          );
                      }
                      return c;
                    }
                    function s(e, t, r) {
                      var s = i(t, r, !1);
                      return !U(s) && z(s.has(e));
                    }
                    function n(e, t, r) {
                      var s = i(t, r, !1);
                      if (!U(s)) return s.get(e);
                    }
                    function a(e, t, r, s) {
                      i(r, s, !0).set(e, t);
                    }
                    function o(e, t) {
                      var r = [],
                        s = i(e, t, !1);
                      if (U(s)) return r;
                      for (var n = Z(s.keys()), a = 0; ; ) {
                        var o = ee(n);
                        if (!o) return (r.length = a), r;
                        var c = $(o);
                        try {
                          r[a] = c;
                        } catch (e) {
                          try {
                            te(n);
                          } finally {
                            throw e;
                          }
                        }
                        a++;
                      }
                    }
                    function c(e, r, s) {
                      var n = i(r, s, !1);
                      if (U(n)) return !1;
                      if (!n.delete(e)) return !1;
                      if (0 === n.size) {
                        var a = t.get(r);
                        U(a) || (a.delete(s), 0 === a.size && t.delete(a));
                      }
                      return !0;
                    }
                  }
                  function ae(e) {
                    var t = e.defineMetadata,
                      r = e.hasOwnMetadata,
                      i = e.getOwnMetadata,
                      s = e.getOwnMetadataKeys,
                      n = e.deleteMetadata,
                      a = new p();
                    return {
                      isProviderFor: function (e, t) {
                        var r = a.get(e);
                        return (
                          !(U(r) || !r.has(t)) ||
                          (!!s(e, t).length &&
                            (U(r) && ((r = new d()), a.set(e, r)), r.add(t), !0))
                        );
                      },
                      OrdinaryDefineOwnMetadata: t,
                      OrdinaryHasOwnMetadata: r,
                      OrdinaryGetOwnMetadata: i,
                      OrdinaryOwnMetadataKeys: s,
                      OrdinaryDeleteMetadata: n,
                    };
                  }
                  function oe(e, t, r) {
                    var i = g.getProvider(e, t);
                    if (!U(i)) return i;
                    if (r) {
                      if (g.setProvider(e, t, m)) return m;
                      throw new Error("Illegal state.");
                    }
                  }
                  function ce() {
                    var e = {},
                      t = [],
                      r = (function () {
                        function e(e, t, r) {
                          (this._index = 0),
                            (this._keys = e),
                            (this._values = t),
                            (this._selector = r);
                        }
                        return (
                          (e.prototype["@@iterator"] = function () {
                            return this;
                          }),
                          (e.prototype[n] = function () {
                            return this;
                          }),
                          (e.prototype.next = function () {
                            var e = this._index;
                            if (e >= 0 && e < this._keys.length) {
                              var r = this._selector(
                                this._keys[e],
                                this._values[e]
                              );
                              return (
                                e + 1 >= this._keys.length
                                  ? ((this._index = -1),
                                    (this._keys = t),
                                    (this._values = t))
                                  : this._index++,
                                { value: r, done: !1 }
                              );
                            }
                            return { value: void 0, done: !0 };
                          }),
                          (e.prototype.throw = function (e) {
                            throw (
                              (this._index >= 0 &&
                                ((this._index = -1),
                                (this._keys = t),
                                (this._values = t)),
                              e)
                            );
                          }),
                          (e.prototype.return = function (e) {
                            return (
                              this._index >= 0 &&
                                ((this._index = -1),
                                (this._keys = t),
                                (this._values = t)),
                              { value: e, done: !0 }
                            );
                          }),
                          e
                        );
                      })(),
                      i = (function () {
                        function t() {
                          (this._keys = []),
                            (this._values = []),
                            (this._cacheKey = e),
                            (this._cacheIndex = -2);
                        }
                        return (
                          Object.defineProperty(t.prototype, "size", {
                            get: function () {
                              return this._keys.length;
                            },
                            enumerable: !0,
                            configurable: !0,
                          }),
                          (t.prototype.has = function (e) {
                            return this._find(e, !1) >= 0;
                          }),
                          (t.prototype.get = function (e) {
                            var t = this._find(e, !1);
                            return t >= 0 ? this._values[t] : void 0;
                          }),
                          (t.prototype.set = function (e, t) {
                            var r = this._find(e, !0);
                            return (this._values[r] = t), this;
                          }),
                          (t.prototype.delete = function (t) {
                            var r = this._find(t, !1);
                            if (r >= 0) {
                              for (
                                var i = this._keys.length, s = r + 1;
                                s < i;
                                s++
                              )
                                (this._keys[s - 1] = this._keys[s]),
                                  (this._values[s - 1] = this._values[s]);
                              return (
                                this._keys.length--,
                                this._values.length--,
                                K(t, this._cacheKey) &&
                                  ((this._cacheKey = e), (this._cacheIndex = -2)),
                                !0
                              );
                            }
                            return !1;
                          }),
                          (t.prototype.clear = function () {
                            (this._keys.length = 0),
                              (this._values.length = 0),
                              (this._cacheKey = e),
                              (this._cacheIndex = -2);
                          }),
                          (t.prototype.keys = function () {
                            return new r(this._keys, this._values, s);
                          }),
                          (t.prototype.values = function () {
                            return new r(this._keys, this._values, a);
                          }),
                          (t.prototype.entries = function () {
                            return new r(this._keys, this._values, o);
                          }),
                          (t.prototype["@@iterator"] = function () {
                            return this.entries();
                          }),
                          (t.prototype[n] = function () {
                            return this.entries();
                          }),
                          (t.prototype._find = function (e, t) {
                            if (!K(this._cacheKey, e)) {
                              this._cacheIndex = -1;
                              for (var r = 0; r < this._keys.length; r++)
                                if (K(this._keys[r], e)) {
                                  this._cacheIndex = r;
                                  break;
                                }
                            }
                            return (
                              this._cacheIndex < 0 &&
                                t &&
                                ((this._cacheIndex = this._keys.length),
                                this._keys.push(e),
                                this._values.push(void 0)),
                              this._cacheIndex
                            );
                          }),
                          t
                        );
                      })();
                    return i;
                    function s(e, t) {
                      return e;
                    }
                    function a(e, t) {
                      return t;
                    }
                    function o(e, t) {
                      return [e, t];
                    }
                  }
                  function le() {
                    return (function () {
                      function e() {
                        this._map = new u();
                      }
                      return (
                        Object.defineProperty(e.prototype, "size", {
                          get: function () {
                            return this._map.size;
                          },
                          enumerable: !0,
                          configurable: !0,
                        }),
                        (e.prototype.has = function (e) {
                          return this._map.has(e);
                        }),
                        (e.prototype.add = function (e) {
                          return this._map.set(e, e), this;
                        }),
                        (e.prototype.delete = function (e) {
                          return this._map.delete(e);
                        }),
                        (e.prototype.clear = function () {
                          this._map.clear();
                        }),
                        (e.prototype.keys = function () {
                          return this._map.keys();
                        }),
                        (e.prototype.values = function () {
                          return this._map.keys();
                        }),
                        (e.prototype.entries = function () {
                          return this._map.entries();
                        }),
                        (e.prototype["@@iterator"] = function () {
                          return this.keys();
                        }),
                        (e.prototype[n] = function () {
                          return this.keys();
                        }),
                        e
                      );
                    })();
                  }
                  function he() {
                    var e = 16,
                      t = l.create(),
                      i = s();
                    return (function () {
                      function e() {
                        this._key = s();
                      }
                      return (
                        (e.prototype.has = function (e) {
                          var t = n(e, !1);
                          return void 0 !== t && l.has(t, this._key);
                        }),
                        (e.prototype.get = function (e) {
                          var t = n(e, !1);
                          return void 0 !== t ? l.get(t, this._key) : void 0;
                        }),
                        (e.prototype.set = function (e, t) {
                          return (n(e, !0)[this._key] = t), this;
                        }),
                        (e.prototype.delete = function (e) {
                          var t = n(e, !1);
                          return void 0 !== t && delete t[this._key];
                        }),
                        (e.prototype.clear = function () {
                          this._key = s();
                        }),
                        e
                      );
                    })();
                    function s() {
                      var e;
                      do {
                        e = "@@WeakMap@@" + c();
                      } while (l.has(t, e));
                      return (t[e] = !0), e;
                    }
                    function n(e, t) {
                      if (!r.call(e, i)) {
                        if (!t) return;
                        Object.defineProperty(e, i, { value: l.create() });
                      }
                      return e[i];
                    }
                    function a(e, t) {
                      for (var r = 0; r < t; ++r)
                        e[r] = (255 * Math.random()) | 0;
                      return e;
                    }
                    function o(e) {
                      if ("function" == typeof Uint8Array) {
                        var t = new Uint8Array(e);
                        return (
                          "undefined" != typeof crypto
                            ? crypto.getRandomValues(t)
                            : "undefined" != typeof msCrypto
                            ? msCrypto.getRandomValues(t)
                            : a(t, e),
                          t
                        );
                      }
                      return a(new Array(e), e);
                    }
                    function c() {
                      var t = o(e);
                      (t[6] = (79 & t[6]) | 64), (t[8] = (191 & t[8]) | 128);
                      for (var r = "", i = 0; i < e; ++i) {
                        var s = t[i];
                        (4 !== i && 6 !== i && 8 !== i) || (r += "-"),
                          s < 16 && (r += "0"),
                          (r += s.toString(16).toLowerCase());
                      }
                      return r;
                    }
                  }
                  function ue(e) {
                    return (e.__ = void 0), delete e.__, e;
                  }
                  e("decorate", y),
                    e("metadata", A),
                    e("defineMetadata", w),
                    e("hasMetadata", E),
                    e("hasOwnMetadata", b),
                    e("getMetadata", v),
                    e("getOwnMetadata", I),
                    e("getMetadataKeys", S),
                    e("getOwnMetadataKeys", T),
                    e("deleteMetadata", _);
                })(s, i),
                void 0 === i.Reflect && (i.Reflect = e);
            })();
          })(i || (i = {}));
        },
      },
      t = {};
    function r(i) {
      var s = t[i];
      if (void 0 !== s) return s.exports;
      var n = (t[i] = { exports: {} });
      return e[i].call(n.exports, n, n.exports, r), n.exports;
    }
    (r.d = (e, t) => {
      for (var i in t)
        r.o(t, i) &&
          !r.o(e, i) &&
          Object.defineProperty(e, i, { enumerable: !0, get: t[i] });
    }),
      (r.g = (function () {
        if ("object" == typeof globalThis) return globalThis;
        try {
          return this || new Function("return this")();
        } catch (e) {
          if ("object" == typeof window) return window;
        }
      })()),
      (r.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t)),
      (r.r = (e) => {
        "undefined" != typeof Symbol &&
          Symbol.toStringTag &&
          Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }),
          Object.defineProperty(e, "__esModule", { value: !0 });
      });
    var i = {};
    (() => {
      "use strict";
      r.r(i);
      var e = {};
      r.r(e),
        r.d(e, {
          Any: () => zu,
          BaseBlock: () => nh,
          BaseStringBlock: () => oh,
          BitString: () => iu,
          BmpString: () => Su,
          Boolean: () => $h,
          CharacterString: () => Lu,
          Choice: () => qu,
          Constructed: () => Yh,
          DATE: () => Mu,
          DateTime: () => Hu,
          Duration: () => Qu,
          EndOfContent: () => Kh,
          Enumerated: () => lu,
          GeneralString: () => Ou,
          GeneralizedTime: () => Uu,
          GraphicString: () => Bu,
          HexBlock: () => $l,
          IA5String: () => Ru,
          Integer: () => cu,
          Null: () => Jh,
          NumericString: () => Cu,
          ObjectIdentifier: () => du,
          OctetString: () => tu,
          Primitive: () => qh,
          PrintableString: () => xu,
          RawData: () => ju,
          RelativeObjectIdentifier: () => gu,
          Repeated: () => Gu,
          Sequence: () => mu,
          Set: () => yu,
          TIME: () => Vu,
          TeletexString: () => Nu,
          TimeOfDay: () => Fu,
          UTCTime: () => Pu,
          UniversalString: () => _u,
          Utf8String: () => vu,
          ValueBlock: () => th,
          VideotexString: () => ku,
          ViewWriter: () => Ol,
          VisibleString: () => Du,
          compareSchema: () => Wu,
          fromBER: () => jh,
          verifySchema: () => Yu,
        });
      const t = "wait_load",
        s = "ready",
        n = "paused",
        a = "running",
        o = "done";
      function c(e, t) {
        return self.chrome && self.chrome.storage
          ? new Promise((r) => {
              const i = {};
              (i[e] = t), self.chrome.storage.local.set(i, () => r());
            })
          : self.localStorage
          ? Promise.resolve(localStorage.setItem(e, t))
          : Promise.reject();
      }
      function l(e) {
        return self.chrome && self.chrome.storage
          ? new Promise((t) => {
              self.chrome.storage.local.get(e, (r) => {
                t(r[e]);
              });
            })
          : self.localStorage
          ? Promise.resolve(localStorage.getItem(e))
          : Promise.reject();
      }
      r(2384);
      var h = r(4698),
        u = r(7083);
      async function d(e, t, r) {
        const i = e;
        try {
          "chunked" === r &&
            (e = (function (e) {
              let t = 0,
                r = 0;
              const i = new TextDecoder("utf-8");
              for (; t < e.length; ) {
                let n = t;
                for (
                  ;
                  (e[n] >= 48 && e[n] <= 57) ||
                  (e[n] >= 65 && e[n] <= 70) ||
                  (e[n] >= 97 && e[n] <= 102);
  
                )
                  n++;
                if (0 === n) return e;
                if (13 != e[n] || 10 != e[n + 1]) return e;
                n += 2;
                var s = parseInt(i.decode(e.subarray(t, n)), 16);
                if (0 == s) break;
                e.set(e.subarray(n, n + s), r),
                  (n += s),
                  (r += s),
                  13 == e[n] && 10 == e[n + 1] && (n += 2),
                  (t = n);
              }
              return e.subarray(0, r);
            })(e));
        } catch (e) {
          console.log("Chunk-Encoding Ignored: " + e);
        }
        try {
          if ("br" === t) 0 === (e = h(e)).length && (e = i);
          else if ("gzip" === t || "gzip" === r) {
            const t = new u.Inflate();
            t.push(e, !0), t.result && !t.err && (e = t.result);
          }
        } catch (e) {
          console.log("Content-Encoding Ignored: " + e);
        }
        return e;
      }
      var p = r(6454);
      const f = 2e6,
        g = 921600,
        m = 1e6,
        y = 412800;
      function A(e = {}) {
        let t, r;
        const i = e && e.response && e.response.extraOpts;
        if (
          i &&
          ((t = i.adaptive_max_resolution || i.maxRes),
          (r = i.adaptive_max_bandwidth || i.maxBand),
          t && r)
        )
          return { maxRes: t, maxBand: r };
        let s;
        return (
          (s =
            e && e.response && !e.response.isLive
              ? { maxRes: g, maxBand: f }
              : { maxRes: y, maxBand: m }),
          e &&
            e.save &&
            ((e.save.maxRes = s.maxRes), (e.save.maxBand = s.maxBand)),
          s
        );
      }
      const w = {
        ignoreAttributes: !1,
        removeNSPrefix: !1,
        format: !1,
        suppressEmptyNode: !0,
        suppressBooleanAttributes: !1,
      };
      function E(e, t, r) {
        try {
          return (function (e, t, r) {
            const i = new p.XMLParser(w).parse(e),
              { maxRes: s, maxBand: n } = A(t);
            let a = null,
              o = 0,
              c = 0,
              l = null;
            l = Array.isArray(i.MPD.Period.AdaptationSet)
              ? i.MPD.Period.AdaptationSet
              : [i.MPD.Period.AdaptationSet];
            for (const e of l) {
              (a = null), (o = 0), (c = 0);
              let t = null;
              t = Array.isArray(e.Representation)
                ? e.Representation
                : [e.Representation];
              for (const e of t) {
                const t =
                    Number(e["@_width"] || "0") * Number(e["@_height"] || "0"),
                  r = Number(e["@_bandwidth"] || "0");
                t && s && t <= s
                  ? t > o && ((o = t), (c = r), (a = e))
                  : r <= n && r > c && ((o = t), (c = r), (a = e));
              }
              a && Array.isArray(r) && r.push(a["@_id"]),
                a && (e.Representation = [a]);
            }
            const h = new p.XMLBuilder(w),
              u = h.build(i).trim();
            return u.slice(0, 5).toLowerCase().startsWith("<?xml")
              ? u
              : "<?xml version='1.0' encoding='UTF-8'?>\n" + u;
          })(e, t, r);
        } catch (t) {
          return console.log(t), e;
        }
      }
      const b = 5e6,
        v = [
          {
            contains: ["youtube.com", "youtube-nocookie.com"],
            rxRules: [
              [
                /ytplayer.load\(\);/,
                S(
                  'ytplayer.config.args.dash = "0"; ytplayer.config.args.dashmpd = ""; {0}'
                ),
              ],
              [
                /yt\.setConfig.*PLAYER_CONFIG.*args":\s*{/,
                S('{0} "dash": "0", dashmpd: "", '),
              ],
              [
                /(?:"player":|ytplayer\.config).*"args":\s*{/,
                S('{0}"dash":"0","dashmpd":"",'),
              ],
              [
                /yt\.setConfig.*PLAYER_VARS.*?{/,
                S('{0}"dash":"0","dashmpd":"",'),
              ],
              [/ytplayer.config={args:\s*{/, S('{0}"dash":"0","dashmpd":"",')],
              [/"0"\s*?==\s*?\w+\.dash&&/m, S("1&&")],
            ],
          },
          {
            contains: ["player.vimeo.com/video/"],
            rxRules: [
              [
                /^\{.+\}$/,
                function (e) {
                  let t;
                  try {
                    t = JSON.parse(e);
                  } catch (t) {
                    return e;
                  }
                  if (t && t.request && t.request.files) {
                    const e = t.request.files;
                    if ("object" == typeof e.progressive && e.progressive.length)
                      return (
                        e.dash && ((e.__dash = e.dash), delete e.dash),
                        e.hls && ((e.__hls = e.hls), delete e.hls),
                        JSON.stringify(t)
                      );
                  }
                  return e.replace(
                    /query_string_ranges=1/g,
                    "query_string_ranges=0"
                  );
                },
              ],
            ],
          },
          {
            contains: ["master.json?query_string_ranges=0", "master.json?base64"],
            rxRules: [
              [
                /^\{.+\}$/,
                function (e, t) {
                  if (!t) return e;
                  let r = null;
                  const i = T(t);
                  try {
                    (r = JSON.parse(e)), console.log("manifest", r);
                  } catch (t) {
                    return e;
                  }
                  function s(e, t, r) {
                    if (!e) return null;
                    let i = 0,
                      s = null;
                    for (const n of e)
                      n.mime_type == r &&
                        n.bitrate > s &&
                        n.bitrate <= t &&
                        ((s = n.bitrate), (i = n));
                    return i ? [i] : e;
                  }
                  return (
                    (r.video = s(r.video, i, "video/mp4")),
                    (r.audio = s(r.audio, i, "audio/mp4")),
                    JSON.stringify(r)
                  );
                },
              ],
            ],
          },
          {
            contains: ["facebook.com/", "fbsbx.com/"],
            rxRules: [
              [/"dash_/, S('"__nodash__')],
              [/_dash"/, S('__nodash__"')],
              [/_dash_/, S("__nodash__")],
              [/"playlist/, S('"__playlist__')],
              [/"debugNoBatching\s?":(?:false|0)/, S('"debugNoBatching":true')],
              [
                /"bulkRouteFetchBatchSize\s?":(?:[^{},]+)/,
                S('"bulkRouteFetchBatchSize":1'),
              ],
              [/"maxBatchSize\s?":(?:[^{},]+)/, S('"maxBatchSize":1')],
            ],
          },
          {
            contains: ["instagram.com/"],
            rxRules: [
              [/"is_dash_eligible":(?:true|1)/, S('"is_dash_eligible":false')],
              [/"debugNoBatching\s?":(?:false|0)/, S('"debugNoBatching":true')],
            ],
          },
          {
            contains: [
              "api.twitter.com/2/",
              "twitter.com/i/api/2/",
              "twitter.com/i/api/graphql/",
              "api.x.com/2/",
              "x.com/i/api/2/",
              "x.com/i/api/graphql/",
            ],
            rxRules: [[/"video_info":.*?}]}/, _('"video_info":')]],
          },
          {
            contains: ["cdn.syndication.twimg.com/tweet-result"],
            rxRules: [[/"video":.*?viewCount":\d+}/, _('"video":')]],
          },
          {
            contains: ["/vqlweb.js"],
            rxRules: [
              [
                /\b\w+\.updatePortSize\(\);this\.updateApplicationSize\(\)(?![*])/gim,
                S("/*{0}*/"),
              ],
            ],
          },
        ],
        I = [
          {
            contains: ["youtube.com", "youtube-nocookie.com"],
            rxRules: [
              [
                /[^"]<head.*?>/,
                (e) =>
                  `\n    ${e}<script>window.MediaSource.isTypeSupported = () => false;<\/script>\n  `,
              ],
            ],
          },
          ...v,
        ];
      function S(e) {
        return (t) => e.replace("{0}", t);
      }
      function T(e) {
        let t = b;
        const r = e.response && e.response.extraOpts;
        return (
          e.save
            ? (e.save.maxBitrate = t)
            : r && r.maxBitrate && (t = r.maxBitrate),
          t
        );
      }
      function _(e) {
        return (t, r) => {
          if (!r) return t;
          const i = t;
          try {
            const i = /([\d]+)x([\d]+)/,
              s = T(r);
            t = t.slice(e.length);
            const n = JSON.parse(t);
            let a = null,
              o = 0;
            for (const e of n.variants)
              if (
                !(
                  (e.content_type && "video/mp4" !== e.content_type) ||
                  (e.type && "video/mp4" !== e.type)
                )
              )
                if (e.bitrate && e.bitrate > o && e.bitrate <= s)
                  (a = e), (o = e.bitrate);
                else if (e.src) {
                  const t = i.exec(e.src);
                  if (t) {
                    const r = Number(t[1]) * Number(t[2]);
                    r > o && ((o = r), (a = e));
                  }
                }
            return a && (n.variants = [a]), e + JSON.stringify(n);
          } catch (e) {
            return console.warn("rewriter error: ", e), i;
          }
        };
      }
      class C {
        constructor(e, t) {
          (this.rwRules = t || v), (this.RewriterCls = e), this._initRules();
        }
        _initRules() {
          this.rewriters = new Map();
          for (const e of this.rwRules)
            e.rxRules && this.rewriters.set(e, new this.RewriterCls(e.rxRules));
          this.defaultRewriter = new this.RewriterCls();
        }
        getCustomRewriter(e) {
          for (const t of this.rwRules)
            if (t.contains)
              for (const r of t.contains)
                if (e.indexOf(r) >= 0) {
                  const e = this.rewriters.get(t);
                  if (e) return e;
                }
          return null;
        }
        getRewriter(e) {
          return this.getCustomRewriter(e) || this.defaultRewriter;
        }
      }
      class x {
        constructor(e) {
          (this.rules = e || null),
            this.rules ? this.compileRules() : (this.rx = null);
        }
        compileRules() {
          let e = "";
          for (let t of this.rules) e && (e += "|"), (e += `(${t[0].source})`);
          const t = `(?:${e})`;
          this.rx = new RegExp(t, "gm");
        }
        doReplace(e, t, r) {
          const i = t[t.length - 2],
            s = t[t.length - 1];
          for (let e = 0; e < this.rules.length; e++) {
            const n = t[e];
            if (!n) continue;
            const a = this.rules[e][1].call(this, n, r, i, s);
            if (a) return a;
          }
          return (
            console.warn(
              `rx no match found for ${e} - rx rule contains extra matching group?`
            ),
            e
          );
        }
        rewrite(e, t) {
          return this.rx
            ? e.replace(this.rx, (e, ...r) => this.doReplace(e, r, t))
            : e;
        }
      }
      var N = [
          509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166,
          1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10,
          3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13,
          2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1,
          2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82,
          19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5,
          9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6,
          4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57,
          21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9,
          9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9,
          87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628,
          1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49,
          513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1,
          2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6,
          9, 4759, 9, 787719, 239,
        ],
        k = [
          0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4,
          48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35,
          5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2,
          1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1,
          4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1,
          65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21,
          11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28,
          11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33,
          24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36,
          17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3,
          21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47,
          21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38,
          6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7,
          3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72,
          264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1,
          2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110,
          18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78,
          18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12,
          65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16,
          0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84,
          2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2,
          6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2,
          30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61,
          147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2,
          14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3,
          2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0,
          2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2,
          2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621,
          2467, 541, 1507, 4938, 6, 4191,
        ],
        R =
          "------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------",
        B = {
          3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
          5: "class enum extends super const export import",
          6: "enum",
          strict:
            "implements interface let package private protected public static yield",
          strictBind: "eval arguments",
        },
        D =
          "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this",
        O = {
          5: D,
          "5module": D + " export import",
          6: D + " const class extends export import super",
        },
        L = /^in(stanceof)?$/,
        P = new RegExp("[" + R + "]"),
        U = new RegExp(
          "[" +
            R +
            "-----------------------------------------------------------------------------------------------------------------------------------------------------]"
        );
      function M(e, t) {
        for (var r = 65536, i = 0; i < t.length; i += 2) {
          if ((r += t[i]) > e) return !1;
          if ((r += t[i + 1]) >= e) return !0;
        }
        return !1;
      }
      function F(e, t) {
        return e < 65
          ? 36 === e
          : e < 91 ||
              (e < 97
                ? 95 === e
                : e < 123 ||
                  (e <= 65535
                    ? e >= 170 && P.test(String.fromCharCode(e))
                    : !1 !== t && M(e, k)));
      }
      function H(e, t) {
        return e < 48
          ? 36 === e
          : e < 58 ||
              (!(e < 65) &&
                (e < 91 ||
                  (e < 97
                    ? 95 === e
                    : e < 123 ||
                      (e <= 65535
                        ? e >= 170 && U.test(String.fromCharCode(e))
                        : !1 !== t && (M(e, k) || M(e, N))))));
      }
      var Q = function (e, t) {
        void 0 === t && (t = {}),
          (this.label = e),
          (this.keyword = t.keyword),
          (this.beforeExpr = !!t.beforeExpr),
          (this.startsExpr = !!t.startsExpr),
          (this.isLoop = !!t.isLoop),
          (this.isAssign = !!t.isAssign),
          (this.prefix = !!t.prefix),
          (this.postfix = !!t.postfix),
          (this.binop = t.binop || null),
          (this.updateContext = null);
      };
      function V(e, t) {
        return new Q(e, { beforeExpr: !0, binop: t });
      }
      var z = { beforeExpr: !0 },
        q = { startsExpr: !0 },
        G = {};
      function j(e, t) {
        return void 0 === t && (t = {}), (t.keyword = e), (G[e] = new Q(e, t));
      }
      var W = {
          num: new Q("num", q),
          regexp: new Q("regexp", q),
          string: new Q("string", q),
          name: new Q("name", q),
          privateId: new Q("privateId", q),
          eof: new Q("eof"),
          bracketL: new Q("[", { beforeExpr: !0, startsExpr: !0 }),
          bracketR: new Q("]"),
          braceL: new Q("{", { beforeExpr: !0, startsExpr: !0 }),
          braceR: new Q("}"),
          parenL: new Q("(", { beforeExpr: !0, startsExpr: !0 }),
          parenR: new Q(")"),
          comma: new Q(",", z),
          semi: new Q(";", z),
          colon: new Q(":", z),
          dot: new Q("."),
          question: new Q("?", z),
          questionDot: new Q("?."),
          arrow: new Q("=>", z),
          template: new Q("template"),
          invalidTemplate: new Q("invalidTemplate"),
          ellipsis: new Q("...", z),
          backQuote: new Q("`", q),
          dollarBraceL: new Q("${", { beforeExpr: !0, startsExpr: !0 }),
          eq: new Q("=", { beforeExpr: !0, isAssign: !0 }),
          assign: new Q("_=", { beforeExpr: !0, isAssign: !0 }),
          incDec: new Q("++/--", { prefix: !0, postfix: !0, startsExpr: !0 }),
          prefix: new Q("!/~", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
          logicalOR: V("||", 1),
          logicalAND: V("&&", 2),
          bitwiseOR: V("|", 3),
          bitwiseXOR: V("^", 4),
          bitwiseAND: V("&", 5),
          equality: V("==/!=/===/!==", 6),
          relational: V("</>/<=/>=", 7),
          bitShift: V("<</>>/>>>", 8),
          plusMin: new Q("+/-", {
            beforeExpr: !0,
            binop: 9,
            prefix: !0,
            startsExpr: !0,
          }),
          modulo: V("%", 10),
          star: V("*", 10),
          slash: V("/", 10),
          starstar: new Q("**", { beforeExpr: !0 }),
          coalesce: V("??", 1),
          _break: j("break"),
          _case: j("case", z),
          _catch: j("catch"),
          _continue: j("continue"),
          _debugger: j("debugger"),
          _default: j("default", z),
          _do: j("do", { isLoop: !0, beforeExpr: !0 }),
          _else: j("else", z),
          _finally: j("finally"),
          _for: j("for", { isLoop: !0 }),
          _function: j("function", q),
          _if: j("if"),
          _return: j("return", z),
          _switch: j("switch"),
          _throw: j("throw", z),
          _try: j("try"),
          _var: j("var"),
          _const: j("const"),
          _while: j("while", { isLoop: !0 }),
          _with: j("with"),
          _new: j("new", { beforeExpr: !0, startsExpr: !0 }),
          _this: j("this", q),
          _super: j("super", q),
          _class: j("class", q),
          _extends: j("extends", z),
          _export: j("export"),
          _import: j("import", q),
          _null: j("null", q),
          _true: j("true", q),
          _false: j("false", q),
          _in: j("in", { beforeExpr: !0, binop: 7 }),
          _instanceof: j("instanceof", { beforeExpr: !0, binop: 7 }),
          _typeof: j("typeof", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
          _void: j("void", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
          _delete: j("delete", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
        },
        Y = /\r\n?|\n|\u2028|\u2029/,
        X = new RegExp(Y.source, "g");
      function K(e) {
        return 10 === e || 13 === e || 8232 === e || 8233 === e;
      }
      function J(e, t, r) {
        void 0 === r && (r = e.length);
        for (var i = t; i < r; i++) {
          var s = e.charCodeAt(i);
          if (K(s))
            return i < r - 1 && 13 === s && 10 === e.charCodeAt(i + 1)
              ? i + 2
              : i + 1;
        }
        return -1;
      }
      var Z = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/,
        $ = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g,
        ee = Object.prototype,
        te = ee.hasOwnProperty,
        re = ee.toString,
        ie =
          Object.hasOwn ||
          function (e, t) {
            return te.call(e, t);
          },
        se =
          Array.isArray ||
          function (e) {
            return "[object Array]" === re.call(e);
          },
        ne = Object.create(null);
      function ae(e) {
        return (
          ne[e] || (ne[e] = new RegExp("^(?:" + e.replace(/ /g, "|") + ")$"))
        );
      }
      function oe(e) {
        return e <= 65535
          ? String.fromCharCode(e)
          : ((e -= 65536),
            String.fromCharCode(55296 + (e >> 10), 56320 + (1023 & e)));
      }
      var ce =
          /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/,
        le = function (e, t) {
          (this.line = e), (this.column = t);
        };
      le.prototype.offset = function (e) {
        return new le(this.line, this.column + e);
      };
      var he = function (e, t, r) {
        (this.start = t),
          (this.end = r),
          null !== e.sourceFile && (this.source = e.sourceFile);
      };
      function ue(e, t) {
        for (var r = 1, i = 0; ; ) {
          var s = J(e, i, t);
          if (s < 0) return new le(r, t - i);
          ++r, (i = s);
        }
      }
      var de = {
          ecmaVersion: null,
          sourceType: "script",
          onInsertedSemicolon: null,
          onTrailingComma: null,
          allowReserved: null,
          allowReturnOutsideFunction: !1,
          allowImportExportEverywhere: !1,
          allowAwaitOutsideFunction: null,
          allowSuperOutsideMethod: null,
          allowHashBang: !1,
          checkPrivateFields: !0,
          locations: !1,
          onToken: null,
          onComment: null,
          ranges: !1,
          program: null,
          sourceFile: null,
          directSourceFile: null,
          preserveParens: !1,
        },
        pe = !1;
      function fe(e) {
        var t = {};
        for (var r in de) t[r] = e && ie(e, r) ? e[r] : de[r];
        if (
          ("latest" === t.ecmaVersion
            ? (t.ecmaVersion = 1e8)
            : null == t.ecmaVersion
            ? (!pe &&
                "object" == typeof console &&
                console.warn &&
                ((pe = !0),
                console.warn(
                  "Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future."
                )),
              (t.ecmaVersion = 11))
            : t.ecmaVersion >= 2015 && (t.ecmaVersion -= 2009),
          null == t.allowReserved && (t.allowReserved = t.ecmaVersion < 5),
          (e && null != e.allowHashBang) ||
            (t.allowHashBang = t.ecmaVersion >= 14),
          se(t.onToken))
        ) {
          var i = t.onToken;
          t.onToken = function (e) {
            return i.push(e);
          };
        }
        return (
          se(t.onComment) &&
            (t.onComment = (function (e, t) {
              return function (r, i, s, n, a, o) {
                var c = {
                  type: r ? "Block" : "Line",
                  value: i,
                  start: s,
                  end: n,
                };
                e.locations && (c.loc = new he(this, a, o)),
                  e.ranges && (c.range = [s, n]),
                  t.push(c);
              };
            })(t, t.onComment)),
          t
        );
      }
      var ge = 256;
      function me(e, t) {
        return 2 | (e ? 4 : 0) | (t ? 8 : 0);
      }
      var ye = function (e, t, r) {
          (this.options = e = fe(e)),
            (this.sourceFile = e.sourceFile),
            (this.keywords = ae(
              O[
                e.ecmaVersion >= 6 ? 6 : "module" === e.sourceType ? "5module" : 5
              ]
            ));
          var i = "";
          !0 !== e.allowReserved &&
            ((i = B[e.ecmaVersion >= 6 ? 6 : 5 === e.ecmaVersion ? 5 : 3]),
            "module" === e.sourceType && (i += " await")),
            (this.reservedWords = ae(i));
          var s = (i ? i + " " : "") + B.strict;
          (this.reservedWordsStrict = ae(s)),
            (this.reservedWordsStrictBind = ae(s + " " + B.strictBind)),
            (this.input = String(t)),
            (this.containsEsc = !1),
            r
              ? ((this.pos = r),
                (this.lineStart = this.input.lastIndexOf("\n", r - 1) + 1),
                (this.curLine = this.input
                  .slice(0, this.lineStart)
                  .split(Y).length))
              : ((this.pos = this.lineStart = 0), (this.curLine = 1)),
            (this.type = W.eof),
            (this.value = null),
            (this.start = this.end = this.pos),
            (this.startLoc = this.endLoc = this.curPosition()),
            (this.lastTokEndLoc = this.lastTokStartLoc = null),
            (this.lastTokStart = this.lastTokEnd = this.pos),
            (this.context = this.initialContext()),
            (this.exprAllowed = !0),
            (this.inModule = "module" === e.sourceType),
            (this.strict = this.inModule || this.strictDirective(this.pos)),
            (this.potentialArrowAt = -1),
            (this.potentialArrowInForAwait = !1),
            (this.yieldPos = this.awaitPos = this.awaitIdentPos = 0),
            (this.labels = []),
            (this.undefinedExports = Object.create(null)),
            0 === this.pos &&
              e.allowHashBang &&
              "#!" === this.input.slice(0, 2) &&
              this.skipLineComment(2),
            (this.scopeStack = []),
            this.enterScope(1),
            (this.regexpState = null),
            (this.privateNameStack = []);
        },
        Ae = {
          inFunction: { configurable: !0 },
          inGenerator: { configurable: !0 },
          inAsync: { configurable: !0 },
          canAwait: { configurable: !0 },
          allowSuper: { configurable: !0 },
          allowDirectSuper: { configurable: !0 },
          treatFunctionsAsVar: { configurable: !0 },
          allowNewDotTarget: { configurable: !0 },
          inClassStaticBlock: { configurable: !0 },
        };
      (ye.prototype.parse = function () {
        var e = this.options.program || this.startNode();
        return this.nextToken(), this.parseTopLevel(e);
      }),
        (Ae.inFunction.get = function () {
          return (2 & this.currentVarScope().flags) > 0;
        }),
        (Ae.inGenerator.get = function () {
          return (
            (8 & this.currentVarScope().flags) > 0 &&
            !this.currentVarScope().inClassFieldInit
          );
        }),
        (Ae.inAsync.get = function () {
          return (
            (4 & this.currentVarScope().flags) > 0 &&
            !this.currentVarScope().inClassFieldInit
          );
        }),
        (Ae.canAwait.get = function () {
          for (var e = this.scopeStack.length - 1; e >= 0; e--) {
            var t = this.scopeStack[e];
            if (t.inClassFieldInit || t.flags & ge) return !1;
            if (2 & t.flags) return (4 & t.flags) > 0;
          }
          return (
            (this.inModule && this.options.ecmaVersion >= 13) ||
            this.options.allowAwaitOutsideFunction
          );
        }),
        (Ae.allowSuper.get = function () {
          var e = this.currentThisScope(),
            t = e.flags,
            r = e.inClassFieldInit;
          return (64 & t) > 0 || r || this.options.allowSuperOutsideMethod;
        }),
        (Ae.allowDirectSuper.get = function () {
          return (128 & this.currentThisScope().flags) > 0;
        }),
        (Ae.treatFunctionsAsVar.get = function () {
          return this.treatFunctionsAsVarInScope(this.currentScope());
        }),
        (Ae.allowNewDotTarget.get = function () {
          var e = this.currentThisScope(),
            t = e.flags,
            r = e.inClassFieldInit;
          return (258 & t) > 0 || r;
        }),
        (Ae.inClassStaticBlock.get = function () {
          return (this.currentVarScope().flags & ge) > 0;
        }),
        (ye.extend = function () {
          for (var e = [], t = arguments.length; t--; ) e[t] = arguments[t];
          for (var r = this, i = 0; i < e.length; i++) r = e[i](r);
          return r;
        }),
        (ye.parse = function (e, t) {
          return new this(t, e).parse();
        }),
        (ye.parseExpressionAt = function (e, t, r) {
          var i = new this(r, e, t);
          return i.nextToken(), i.parseExpression();
        }),
        (ye.tokenizer = function (e, t) {
          return new this(t, e);
        }),
        Object.defineProperties(ye.prototype, Ae);
      var we = ye.prototype,
        Ee = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
      (we.strictDirective = function (e) {
        if (this.options.ecmaVersion < 5) return !1;
        for (;;) {
          ($.lastIndex = e), (e += $.exec(this.input)[0].length);
          var t = Ee.exec(this.input.slice(e));
          if (!t) return !1;
          if ("use strict" === (t[1] || t[2])) {
            $.lastIndex = e + t[0].length;
            var r = $.exec(this.input),
              i = r.index + r[0].length,
              s = this.input.charAt(i);
            return (
              ";" === s ||
              "}" === s ||
              (Y.test(r[0]) &&
                !(
                  /[(`.[+\-/*%<>=,?^&]/.test(s) ||
                  ("!" === s && "=" === this.input.charAt(i + 1))
                ))
            );
          }
          (e += t[0].length),
            ($.lastIndex = e),
            (e += $.exec(this.input)[0].length),
            ";" === this.input[e] && e++;
        }
      }),
        (we.eat = function (e) {
          return this.type === e && (this.next(), !0);
        }),
        (we.isContextual = function (e) {
          return this.type === W.name && this.value === e && !this.containsEsc;
        }),
        (we.eatContextual = function (e) {
          return !!this.isContextual(e) && (this.next(), !0);
        }),
        (we.expectContextual = function (e) {
          this.eatContextual(e) || this.unexpected();
        }),
        (we.canInsertSemicolon = function () {
          return (
            this.type === W.eof ||
            this.type === W.braceR ||
            Y.test(this.input.slice(this.lastTokEnd, this.start))
          );
        }),
        (we.insertSemicolon = function () {
          if (this.canInsertSemicolon())
            return (
              this.options.onInsertedSemicolon &&
                this.options.onInsertedSemicolon(
                  this.lastTokEnd,
                  this.lastTokEndLoc
                ),
              !0
            );
        }),
        (we.semicolon = function () {
          this.eat(W.semi) || this.insertSemicolon() || this.unexpected();
        }),
        (we.afterTrailingComma = function (e, t) {
          if (this.type === e)
            return (
              this.options.onTrailingComma &&
                this.options.onTrailingComma(
                  this.lastTokStart,
                  this.lastTokStartLoc
                ),
              t || this.next(),
              !0
            );
        }),
        (we.expect = function (e) {
          this.eat(e) || this.unexpected();
        }),
        (we.unexpected = function (e) {
          this.raise(null != e ? e : this.start, "Unexpected token");
        });
      var be = function () {
        this.shorthandAssign =
          this.trailingComma =
          this.parenthesizedAssign =
          this.parenthesizedBind =
          this.doubleProto =
            -1;
      };
      (we.checkPatternErrors = function (e, t) {
        if (e) {
          e.trailingComma > -1 &&
            this.raiseRecoverable(
              e.trailingComma,
              "Comma is not permitted after the rest element"
            );
          var r = t ? e.parenthesizedAssign : e.parenthesizedBind;
          r > -1 &&
            this.raiseRecoverable(
              r,
              t ? "Assigning to rvalue" : "Parenthesized pattern"
            );
        }
      }),
        (we.checkExpressionErrors = function (e, t) {
          if (!e) return !1;
          var r = e.shorthandAssign,
            i = e.doubleProto;
          if (!t) return r >= 0 || i >= 0;
          r >= 0 &&
            this.raise(
              r,
              "Shorthand property assignments are valid only in destructuring patterns"
            ),
            i >= 0 &&
              this.raiseRecoverable(i, "Redefinition of __proto__ property");
        }),
        (we.checkYieldAwaitInDefaultParams = function () {
          this.yieldPos &&
            (!this.awaitPos || this.yieldPos < this.awaitPos) &&
            this.raise(
              this.yieldPos,
              "Yield expression cannot be a default value"
            ),
            this.awaitPos &&
              this.raise(
                this.awaitPos,
                "Await expression cannot be a default value"
              );
        }),
        (we.isSimpleAssignTarget = function (e) {
          return "ParenthesizedExpression" === e.type
            ? this.isSimpleAssignTarget(e.expression)
            : "Identifier" === e.type || "MemberExpression" === e.type;
        });
      var ve = ye.prototype;
      ve.parseTopLevel = function (e) {
        var t = Object.create(null);
        for (e.body || (e.body = []); this.type !== W.eof; ) {
          var r = this.parseStatement(null, !0, t);
          e.body.push(r);
        }
        if (this.inModule)
          for (
            var i = 0, s = Object.keys(this.undefinedExports);
            i < s.length;
            i += 1
          ) {
            var n = s[i];
            this.raiseRecoverable(
              this.undefinedExports[n].start,
              "Export '" + n + "' is not defined"
            );
          }
        return (
          this.adaptDirectivePrologue(e.body),
          this.next(),
          (e.sourceType = this.options.sourceType),
          this.finishNode(e, "Program")
        );
      };
      var Ie = { kind: "loop" },
        Se = { kind: "switch" };
      (ve.isLet = function (e) {
        if (this.options.ecmaVersion < 6 || !this.isContextual("let")) return !1;
        $.lastIndex = this.pos;
        var t = $.exec(this.input),
          r = this.pos + t[0].length,
          i = this.input.charCodeAt(r);
        if (91 === i || 92 === i) return !0;
        if (e) return !1;
        if (123 === i || (i > 55295 && i < 56320)) return !0;
        if (F(i, !0)) {
          for (var s = r + 1; H((i = this.input.charCodeAt(s)), !0); ) ++s;
          if (92 === i || (i > 55295 && i < 56320)) return !0;
          var n = this.input.slice(r, s);
          if (!L.test(n)) return !0;
        }
        return !1;
      }),
        (ve.isAsyncFunction = function () {
          if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
            return !1;
          $.lastIndex = this.pos;
          var e,
            t = $.exec(this.input),
            r = this.pos + t[0].length;
          return !(
            Y.test(this.input.slice(this.pos, r)) ||
            "function" !== this.input.slice(r, r + 8) ||
            (r + 8 !== this.input.length &&
              (H((e = this.input.charCodeAt(r + 8))) || (e > 55295 && e < 56320)))
          );
        }),
        (ve.parseStatement = function (e, t, r) {
          var i,
            s = this.type,
            n = this.startNode();
          switch ((this.isLet(e) && ((s = W._var), (i = "let")), s)) {
            case W._break:
            case W._continue:
              return this.parseBreakContinueStatement(n, s.keyword);
            case W._debugger:
              return this.parseDebuggerStatement(n);
            case W._do:
              return this.parseDoStatement(n);
            case W._for:
              return this.parseForStatement(n);
            case W._function:
              return (
                e &&
                  (this.strict || ("if" !== e && "label" !== e)) &&
                  this.options.ecmaVersion >= 6 &&
                  this.unexpected(),
                this.parseFunctionStatement(n, !1, !e)
              );
            case W._class:
              return e && this.unexpected(), this.parseClass(n, !0);
            case W._if:
              return this.parseIfStatement(n);
            case W._return:
              return this.parseReturnStatement(n);
            case W._switch:
              return this.parseSwitchStatement(n);
            case W._throw:
              return this.parseThrowStatement(n);
            case W._try:
              return this.parseTryStatement(n);
            case W._const:
            case W._var:
              return (
                (i = i || this.value),
                e && "var" !== i && this.unexpected(),
                this.parseVarStatement(n, i)
              );
            case W._while:
              return this.parseWhileStatement(n);
            case W._with:
              return this.parseWithStatement(n);
            case W.braceL:
              return this.parseBlock(!0, n);
            case W.semi:
              return this.parseEmptyStatement(n);
            case W._export:
            case W._import:
              if (this.options.ecmaVersion > 10 && s === W._import) {
                $.lastIndex = this.pos;
                var a = $.exec(this.input),
                  o = this.pos + a[0].length,
                  c = this.input.charCodeAt(o);
                if (40 === c || 46 === c)
                  return this.parseExpressionStatement(n, this.parseExpression());
              }
              return (
                this.options.allowImportExportEverywhere ||
                  (t ||
                    this.raise(
                      this.start,
                      "'import' and 'export' may only appear at the top level"
                    ),
                  this.inModule ||
                    this.raise(
                      this.start,
                      "'import' and 'export' may appear only with 'sourceType: module'"
                    )),
                s === W._import ? this.parseImport(n) : this.parseExport(n, r)
              );
            default:
              if (this.isAsyncFunction())
                return (
                  e && this.unexpected(),
                  this.next(),
                  this.parseFunctionStatement(n, !0, !e)
                );
              var l = this.value,
                h = this.parseExpression();
              return s === W.name && "Identifier" === h.type && this.eat(W.colon)
                ? this.parseLabeledStatement(n, l, h, e)
                : this.parseExpressionStatement(n, h);
          }
        }),
        (ve.parseBreakContinueStatement = function (e, t) {
          var r = "break" === t;
          this.next(),
            this.eat(W.semi) || this.insertSemicolon()
              ? (e.label = null)
              : this.type !== W.name
              ? this.unexpected()
              : ((e.label = this.parseIdent()), this.semicolon());
          for (var i = 0; i < this.labels.length; ++i) {
            var s = this.labels[i];
            if (null == e.label || s.name === e.label.name) {
              if (null != s.kind && (r || "loop" === s.kind)) break;
              if (e.label && r) break;
            }
          }
          return (
            i === this.labels.length && this.raise(e.start, "Unsyntactic " + t),
            this.finishNode(e, r ? "BreakStatement" : "ContinueStatement")
          );
        }),
        (ve.parseDebuggerStatement = function (e) {
          return (
            this.next(), this.semicolon(), this.finishNode(e, "DebuggerStatement")
          );
        }),
        (ve.parseDoStatement = function (e) {
          return (
            this.next(),
            this.labels.push(Ie),
            (e.body = this.parseStatement("do")),
            this.labels.pop(),
            this.expect(W._while),
            (e.test = this.parseParenExpression()),
            this.options.ecmaVersion >= 6 ? this.eat(W.semi) : this.semicolon(),
            this.finishNode(e, "DoWhileStatement")
          );
        }),
        (ve.parseForStatement = function (e) {
          this.next();
          var t =
            this.options.ecmaVersion >= 9 &&
            this.canAwait &&
            this.eatContextual("await")
              ? this.lastTokStart
              : -1;
          if (
            (this.labels.push(Ie),
            this.enterScope(0),
            this.expect(W.parenL),
            this.type === W.semi)
          )
            return t > -1 && this.unexpected(t), this.parseFor(e, null);
          var r = this.isLet();
          if (this.type === W._var || this.type === W._const || r) {
            var i = this.startNode(),
              s = r ? "let" : this.value;
            return (
              this.next(),
              this.parseVar(i, !0, s),
              this.finishNode(i, "VariableDeclaration"),
              (this.type === W._in ||
                (this.options.ecmaVersion >= 6 && this.isContextual("of"))) &&
              1 === i.declarations.length
                ? (this.options.ecmaVersion >= 9 &&
                    (this.type === W._in
                      ? t > -1 && this.unexpected(t)
                      : (e.await = t > -1)),
                  this.parseForIn(e, i))
                : (t > -1 && this.unexpected(t), this.parseFor(e, i))
            );
          }
          var n = this.isContextual("let"),
            a = !1,
            o = new be(),
            c = this.parseExpression(!(t > -1) || "await", o);
          return this.type === W._in ||
            (a = this.options.ecmaVersion >= 6 && this.isContextual("of"))
            ? (this.options.ecmaVersion >= 9 &&
                (this.type === W._in
                  ? t > -1 && this.unexpected(t)
                  : (e.await = t > -1)),
              n &&
                a &&
                this.raise(
                  c.start,
                  "The left-hand side of a for-of loop may not start with 'let'."
                ),
              this.toAssignable(c, !1, o),
              this.checkLValPattern(c),
              this.parseForIn(e, c))
            : (this.checkExpressionErrors(o, !0),
              t > -1 && this.unexpected(t),
              this.parseFor(e, c));
        }),
        (ve.parseFunctionStatement = function (e, t, r) {
          return this.next(), this.parseFunction(e, _e | (r ? 0 : Ce), !1, t);
        }),
        (ve.parseIfStatement = function (e) {
          return (
            this.next(),
            (e.test = this.parseParenExpression()),
            (e.consequent = this.parseStatement("if")),
            (e.alternate = this.eat(W._else) ? this.parseStatement("if") : null),
            this.finishNode(e, "IfStatement")
          );
        }),
        (ve.parseReturnStatement = function (e) {
          return (
            this.inFunction ||
              this.options.allowReturnOutsideFunction ||
              this.raise(this.start, "'return' outside of function"),
            this.next(),
            this.eat(W.semi) || this.insertSemicolon()
              ? (e.argument = null)
              : ((e.argument = this.parseExpression()), this.semicolon()),
            this.finishNode(e, "ReturnStatement")
          );
        }),
        (ve.parseSwitchStatement = function (e) {
          var t;
          this.next(),
            (e.discriminant = this.parseParenExpression()),
            (e.cases = []),
            this.expect(W.braceL),
            this.labels.push(Se),
            this.enterScope(0);
          for (var r = !1; this.type !== W.braceR; )
            if (this.type === W._case || this.type === W._default) {
              var i = this.type === W._case;
              t && this.finishNode(t, "SwitchCase"),
                e.cases.push((t = this.startNode())),
                (t.consequent = []),
                this.next(),
                i
                  ? (t.test = this.parseExpression())
                  : (r &&
                      this.raiseRecoverable(
                        this.lastTokStart,
                        "Multiple default clauses"
                      ),
                    (r = !0),
                    (t.test = null)),
                this.expect(W.colon);
            } else
              t || this.unexpected(),
                t.consequent.push(this.parseStatement(null));
          return (
            this.exitScope(),
            t && this.finishNode(t, "SwitchCase"),
            this.next(),
            this.labels.pop(),
            this.finishNode(e, "SwitchStatement")
          );
        }),
        (ve.parseThrowStatement = function (e) {
          return (
            this.next(),
            Y.test(this.input.slice(this.lastTokEnd, this.start)) &&
              this.raise(this.lastTokEnd, "Illegal newline after throw"),
            (e.argument = this.parseExpression()),
            this.semicolon(),
            this.finishNode(e, "ThrowStatement")
          );
        });
      var Te = [];
      (ve.parseCatchClauseParam = function () {
        var e = this.parseBindingAtom(),
          t = "Identifier" === e.type;
        return (
          this.enterScope(t ? 32 : 0),
          this.checkLValPattern(e, t ? 4 : 2),
          this.expect(W.parenR),
          e
        );
      }),
        (ve.parseTryStatement = function (e) {
          if (
            (this.next(),
            (e.block = this.parseBlock()),
            (e.handler = null),
            this.type === W._catch)
          ) {
            var t = this.startNode();
            this.next(),
              this.eat(W.parenL)
                ? (t.param = this.parseCatchClauseParam())
                : (this.options.ecmaVersion < 10 && this.unexpected(),
                  (t.param = null),
                  this.enterScope(0)),
              (t.body = this.parseBlock(!1)),
              this.exitScope(),
              (e.handler = this.finishNode(t, "CatchClause"));
          }
          return (
            (e.finalizer = this.eat(W._finally) ? this.parseBlock() : null),
            e.handler ||
              e.finalizer ||
              this.raise(e.start, "Missing catch or finally clause"),
            this.finishNode(e, "TryStatement")
          );
        }),
        (ve.parseVarStatement = function (e, t, r) {
          return (
            this.next(),
            this.parseVar(e, !1, t, r),
            this.semicolon(),
            this.finishNode(e, "VariableDeclaration")
          );
        }),
        (ve.parseWhileStatement = function (e) {
          return (
            this.next(),
            (e.test = this.parseParenExpression()),
            this.labels.push(Ie),
            (e.body = this.parseStatement("while")),
            this.labels.pop(),
            this.finishNode(e, "WhileStatement")
          );
        }),
        (ve.parseWithStatement = function (e) {
          return (
            this.strict && this.raise(this.start, "'with' in strict mode"),
            this.next(),
            (e.object = this.parseParenExpression()),
            (e.body = this.parseStatement("with")),
            this.finishNode(e, "WithStatement")
          );
        }),
        (ve.parseEmptyStatement = function (e) {
          return this.next(), this.finishNode(e, "EmptyStatement");
        }),
        (ve.parseLabeledStatement = function (e, t, r, i) {
          for (var s = 0, n = this.labels; s < n.length; s += 1) {
            n[s].name === t &&
              this.raise(r.start, "Label '" + t + "' is already declared");
          }
          for (
            var a = this.type.isLoop
                ? "loop"
                : this.type === W._switch
                ? "switch"
                : null,
              o = this.labels.length - 1;
            o >= 0;
            o--
          ) {
            var c = this.labels[o];
            if (c.statementStart !== e.start) break;
            (c.statementStart = this.start), (c.kind = a);
          }
          return (
            this.labels.push({ name: t, kind: a, statementStart: this.start }),
            (e.body = this.parseStatement(
              i ? (-1 === i.indexOf("label") ? i + "label" : i) : "label"
            )),
            this.labels.pop(),
            (e.label = r),
            this.finishNode(e, "LabeledStatement")
          );
        }),
        (ve.parseExpressionStatement = function (e, t) {
          return (
            (e.expression = t),
            this.semicolon(),
            this.finishNode(e, "ExpressionStatement")
          );
        }),
        (ve.parseBlock = function (e, t, r) {
          for (
            void 0 === e && (e = !0),
              void 0 === t && (t = this.startNode()),
              t.body = [],
              this.expect(W.braceL),
              e && this.enterScope(0);
            this.type !== W.braceR;
  
          ) {
            var i = this.parseStatement(null);
            t.body.push(i);
          }
          return (
            r && (this.strict = !1),
            this.next(),
            e && this.exitScope(),
            this.finishNode(t, "BlockStatement")
          );
        }),
        (ve.parseFor = function (e, t) {
          return (
            (e.init = t),
            this.expect(W.semi),
            (e.test = this.type === W.semi ? null : this.parseExpression()),
            this.expect(W.semi),
            (e.update = this.type === W.parenR ? null : this.parseExpression()),
            this.expect(W.parenR),
            (e.body = this.parseStatement("for")),
            this.exitScope(),
            this.labels.pop(),
            this.finishNode(e, "ForStatement")
          );
        }),
        (ve.parseForIn = function (e, t) {
          var r = this.type === W._in;
          return (
            this.next(),
            "VariableDeclaration" === t.type &&
              null != t.declarations[0].init &&
              (!r ||
                this.options.ecmaVersion < 8 ||
                this.strict ||
                "var" !== t.kind ||
                "Identifier" !== t.declarations[0].id.type) &&
              this.raise(
                t.start,
                (r ? "for-in" : "for-of") +
                  " loop variable declaration may not have an initializer"
              ),
            (e.left = t),
            (e.right = r ? this.parseExpression() : this.parseMaybeAssign()),
            this.expect(W.parenR),
            (e.body = this.parseStatement("for")),
            this.exitScope(),
            this.labels.pop(),
            this.finishNode(e, r ? "ForInStatement" : "ForOfStatement")
          );
        }),
        (ve.parseVar = function (e, t, r, i) {
          for (e.declarations = [], e.kind = r; ; ) {
            var s = this.startNode();
            if (
              (this.parseVarId(s, r),
              this.eat(W.eq)
                ? (s.init = this.parseMaybeAssign(t))
                : i ||
                  "const" !== r ||
                  this.type === W._in ||
                  (this.options.ecmaVersion >= 6 && this.isContextual("of"))
                ? i ||
                  "Identifier" === s.id.type ||
                  (t && (this.type === W._in || this.isContextual("of")))
                  ? (s.init = null)
                  : this.raise(
                      this.lastTokEnd,
                      "Complex binding patterns require an initialization value"
                    )
                : this.unexpected(),
              e.declarations.push(this.finishNode(s, "VariableDeclarator")),
              !this.eat(W.comma))
            )
              break;
          }
          return e;
        }),
        (ve.parseVarId = function (e, t) {
          (e.id = this.parseBindingAtom()),
            this.checkLValPattern(e.id, "var" === t ? 1 : 2, !1);
        });
      var _e = 1,
        Ce = 2;
      function xe(e, t) {
        var r = t.key.name,
          i = e[r],
          s = "true";
        return (
          "MethodDefinition" !== t.type ||
            ("get" !== t.kind && "set" !== t.kind) ||
            (s = (t.static ? "s" : "i") + t.kind),
          ("iget" === i && "iset" === s) ||
          ("iset" === i && "iget" === s) ||
          ("sget" === i && "sset" === s) ||
          ("sset" === i && "sget" === s)
            ? ((e[r] = "true"), !1)
            : !!i || ((e[r] = s), !1)
        );
      }
      function Ne(e, t) {
        var r = e.computed,
          i = e.key;
        return (
          !r &&
          (("Identifier" === i.type && i.name === t) ||
            ("Literal" === i.type && i.value === t))
        );
      }
      (ve.parseFunction = function (e, t, r, i, s) {
        this.initFunction(e),
          (this.options.ecmaVersion >= 9 ||
            (this.options.ecmaVersion >= 6 && !i)) &&
            (this.type === W.star && t & Ce && this.unexpected(),
            (e.generator = this.eat(W.star))),
          this.options.ecmaVersion >= 8 && (e.async = !!i),
          t & _e &&
            ((e.id = 4 & t && this.type !== W.name ? null : this.parseIdent()),
            !e.id ||
              t & Ce ||
              this.checkLValSimple(
                e.id,
                this.strict || e.generator || e.async
                  ? this.treatFunctionsAsVar
                    ? 1
                    : 2
                  : 3
              ));
        var n = this.yieldPos,
          a = this.awaitPos,
          o = this.awaitIdentPos;
        return (
          (this.yieldPos = 0),
          (this.awaitPos = 0),
          (this.awaitIdentPos = 0),
          this.enterScope(me(e.async, e.generator)),
          t & _e || (e.id = this.type === W.name ? this.parseIdent() : null),
          this.parseFunctionParams(e),
          this.parseFunctionBody(e, r, !1, s),
          (this.yieldPos = n),
          (this.awaitPos = a),
          (this.awaitIdentPos = o),
          this.finishNode(
            e,
            t & _e ? "FunctionDeclaration" : "FunctionExpression"
          )
        );
      }),
        (ve.parseFunctionParams = function (e) {
          this.expect(W.parenL),
            (e.params = this.parseBindingList(
              W.parenR,
              !1,
              this.options.ecmaVersion >= 8
            )),
            this.checkYieldAwaitInDefaultParams();
        }),
        (ve.parseClass = function (e, t) {
          this.next();
          var r = this.strict;
          (this.strict = !0), this.parseClassId(e, t), this.parseClassSuper(e);
          var i = this.enterClassBody(),
            s = this.startNode(),
            n = !1;
          for (s.body = [], this.expect(W.braceL); this.type !== W.braceR; ) {
            var a = this.parseClassElement(null !== e.superClass);
            a &&
              (s.body.push(a),
              "MethodDefinition" === a.type && "constructor" === a.kind
                ? (n &&
                    this.raiseRecoverable(
                      a.start,
                      "Duplicate constructor in the same class"
                    ),
                  (n = !0))
                : a.key &&
                  "PrivateIdentifier" === a.key.type &&
                  xe(i, a) &&
                  this.raiseRecoverable(
                    a.key.start,
                    "Identifier '#" + a.key.name + "' has already been declared"
                  ));
          }
          return (
            (this.strict = r),
            this.next(),
            (e.body = this.finishNode(s, "ClassBody")),
            this.exitClassBody(),
            this.finishNode(e, t ? "ClassDeclaration" : "ClassExpression")
          );
        }),
        (ve.parseClassElement = function (e) {
          if (this.eat(W.semi)) return null;
          var t = this.options.ecmaVersion,
            r = this.startNode(),
            i = "",
            s = !1,
            n = !1,
            a = "method",
            o = !1;
          if (this.eatContextual("static")) {
            if (t >= 13 && this.eat(W.braceL))
              return this.parseClassStaticBlock(r), r;
            this.isClassElementNameStart() || this.type === W.star
              ? (o = !0)
              : (i = "static");
          }
          if (
            ((r.static = o),
            !i &&
              t >= 8 &&
              this.eatContextual("async") &&
              ((!this.isClassElementNameStart() && this.type !== W.star) ||
              this.canInsertSemicolon()
                ? (i = "async")
                : (n = !0)),
            !i && (t >= 9 || !n) && this.eat(W.star) && (s = !0),
            !i && !n && !s)
          ) {
            var c = this.value;
            (this.eatContextual("get") || this.eatContextual("set")) &&
              (this.isClassElementNameStart() ? (a = c) : (i = c));
          }
          if (
            (i
              ? ((r.computed = !1),
                (r.key = this.startNodeAt(
                  this.lastTokStart,
                  this.lastTokStartLoc
                )),
                (r.key.name = i),
                this.finishNode(r.key, "Identifier"))
              : this.parseClassElementName(r),
            t < 13 || this.type === W.parenL || "method" !== a || s || n)
          ) {
            var l = !r.static && Ne(r, "constructor"),
              h = l && e;
            l &&
              "method" !== a &&
              this.raise(r.key.start, "Constructor can't have get/set modifier"),
              (r.kind = l ? "constructor" : a),
              this.parseClassMethod(r, s, n, h);
          } else this.parseClassField(r);
          return r;
        }),
        (ve.isClassElementNameStart = function () {
          return (
            this.type === W.name ||
            this.type === W.privateId ||
            this.type === W.num ||
            this.type === W.string ||
            this.type === W.bracketL ||
            this.type.keyword
          );
        }),
        (ve.parseClassElementName = function (e) {
          this.type === W.privateId
            ? ("constructor" === this.value &&
                this.raise(
                  this.start,
                  "Classes can't have an element named '#constructor'"
                ),
              (e.computed = !1),
              (e.key = this.parsePrivateIdent()))
            : this.parsePropertyName(e);
        }),
        (ve.parseClassMethod = function (e, t, r, i) {
          var s = e.key;
          "constructor" === e.kind
            ? (t && this.raise(s.start, "Constructor can't be a generator"),
              r && this.raise(s.start, "Constructor can't be an async method"))
            : e.static &&
              Ne(e, "prototype") &&
              this.raise(
                s.start,
                "Classes may not have a static property named prototype"
              );
          var n = (e.value = this.parseMethod(t, r, i));
          return (
            "get" === e.kind &&
              0 !== n.params.length &&
              this.raiseRecoverable(n.start, "getter should have no params"),
            "set" === e.kind &&
              1 !== n.params.length &&
              this.raiseRecoverable(
                n.start,
                "setter should have exactly one param"
              ),
            "set" === e.kind &&
              "RestElement" === n.params[0].type &&
              this.raiseRecoverable(
                n.params[0].start,
                "Setter cannot use rest params"
              ),
            this.finishNode(e, "MethodDefinition")
          );
        }),
        (ve.parseClassField = function (e) {
          if (
            (Ne(e, "constructor")
              ? this.raise(
                  e.key.start,
                  "Classes can't have a field named 'constructor'"
                )
              : e.static &&
                Ne(e, "prototype") &&
                this.raise(
                  e.key.start,
                  "Classes can't have a static field named 'prototype'"
                ),
            this.eat(W.eq))
          ) {
            var t = this.currentThisScope(),
              r = t.inClassFieldInit;
            (t.inClassFieldInit = !0),
              (e.value = this.parseMaybeAssign()),
              (t.inClassFieldInit = r);
          } else e.value = null;
          return this.semicolon(), this.finishNode(e, "PropertyDefinition");
        }),
        (ve.parseClassStaticBlock = function (e) {
          e.body = [];
          var t = this.labels;
          for (this.labels = [], this.enterScope(320); this.type !== W.braceR; ) {
            var r = this.parseStatement(null);
            e.body.push(r);
          }
          return (
            this.next(),
            this.exitScope(),
            (this.labels = t),
            this.finishNode(e, "StaticBlock")
          );
        }),
        (ve.parseClassId = function (e, t) {
          this.type === W.name
            ? ((e.id = this.parseIdent()), t && this.checkLValSimple(e.id, 2, !1))
            : (!0 === t && this.unexpected(), (e.id = null));
        }),
        (ve.parseClassSuper = function (e) {
          e.superClass = this.eat(W._extends)
            ? this.parseExprSubscripts(null, !1)
            : null;
        }),
        (ve.enterClassBody = function () {
          var e = { declared: Object.create(null), used: [] };
          return this.privateNameStack.push(e), e.declared;
        }),
        (ve.exitClassBody = function () {
          var e = this.privateNameStack.pop(),
            t = e.declared,
            r = e.used;
          if (this.options.checkPrivateFields)
            for (
              var i = this.privateNameStack.length,
                s = 0 === i ? null : this.privateNameStack[i - 1],
                n = 0;
              n < r.length;
              ++n
            ) {
              var a = r[n];
              ie(t, a.name) ||
                (s
                  ? s.used.push(a)
                  : this.raiseRecoverable(
                      a.start,
                      "Private field '#" +
                        a.name +
                        "' must be declared in an enclosing class"
                    ));
            }
        }),
        (ve.parseExportAllDeclaration = function (e, t) {
          return (
            this.options.ecmaVersion >= 11 &&
              (this.eatContextual("as")
                ? ((e.exported = this.parseModuleExportName()),
                  this.checkExport(t, e.exported, this.lastTokStart))
                : (e.exported = null)),
            this.expectContextual("from"),
            this.type !== W.string && this.unexpected(),
            (e.source = this.parseExprAtom()),
            this.semicolon(),
            this.finishNode(e, "ExportAllDeclaration")
          );
        }),
        (ve.parseExport = function (e, t) {
          if ((this.next(), this.eat(W.star)))
            return this.parseExportAllDeclaration(e, t);
          if (this.eat(W._default))
            return (
              this.checkExport(t, "default", this.lastTokStart),
              (e.declaration = this.parseExportDefaultDeclaration()),
              this.finishNode(e, "ExportDefaultDeclaration")
            );
          if (this.shouldParseExportStatement())
            (e.declaration = this.parseExportDeclaration(e)),
              "VariableDeclaration" === e.declaration.type
                ? this.checkVariableExport(t, e.declaration.declarations)
                : this.checkExport(t, e.declaration.id, e.declaration.id.start),
              (e.specifiers = []),
              (e.source = null);
          else {
            if (
              ((e.declaration = null),
              (e.specifiers = this.parseExportSpecifiers(t)),
              this.eatContextual("from"))
            )
              this.type !== W.string && this.unexpected(),
                (e.source = this.parseExprAtom());
            else {
              for (var r = 0, i = e.specifiers; r < i.length; r += 1) {
                var s = i[r];
                this.checkUnreserved(s.local),
                  this.checkLocalExport(s.local),
                  "Literal" === s.local.type &&
                    this.raise(
                      s.local.start,
                      "A string literal cannot be used as an exported binding without `from`."
                    );
              }
              e.source = null;
            }
            this.semicolon();
          }
          return this.finishNode(e, "ExportNamedDeclaration");
        }),
        (ve.parseExportDeclaration = function (e) {
          return this.parseStatement(null);
        }),
        (ve.parseExportDefaultDeclaration = function () {
          var e;
          if (this.type === W._function || (e = this.isAsyncFunction())) {
            var t = this.startNode();
            return (
              this.next(), e && this.next(), this.parseFunction(t, 4 | _e, !1, e)
            );
          }
          if (this.type === W._class) {
            var r = this.startNode();
            return this.parseClass(r, "nullableID");
          }
          var i = this.parseMaybeAssign();
          return this.semicolon(), i;
        }),
        (ve.checkExport = function (e, t, r) {
          e &&
            ("string" != typeof t &&
              (t = "Identifier" === t.type ? t.name : t.value),
            ie(e, t) && this.raiseRecoverable(r, "Duplicate export '" + t + "'"),
            (e[t] = !0));
        }),
        (ve.checkPatternExport = function (e, t) {
          var r = t.type;
          if ("Identifier" === r) this.checkExport(e, t, t.start);
          else if ("ObjectPattern" === r)
            for (var i = 0, s = t.properties; i < s.length; i += 1) {
              var n = s[i];
              this.checkPatternExport(e, n);
            }
          else if ("ArrayPattern" === r)
            for (var a = 0, o = t.elements; a < o.length; a += 1) {
              var c = o[a];
              c && this.checkPatternExport(e, c);
            }
          else
            "Property" === r
              ? this.checkPatternExport(e, t.value)
              : "AssignmentPattern" === r
              ? this.checkPatternExport(e, t.left)
              : "RestElement" === r && this.checkPatternExport(e, t.argument);
        }),
        (ve.checkVariableExport = function (e, t) {
          if (e)
            for (var r = 0, i = t; r < i.length; r += 1) {
              var s = i[r];
              this.checkPatternExport(e, s.id);
            }
        }),
        (ve.shouldParseExportStatement = function () {
          return (
            "var" === this.type.keyword ||
            "const" === this.type.keyword ||
            "class" === this.type.keyword ||
            "function" === this.type.keyword ||
            this.isLet() ||
            this.isAsyncFunction()
          );
        }),
        (ve.parseExportSpecifier = function (e) {
          var t = this.startNode();
          return (
            (t.local = this.parseModuleExportName()),
            (t.exported = this.eatContextual("as")
              ? this.parseModuleExportName()
              : t.local),
            this.checkExport(e, t.exported, t.exported.start),
            this.finishNode(t, "ExportSpecifier")
          );
        }),
        (ve.parseExportSpecifiers = function (e) {
          var t = [],
            r = !0;
          for (this.expect(W.braceL); !this.eat(W.braceR); ) {
            if (r) r = !1;
            else if ((this.expect(W.comma), this.afterTrailingComma(W.braceR)))
              break;
            t.push(this.parseExportSpecifier(e));
          }
          return t;
        }),
        (ve.parseImport = function (e) {
          return (
            this.next(),
            this.type === W.string
              ? ((e.specifiers = Te), (e.source = this.parseExprAtom()))
              : ((e.specifiers = this.parseImportSpecifiers()),
                this.expectContextual("from"),
                (e.source =
                  this.type === W.string
                    ? this.parseExprAtom()
                    : this.unexpected())),
            this.semicolon(),
            this.finishNode(e, "ImportDeclaration")
          );
        }),
        (ve.parseImportSpecifier = function () {
          var e = this.startNode();
          return (
            (e.imported = this.parseModuleExportName()),
            this.eatContextual("as")
              ? (e.local = this.parseIdent())
              : (this.checkUnreserved(e.imported), (e.local = e.imported)),
            this.checkLValSimple(e.local, 2),
            this.finishNode(e, "ImportSpecifier")
          );
        }),
        (ve.parseImportDefaultSpecifier = function () {
          var e = this.startNode();
          return (
            (e.local = this.parseIdent()),
            this.checkLValSimple(e.local, 2),
            this.finishNode(e, "ImportDefaultSpecifier")
          );
        }),
        (ve.parseImportNamespaceSpecifier = function () {
          var e = this.startNode();
          return (
            this.next(),
            this.expectContextual("as"),
            (e.local = this.parseIdent()),
            this.checkLValSimple(e.local, 2),
            this.finishNode(e, "ImportNamespaceSpecifier")
          );
        }),
        (ve.parseImportSpecifiers = function () {
          var e = [],
            t = !0;
          if (
            this.type === W.name &&
            (e.push(this.parseImportDefaultSpecifier()), !this.eat(W.comma))
          )
            return e;
          if (this.type === W.star)
            return e.push(this.parseImportNamespaceSpecifier()), e;
          for (this.expect(W.braceL); !this.eat(W.braceR); ) {
            if (t) t = !1;
            else if ((this.expect(W.comma), this.afterTrailingComma(W.braceR)))
              break;
            e.push(this.parseImportSpecifier());
          }
          return e;
        }),
        (ve.parseModuleExportName = function () {
          if (this.options.ecmaVersion >= 13 && this.type === W.string) {
            var e = this.parseLiteral(this.value);
            return (
              ce.test(e.value) &&
                this.raise(
                  e.start,
                  "An export name cannot include a lone surrogate."
                ),
              e
            );
          }
          return this.parseIdent(!0);
        }),
        (ve.adaptDirectivePrologue = function (e) {
          for (var t = 0; t < e.length && this.isDirectiveCandidate(e[t]); ++t)
            e[t].directive = e[t].expression.raw.slice(1, -1);
        }),
        (ve.isDirectiveCandidate = function (e) {
          return (
            this.options.ecmaVersion >= 5 &&
            "ExpressionStatement" === e.type &&
            "Literal" === e.expression.type &&
            "string" == typeof e.expression.value &&
            ('"' === this.input[e.start] || "'" === this.input[e.start])
          );
        });
      var ke = ye.prototype;
      (ke.toAssignable = function (e, t, r) {
        if (this.options.ecmaVersion >= 6 && e)
          switch (e.type) {
            case "Identifier":
              this.inAsync &&
                "await" === e.name &&
                this.raise(
                  e.start,
                  "Cannot use 'await' as identifier inside an async function"
                );
              break;
            case "ObjectPattern":
            case "ArrayPattern":
            case "AssignmentPattern":
            case "RestElement":
              break;
            case "ObjectExpression":
              (e.type = "ObjectPattern"), r && this.checkPatternErrors(r, !0);
              for (var i = 0, s = e.properties; i < s.length; i += 1) {
                var n = s[i];
                this.toAssignable(n, t),
                  "RestElement" !== n.type ||
                    ("ArrayPattern" !== n.argument.type &&
                      "ObjectPattern" !== n.argument.type) ||
                    this.raise(n.argument.start, "Unexpected token");
              }
              break;
            case "Property":
              "init" !== e.kind &&
                this.raise(
                  e.key.start,
                  "Object pattern can't contain getter or setter"
                ),
                this.toAssignable(e.value, t);
              break;
            case "ArrayExpression":
              (e.type = "ArrayPattern"),
                r && this.checkPatternErrors(r, !0),
                this.toAssignableList(e.elements, t);
              break;
            case "SpreadElement":
              (e.type = "RestElement"),
                this.toAssignable(e.argument, t),
                "AssignmentPattern" === e.argument.type &&
                  this.raise(
                    e.argument.start,
                    "Rest elements cannot have a default value"
                  );
              break;
            case "AssignmentExpression":
              "=" !== e.operator &&
                this.raise(
                  e.left.end,
                  "Only '=' operator can be used for specifying default value."
                ),
                (e.type = "AssignmentPattern"),
                delete e.operator,
                this.toAssignable(e.left, t);
              break;
            case "ParenthesizedExpression":
              this.toAssignable(e.expression, t, r);
              break;
            case "ChainExpression":
              this.raiseRecoverable(
                e.start,
                "Optional chaining cannot appear in left-hand side"
              );
              break;
            case "MemberExpression":
              if (!t) break;
            default:
              this.raise(e.start, "Assigning to rvalue");
          }
        else r && this.checkPatternErrors(r, !0);
        return e;
      }),
        (ke.toAssignableList = function (e, t) {
          for (var r = e.length, i = 0; i < r; i++) {
            var s = e[i];
            s && this.toAssignable(s, t);
          }
          if (r) {
            var n = e[r - 1];
            6 === this.options.ecmaVersion &&
              t &&
              n &&
              "RestElement" === n.type &&
              "Identifier" !== n.argument.type &&
              this.unexpected(n.argument.start);
          }
          return e;
        }),
        (ke.parseSpread = function (e) {
          var t = this.startNode();
          return (
            this.next(),
            (t.argument = this.parseMaybeAssign(!1, e)),
            this.finishNode(t, "SpreadElement")
          );
        }),
        (ke.parseRestBinding = function () {
          var e = this.startNode();
          return (
            this.next(),
            6 === this.options.ecmaVersion &&
              this.type !== W.name &&
              this.unexpected(),
            (e.argument = this.parseBindingAtom()),
            this.finishNode(e, "RestElement")
          );
        }),
        (ke.parseBindingAtom = function () {
          if (this.options.ecmaVersion >= 6)
            switch (this.type) {
              case W.bracketL:
                var e = this.startNode();
                return (
                  this.next(),
                  (e.elements = this.parseBindingList(W.bracketR, !0, !0)),
                  this.finishNode(e, "ArrayPattern")
                );
              case W.braceL:
                return this.parseObj(!0);
            }
          return this.parseIdent();
        }),
        (ke.parseBindingList = function (e, t, r, i) {
          for (var s = [], n = !0; !this.eat(e); )
            if ((n ? (n = !1) : this.expect(W.comma), t && this.type === W.comma))
              s.push(null);
            else {
              if (r && this.afterTrailingComma(e)) break;
              if (this.type === W.ellipsis) {
                var a = this.parseRestBinding();
                this.parseBindingListItem(a),
                  s.push(a),
                  this.type === W.comma &&
                    this.raiseRecoverable(
                      this.start,
                      "Comma is not permitted after the rest element"
                    ),
                  this.expect(e);
                break;
              }
              s.push(this.parseAssignableListItem(i));
            }
          return s;
        }),
        (ke.parseAssignableListItem = function (e) {
          var t = this.parseMaybeDefault(this.start, this.startLoc);
          return this.parseBindingListItem(t), t;
        }),
        (ke.parseBindingListItem = function (e) {
          return e;
        }),
        (ke.parseMaybeDefault = function (e, t, r) {
          if (
            ((r = r || this.parseBindingAtom()),
            this.options.ecmaVersion < 6 || !this.eat(W.eq))
          )
            return r;
          var i = this.startNodeAt(e, t);
          return (
            (i.left = r),
            (i.right = this.parseMaybeAssign()),
            this.finishNode(i, "AssignmentPattern")
          );
        }),
        (ke.checkLValSimple = function (e, t, r) {
          void 0 === t && (t = 0);
          var i = 0 !== t;
          switch (e.type) {
            case "Identifier":
              this.strict &&
                this.reservedWordsStrictBind.test(e.name) &&
                this.raiseRecoverable(
                  e.start,
                  (i ? "Binding " : "Assigning to ") + e.name + " in strict mode"
                ),
                i &&
                  (2 === t &&
                    "let" === e.name &&
                    this.raiseRecoverable(
                      e.start,
                      "let is disallowed as a lexically bound name"
                    ),
                  r &&
                    (ie(r, e.name) &&
                      this.raiseRecoverable(e.start, "Argument name clash"),
                    (r[e.name] = !0)),
                  5 !== t && this.declareName(e.name, t, e.start));
              break;
            case "ChainExpression":
              this.raiseRecoverable(
                e.start,
                "Optional chaining cannot appear in left-hand side"
              );
              break;
            case "MemberExpression":
              i && this.raiseRecoverable(e.start, "Binding member expression");
              break;
            case "ParenthesizedExpression":
              return (
                i &&
                  this.raiseRecoverable(
                    e.start,
                    "Binding parenthesized expression"
                  ),
                this.checkLValSimple(e.expression, t, r)
              );
            default:
              this.raise(e.start, (i ? "Binding" : "Assigning to") + " rvalue");
          }
        }),
        (ke.checkLValPattern = function (e, t, r) {
          switch ((void 0 === t && (t = 0), e.type)) {
            case "ObjectPattern":
              for (var i = 0, s = e.properties; i < s.length; i += 1) {
                var n = s[i];
                this.checkLValInnerPattern(n, t, r);
              }
              break;
            case "ArrayPattern":
              for (var a = 0, o = e.elements; a < o.length; a += 1) {
                var c = o[a];
                c && this.checkLValInnerPattern(c, t, r);
              }
              break;
            default:
              this.checkLValSimple(e, t, r);
          }
        }),
        (ke.checkLValInnerPattern = function (e, t, r) {
          switch ((void 0 === t && (t = 0), e.type)) {
            case "Property":
              this.checkLValInnerPattern(e.value, t, r);
              break;
            case "AssignmentPattern":
              this.checkLValPattern(e.left, t, r);
              break;
            case "RestElement":
              this.checkLValPattern(e.argument, t, r);
              break;
            default:
              this.checkLValPattern(e, t, r);
          }
        });
      var Re = function (e, t, r, i, s) {
          (this.token = e),
            (this.isExpr = !!t),
            (this.preserveSpace = !!r),
            (this.override = i),
            (this.generator = !!s);
        },
        Be = {
          b_stat: new Re("{", !1),
          b_expr: new Re("{", !0),
          b_tmpl: new Re("${", !1),
          p_stat: new Re("(", !1),
          p_expr: new Re("(", !0),
          q_tmpl: new Re("`", !0, !0, function (e) {
            return e.tryReadTemplateToken();
          }),
          f_stat: new Re("function", !1),
          f_expr: new Re("function", !0),
          f_expr_gen: new Re("function", !0, !1, null, !0),
          f_gen: new Re("function", !1, !1, null, !0),
        },
        De = ye.prototype;
      (De.initialContext = function () {
        return [Be.b_stat];
      }),
        (De.curContext = function () {
          return this.context[this.context.length - 1];
        }),
        (De.braceIsBlock = function (e) {
          var t = this.curContext();
          return (
            t === Be.f_expr ||
            t === Be.f_stat ||
            (e !== W.colon || (t !== Be.b_stat && t !== Be.b_expr)
              ? e === W._return || (e === W.name && this.exprAllowed)
                ? Y.test(this.input.slice(this.lastTokEnd, this.start))
                : e === W._else ||
                  e === W.semi ||
                  e === W.eof ||
                  e === W.parenR ||
                  e === W.arrow ||
                  (e === W.braceL
                    ? t === Be.b_stat
                    : e !== W._var &&
                      e !== W._const &&
                      e !== W.name &&
                      !this.exprAllowed)
              : !t.isExpr)
          );
        }),
        (De.inGeneratorContext = function () {
          for (var e = this.context.length - 1; e >= 1; e--) {
            var t = this.context[e];
            if ("function" === t.token) return t.generator;
          }
          return !1;
        }),
        (De.updateContext = function (e) {
          var t,
            r = this.type;
          r.keyword && e === W.dot
            ? (this.exprAllowed = !1)
            : (t = r.updateContext)
            ? t.call(this, e)
            : (this.exprAllowed = r.beforeExpr);
        }),
        (De.overrideContext = function (e) {
          this.curContext() !== e && (this.context[this.context.length - 1] = e);
        }),
        (W.parenR.updateContext = W.braceR.updateContext =
          function () {
            if (1 !== this.context.length) {
              var e = this.context.pop();
              e === Be.b_stat &&
                "function" === this.curContext().token &&
                (e = this.context.pop()),
                (this.exprAllowed = !e.isExpr);
            } else this.exprAllowed = !0;
          }),
        (W.braceL.updateContext = function (e) {
          this.context.push(this.braceIsBlock(e) ? Be.b_stat : Be.b_expr),
            (this.exprAllowed = !0);
        }),
        (W.dollarBraceL.updateContext = function () {
          this.context.push(Be.b_tmpl), (this.exprAllowed = !0);
        }),
        (W.parenL.updateContext = function (e) {
          var t = e === W._if || e === W._for || e === W._with || e === W._while;
          this.context.push(t ? Be.p_stat : Be.p_expr), (this.exprAllowed = !0);
        }),
        (W.incDec.updateContext = function () {}),
        (W._function.updateContext = W._class.updateContext =
          function (e) {
            !e.beforeExpr ||
            e === W._else ||
            (e === W.semi && this.curContext() !== Be.p_stat) ||
            (e === W._return &&
              Y.test(this.input.slice(this.lastTokEnd, this.start))) ||
            ((e === W.colon || e === W.braceL) && this.curContext() === Be.b_stat)
              ? this.context.push(Be.f_stat)
              : this.context.push(Be.f_expr),
              (this.exprAllowed = !1);
          }),
        (W.colon.updateContext = function () {
          "function" === this.curContext().token && this.context.pop(),
            (this.exprAllowed = !0);
        }),
        (W.backQuote.updateContext = function () {
          this.curContext() === Be.q_tmpl
            ? this.context.pop()
            : this.context.push(Be.q_tmpl),
            (this.exprAllowed = !1);
        }),
        (W.star.updateContext = function (e) {
          if (e === W._function) {
            var t = this.context.length - 1;
            this.context[t] === Be.f_expr
              ? (this.context[t] = Be.f_expr_gen)
              : (this.context[t] = Be.f_gen);
          }
          this.exprAllowed = !0;
        }),
        (W.name.updateContext = function (e) {
          var t = !1;
          this.options.ecmaVersion >= 6 &&
            e !== W.dot &&
            (("of" === this.value && !this.exprAllowed) ||
              ("yield" === this.value && this.inGeneratorContext())) &&
            (t = !0),
            (this.exprAllowed = t);
        });
      var Oe = ye.prototype;
      function Le(e) {
        return (
          ("MemberExpression" === e.type &&
            "PrivateIdentifier" === e.property.type) ||
          ("ChainExpression" === e.type && Le(e.expression))
        );
      }
      (Oe.checkPropClash = function (e, t, r) {
        if (
          !(
            (this.options.ecmaVersion >= 9 && "SpreadElement" === e.type) ||
            (this.options.ecmaVersion >= 6 &&
              (e.computed || e.method || e.shorthand))
          )
        ) {
          var i,
            s = e.key;
          switch (s.type) {
            case "Identifier":
              i = s.name;
              break;
            case "Literal":
              i = String(s.value);
              break;
            default:
              return;
          }
          var n = e.kind;
          if (this.options.ecmaVersion >= 6)
            "__proto__" === i &&
              "init" === n &&
              (t.proto &&
                (r
                  ? r.doubleProto < 0 && (r.doubleProto = s.start)
                  : this.raiseRecoverable(
                      s.start,
                      "Redefinition of __proto__ property"
                    )),
              (t.proto = !0));
          else {
            var a = t[(i = "$" + i)];
            if (a)
              ("init" === n
                ? (this.strict && a.init) || a.get || a.set
                : a.init || a[n]) &&
                this.raiseRecoverable(s.start, "Redefinition of property");
            else a = t[i] = { init: !1, get: !1, set: !1 };
            a[n] = !0;
          }
        }
      }),
        (Oe.parseExpression = function (e, t) {
          var r = this.start,
            i = this.startLoc,
            s = this.parseMaybeAssign(e, t);
          if (this.type === W.comma) {
            var n = this.startNodeAt(r, i);
            for (n.expressions = [s]; this.eat(W.comma); )
              n.expressions.push(this.parseMaybeAssign(e, t));
            return this.finishNode(n, "SequenceExpression");
          }
          return s;
        }),
        (Oe.parseMaybeAssign = function (e, t, r) {
          if (this.isContextual("yield")) {
            if (this.inGenerator) return this.parseYield(e);
            this.exprAllowed = !1;
          }
          var i = !1,
            s = -1,
            n = -1,
            a = -1;
          t
            ? ((s = t.parenthesizedAssign),
              (n = t.trailingComma),
              (a = t.doubleProto),
              (t.parenthesizedAssign = t.trailingComma = -1))
            : ((t = new be()), (i = !0));
          var o = this.start,
            c = this.startLoc;
          (this.type !== W.parenL && this.type !== W.name) ||
            ((this.potentialArrowAt = this.start),
            (this.potentialArrowInForAwait = "await" === e));
          var l = this.parseMaybeConditional(e, t);
          if ((r && (l = r.call(this, l, o, c)), this.type.isAssign)) {
            var h = this.startNodeAt(o, c);
            return (
              (h.operator = this.value),
              this.type === W.eq && (l = this.toAssignable(l, !1, t)),
              i || (t.parenthesizedAssign = t.trailingComma = t.doubleProto = -1),
              t.shorthandAssign >= l.start && (t.shorthandAssign = -1),
              this.type === W.eq
                ? this.checkLValPattern(l)
                : this.checkLValSimple(l),
              (h.left = l),
              this.next(),
              (h.right = this.parseMaybeAssign(e)),
              a > -1 && (t.doubleProto = a),
              this.finishNode(h, "AssignmentExpression")
            );
          }
          return (
            i && this.checkExpressionErrors(t, !0),
            s > -1 && (t.parenthesizedAssign = s),
            n > -1 && (t.trailingComma = n),
            l
          );
        }),
        (Oe.parseMaybeConditional = function (e, t) {
          var r = this.start,
            i = this.startLoc,
            s = this.parseExprOps(e, t);
          if (this.checkExpressionErrors(t)) return s;
          if (this.eat(W.question)) {
            var n = this.startNodeAt(r, i);
            return (
              (n.test = s),
              (n.consequent = this.parseMaybeAssign()),
              this.expect(W.colon),
              (n.alternate = this.parseMaybeAssign(e)),
              this.finishNode(n, "ConditionalExpression")
            );
          }
          return s;
        }),
        (Oe.parseExprOps = function (e, t) {
          var r = this.start,
            i = this.startLoc,
            s = this.parseMaybeUnary(t, !1, !1, e);
          return this.checkExpressionErrors(t) ||
            (s.start === r && "ArrowFunctionExpression" === s.type)
            ? s
            : this.parseExprOp(s, r, i, -1, e);
        }),
        (Oe.parseExprOp = function (e, t, r, i, s) {
          var n = this.type.binop;
          if (null != n && (!s || this.type !== W._in) && n > i) {
            var a = this.type === W.logicalOR || this.type === W.logicalAND,
              o = this.type === W.coalesce;
            o && (n = W.logicalAND.binop);
            var c = this.value;
            this.next();
            var l = this.start,
              h = this.startLoc,
              u = this.parseExprOp(
                this.parseMaybeUnary(null, !1, !1, s),
                l,
                h,
                n,
                s
              ),
              d = this.buildBinary(t, r, e, u, c, a || o);
            return (
              ((a && this.type === W.coalesce) ||
                (o &&
                  (this.type === W.logicalOR || this.type === W.logicalAND))) &&
                this.raiseRecoverable(
                  this.start,
                  "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses"
                ),
              this.parseExprOp(d, t, r, i, s)
            );
          }
          return e;
        }),
        (Oe.buildBinary = function (e, t, r, i, s, n) {
          "PrivateIdentifier" === i.type &&
            this.raise(
              i.start,
              "Private identifier can only be left side of binary expression"
            );
          var a = this.startNodeAt(e, t);
          return (
            (a.left = r),
            (a.operator = s),
            (a.right = i),
            this.finishNode(a, n ? "LogicalExpression" : "BinaryExpression")
          );
        }),
        (Oe.parseMaybeUnary = function (e, t, r, i) {
          var s,
            n = this.start,
            a = this.startLoc;
          if (this.isContextual("await") && this.canAwait)
            (s = this.parseAwait(i)), (t = !0);
          else if (this.type.prefix) {
            var o = this.startNode(),
              c = this.type === W.incDec;
            (o.operator = this.value),
              (o.prefix = !0),
              this.next(),
              (o.argument = this.parseMaybeUnary(null, !0, c, i)),
              this.checkExpressionErrors(e, !0),
              c
                ? this.checkLValSimple(o.argument)
                : this.strict &&
                  "delete" === o.operator &&
                  "Identifier" === o.argument.type
                ? this.raiseRecoverable(
                    o.start,
                    "Deleting local variable in strict mode"
                  )
                : "delete" === o.operator && Le(o.argument)
                ? this.raiseRecoverable(
                    o.start,
                    "Private fields can not be deleted"
                  )
                : (t = !0),
              (s = this.finishNode(
                o,
                c ? "UpdateExpression" : "UnaryExpression"
              ));
          } else if (t || this.type !== W.privateId) {
            if (
              ((s = this.parseExprSubscripts(e, i)),
              this.checkExpressionErrors(e))
            )
              return s;
            for (; this.type.postfix && !this.canInsertSemicolon(); ) {
              var l = this.startNodeAt(n, a);
              (l.operator = this.value),
                (l.prefix = !1),
                (l.argument = s),
                this.checkLValSimple(s),
                this.next(),
                (s = this.finishNode(l, "UpdateExpression"));
            }
          } else
            (i || 0 === this.privateNameStack.length) &&
              this.options.checkPrivateFields &&
              this.unexpected(),
              (s = this.parsePrivateIdent()),
              this.type !== W._in && this.unexpected();
          return r || !this.eat(W.starstar)
            ? s
            : t
            ? void this.unexpected(this.lastTokStart)
            : this.buildBinary(
                n,
                a,
                s,
                this.parseMaybeUnary(null, !1, !1, i),
                "**",
                !1
              );
        }),
        (Oe.parseExprSubscripts = function (e, t) {
          var r = this.start,
            i = this.startLoc,
            s = this.parseExprAtom(e, t);
          if (
            "ArrowFunctionExpression" === s.type &&
            ")" !== this.input.slice(this.lastTokStart, this.lastTokEnd)
          )
            return s;
          var n = this.parseSubscripts(s, r, i, !1, t);
          return (
            e &&
              "MemberExpression" === n.type &&
              (e.parenthesizedAssign >= n.start && (e.parenthesizedAssign = -1),
              e.parenthesizedBind >= n.start && (e.parenthesizedBind = -1),
              e.trailingComma >= n.start && (e.trailingComma = -1)),
            n
          );
        }),
        (Oe.parseSubscripts = function (e, t, r, i, s) {
          for (
            var n =
                this.options.ecmaVersion >= 8 &&
                "Identifier" === e.type &&
                "async" === e.name &&
                this.lastTokEnd === e.end &&
                !this.canInsertSemicolon() &&
                e.end - e.start == 5 &&
                this.potentialArrowAt === e.start,
              a = !1;
            ;
  
          ) {
            var o = this.parseSubscript(e, t, r, i, n, a, s);
            if (
              (o.optional && (a = !0),
              o === e || "ArrowFunctionExpression" === o.type)
            ) {
              if (a) {
                var c = this.startNodeAt(t, r);
                (c.expression = o), (o = this.finishNode(c, "ChainExpression"));
              }
              return o;
            }
            e = o;
          }
        }),
        (Oe.shouldParseAsyncArrow = function () {
          return !this.canInsertSemicolon() && this.eat(W.arrow);
        }),
        (Oe.parseSubscriptAsyncArrow = function (e, t, r, i) {
          return this.parseArrowExpression(this.startNodeAt(e, t), r, !0, i);
        }),
        (Oe.parseSubscript = function (e, t, r, i, s, n, a) {
          var o = this.options.ecmaVersion >= 11,
            c = o && this.eat(W.questionDot);
          i &&
            c &&
            this.raise(
              this.lastTokStart,
              "Optional chaining cannot appear in the callee of new expressions"
            );
          var l = this.eat(W.bracketL);
          if (
            l ||
            (c && this.type !== W.parenL && this.type !== W.backQuote) ||
            this.eat(W.dot)
          ) {
            var h = this.startNodeAt(t, r);
            (h.object = e),
              l
                ? ((h.property = this.parseExpression()), this.expect(W.bracketR))
                : this.type === W.privateId && "Super" !== e.type
                ? (h.property = this.parsePrivateIdent())
                : (h.property = this.parseIdent(
                    "never" !== this.options.allowReserved
                  )),
              (h.computed = !!l),
              o && (h.optional = c),
              (e = this.finishNode(h, "MemberExpression"));
          } else if (!i && this.eat(W.parenL)) {
            var u = new be(),
              d = this.yieldPos,
              p = this.awaitPos,
              f = this.awaitIdentPos;
            (this.yieldPos = 0), (this.awaitPos = 0), (this.awaitIdentPos = 0);
            var g = this.parseExprList(
              W.parenR,
              this.options.ecmaVersion >= 8,
              !1,
              u
            );
            if (s && !c && this.shouldParseAsyncArrow())
              return (
                this.checkPatternErrors(u, !1),
                this.checkYieldAwaitInDefaultParams(),
                this.awaitIdentPos > 0 &&
                  this.raise(
                    this.awaitIdentPos,
                    "Cannot use 'await' as identifier inside an async function"
                  ),
                (this.yieldPos = d),
                (this.awaitPos = p),
                (this.awaitIdentPos = f),
                this.parseSubscriptAsyncArrow(t, r, g, a)
              );
            this.checkExpressionErrors(u, !0),
              (this.yieldPos = d || this.yieldPos),
              (this.awaitPos = p || this.awaitPos),
              (this.awaitIdentPos = f || this.awaitIdentPos);
            var m = this.startNodeAt(t, r);
            (m.callee = e),
              (m.arguments = g),
              o && (m.optional = c),
              (e = this.finishNode(m, "CallExpression"));
          } else if (this.type === W.backQuote) {
            (c || n) &&
              this.raise(
                this.start,
                "Optional chaining cannot appear in the tag of tagged template expressions"
              );
            var y = this.startNodeAt(t, r);
            (y.tag = e),
              (y.quasi = this.parseTemplate({ isTagged: !0 })),
              (e = this.finishNode(y, "TaggedTemplateExpression"));
          }
          return e;
        }),
        (Oe.parseExprAtom = function (e, t, r) {
          this.type === W.slash && this.readRegexp();
          var i,
            s = this.potentialArrowAt === this.start;
          switch (this.type) {
            case W._super:
              return (
                this.allowSuper ||
                  this.raise(this.start, "'super' keyword outside a method"),
                (i = this.startNode()),
                this.next(),
                this.type !== W.parenL ||
                  this.allowDirectSuper ||
                  this.raise(
                    i.start,
                    "super() call outside constructor of a subclass"
                  ),
                this.type !== W.dot &&
                  this.type !== W.bracketL &&
                  this.type !== W.parenL &&
                  this.unexpected(),
                this.finishNode(i, "Super")
              );
            case W._this:
              return (
                (i = this.startNode()),
                this.next(),
                this.finishNode(i, "ThisExpression")
              );
            case W.name:
              var n = this.start,
                a = this.startLoc,
                o = this.containsEsc,
                c = this.parseIdent(!1);
              if (
                this.options.ecmaVersion >= 8 &&
                !o &&
                "async" === c.name &&
                !this.canInsertSemicolon() &&
                this.eat(W._function)
              )
                return (
                  this.overrideContext(Be.f_expr),
                  this.parseFunction(this.startNodeAt(n, a), 0, !1, !0, t)
                );
              if (s && !this.canInsertSemicolon()) {
                if (this.eat(W.arrow))
                  return this.parseArrowExpression(
                    this.startNodeAt(n, a),
                    [c],
                    !1,
                    t
                  );
                if (
                  this.options.ecmaVersion >= 8 &&
                  "async" === c.name &&
                  this.type === W.name &&
                  !o &&
                  (!this.potentialArrowInForAwait ||
                    "of" !== this.value ||
                    this.containsEsc)
                )
                  return (
                    (c = this.parseIdent(!1)),
                    (!this.canInsertSemicolon() && this.eat(W.arrow)) ||
                      this.unexpected(),
                    this.parseArrowExpression(this.startNodeAt(n, a), [c], !0, t)
                  );
              }
              return c;
            case W.regexp:
              var l = this.value;
              return (
                ((i = this.parseLiteral(l.value)).regex = {
                  pattern: l.pattern,
                  flags: l.flags,
                }),
                i
              );
            case W.num:
            case W.string:
              return this.parseLiteral(this.value);
            case W._null:
            case W._true:
            case W._false:
              return (
                ((i = this.startNode()).value =
                  this.type === W._null ? null : this.type === W._true),
                (i.raw = this.type.keyword),
                this.next(),
                this.finishNode(i, "Literal")
              );
            case W.parenL:
              var h = this.start,
                u = this.parseParenAndDistinguishExpression(s, t);
              return (
                e &&
                  (e.parenthesizedAssign < 0 &&
                    !this.isSimpleAssignTarget(u) &&
                    (e.parenthesizedAssign = h),
                  e.parenthesizedBind < 0 && (e.parenthesizedBind = h)),
                u
              );
            case W.bracketL:
              return (
                (i = this.startNode()),
                this.next(),
                (i.elements = this.parseExprList(W.bracketR, !0, !0, e)),
                this.finishNode(i, "ArrayExpression")
              );
            case W.braceL:
              return this.overrideContext(Be.b_expr), this.parseObj(!1, e);
            case W._function:
              return (
                (i = this.startNode()), this.next(), this.parseFunction(i, 0)
              );
            case W._class:
              return this.parseClass(this.startNode(), !1);
            case W._new:
              return this.parseNew();
            case W.backQuote:
              return this.parseTemplate();
            case W._import:
              return this.options.ecmaVersion >= 11
                ? this.parseExprImport(r)
                : this.unexpected();
            default:
              return this.parseExprAtomDefault();
          }
        }),
        (Oe.parseExprAtomDefault = function () {
          this.unexpected();
        }),
        (Oe.parseExprImport = function (e) {
          var t = this.startNode();
          if (
            (this.containsEsc &&
              this.raiseRecoverable(
                this.start,
                "Escape sequence in keyword import"
              ),
            this.next(),
            this.type === W.parenL && !e)
          )
            return this.parseDynamicImport(t);
          if (this.type === W.dot) {
            var r = this.startNodeAt(t.start, t.loc && t.loc.start);
            return (
              (r.name = "import"),
              (t.meta = this.finishNode(r, "Identifier")),
              this.parseImportMeta(t)
            );
          }
          this.unexpected();
        }),
        (Oe.parseDynamicImport = function (e) {
          if (
            (this.next(),
            (e.source = this.parseMaybeAssign()),
            !this.eat(W.parenR))
          ) {
            var t = this.start;
            this.eat(W.comma) && this.eat(W.parenR)
              ? this.raiseRecoverable(
                  t,
                  "Trailing comma is not allowed in import()"
                )
              : this.unexpected(t);
          }
          return this.finishNode(e, "ImportExpression");
        }),
        (Oe.parseImportMeta = function (e) {
          this.next();
          var t = this.containsEsc;
          return (
            (e.property = this.parseIdent(!0)),
            "meta" !== e.property.name &&
              this.raiseRecoverable(
                e.property.start,
                "The only valid meta property for import is 'import.meta'"
              ),
            t &&
              this.raiseRecoverable(
                e.start,
                "'import.meta' must not contain escaped characters"
              ),
            "module" === this.options.sourceType ||
              this.options.allowImportExportEverywhere ||
              this.raiseRecoverable(
                e.start,
                "Cannot use 'import.meta' outside a module"
              ),
            this.finishNode(e, "MetaProperty")
          );
        }),
        (Oe.parseLiteral = function (e) {
          var t = this.startNode();
          return (
            (t.value = e),
            (t.raw = this.input.slice(this.start, this.end)),
            110 === t.raw.charCodeAt(t.raw.length - 1) &&
              (t.bigint = t.raw.slice(0, -1).replace(/_/g, "")),
            this.next(),
            this.finishNode(t, "Literal")
          );
        }),
        (Oe.parseParenExpression = function () {
          this.expect(W.parenL);
          var e = this.parseExpression();
          return this.expect(W.parenR), e;
        }),
        (Oe.shouldParseArrow = function (e) {
          return !this.canInsertSemicolon();
        }),
        (Oe.parseParenAndDistinguishExpression = function (e, t) {
          var r,
            i = this.start,
            s = this.startLoc,
            n = this.options.ecmaVersion >= 8;
          if (this.options.ecmaVersion >= 6) {
            this.next();
            var a,
              o = this.start,
              c = this.startLoc,
              l = [],
              h = !0,
              u = !1,
              d = new be(),
              p = this.yieldPos,
              f = this.awaitPos;
            for (this.yieldPos = 0, this.awaitPos = 0; this.type !== W.parenR; ) {
              if (
                (h ? (h = !1) : this.expect(W.comma),
                n && this.afterTrailingComma(W.parenR, !0))
              ) {
                u = !0;
                break;
              }
              if (this.type === W.ellipsis) {
                (a = this.start),
                  l.push(this.parseParenItem(this.parseRestBinding())),
                  this.type === W.comma &&
                    this.raiseRecoverable(
                      this.start,
                      "Comma is not permitted after the rest element"
                    );
                break;
              }
              l.push(this.parseMaybeAssign(!1, d, this.parseParenItem));
            }
            var g = this.lastTokEnd,
              m = this.lastTokEndLoc;
            if (
              (this.expect(W.parenR),
              e && this.shouldParseArrow(l) && this.eat(W.arrow))
            )
              return (
                this.checkPatternErrors(d, !1),
                this.checkYieldAwaitInDefaultParams(),
                (this.yieldPos = p),
                (this.awaitPos = f),
                this.parseParenArrowList(i, s, l, t)
              );
            (l.length && !u) || this.unexpected(this.lastTokStart),
              a && this.unexpected(a),
              this.checkExpressionErrors(d, !0),
              (this.yieldPos = p || this.yieldPos),
              (this.awaitPos = f || this.awaitPos),
              l.length > 1
                ? (((r = this.startNodeAt(o, c)).expressions = l),
                  this.finishNodeAt(r, "SequenceExpression", g, m))
                : (r = l[0]);
          } else r = this.parseParenExpression();
          if (this.options.preserveParens) {
            var y = this.startNodeAt(i, s);
            return (
              (y.expression = r), this.finishNode(y, "ParenthesizedExpression")
            );
          }
          return r;
        }),
        (Oe.parseParenItem = function (e) {
          return e;
        }),
        (Oe.parseParenArrowList = function (e, t, r, i) {
          return this.parseArrowExpression(this.startNodeAt(e, t), r, !1, i);
        });
      var Pe = [];
      (Oe.parseNew = function () {
        this.containsEsc &&
          this.raiseRecoverable(this.start, "Escape sequence in keyword new");
        var e = this.startNode();
        if ((this.next(), this.options.ecmaVersion >= 6 && this.type === W.dot)) {
          var t = this.startNodeAt(e.start, e.loc && e.loc.start);
          (t.name = "new"),
            (e.meta = this.finishNode(t, "Identifier")),
            this.next();
          var r = this.containsEsc;
          return (
            (e.property = this.parseIdent(!0)),
            "target" !== e.property.name &&
              this.raiseRecoverable(
                e.property.start,
                "The only valid meta property for new is 'new.target'"
              ),
            r &&
              this.raiseRecoverable(
                e.start,
                "'new.target' must not contain escaped characters"
              ),
            this.allowNewDotTarget ||
              this.raiseRecoverable(
                e.start,
                "'new.target' can only be used in functions and class static block"
              ),
            this.finishNode(e, "MetaProperty")
          );
        }
        var i = this.start,
          s = this.startLoc;
        return (
          (e.callee = this.parseSubscripts(
            this.parseExprAtom(null, !1, !0),
            i,
            s,
            !0,
            !1
          )),
          this.eat(W.parenL)
            ? (e.arguments = this.parseExprList(
                W.parenR,
                this.options.ecmaVersion >= 8,
                !1
              ))
            : (e.arguments = Pe),
          this.finishNode(e, "NewExpression")
        );
      }),
        (Oe.parseTemplateElement = function (e) {
          var t = e.isTagged,
            r = this.startNode();
          return (
            this.type === W.invalidTemplate
              ? (t ||
                  this.raiseRecoverable(
                    this.start,
                    "Bad escape sequence in untagged template literal"
                  ),
                (r.value = { raw: this.value, cooked: null }))
              : (r.value = {
                  raw: this.input
                    .slice(this.start, this.end)
                    .replace(/\r\n?/g, "\n"),
                  cooked: this.value,
                }),
            this.next(),
            (r.tail = this.type === W.backQuote),
            this.finishNode(r, "TemplateElement")
          );
        }),
        (Oe.parseTemplate = function (e) {
          void 0 === e && (e = {});
          var t = e.isTagged;
          void 0 === t && (t = !1);
          var r = this.startNode();
          this.next(), (r.expressions = []);
          var i = this.parseTemplateElement({ isTagged: t });
          for (r.quasis = [i]; !i.tail; )
            this.type === W.eof &&
              this.raise(this.pos, "Unterminated template literal"),
              this.expect(W.dollarBraceL),
              r.expressions.push(this.parseExpression()),
              this.expect(W.braceR),
              r.quasis.push((i = this.parseTemplateElement({ isTagged: t })));
          return this.next(), this.finishNode(r, "TemplateLiteral");
        }),
        (Oe.isAsyncProp = function (e) {
          return (
            !e.computed &&
            "Identifier" === e.key.type &&
            "async" === e.key.name &&
            (this.type === W.name ||
              this.type === W.num ||
              this.type === W.string ||
              this.type === W.bracketL ||
              this.type.keyword ||
              (this.options.ecmaVersion >= 9 && this.type === W.star)) &&
            !Y.test(this.input.slice(this.lastTokEnd, this.start))
          );
        }),
        (Oe.parseObj = function (e, t) {
          var r = this.startNode(),
            i = !0,
            s = {};
          for (r.properties = [], this.next(); !this.eat(W.braceR); ) {
            if (i) i = !1;
            else if (
              (this.expect(W.comma),
              this.options.ecmaVersion >= 5 && this.afterTrailingComma(W.braceR))
            )
              break;
            var n = this.parseProperty(e, t);
            e || this.checkPropClash(n, s, t), r.properties.push(n);
          }
          return this.finishNode(r, e ? "ObjectPattern" : "ObjectExpression");
        }),
        (Oe.parseProperty = function (e, t) {
          var r,
            i,
            s,
            n,
            a = this.startNode();
          if (this.options.ecmaVersion >= 9 && this.eat(W.ellipsis))
            return e
              ? ((a.argument = this.parseIdent(!1)),
                this.type === W.comma &&
                  this.raiseRecoverable(
                    this.start,
                    "Comma is not permitted after the rest element"
                  ),
                this.finishNode(a, "RestElement"))
              : ((a.argument = this.parseMaybeAssign(!1, t)),
                this.type === W.comma &&
                  t &&
                  t.trailingComma < 0 &&
                  (t.trailingComma = this.start),
                this.finishNode(a, "SpreadElement"));
          this.options.ecmaVersion >= 6 &&
            ((a.method = !1),
            (a.shorthand = !1),
            (e || t) && ((s = this.start), (n = this.startLoc)),
            e || (r = this.eat(W.star)));
          var o = this.containsEsc;
          return (
            this.parsePropertyName(a),
            !e && !o && this.options.ecmaVersion >= 8 && !r && this.isAsyncProp(a)
              ? ((i = !0),
                (r = this.options.ecmaVersion >= 9 && this.eat(W.star)),
                this.parsePropertyName(a))
              : (i = !1),
            this.parsePropertyValue(a, e, r, i, s, n, t, o),
            this.finishNode(a, "Property")
          );
        }),
        (Oe.parseGetterSetter = function (e) {
          (e.kind = e.key.name),
            this.parsePropertyName(e),
            (e.value = this.parseMethod(!1));
          var t = "get" === e.kind ? 0 : 1;
          if (e.value.params.length !== t) {
            var r = e.value.start;
            "get" === e.kind
              ? this.raiseRecoverable(r, "getter should have no params")
              : this.raiseRecoverable(r, "setter should have exactly one param");
          } else
            "set" === e.kind &&
              "RestElement" === e.value.params[0].type &&
              this.raiseRecoverable(
                e.value.params[0].start,
                "Setter cannot use rest params"
              );
        }),
        (Oe.parsePropertyValue = function (e, t, r, i, s, n, a, o) {
          (r || i) && this.type === W.colon && this.unexpected(),
            this.eat(W.colon)
              ? ((e.value = t
                  ? this.parseMaybeDefault(this.start, this.startLoc)
                  : this.parseMaybeAssign(!1, a)),
                (e.kind = "init"))
              : this.options.ecmaVersion >= 6 && this.type === W.parenL
              ? (t && this.unexpected(),
                (e.kind = "init"),
                (e.method = !0),
                (e.value = this.parseMethod(r, i)))
              : t ||
                o ||
                !(this.options.ecmaVersion >= 5) ||
                e.computed ||
                "Identifier" !== e.key.type ||
                ("get" !== e.key.name && "set" !== e.key.name) ||
                this.type === W.comma ||
                this.type === W.braceR ||
                this.type === W.eq
              ? this.options.ecmaVersion >= 6 &&
                !e.computed &&
                "Identifier" === e.key.type
                ? ((r || i) && this.unexpected(),
                  this.checkUnreserved(e.key),
                  "await" !== e.key.name ||
                    this.awaitIdentPos ||
                    (this.awaitIdentPos = s),
                  (e.kind = "init"),
                  t
                    ? (e.value = this.parseMaybeDefault(
                        s,
                        n,
                        this.copyNode(e.key)
                      ))
                    : this.type === W.eq && a
                    ? (a.shorthandAssign < 0 && (a.shorthandAssign = this.start),
                      (e.value = this.parseMaybeDefault(
                        s,
                        n,
                        this.copyNode(e.key)
                      )))
                    : (e.value = this.copyNode(e.key)),
                  (e.shorthand = !0))
                : this.unexpected()
              : ((r || i) && this.unexpected(), this.parseGetterSetter(e));
        }),
        (Oe.parsePropertyName = function (e) {
          if (this.options.ecmaVersion >= 6) {
            if (this.eat(W.bracketL))
              return (
                (e.computed = !0),
                (e.key = this.parseMaybeAssign()),
                this.expect(W.bracketR),
                e.key
              );
            e.computed = !1;
          }
          return (e.key =
            this.type === W.num || this.type === W.string
              ? this.parseExprAtom()
              : this.parseIdent("never" !== this.options.allowReserved));
        }),
        (Oe.initFunction = function (e) {
          (e.id = null),
            this.options.ecmaVersion >= 6 && (e.generator = e.expression = !1),
            this.options.ecmaVersion >= 8 && (e.async = !1);
        }),
        (Oe.parseMethod = function (e, t, r) {
          var i = this.startNode(),
            s = this.yieldPos,
            n = this.awaitPos,
            a = this.awaitIdentPos;
          return (
            this.initFunction(i),
            this.options.ecmaVersion >= 6 && (i.generator = e),
            this.options.ecmaVersion >= 8 && (i.async = !!t),
            (this.yieldPos = 0),
            (this.awaitPos = 0),
            (this.awaitIdentPos = 0),
            this.enterScope(64 | me(t, i.generator) | (r ? 128 : 0)),
            this.expect(W.parenL),
            (i.params = this.parseBindingList(
              W.parenR,
              !1,
              this.options.ecmaVersion >= 8
            )),
            this.checkYieldAwaitInDefaultParams(),
            this.parseFunctionBody(i, !1, !0, !1),
            (this.yieldPos = s),
            (this.awaitPos = n),
            (this.awaitIdentPos = a),
            this.finishNode(i, "FunctionExpression")
          );
        }),
        (Oe.parseArrowExpression = function (e, t, r, i) {
          var s = this.yieldPos,
            n = this.awaitPos,
            a = this.awaitIdentPos;
          return (
            this.enterScope(16 | me(r, !1)),
            this.initFunction(e),
            this.options.ecmaVersion >= 8 && (e.async = !!r),
            (this.yieldPos = 0),
            (this.awaitPos = 0),
            (this.awaitIdentPos = 0),
            (e.params = this.toAssignableList(t, !0)),
            this.parseFunctionBody(e, !0, !1, i),
            (this.yieldPos = s),
            (this.awaitPos = n),
            (this.awaitIdentPos = a),
            this.finishNode(e, "ArrowFunctionExpression")
          );
        }),
        (Oe.parseFunctionBody = function (e, t, r, i) {
          var s = t && this.type !== W.braceL,
            n = this.strict,
            a = !1;
          if (s)
            (e.body = this.parseMaybeAssign(i)),
              (e.expression = !0),
              this.checkParams(e, !1);
          else {
            var o =
              this.options.ecmaVersion >= 7 && !this.isSimpleParamList(e.params);
            (n && !o) ||
              ((a = this.strictDirective(this.end)) &&
                o &&
                this.raiseRecoverable(
                  e.start,
                  "Illegal 'use strict' directive in function with non-simple parameter list"
                ));
            var c = this.labels;
            (this.labels = []),
              a && (this.strict = !0),
              this.checkParams(
                e,
                !n && !a && !t && !r && this.isSimpleParamList(e.params)
              ),
              this.strict && e.id && this.checkLValSimple(e.id, 5),
              (e.body = this.parseBlock(!1, void 0, a && !n)),
              (e.expression = !1),
              this.adaptDirectivePrologue(e.body.body),
              (this.labels = c);
          }
          this.exitScope();
        }),
        (Oe.isSimpleParamList = function (e) {
          for (var t = 0, r = e; t < r.length; t += 1) {
            if ("Identifier" !== r[t].type) return !1;
          }
          return !0;
        }),
        (Oe.checkParams = function (e, t) {
          for (
            var r = Object.create(null), i = 0, s = e.params;
            i < s.length;
            i += 1
          ) {
            var n = s[i];
            this.checkLValInnerPattern(n, 1, t ? null : r);
          }
        }),
        (Oe.parseExprList = function (e, t, r, i) {
          for (var s = [], n = !0; !this.eat(e); ) {
            if (n) n = !1;
            else if ((this.expect(W.comma), t && this.afterTrailingComma(e)))
              break;
            var a = void 0;
            r && this.type === W.comma
              ? (a = null)
              : this.type === W.ellipsis
              ? ((a = this.parseSpread(i)),
                i &&
                  this.type === W.comma &&
                  i.trailingComma < 0 &&
                  (i.trailingComma = this.start))
              : (a = this.parseMaybeAssign(!1, i)),
              s.push(a);
          }
          return s;
        }),
        (Oe.checkUnreserved = function (e) {
          var t = e.start,
            r = e.end,
            i = e.name;
          (this.inGenerator &&
            "yield" === i &&
            this.raiseRecoverable(
              t,
              "Cannot use 'yield' as identifier inside a generator"
            ),
          this.inAsync &&
            "await" === i &&
            this.raiseRecoverable(
              t,
              "Cannot use 'await' as identifier inside an async function"
            ),
          this.currentThisScope().inClassFieldInit &&
            "arguments" === i &&
            this.raiseRecoverable(
              t,
              "Cannot use 'arguments' in class field initializer"
            ),
          !this.inClassStaticBlock ||
            ("arguments" !== i && "await" !== i) ||
            this.raise(
              t,
              "Cannot use " + i + " in class static initialization block"
            ),
          this.keywords.test(i) &&
            this.raise(t, "Unexpected keyword '" + i + "'"),
          this.options.ecmaVersion < 6 &&
            -1 !== this.input.slice(t, r).indexOf("\\")) ||
            ((this.strict ? this.reservedWordsStrict : this.reservedWords).test(
              i
            ) &&
              (this.inAsync ||
                "await" !== i ||
                this.raiseRecoverable(
                  t,
                  "Cannot use keyword 'await' outside an async function"
                ),
              this.raiseRecoverable(t, "The keyword '" + i + "' is reserved")));
        }),
        (Oe.parseIdent = function (e) {
          var t = this.parseIdentNode();
          return (
            this.next(!!e),
            this.finishNode(t, "Identifier"),
            e ||
              (this.checkUnreserved(t),
              "await" !== t.name ||
                this.awaitIdentPos ||
                (this.awaitIdentPos = t.start)),
            t
          );
        }),
        (Oe.parseIdentNode = function () {
          var e = this.startNode();
          return (
            this.type === W.name
              ? (e.name = this.value)
              : this.type.keyword
              ? ((e.name = this.type.keyword),
                ("class" !== e.name && "function" !== e.name) ||
                  (this.lastTokEnd === this.lastTokStart + 1 &&
                    46 === this.input.charCodeAt(this.lastTokStart)) ||
                  this.context.pop(),
                (this.type = W.name))
              : this.unexpected(),
            e
          );
        }),
        (Oe.parsePrivateIdent = function () {
          var e = this.startNode();
          return (
            this.type === W.privateId ? (e.name = this.value) : this.unexpected(),
            this.next(),
            this.finishNode(e, "PrivateIdentifier"),
            this.options.checkPrivateFields &&
              (0 === this.privateNameStack.length
                ? this.raise(
                    e.start,
                    "Private field '#" +
                      e.name +
                      "' must be declared in an enclosing class"
                  )
                : this.privateNameStack[
                    this.privateNameStack.length - 1
                  ].used.push(e)),
            e
          );
        }),
        (Oe.parseYield = function (e) {
          this.yieldPos || (this.yieldPos = this.start);
          var t = this.startNode();
          return (
            this.next(),
            this.type === W.semi ||
            this.canInsertSemicolon() ||
            (this.type !== W.star && !this.type.startsExpr)
              ? ((t.delegate = !1), (t.argument = null))
              : ((t.delegate = this.eat(W.star)),
                (t.argument = this.parseMaybeAssign(e))),
            this.finishNode(t, "YieldExpression")
          );
        }),
        (Oe.parseAwait = function (e) {
          this.awaitPos || (this.awaitPos = this.start);
          var t = this.startNode();
          return (
            this.next(),
            (t.argument = this.parseMaybeUnary(null, !0, !1, e)),
            this.finishNode(t, "AwaitExpression")
          );
        });
      var Ue = ye.prototype;
      (Ue.raise = function (e, t) {
        var r = ue(this.input, e);
        t += " (" + r.line + ":" + r.column + ")";
        var i = new SyntaxError(t);
        throw ((i.pos = e), (i.loc = r), (i.raisedAt = this.pos), i);
      }),
        (Ue.raiseRecoverable = Ue.raise),
        (Ue.curPosition = function () {
          if (this.options.locations)
            return new le(this.curLine, this.pos - this.lineStart);
        });
      var Me = ye.prototype,
        Fe = function (e) {
          (this.flags = e),
            (this.var = []),
            (this.lexical = []),
            (this.functions = []),
            (this.inClassFieldInit = !1);
        };
      (Me.enterScope = function (e) {
        this.scopeStack.push(new Fe(e));
      }),
        (Me.exitScope = function () {
          this.scopeStack.pop();
        }),
        (Me.treatFunctionsAsVarInScope = function (e) {
          return 2 & e.flags || (!this.inModule && 1 & e.flags);
        }),
        (Me.declareName = function (e, t, r) {
          var i = !1;
          if (2 === t) {
            var s = this.currentScope();
            (i =
              s.lexical.indexOf(e) > -1 ||
              s.functions.indexOf(e) > -1 ||
              s.var.indexOf(e) > -1),
              s.lexical.push(e),
              this.inModule && 1 & s.flags && delete this.undefinedExports[e];
          } else if (4 === t) {
            this.currentScope().lexical.push(e);
          } else if (3 === t) {
            var n = this.currentScope();
            (i = this.treatFunctionsAsVar
              ? n.lexical.indexOf(e) > -1
              : n.lexical.indexOf(e) > -1 || n.var.indexOf(e) > -1),
              n.functions.push(e);
          } else
            for (var a = this.scopeStack.length - 1; a >= 0; --a) {
              var o = this.scopeStack[a];
              if (
                (o.lexical.indexOf(e) > -1 &&
                  !(32 & o.flags && o.lexical[0] === e)) ||
                (!this.treatFunctionsAsVarInScope(o) &&
                  o.functions.indexOf(e) > -1)
              ) {
                i = !0;
                break;
              }
              if (
                (o.var.push(e),
                this.inModule && 1 & o.flags && delete this.undefinedExports[e],
                259 & o.flags)
              )
                break;
            }
          i &&
            this.raiseRecoverable(
              r,
              "Identifier '" + e + "' has already been declared"
            );
        }),
        (Me.checkLocalExport = function (e) {
          -1 === this.scopeStack[0].lexical.indexOf(e.name) &&
            -1 === this.scopeStack[0].var.indexOf(e.name) &&
            (this.undefinedExports[e.name] = e);
        }),
        (Me.currentScope = function () {
          return this.scopeStack[this.scopeStack.length - 1];
        }),
        (Me.currentVarScope = function () {
          for (var e = this.scopeStack.length - 1; ; e--) {
            var t = this.scopeStack[e];
            if (259 & t.flags) return t;
          }
        }),
        (Me.currentThisScope = function () {
          for (var e = this.scopeStack.length - 1; ; e--) {
            var t = this.scopeStack[e];
            if (259 & t.flags && !(16 & t.flags)) return t;
          }
        });
      var He = function (e, t, r) {
          (this.type = ""),
            (this.start = t),
            (this.end = 0),
            e.options.locations && (this.loc = new he(e, r)),
            e.options.directSourceFile &&
              (this.sourceFile = e.options.directSourceFile),
            e.options.ranges && (this.range = [t, 0]);
        },
        Qe = ye.prototype;
      function Ve(e, t, r, i) {
        return (
          (e.type = t),
          (e.end = r),
          this.options.locations && (e.loc.end = i),
          this.options.ranges && (e.range[1] = r),
          e
        );
      }
      (Qe.startNode = function () {
        return new He(this, this.start, this.startLoc);
      }),
        (Qe.startNodeAt = function (e, t) {
          return new He(this, e, t);
        }),
        (Qe.finishNode = function (e, t) {
          return Ve.call(this, e, t, this.lastTokEnd, this.lastTokEndLoc);
        }),
        (Qe.finishNodeAt = function (e, t, r, i) {
          return Ve.call(this, e, t, r, i);
        }),
        (Qe.copyNode = function (e) {
          var t = new He(this, e.start, this.startLoc);
          for (var r in e) t[r] = e[r];
          return t;
        });
      var ze =
          "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS",
        qe = ze + " Extended_Pictographic",
        Ge = qe + " EBase EComp EMod EPres ExtPict",
        je = { 9: ze, 10: qe, 11: qe, 12: Ge, 13: Ge, 14: Ge },
        We = {
          9: "",
          10: "",
          11: "",
          12: "",
          13: "",
          14: "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji",
        },
        Ye =
          "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu",
        Xe =
          "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb",
        Ke =
          Xe +
          " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd",
        Je =
          Ke +
          " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho",
        Ze =
          Je +
          " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi",
        $e =
          Ze +
          " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith",
        et = {
          9: Xe,
          10: Ke,
          11: Je,
          12: Ze,
          13: $e,
          14:
            $e + " Hrkt Katakana_Or_Hiragana Kawi Nag_Mundari Nagm Unknown Zzzz",
        },
        tt = {};
      function rt(e) {
        var t = (tt[e] = {
          binary: ae(je[e] + " " + Ye),
          binaryOfStrings: ae(We[e]),
          nonBinary: { General_Category: ae(Ye), Script: ae(et[e]) },
        });
        (t.nonBinary.Script_Extensions = t.nonBinary.Script),
          (t.nonBinary.gc = t.nonBinary.General_Category),
          (t.nonBinary.sc = t.nonBinary.Script),
          (t.nonBinary.scx = t.nonBinary.Script_Extensions);
      }
      for (var it = 0, st = [9, 10, 11, 12, 13, 14]; it < st.length; it += 1) {
        rt(st[it]);
      }
      var nt = ye.prototype,
        at = function (e) {
          (this.parser = e),
            (this.validFlags =
              "gim" +
              (e.options.ecmaVersion >= 6 ? "uy" : "") +
              (e.options.ecmaVersion >= 9 ? "s" : "") +
              (e.options.ecmaVersion >= 13 ? "d" : "") +
              (e.options.ecmaVersion >= 15 ? "v" : "")),
            (this.unicodeProperties =
              tt[e.options.ecmaVersion >= 14 ? 14 : e.options.ecmaVersion]),
            (this.source = ""),
            (this.flags = ""),
            (this.start = 0),
            (this.switchU = !1),
            (this.switchV = !1),
            (this.switchN = !1),
            (this.pos = 0),
            (this.lastIntValue = 0),
            (this.lastStringValue = ""),
            (this.lastAssertionIsQuantifiable = !1),
            (this.numCapturingParens = 0),
            (this.maxBackReference = 0),
            (this.groupNames = []),
            (this.backReferenceNames = []);
        };
      function ot(e) {
        return (
          36 === e ||
          (e >= 40 && e <= 43) ||
          46 === e ||
          63 === e ||
          (e >= 91 && e <= 94) ||
          (e >= 123 && e <= 125)
        );
      }
      function ct(e) {
        return (e >= 65 && e <= 90) || (e >= 97 && e <= 122);
      }
      (at.prototype.reset = function (e, t, r) {
        var i = -1 !== r.indexOf("v"),
          s = -1 !== r.indexOf("u");
        (this.start = 0 | e),
          (this.source = t + ""),
          (this.flags = r),
          i && this.parser.options.ecmaVersion >= 15
            ? ((this.switchU = !0), (this.switchV = !0), (this.switchN = !0))
            : ((this.switchU = s && this.parser.options.ecmaVersion >= 6),
              (this.switchV = !1),
              (this.switchN = s && this.parser.options.ecmaVersion >= 9));
      }),
        (at.prototype.raise = function (e) {
          this.parser.raiseRecoverable(
            this.start,
            "Invalid regular expression: /" + this.source + "/: " + e
          );
        }),
        (at.prototype.at = function (e, t) {
          void 0 === t && (t = !1);
          var r = this.source,
            i = r.length;
          if (e >= i) return -1;
          var s = r.charCodeAt(e);
          if ((!t && !this.switchU) || s <= 55295 || s >= 57344 || e + 1 >= i)
            return s;
          var n = r.charCodeAt(e + 1);
          return n >= 56320 && n <= 57343 ? (s << 10) + n - 56613888 : s;
        }),
        (at.prototype.nextIndex = function (e, t) {
          void 0 === t && (t = !1);
          var r = this.source,
            i = r.length;
          if (e >= i) return i;
          var s,
            n = r.charCodeAt(e);
          return (!t && !this.switchU) ||
            n <= 55295 ||
            n >= 57344 ||
            e + 1 >= i ||
            (s = r.charCodeAt(e + 1)) < 56320 ||
            s > 57343
            ? e + 1
            : e + 2;
        }),
        (at.prototype.current = function (e) {
          return void 0 === e && (e = !1), this.at(this.pos, e);
        }),
        (at.prototype.lookahead = function (e) {
          return (
            void 0 === e && (e = !1), this.at(this.nextIndex(this.pos, e), e)
          );
        }),
        (at.prototype.advance = function (e) {
          void 0 === e && (e = !1), (this.pos = this.nextIndex(this.pos, e));
        }),
        (at.prototype.eat = function (e, t) {
          return (
            void 0 === t && (t = !1),
            this.current(t) === e && (this.advance(t), !0)
          );
        }),
        (at.prototype.eatChars = function (e, t) {
          void 0 === t && (t = !1);
          for (var r = this.pos, i = 0, s = e; i < s.length; i += 1) {
            var n = s[i],
              a = this.at(r, t);
            if (-1 === a || a !== n) return !1;
            r = this.nextIndex(r, t);
          }
          return (this.pos = r), !0;
        }),
        (nt.validateRegExpFlags = function (e) {
          for (
            var t = e.validFlags, r = e.flags, i = !1, s = !1, n = 0;
            n < r.length;
            n++
          ) {
            var a = r.charAt(n);
            -1 === t.indexOf(a) &&
              this.raise(e.start, "Invalid regular expression flag"),
              r.indexOf(a, n + 1) > -1 &&
                this.raise(e.start, "Duplicate regular expression flag"),
              "u" === a && (i = !0),
              "v" === a && (s = !0);
          }
          this.options.ecmaVersion >= 15 &&
            i &&
            s &&
            this.raise(e.start, "Invalid regular expression flag");
        }),
        (nt.validateRegExpPattern = function (e) {
          this.regexp_pattern(e),
            !e.switchN &&
              this.options.ecmaVersion >= 9 &&
              e.groupNames.length > 0 &&
              ((e.switchN = !0), this.regexp_pattern(e));
        }),
        (nt.regexp_pattern = function (e) {
          (e.pos = 0),
            (e.lastIntValue = 0),
            (e.lastStringValue = ""),
            (e.lastAssertionIsQuantifiable = !1),
            (e.numCapturingParens = 0),
            (e.maxBackReference = 0),
            (e.groupNames.length = 0),
            (e.backReferenceNames.length = 0),
            this.regexp_disjunction(e),
            e.pos !== e.source.length &&
              (e.eat(41) && e.raise("Unmatched ')'"),
              (e.eat(93) || e.eat(125)) && e.raise("Lone quantifier brackets")),
            e.maxBackReference > e.numCapturingParens &&
              e.raise("Invalid escape");
          for (var t = 0, r = e.backReferenceNames; t < r.length; t += 1) {
            var i = r[t];
            -1 === e.groupNames.indexOf(i) &&
              e.raise("Invalid named capture referenced");
          }
        }),
        (nt.regexp_disjunction = function (e) {
          for (this.regexp_alternative(e); e.eat(124); )
            this.regexp_alternative(e);
          this.regexp_eatQuantifier(e, !0) && e.raise("Nothing to repeat"),
            e.eat(123) && e.raise("Lone quantifier brackets");
        }),
        (nt.regexp_alternative = function (e) {
          for (; e.pos < e.source.length && this.regexp_eatTerm(e); );
        }),
        (nt.regexp_eatTerm = function (e) {
          return this.regexp_eatAssertion(e)
            ? (e.lastAssertionIsQuantifiable &&
                this.regexp_eatQuantifier(e) &&
                e.switchU &&
                e.raise("Invalid quantifier"),
              !0)
            : !!(e.switchU
                ? this.regexp_eatAtom(e)
                : this.regexp_eatExtendedAtom(e)) &&
                (this.regexp_eatQuantifier(e), !0);
        }),
        (nt.regexp_eatAssertion = function (e) {
          var t = e.pos;
          if (((e.lastAssertionIsQuantifiable = !1), e.eat(94) || e.eat(36)))
            return !0;
          if (e.eat(92)) {
            if (e.eat(66) || e.eat(98)) return !0;
            e.pos = t;
          }
          if (e.eat(40) && e.eat(63)) {
            var r = !1;
            if (
              (this.options.ecmaVersion >= 9 && (r = e.eat(60)),
              e.eat(61) || e.eat(33))
            )
              return (
                this.regexp_disjunction(e),
                e.eat(41) || e.raise("Unterminated group"),
                (e.lastAssertionIsQuantifiable = !r),
                !0
              );
          }
          return (e.pos = t), !1;
        }),
        (nt.regexp_eatQuantifier = function (e, t) {
          return (
            void 0 === t && (t = !1),
            !!this.regexp_eatQuantifierPrefix(e, t) && (e.eat(63), !0)
          );
        }),
        (nt.regexp_eatQuantifierPrefix = function (e, t) {
          return (
            e.eat(42) ||
            e.eat(43) ||
            e.eat(63) ||
            this.regexp_eatBracedQuantifier(e, t)
          );
        }),
        (nt.regexp_eatBracedQuantifier = function (e, t) {
          var r = e.pos;
          if (e.eat(123)) {
            var i = 0,
              s = -1;
            if (
              this.regexp_eatDecimalDigits(e) &&
              ((i = e.lastIntValue),
              e.eat(44) &&
                this.regexp_eatDecimalDigits(e) &&
                (s = e.lastIntValue),
              e.eat(125))
            )
              return (
                -1 !== s &&
                  s < i &&
                  !t &&
                  e.raise("numbers out of order in {} quantifier"),
                !0
              );
            e.switchU && !t && e.raise("Incomplete quantifier"), (e.pos = r);
          }
          return !1;
        }),
        (nt.regexp_eatAtom = function (e) {
          return (
            this.regexp_eatPatternCharacters(e) ||
            e.eat(46) ||
            this.regexp_eatReverseSolidusAtomEscape(e) ||
            this.regexp_eatCharacterClass(e) ||
            this.regexp_eatUncapturingGroup(e) ||
            this.regexp_eatCapturingGroup(e)
          );
        }),
        (nt.regexp_eatReverseSolidusAtomEscape = function (e) {
          var t = e.pos;
          if (e.eat(92)) {
            if (this.regexp_eatAtomEscape(e)) return !0;
            e.pos = t;
          }
          return !1;
        }),
        (nt.regexp_eatUncapturingGroup = function (e) {
          var t = e.pos;
          if (e.eat(40)) {
            if (e.eat(63) && e.eat(58)) {
              if ((this.regexp_disjunction(e), e.eat(41))) return !0;
              e.raise("Unterminated group");
            }
            e.pos = t;
          }
          return !1;
        }),
        (nt.regexp_eatCapturingGroup = function (e) {
          if (e.eat(40)) {
            if (
              (this.options.ecmaVersion >= 9
                ? this.regexp_groupSpecifier(e)
                : 63 === e.current() && e.raise("Invalid group"),
              this.regexp_disjunction(e),
              e.eat(41))
            )
              return (e.numCapturingParens += 1), !0;
            e.raise("Unterminated group");
          }
          return !1;
        }),
        (nt.regexp_eatExtendedAtom = function (e) {
          return (
            e.eat(46) ||
            this.regexp_eatReverseSolidusAtomEscape(e) ||
            this.regexp_eatCharacterClass(e) ||
            this.regexp_eatUncapturingGroup(e) ||
            this.regexp_eatCapturingGroup(e) ||
            this.regexp_eatInvalidBracedQuantifier(e) ||
            this.regexp_eatExtendedPatternCharacter(e)
          );
        }),
        (nt.regexp_eatInvalidBracedQuantifier = function (e) {
          return (
            this.regexp_eatBracedQuantifier(e, !0) &&
              e.raise("Nothing to repeat"),
            !1
          );
        }),
        (nt.regexp_eatSyntaxCharacter = function (e) {
          var t = e.current();
          return !!ot(t) && ((e.lastIntValue = t), e.advance(), !0);
        }),
        (nt.regexp_eatPatternCharacters = function (e) {
          for (var t = e.pos, r = 0; -1 !== (r = e.current()) && !ot(r); )
            e.advance();
          return e.pos !== t;
        }),
        (nt.regexp_eatExtendedPatternCharacter = function (e) {
          var t = e.current();
          return (
            !(
              -1 === t ||
              36 === t ||
              (t >= 40 && t <= 43) ||
              46 === t ||
              63 === t ||
              91 === t ||
              94 === t ||
              124 === t
            ) && (e.advance(), !0)
          );
        }),
        (nt.regexp_groupSpecifier = function (e) {
          if (e.eat(63)) {
            if (this.regexp_eatGroupName(e))
              return (
                -1 !== e.groupNames.indexOf(e.lastStringValue) &&
                  e.raise("Duplicate capture group name"),
                void e.groupNames.push(e.lastStringValue)
              );
            e.raise("Invalid group");
          }
        }),
        (nt.regexp_eatGroupName = function (e) {
          if (((e.lastStringValue = ""), e.eat(60))) {
            if (this.regexp_eatRegExpIdentifierName(e) && e.eat(62)) return !0;
            e.raise("Invalid capture group name");
          }
          return !1;
        }),
        (nt.regexp_eatRegExpIdentifierName = function (e) {
          if (
            ((e.lastStringValue = ""), this.regexp_eatRegExpIdentifierStart(e))
          ) {
            for (
              e.lastStringValue += oe(e.lastIntValue);
              this.regexp_eatRegExpIdentifierPart(e);
  
            )
              e.lastStringValue += oe(e.lastIntValue);
            return !0;
          }
          return !1;
        }),
        (nt.regexp_eatRegExpIdentifierStart = function (e) {
          var t = e.pos,
            r = this.options.ecmaVersion >= 11,
            i = e.current(r);
          return (
            e.advance(r),
            92 === i &&
              this.regexp_eatRegExpUnicodeEscapeSequence(e, r) &&
              (i = e.lastIntValue),
            (function (e) {
              return F(e, !0) || 36 === e || 95 === e;
            })(i)
              ? ((e.lastIntValue = i), !0)
              : ((e.pos = t), !1)
          );
        }),
        (nt.regexp_eatRegExpIdentifierPart = function (e) {
          var t = e.pos,
            r = this.options.ecmaVersion >= 11,
            i = e.current(r);
          return (
            e.advance(r),
            92 === i &&
              this.regexp_eatRegExpUnicodeEscapeSequence(e, r) &&
              (i = e.lastIntValue),
            (function (e) {
              return H(e, !0) || 36 === e || 95 === e || 8204 === e || 8205 === e;
            })(i)
              ? ((e.lastIntValue = i), !0)
              : ((e.pos = t), !1)
          );
        }),
        (nt.regexp_eatAtomEscape = function (e) {
          return (
            !!(
              this.regexp_eatBackReference(e) ||
              this.regexp_eatCharacterClassEscape(e) ||
              this.regexp_eatCharacterEscape(e) ||
              (e.switchN && this.regexp_eatKGroupName(e))
            ) ||
            (e.switchU &&
              (99 === e.current() && e.raise("Invalid unicode escape"),
              e.raise("Invalid escape")),
            !1)
          );
        }),
        (nt.regexp_eatBackReference = function (e) {
          var t = e.pos;
          if (this.regexp_eatDecimalEscape(e)) {
            var r = e.lastIntValue;
            if (e.switchU)
              return r > e.maxBackReference && (e.maxBackReference = r), !0;
            if (r <= e.numCapturingParens) return !0;
            e.pos = t;
          }
          return !1;
        }),
        (nt.regexp_eatKGroupName = function (e) {
          if (e.eat(107)) {
            if (this.regexp_eatGroupName(e))
              return e.backReferenceNames.push(e.lastStringValue), !0;
            e.raise("Invalid named reference");
          }
          return !1;
        }),
        (nt.regexp_eatCharacterEscape = function (e) {
          return (
            this.regexp_eatControlEscape(e) ||
            this.regexp_eatCControlLetter(e) ||
            this.regexp_eatZero(e) ||
            this.regexp_eatHexEscapeSequence(e) ||
            this.regexp_eatRegExpUnicodeEscapeSequence(e, !1) ||
            (!e.switchU && this.regexp_eatLegacyOctalEscapeSequence(e)) ||
            this.regexp_eatIdentityEscape(e)
          );
        }),
        (nt.regexp_eatCControlLetter = function (e) {
          var t = e.pos;
          if (e.eat(99)) {
            if (this.regexp_eatControlLetter(e)) return !0;
            e.pos = t;
          }
          return !1;
        }),
        (nt.regexp_eatZero = function (e) {
          return (
            48 === e.current() &&
            !ut(e.lookahead()) &&
            ((e.lastIntValue = 0), e.advance(), !0)
          );
        }),
        (nt.regexp_eatControlEscape = function (e) {
          var t = e.current();
          return 116 === t
            ? ((e.lastIntValue = 9), e.advance(), !0)
            : 110 === t
            ? ((e.lastIntValue = 10), e.advance(), !0)
            : 118 === t
            ? ((e.lastIntValue = 11), e.advance(), !0)
            : 102 === t
            ? ((e.lastIntValue = 12), e.advance(), !0)
            : 114 === t && ((e.lastIntValue = 13), e.advance(), !0);
        }),
        (nt.regexp_eatControlLetter = function (e) {
          var t = e.current();
          return !!ct(t) && ((e.lastIntValue = t % 32), e.advance(), !0);
        }),
        (nt.regexp_eatRegExpUnicodeEscapeSequence = function (e, t) {
          void 0 === t && (t = !1);
          var r,
            i = e.pos,
            s = t || e.switchU;
          if (e.eat(117)) {
            if (this.regexp_eatFixedHexDigits(e, 4)) {
              var n = e.lastIntValue;
              if (s && n >= 55296 && n <= 56319) {
                var a = e.pos;
                if (
                  e.eat(92) &&
                  e.eat(117) &&
                  this.regexp_eatFixedHexDigits(e, 4)
                ) {
                  var o = e.lastIntValue;
                  if (o >= 56320 && o <= 57343)
                    return (
                      (e.lastIntValue = 1024 * (n - 55296) + (o - 56320) + 65536),
                      !0
                    );
                }
                (e.pos = a), (e.lastIntValue = n);
              }
              return !0;
            }
            if (
              s &&
              e.eat(123) &&
              this.regexp_eatHexDigits(e) &&
              e.eat(125) &&
              (r = e.lastIntValue) >= 0 &&
              r <= 1114111
            )
              return !0;
            s && e.raise("Invalid unicode escape"), (e.pos = i);
          }
          return !1;
        }),
        (nt.regexp_eatIdentityEscape = function (e) {
          if (e.switchU)
            return (
              !!this.regexp_eatSyntaxCharacter(e) ||
              (!!e.eat(47) && ((e.lastIntValue = 47), !0))
            );
          var t = e.current();
          return (
            !(99 === t || (e.switchN && 107 === t)) &&
            ((e.lastIntValue = t), e.advance(), !0)
          );
        }),
        (nt.regexp_eatDecimalEscape = function (e) {
          e.lastIntValue = 0;
          var t = e.current();
          if (t >= 49 && t <= 57) {
            do {
              (e.lastIntValue = 10 * e.lastIntValue + (t - 48)), e.advance();
            } while ((t = e.current()) >= 48 && t <= 57);
            return !0;
          }
          return !1;
        });
      function lt(e) {
        return ct(e) || 95 === e;
      }
      function ht(e) {
        return lt(e) || ut(e);
      }
      function ut(e) {
        return e >= 48 && e <= 57;
      }
      function dt(e) {
        return (
          (e >= 48 && e <= 57) || (e >= 65 && e <= 70) || (e >= 97 && e <= 102)
        );
      }
      function pt(e) {
        return e >= 65 && e <= 70
          ? e - 65 + 10
          : e >= 97 && e <= 102
          ? e - 97 + 10
          : e - 48;
      }
      function ft(e) {
        return e >= 48 && e <= 55;
      }
      (nt.regexp_eatCharacterClassEscape = function (e) {
        var t = e.current();
        if (
          (function (e) {
            return (
              100 === e ||
              68 === e ||
              115 === e ||
              83 === e ||
              119 === e ||
              87 === e
            );
          })(t)
        )
          return (e.lastIntValue = -1), e.advance(), 1;
        var r = !1;
        if (
          e.switchU &&
          this.options.ecmaVersion >= 9 &&
          ((r = 80 === t) || 112 === t)
        ) {
          var i;
          if (
            ((e.lastIntValue = -1),
            e.advance(),
            e.eat(123) &&
              (i = this.regexp_eatUnicodePropertyValueExpression(e)) &&
              e.eat(125))
          )
            return r && 2 === i && e.raise("Invalid property name"), i;
          e.raise("Invalid property name");
        }
        return 0;
      }),
        (nt.regexp_eatUnicodePropertyValueExpression = function (e) {
          var t = e.pos;
          if (this.regexp_eatUnicodePropertyName(e) && e.eat(61)) {
            var r = e.lastStringValue;
            if (this.regexp_eatUnicodePropertyValue(e)) {
              var i = e.lastStringValue;
              return this.regexp_validateUnicodePropertyNameAndValue(e, r, i), 1;
            }
          }
          if (((e.pos = t), this.regexp_eatLoneUnicodePropertyNameOrValue(e))) {
            var s = e.lastStringValue;
            return this.regexp_validateUnicodePropertyNameOrValue(e, s);
          }
          return 0;
        }),
        (nt.regexp_validateUnicodePropertyNameAndValue = function (e, t, r) {
          ie(e.unicodeProperties.nonBinary, t) ||
            e.raise("Invalid property name"),
            e.unicodeProperties.nonBinary[t].test(r) ||
              e.raise("Invalid property value");
        }),
        (nt.regexp_validateUnicodePropertyNameOrValue = function (e, t) {
          return e.unicodeProperties.binary.test(t)
            ? 1
            : e.switchV && e.unicodeProperties.binaryOfStrings.test(t)
            ? 2
            : void e.raise("Invalid property name");
        }),
        (nt.regexp_eatUnicodePropertyName = function (e) {
          var t = 0;
          for (e.lastStringValue = ""; lt((t = e.current())); )
            (e.lastStringValue += oe(t)), e.advance();
          return "" !== e.lastStringValue;
        }),
        (nt.regexp_eatUnicodePropertyValue = function (e) {
          var t = 0;
          for (e.lastStringValue = ""; ht((t = e.current())); )
            (e.lastStringValue += oe(t)), e.advance();
          return "" !== e.lastStringValue;
        }),
        (nt.regexp_eatLoneUnicodePropertyNameOrValue = function (e) {
          return this.regexp_eatUnicodePropertyValue(e);
        }),
        (nt.regexp_eatCharacterClass = function (e) {
          if (e.eat(91)) {
            var t = e.eat(94),
              r = this.regexp_classContents(e);
            return (
              e.eat(93) || e.raise("Unterminated character class"),
              t &&
                2 === r &&
                e.raise("Negated character class may contain strings"),
              !0
            );
          }
          return !1;
        }),
        (nt.regexp_classContents = function (e) {
          return 93 === e.current()
            ? 1
            : e.switchV
            ? this.regexp_classSetExpression(e)
            : (this.regexp_nonEmptyClassRanges(e), 1);
        }),
        (nt.regexp_nonEmptyClassRanges = function (e) {
          for (; this.regexp_eatClassAtom(e); ) {
            var t = e.lastIntValue;
            if (e.eat(45) && this.regexp_eatClassAtom(e)) {
              var r = e.lastIntValue;
              !e.switchU ||
                (-1 !== t && -1 !== r) ||
                e.raise("Invalid character class"),
                -1 !== t &&
                  -1 !== r &&
                  t > r &&
                  e.raise("Range out of order in character class");
            }
          }
        }),
        (nt.regexp_eatClassAtom = function (e) {
          var t = e.pos;
          if (e.eat(92)) {
            if (this.regexp_eatClassEscape(e)) return !0;
            if (e.switchU) {
              var r = e.current();
              (99 === r || ft(r)) && e.raise("Invalid class escape"),
                e.raise("Invalid escape");
            }
            e.pos = t;
          }
          var i = e.current();
          return 93 !== i && ((e.lastIntValue = i), e.advance(), !0);
        }),
        (nt.regexp_eatClassEscape = function (e) {
          var t = e.pos;
          if (e.eat(98)) return (e.lastIntValue = 8), !0;
          if (e.switchU && e.eat(45)) return (e.lastIntValue = 45), !0;
          if (!e.switchU && e.eat(99)) {
            if (this.regexp_eatClassControlLetter(e)) return !0;
            e.pos = t;
          }
          return (
            this.regexp_eatCharacterClassEscape(e) ||
            this.regexp_eatCharacterEscape(e)
          );
        }),
        (nt.regexp_classSetExpression = function (e) {
          var t,
            r = 1;
          if (this.regexp_eatClassSetRange(e));
          else if ((t = this.regexp_eatClassSetOperand(e))) {
            2 === t && (r = 2);
            for (var i = e.pos; e.eatChars([38, 38]); )
              38 !== e.current() && (t = this.regexp_eatClassSetOperand(e))
                ? 2 !== t && (r = 1)
                : e.raise("Invalid character in character class");
            if (i !== e.pos) return r;
            for (; e.eatChars([45, 45]); )
              this.regexp_eatClassSetOperand(e) ||
                e.raise("Invalid character in character class");
            if (i !== e.pos) return r;
          } else e.raise("Invalid character in character class");
          for (;;)
            if (!this.regexp_eatClassSetRange(e)) {
              if (!(t = this.regexp_eatClassSetOperand(e))) return r;
              2 === t && (r = 2);
            }
        }),
        (nt.regexp_eatClassSetRange = function (e) {
          var t = e.pos;
          if (this.regexp_eatClassSetCharacter(e)) {
            var r = e.lastIntValue;
            if (e.eat(45) && this.regexp_eatClassSetCharacter(e)) {
              var i = e.lastIntValue;
              return (
                -1 !== r &&
                  -1 !== i &&
                  r > i &&
                  e.raise("Range out of order in character class"),
                !0
              );
            }
            e.pos = t;
          }
          return !1;
        }),
        (nt.regexp_eatClassSetOperand = function (e) {
          return this.regexp_eatClassSetCharacter(e)
            ? 1
            : this.regexp_eatClassStringDisjunction(e) ||
                this.regexp_eatNestedClass(e);
        }),
        (nt.regexp_eatNestedClass = function (e) {
          var t = e.pos;
          if (e.eat(91)) {
            var r = e.eat(94),
              i = this.regexp_classContents(e);
            if (e.eat(93))
              return (
                r &&
                  2 === i &&
                  e.raise("Negated character class may contain strings"),
                i
              );
            e.pos = t;
          }
          if (e.eat(92)) {
            var s = this.regexp_eatCharacterClassEscape(e);
            if (s) return s;
            e.pos = t;
          }
          return null;
        }),
        (nt.regexp_eatClassStringDisjunction = function (e) {
          var t = e.pos;
          if (e.eatChars([92, 113])) {
            if (e.eat(123)) {
              var r = this.regexp_classStringDisjunctionContents(e);
              if (e.eat(125)) return r;
            } else e.raise("Invalid escape");
            e.pos = t;
          }
          return null;
        }),
        (nt.regexp_classStringDisjunctionContents = function (e) {
          for (var t = this.regexp_classString(e); e.eat(124); )
            2 === this.regexp_classString(e) && (t = 2);
          return t;
        }),
        (nt.regexp_classString = function (e) {
          for (var t = 0; this.regexp_eatClassSetCharacter(e); ) t++;
          return 1 === t ? 1 : 2;
        }),
        (nt.regexp_eatClassSetCharacter = function (e) {
          var t = e.pos;
          if (e.eat(92))
            return (
              !(
                !this.regexp_eatCharacterEscape(e) &&
                !this.regexp_eatClassSetReservedPunctuator(e)
              ) || (e.eat(98) ? ((e.lastIntValue = 8), !0) : ((e.pos = t), !1))
            );
          var r = e.current();
          return (
            !(
              r < 0 ||
              (r === e.lookahead() &&
                (function (e) {
                  return (
                    33 === e ||
                    (e >= 35 && e <= 38) ||
                    (e >= 42 && e <= 44) ||
                    46 === e ||
                    (e >= 58 && e <= 64) ||
                    94 === e ||
                    96 === e ||
                    126 === e
                  );
                })(r))
            ) &&
            !(function (e) {
              return (
                40 === e ||
                41 === e ||
                45 === e ||
                47 === e ||
                (e >= 91 && e <= 93) ||
                (e >= 123 && e <= 125)
              );
            })(r) &&
            (e.advance(), (e.lastIntValue = r), !0)
          );
        }),
        (nt.regexp_eatClassSetReservedPunctuator = function (e) {
          var t = e.current();
          return (
            !!(function (e) {
              return (
                33 === e ||
                35 === e ||
                37 === e ||
                38 === e ||
                44 === e ||
                45 === e ||
                (e >= 58 && e <= 62) ||
                64 === e ||
                96 === e ||
                126 === e
              );
            })(t) && ((e.lastIntValue = t), e.advance(), !0)
          );
        }),
        (nt.regexp_eatClassControlLetter = function (e) {
          var t = e.current();
          return (
            !(!ut(t) && 95 !== t) && ((e.lastIntValue = t % 32), e.advance(), !0)
          );
        }),
        (nt.regexp_eatHexEscapeSequence = function (e) {
          var t = e.pos;
          if (e.eat(120)) {
            if (this.regexp_eatFixedHexDigits(e, 2)) return !0;
            e.switchU && e.raise("Invalid escape"), (e.pos = t);
          }
          return !1;
        }),
        (nt.regexp_eatDecimalDigits = function (e) {
          var t = e.pos,
            r = 0;
          for (e.lastIntValue = 0; ut((r = e.current())); )
            (e.lastIntValue = 10 * e.lastIntValue + (r - 48)), e.advance();
          return e.pos !== t;
        }),
        (nt.regexp_eatHexDigits = function (e) {
          var t = e.pos,
            r = 0;
          for (e.lastIntValue = 0; dt((r = e.current())); )
            (e.lastIntValue = 16 * e.lastIntValue + pt(r)), e.advance();
          return e.pos !== t;
        }),
        (nt.regexp_eatLegacyOctalEscapeSequence = function (e) {
          if (this.regexp_eatOctalDigit(e)) {
            var t = e.lastIntValue;
            if (this.regexp_eatOctalDigit(e)) {
              var r = e.lastIntValue;
              t <= 3 && this.regexp_eatOctalDigit(e)
                ? (e.lastIntValue = 64 * t + 8 * r + e.lastIntValue)
                : (e.lastIntValue = 8 * t + r);
            } else e.lastIntValue = t;
            return !0;
          }
          return !1;
        }),
        (nt.regexp_eatOctalDigit = function (e) {
          var t = e.current();
          return ft(t)
            ? ((e.lastIntValue = t - 48), e.advance(), !0)
            : ((e.lastIntValue = 0), !1);
        }),
        (nt.regexp_eatFixedHexDigits = function (e, t) {
          var r = e.pos;
          e.lastIntValue = 0;
          for (var i = 0; i < t; ++i) {
            var s = e.current();
            if (!dt(s)) return (e.pos = r), !1;
            (e.lastIntValue = 16 * e.lastIntValue + pt(s)), e.advance();
          }
          return !0;
        });
      var gt = function (e) {
          (this.type = e.type),
            (this.value = e.value),
            (this.start = e.start),
            (this.end = e.end),
            e.options.locations && (this.loc = new he(e, e.startLoc, e.endLoc)),
            e.options.ranges && (this.range = [e.start, e.end]);
        },
        mt = ye.prototype;
      function yt(e) {
        return "function" != typeof BigInt ? null : BigInt(e.replace(/_/g, ""));
      }
      (mt.next = function (e) {
        !e &&
          this.type.keyword &&
          this.containsEsc &&
          this.raiseRecoverable(
            this.start,
            "Escape sequence in keyword " + this.type.keyword
          ),
          this.options.onToken && this.options.onToken(new gt(this)),
          (this.lastTokEnd = this.end),
          (this.lastTokStart = this.start),
          (this.lastTokEndLoc = this.endLoc),
          (this.lastTokStartLoc = this.startLoc),
          this.nextToken();
      }),
        (mt.getToken = function () {
          return this.next(), new gt(this);
        }),
        "undefined" != typeof Symbol &&
          (mt[Symbol.iterator] = function () {
            var e = this;
            return {
              next: function () {
                var t = e.getToken();
                return { done: t.type === W.eof, value: t };
              },
            };
          }),
        (mt.nextToken = function () {
          var e = this.curContext();
          return (
            (e && e.preserveSpace) || this.skipSpace(),
            (this.start = this.pos),
            this.options.locations && (this.startLoc = this.curPosition()),
            this.pos >= this.input.length
              ? this.finishToken(W.eof)
              : e.override
              ? e.override(this)
              : void this.readToken(this.fullCharCodeAtPos())
          );
        }),
        (mt.readToken = function (e) {
          return F(e, this.options.ecmaVersion >= 6) || 92 === e
            ? this.readWord()
            : this.getTokenFromCode(e);
        }),
        (mt.fullCharCodeAtPos = function () {
          var e = this.input.charCodeAt(this.pos);
          if (e <= 55295 || e >= 56320) return e;
          var t = this.input.charCodeAt(this.pos + 1);
          return t <= 56319 || t >= 57344 ? e : (e << 10) + t - 56613888;
        }),
        (mt.skipBlockComment = function () {
          var e = this.options.onComment && this.curPosition(),
            t = this.pos,
            r = this.input.indexOf("*/", (this.pos += 2));
          if (
            (-1 === r && this.raise(this.pos - 2, "Unterminated comment"),
            (this.pos = r + 2),
            this.options.locations)
          )
            for (var i = void 0, s = t; (i = J(this.input, s, this.pos)) > -1; )
              ++this.curLine, (s = this.lineStart = i);
          this.options.onComment &&
            this.options.onComment(
              !0,
              this.input.slice(t + 2, r),
              t,
              this.pos,
              e,
              this.curPosition()
            );
        }),
        (mt.skipLineComment = function (e) {
          for (
            var t = this.pos,
              r = this.options.onComment && this.curPosition(),
              i = this.input.charCodeAt((this.pos += e));
            this.pos < this.input.length && !K(i);
  
          )
            i = this.input.charCodeAt(++this.pos);
          this.options.onComment &&
            this.options.onComment(
              !1,
              this.input.slice(t + e, this.pos),
              t,
              this.pos,
              r,
              this.curPosition()
            );
        }),
        (mt.skipSpace = function () {
          e: for (; this.pos < this.input.length; ) {
            var e = this.input.charCodeAt(this.pos);
            switch (e) {
              case 32:
              case 160:
                ++this.pos;
                break;
              case 13:
                10 === this.input.charCodeAt(this.pos + 1) && ++this.pos;
              case 10:
              case 8232:
              case 8233:
                ++this.pos,
                  this.options.locations &&
                    (++this.curLine, (this.lineStart = this.pos));
                break;
              case 47:
                switch (this.input.charCodeAt(this.pos + 1)) {
                  case 42:
                    this.skipBlockComment();
                    break;
                  case 47:
                    this.skipLineComment(2);
                    break;
                  default:
                    break e;
                }
                break;
              default:
                if (
                  !(
                    (e > 8 && e < 14) ||
                    (e >= 5760 && Z.test(String.fromCharCode(e)))
                  )
                )
                  break e;
                ++this.pos;
            }
          }
        }),
        (mt.finishToken = function (e, t) {
          (this.end = this.pos),
            this.options.locations && (this.endLoc = this.curPosition());
          var r = this.type;
          (this.type = e), (this.value = t), this.updateContext(r);
        }),
        (mt.readToken_dot = function () {
          var e = this.input.charCodeAt(this.pos + 1);
          if (e >= 48 && e <= 57) return this.readNumber(!0);
          var t = this.input.charCodeAt(this.pos + 2);
          return this.options.ecmaVersion >= 6 && 46 === e && 46 === t
            ? ((this.pos += 3), this.finishToken(W.ellipsis))
            : (++this.pos, this.finishToken(W.dot));
        }),
        (mt.readToken_slash = function () {
          var e = this.input.charCodeAt(this.pos + 1);
          return this.exprAllowed
            ? (++this.pos, this.readRegexp())
            : 61 === e
            ? this.finishOp(W.assign, 2)
            : this.finishOp(W.slash, 1);
        }),
        (mt.readToken_mult_modulo_exp = function (e) {
          var t = this.input.charCodeAt(this.pos + 1),
            r = 1,
            i = 42 === e ? W.star : W.modulo;
          return (
            this.options.ecmaVersion >= 7 &&
              42 === e &&
              42 === t &&
              (++r, (i = W.starstar), (t = this.input.charCodeAt(this.pos + 2))),
            61 === t ? this.finishOp(W.assign, r + 1) : this.finishOp(i, r)
          );
        }),
        (mt.readToken_pipe_amp = function (e) {
          var t = this.input.charCodeAt(this.pos + 1);
          if (t === e) {
            if (this.options.ecmaVersion >= 12)
              if (61 === this.input.charCodeAt(this.pos + 2))
                return this.finishOp(W.assign, 3);
            return this.finishOp(124 === e ? W.logicalOR : W.logicalAND, 2);
          }
          return 61 === t
            ? this.finishOp(W.assign, 2)
            : this.finishOp(124 === e ? W.bitwiseOR : W.bitwiseAND, 1);
        }),
        (mt.readToken_caret = function () {
          return 61 === this.input.charCodeAt(this.pos + 1)
            ? this.finishOp(W.assign, 2)
            : this.finishOp(W.bitwiseXOR, 1);
        }),
        (mt.readToken_plus_min = function (e) {
          var t = this.input.charCodeAt(this.pos + 1);
          return t === e
            ? 45 !== t ||
              this.inModule ||
              62 !== this.input.charCodeAt(this.pos + 2) ||
              (0 !== this.lastTokEnd &&
                !Y.test(this.input.slice(this.lastTokEnd, this.pos)))
              ? this.finishOp(W.incDec, 2)
              : (this.skipLineComment(3), this.skipSpace(), this.nextToken())
            : 61 === t
            ? this.finishOp(W.assign, 2)
            : this.finishOp(W.plusMin, 1);
        }),
        (mt.readToken_lt_gt = function (e) {
          var t = this.input.charCodeAt(this.pos + 1),
            r = 1;
          return t === e
            ? ((r =
                62 === e && 62 === this.input.charCodeAt(this.pos + 2) ? 3 : 2),
              61 === this.input.charCodeAt(this.pos + r)
                ? this.finishOp(W.assign, r + 1)
                : this.finishOp(W.bitShift, r))
            : 33 !== t ||
              60 !== e ||
              this.inModule ||
              45 !== this.input.charCodeAt(this.pos + 2) ||
              45 !== this.input.charCodeAt(this.pos + 3)
            ? (61 === t && (r = 2), this.finishOp(W.relational, r))
            : (this.skipLineComment(4), this.skipSpace(), this.nextToken());
        }),
        (mt.readToken_eq_excl = function (e) {
          var t = this.input.charCodeAt(this.pos + 1);
          return 61 === t
            ? this.finishOp(
                W.equality,
                61 === this.input.charCodeAt(this.pos + 2) ? 3 : 2
              )
            : 61 === e && 62 === t && this.options.ecmaVersion >= 6
            ? ((this.pos += 2), this.finishToken(W.arrow))
            : this.finishOp(61 === e ? W.eq : W.prefix, 1);
        }),
        (mt.readToken_question = function () {
          var e = this.options.ecmaVersion;
          if (e >= 11) {
            var t = this.input.charCodeAt(this.pos + 1);
            if (46 === t) {
              var r = this.input.charCodeAt(this.pos + 2);
              if (r < 48 || r > 57) return this.finishOp(W.questionDot, 2);
            }
            if (63 === t) {
              if (e >= 12)
                if (61 === this.input.charCodeAt(this.pos + 2))
                  return this.finishOp(W.assign, 3);
              return this.finishOp(W.coalesce, 2);
            }
          }
          return this.finishOp(W.question, 1);
        }),
        (mt.readToken_numberSign = function () {
          var e = 35;
          if (
            this.options.ecmaVersion >= 13 &&
            (++this.pos, F((e = this.fullCharCodeAtPos()), !0) || 92 === e)
          )
            return this.finishToken(W.privateId, this.readWord1());
          this.raise(this.pos, "Unexpected character '" + oe(e) + "'");
        }),
        (mt.getTokenFromCode = function (e) {
          switch (e) {
            case 46:
              return this.readToken_dot();
            case 40:
              return ++this.pos, this.finishToken(W.parenL);
            case 41:
              return ++this.pos, this.finishToken(W.parenR);
            case 59:
              return ++this.pos, this.finishToken(W.semi);
            case 44:
              return ++this.pos, this.finishToken(W.comma);
            case 91:
              return ++this.pos, this.finishToken(W.bracketL);
            case 93:
              return ++this.pos, this.finishToken(W.bracketR);
            case 123:
              return ++this.pos, this.finishToken(W.braceL);
            case 125:
              return ++this.pos, this.finishToken(W.braceR);
            case 58:
              return ++this.pos, this.finishToken(W.colon);
            case 96:
              if (this.options.ecmaVersion < 6) break;
              return ++this.pos, this.finishToken(W.backQuote);
            case 48:
              var t = this.input.charCodeAt(this.pos + 1);
              if (120 === t || 88 === t) return this.readRadixNumber(16);
              if (this.options.ecmaVersion >= 6) {
                if (111 === t || 79 === t) return this.readRadixNumber(8);
                if (98 === t || 66 === t) return this.readRadixNumber(2);
              }
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
              return this.readNumber(!1);
            case 34:
            case 39:
              return this.readString(e);
            case 47:
              return this.readToken_slash();
            case 37:
            case 42:
              return this.readToken_mult_modulo_exp(e);
            case 124:
            case 38:
              return this.readToken_pipe_amp(e);
            case 94:
              return this.readToken_caret();
            case 43:
            case 45:
              return this.readToken_plus_min(e);
            case 60:
            case 62:
              return this.readToken_lt_gt(e);
            case 61:
            case 33:
              return this.readToken_eq_excl(e);
            case 63:
              return this.readToken_question();
            case 126:
              return this.finishOp(W.prefix, 1);
            case 35:
              return this.readToken_numberSign();
          }
          this.raise(this.pos, "Unexpected character '" + oe(e) + "'");
        }),
        (mt.finishOp = function (e, t) {
          var r = this.input.slice(this.pos, this.pos + t);
          return (this.pos += t), this.finishToken(e, r);
        }),
        (mt.readRegexp = function () {
          for (var e, t, r = this.pos; ; ) {
            this.pos >= this.input.length &&
              this.raise(r, "Unterminated regular expression");
            var i = this.input.charAt(this.pos);
            if (
              (Y.test(i) && this.raise(r, "Unterminated regular expression"), e)
            )
              e = !1;
            else {
              if ("[" === i) t = !0;
              else if ("]" === i && t) t = !1;
              else if ("/" === i && !t) break;
              e = "\\" === i;
            }
            ++this.pos;
          }
          var s = this.input.slice(r, this.pos);
          ++this.pos;
          var n = this.pos,
            a = this.readWord1();
          this.containsEsc && this.unexpected(n);
          var o = this.regexpState || (this.regexpState = new at(this));
          o.reset(r, s, a),
            this.validateRegExpFlags(o),
            this.validateRegExpPattern(o);
          var c = null;
          try {
            c = new RegExp(s, a);
          } catch (e) {}
          return this.finishToken(W.regexp, { pattern: s, flags: a, value: c });
        }),
        (mt.readInt = function (e, t, r) {
          for (
            var i = this.options.ecmaVersion >= 12 && void 0 === t,
              s = r && 48 === this.input.charCodeAt(this.pos),
              n = this.pos,
              a = 0,
              o = 0,
              c = 0,
              l = null == t ? 1 / 0 : t;
            c < l;
            ++c, ++this.pos
          ) {
            var h = this.input.charCodeAt(this.pos),
              u = void 0;
            if (i && 95 === h)
              s &&
                this.raiseRecoverable(
                  this.pos,
                  "Numeric separator is not allowed in legacy octal numeric literals"
                ),
                95 === o &&
                  this.raiseRecoverable(
                    this.pos,
                    "Numeric separator must be exactly one underscore"
                  ),
                0 === c &&
                  this.raiseRecoverable(
                    this.pos,
                    "Numeric separator is not allowed at the first of digits"
                  ),
                (o = h);
            else {
              if (
                (u =
                  h >= 97
                    ? h - 97 + 10
                    : h >= 65
                    ? h - 65 + 10
                    : h >= 48 && h <= 57
                    ? h - 48
                    : 1 / 0) >= e
              )
                break;
              (o = h), (a = a * e + u);
            }
          }
          return (
            i &&
              95 === o &&
              this.raiseRecoverable(
                this.pos - 1,
                "Numeric separator is not allowed at the last of digits"
              ),
            this.pos === n || (null != t && this.pos - n !== t) ? null : a
          );
        }),
        (mt.readRadixNumber = function (e) {
          var t = this.pos;
          this.pos += 2;
          var r = this.readInt(e);
          return (
            null == r &&
              this.raise(this.start + 2, "Expected number in radix " + e),
            this.options.ecmaVersion >= 11 &&
            110 === this.input.charCodeAt(this.pos)
              ? ((r = yt(this.input.slice(t, this.pos))), ++this.pos)
              : F(this.fullCharCodeAtPos()) &&
                this.raise(this.pos, "Identifier directly after number"),
            this.finishToken(W.num, r)
          );
        }),
        (mt.readNumber = function (e) {
          var t = this.pos;
          e ||
            null !== this.readInt(10, void 0, !0) ||
            this.raise(t, "Invalid number");
          var r = this.pos - t >= 2 && 48 === this.input.charCodeAt(t);
          r && this.strict && this.raise(t, "Invalid number");
          var i = this.input.charCodeAt(this.pos);
          if (!r && !e && this.options.ecmaVersion >= 11 && 110 === i) {
            var s = yt(this.input.slice(t, this.pos));
            return (
              ++this.pos,
              F(this.fullCharCodeAtPos()) &&
                this.raise(this.pos, "Identifier directly after number"),
              this.finishToken(W.num, s)
            );
          }
          r && /[89]/.test(this.input.slice(t, this.pos)) && (r = !1),
            46 !== i ||
              r ||
              (++this.pos,
              this.readInt(10),
              (i = this.input.charCodeAt(this.pos))),
            (69 !== i && 101 !== i) ||
              r ||
              ((43 !== (i = this.input.charCodeAt(++this.pos)) && 45 !== i) ||
                ++this.pos,
              null === this.readInt(10) && this.raise(t, "Invalid number")),
            F(this.fullCharCodeAtPos()) &&
              this.raise(this.pos, "Identifier directly after number");
          var n = (function (e, t) {
            return t ? parseInt(e, 8) : parseFloat(e.replace(/_/g, ""));
          })(this.input.slice(t, this.pos), r);
          return this.finishToken(W.num, n);
        }),
        (mt.readCodePoint = function () {
          var e;
          if (123 === this.input.charCodeAt(this.pos)) {
            this.options.ecmaVersion < 6 && this.unexpected();
            var t = ++this.pos;
            (e = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos)),
              ++this.pos,
              e > 1114111 &&
                this.invalidStringToken(t, "Code point out of bounds");
          } else e = this.readHexChar(4);
          return e;
        }),
        (mt.readString = function (e) {
          for (var t = "", r = ++this.pos; ; ) {
            this.pos >= this.input.length &&
              this.raise(this.start, "Unterminated string constant");
            var i = this.input.charCodeAt(this.pos);
            if (i === e) break;
            92 === i
              ? ((t += this.input.slice(r, this.pos)),
                (t += this.readEscapedChar(!1)),
                (r = this.pos))
              : 8232 === i || 8233 === i
              ? (this.options.ecmaVersion < 10 &&
                  this.raise(this.start, "Unterminated string constant"),
                ++this.pos,
                this.options.locations &&
                  (this.curLine++, (this.lineStart = this.pos)))
              : (K(i) && this.raise(this.start, "Unterminated string constant"),
                ++this.pos);
          }
          return (
            (t += this.input.slice(r, this.pos++)), this.finishToken(W.string, t)
          );
        });
      var At = {};
      (mt.tryReadTemplateToken = function () {
        this.inTemplateElement = !0;
        try {
          this.readTmplToken();
        } catch (e) {
          if (e !== At) throw e;
          this.readInvalidTemplateToken();
        }
        this.inTemplateElement = !1;
      }),
        (mt.invalidStringToken = function (e, t) {
          if (this.inTemplateElement && this.options.ecmaVersion >= 9) throw At;
          this.raise(e, t);
        }),
        (mt.readTmplToken = function () {
          for (var e = "", t = this.pos; ; ) {
            this.pos >= this.input.length &&
              this.raise(this.start, "Unterminated template");
            var r = this.input.charCodeAt(this.pos);
            if (
              96 === r ||
              (36 === r && 123 === this.input.charCodeAt(this.pos + 1))
            )
              return this.pos !== this.start ||
                (this.type !== W.template && this.type !== W.invalidTemplate)
                ? ((e += this.input.slice(t, this.pos)),
                  this.finishToken(W.template, e))
                : 36 === r
                ? ((this.pos += 2), this.finishToken(W.dollarBraceL))
                : (++this.pos, this.finishToken(W.backQuote));
            if (92 === r)
              (e += this.input.slice(t, this.pos)),
                (e += this.readEscapedChar(!0)),
                (t = this.pos);
            else if (K(r)) {
              switch (((e += this.input.slice(t, this.pos)), ++this.pos, r)) {
                case 13:
                  10 === this.input.charCodeAt(this.pos) && ++this.pos;
                case 10:
                  e += "\n";
                  break;
                default:
                  e += String.fromCharCode(r);
              }
              this.options.locations &&
                (++this.curLine, (this.lineStart = this.pos)),
                (t = this.pos);
            } else ++this.pos;
          }
        }),
        (mt.readInvalidTemplateToken = function () {
          for (; this.pos < this.input.length; this.pos++)
            switch (this.input[this.pos]) {
              case "\\":
                ++this.pos;
                break;
              case "$":
                if ("{" !== this.input[this.pos + 1]) break;
              case "`":
                return this.finishToken(
                  W.invalidTemplate,
                  this.input.slice(this.start, this.pos)
                );
            }
          this.raise(this.start, "Unterminated template");
        }),
        (mt.readEscapedChar = function (e) {
          var t = this.input.charCodeAt(++this.pos);
          switch ((++this.pos, t)) {
            case 110:
              return "\n";
            case 114:
              return "\r";
            case 120:
              return String.fromCharCode(this.readHexChar(2));
            case 117:
              return oe(this.readCodePoint());
            case 116:
              return "\t";
            case 98:
              return "\b";
            case 118:
              return "\v";
            case 102:
              return "\f";
            case 13:
              10 === this.input.charCodeAt(this.pos) && ++this.pos;
            case 10:
              return (
                this.options.locations &&
                  ((this.lineStart = this.pos), ++this.curLine),
                ""
              );
            case 56:
            case 57:
              if (
                (this.strict &&
                  this.invalidStringToken(
                    this.pos - 1,
                    "Invalid escape sequence"
                  ),
                e)
              ) {
                var r = this.pos - 1;
                this.invalidStringToken(
                  r,
                  "Invalid escape sequence in template string"
                );
              }
            default:
              if (t >= 48 && t <= 55) {
                var i = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0],
                  s = parseInt(i, 8);
                return (
                  s > 255 && ((i = i.slice(0, -1)), (s = parseInt(i, 8))),
                  (this.pos += i.length - 1),
                  (t = this.input.charCodeAt(this.pos)),
                  ("0" === i && 56 !== t && 57 !== t) ||
                    (!this.strict && !e) ||
                    this.invalidStringToken(
                      this.pos - 1 - i.length,
                      e
                        ? "Octal literal in template string"
                        : "Octal literal in strict mode"
                    ),
                  String.fromCharCode(s)
                );
              }
              return K(t) ? "" : String.fromCharCode(t);
          }
        }),
        (mt.readHexChar = function (e) {
          var t = this.pos,
            r = this.readInt(16, e);
          return (
            null === r &&
              this.invalidStringToken(t, "Bad character escape sequence"),
            r
          );
        }),
        (mt.readWord1 = function () {
          this.containsEsc = !1;
          for (
            var e = "", t = !0, r = this.pos, i = this.options.ecmaVersion >= 6;
            this.pos < this.input.length;
  
          ) {
            var s = this.fullCharCodeAtPos();
            if (H(s, i)) this.pos += s <= 65535 ? 1 : 2;
            else {
              if (92 !== s) break;
              (this.containsEsc = !0), (e += this.input.slice(r, this.pos));
              var n = this.pos;
              117 !== this.input.charCodeAt(++this.pos) &&
                this.invalidStringToken(
                  this.pos,
                  "Expecting Unicode escape sequence \\uXXXX"
                ),
                ++this.pos;
              var a = this.readCodePoint();
              (t ? F : H)(a, i) ||
                this.invalidStringToken(n, "Invalid Unicode escape"),
                (e += oe(a)),
                (r = this.pos);
            }
            t = !1;
          }
          return e + this.input.slice(r, this.pos);
        }),
        (mt.readWord = function () {
          var e = this.readWord1(),
            t = W.name;
          return this.keywords.test(e) && (t = G[e]), this.finishToken(t, e);
        });
      ye.acorn = {
        Parser: ye,
        version: "8.11.3",
        defaultOptions: de,
        Position: le,
        SourceLocation: he,
        getLineInfo: ue,
        Node: He,
        TokenType: Q,
        tokTypes: W,
        keywordTypes: G,
        TokContext: Re,
        tokContexts: Be,
        isIdentifierChar: H,
        isIdentifierStart: F,
        Token: gt,
        isNewLine: K,
        lineBreak: Y,
        lineBreakG: X,
        nonASCIIwhitespace: Z,
      };
      const wt = /^\s*?import\s*?[{"'*]/,
        Et = /^\s*?export\s*?({([\s\w,$\n]+?)}[\s;]*|default|class)\s+/m,
        bt =
          /^\s*?import(?:['"\s]*(?:[\w*${}\s,]+from\s*)?['"\s]?['"\s])(?:.*?)['"\s]/,
        vt =
          /(import(?:['"\s]*(?:[\w*${}\s,]+from\s*)?['"\s]?['"\s]))((?:https?|[./]).*?)(['"\s])/,
        It = [
          "window",
          "globalThis",
          "self",
          "document",
          "location",
          "top",
          "parent",
          "frames",
          "opener",
        ],
        St = It.map((e) => `(?:^|[^$.])\\b${e}\\b(?:$|[^$])`).join("|"),
        Tt = new RegExp(`(${St})`),
        _t = (() => {
          const e = "_____WB$wombat$check$this$function_____(this)",
            t =
              "WB_wombat_runEval2((_______eval_arg, isGlobal) => { var ge = eval; return isGlobal ? ge(_______eval_arg) : eval(_______eval_arg); }).eval(this, (function() { return arguments })(),";
          function r() {
            return (t, r, i, s) =>
              (function (e, t) {
                let r = e.lastIndexOf('"', t);
                return (
                  r < 0 && (r = e.indexOf('"', t)), r > 0 && "\\" === e[r - 1]
                );
              })(s, i)
                ? t
                : t.replace("this", e);
          }
          function i(e, t) {
            return (r) => r.replace(e, t);
          }
          return [
            [
              /(?:^|\s)\beval\s*\(/,
              ((o = t),
              (c = "eval"),
              (e) => {
                const t = e.indexOf(c);
                return 0 === t ? o : e.slice(0, t) + o;
              }),
            ],
            [/\([\w]+,\s*eval\)\(/, () => " " + t],
            [/[=]\s*\beval\b(?![(:.$])/, i("eval", "self.eval")],
            [/var\s+self/, i("var", "let")],
            [
              /\.postMessage\b\(/,
              (function (e) {
                return (t) => e + t;
              })(".__WB_pmw(self)"),
            ],
            [
              /(?:^|[^$.+*/%^-])\s?\blocation\b\s*[=]\s*(?![\s\d=])/,
              ((a =
                "((self.__WB_check_loc && self.__WB_check_loc(location, arguments)) || {}).href = "),
              (e, t, r, i) => {
                if (r > 0) {
                  const t = i[r - 1];
                  if ("." === t || "$" === t) return e;
                }
                return e + a;
              }),
            ],
            [/\breturn\s+this\b\s*(?![\s\w.$])/, r()],
            [
              new RegExp(`[^$.]\\s?\\bthis\\b(?=(?:\\.(?:${It.join("|")})\\b))`),
              (t, r, i, s) => {
                const n = s[i];
                return "\n" === n
                  ? t.replace("this", ";" + e)
                  : "." !== n && "$" !== n
                  ? t.replace("this", e)
                  : t;
              },
            ],
            [/[=,]\s*\bthis\b\s*(?![\s\w:.$])/, r()],
            [/\}(?:\s*\))?\s*\(this\)/, r()],
            [/[^|&][|&]{2}\s*this\b\s*(?![|\s&.$](?:[^|&]|$))/, r()],
            [/async\s+import\s*\(/, (e) => e],
            [/[^$.]\bimport\s*\([^)]*\)\s*\{/, (e) => e],
            [
              /[^$.]\bimport\s*\(/,
              ((s = "import"),
              (n = "____wb_rewrite_import__"),
              (e, t) => {
                let r = e.replace(s, n);
                return (r += t.isModule ? "import.meta.url, " : "null, "), r;
              }),
            ],
          ];
          var s, n, a, o, c;
        })();
      const Ct = new Set([
          65534, 65535, 131070, 131071, 196606, 196607, 262142, 262143, 327678,
          327679, 393214, 393215, 458750, 458751, 524286, 524287, 589822, 589823,
          655358, 655359, 720894, 720895, 786430, 786431, 851966, 851967, 917502,
          917503, 983038, 983039, 1048574, 1048575, 1114110, 1114111,
        ]),
        xt = "";
      var Nt;
      !(function (e) {
        (e[(e.EOF = -1)] = "EOF"),
          (e[(e.NULL = 0)] = "NULL"),
          (e[(e.TABULATION = 9)] = "TABULATION"),
          (e[(e.CARRIAGE_RETURN = 13)] = "CARRIAGE_RETURN"),
          (e[(e.LINE_FEED = 10)] = "LINE_FEED"),
          (e[(e.FORM_FEED = 12)] = "FORM_FEED"),
          (e[(e.SPACE = 32)] = "SPACE"),
          (e[(e.EXCLAMATION_MARK = 33)] = "EXCLAMATION_MARK"),
          (e[(e.QUOTATION_MARK = 34)] = "QUOTATION_MARK"),
          (e[(e.NUMBER_SIGN = 35)] = "NUMBER_SIGN"),
          (e[(e.AMPERSAND = 38)] = "AMPERSAND"),
          (e[(e.APOSTROPHE = 39)] = "APOSTROPHE"),
          (e[(e.HYPHEN_MINUS = 45)] = "HYPHEN_MINUS"),
          (e[(e.SOLIDUS = 47)] = "SOLIDUS"),
          (e[(e.DIGIT_0 = 48)] = "DIGIT_0"),
          (e[(e.DIGIT_9 = 57)] = "DIGIT_9"),
          (e[(e.SEMICOLON = 59)] = "SEMICOLON"),
          (e[(e.LESS_THAN_SIGN = 60)] = "LESS_THAN_SIGN"),
          (e[(e.EQUALS_SIGN = 61)] = "EQUALS_SIGN"),
          (e[(e.GREATER_THAN_SIGN = 62)] = "GREATER_THAN_SIGN"),
          (e[(e.QUESTION_MARK = 63)] = "QUESTION_MARK"),
          (e[(e.LATIN_CAPITAL_A = 65)] = "LATIN_CAPITAL_A"),
          (e[(e.LATIN_CAPITAL_F = 70)] = "LATIN_CAPITAL_F"),
          (e[(e.LATIN_CAPITAL_X = 88)] = "LATIN_CAPITAL_X"),
          (e[(e.LATIN_CAPITAL_Z = 90)] = "LATIN_CAPITAL_Z"),
          (e[(e.RIGHT_SQUARE_BRACKET = 93)] = "RIGHT_SQUARE_BRACKET"),
          (e[(e.GRAVE_ACCENT = 96)] = "GRAVE_ACCENT"),
          (e[(e.LATIN_SMALL_A = 97)] = "LATIN_SMALL_A"),
          (e[(e.LATIN_SMALL_F = 102)] = "LATIN_SMALL_F"),
          (e[(e.LATIN_SMALL_X = 120)] = "LATIN_SMALL_X"),
          (e[(e.LATIN_SMALL_Z = 122)] = "LATIN_SMALL_Z"),
          (e[(e.REPLACEMENT_CHARACTER = 65533)] = "REPLACEMENT_CHARACTER");
      })((Nt = Nt || (Nt = {})));
      const kt = "--",
        Rt = "[CDATA[",
        Bt = "doctype",
        Dt = "script",
        Ot = "public",
        Lt = "system";
      function Pt(e) {
        return e >= 55296 && e <= 57343;
      }
      function Ut(e) {
        return (
          (32 !== e &&
            10 !== e &&
            13 !== e &&
            9 !== e &&
            12 !== e &&
            e >= 1 &&
            e <= 31) ||
          (e >= 127 && e <= 159)
        );
      }
      function Mt(e) {
        return (e >= 64976 && e <= 65007) || Ct.has(e);
      }
      var Ft;
      !(function (e) {
        (e.controlCharacterInInputStream = "control-character-in-input-stream"),
          (e.noncharacterInInputStream = "noncharacter-in-input-stream"),
          (e.surrogateInInputStream = "surrogate-in-input-stream"),
          (e.nonVoidHtmlElementStartTagWithTrailingSolidus =
            "non-void-html-element-start-tag-with-trailing-solidus"),
          (e.endTagWithAttributes = "end-tag-with-attributes"),
          (e.endTagWithTrailingSolidus = "end-tag-with-trailing-solidus"),
          (e.unexpectedSolidusInTag = "unexpected-solidus-in-tag"),
          (e.unexpectedNullCharacter = "unexpected-null-character"),
          (e.unexpectedQuestionMarkInsteadOfTagName =
            "unexpected-question-mark-instead-of-tag-name"),
          (e.invalidFirstCharacterOfTagName =
            "invalid-first-character-of-tag-name"),
          (e.unexpectedEqualsSignBeforeAttributeName =
            "unexpected-equals-sign-before-attribute-name"),
          (e.missingEndTagName = "missing-end-tag-name"),
          (e.unexpectedCharacterInAttributeName =
            "unexpected-character-in-attribute-name"),
          (e.unknownNamedCharacterReference =
            "unknown-named-character-reference"),
          (e.missingSemicolonAfterCharacterReference =
            "missing-semicolon-after-character-reference"),
          (e.unexpectedCharacterAfterDoctypeSystemIdentifier =
            "unexpected-character-after-doctype-system-identifier"),
          (e.unexpectedCharacterInUnquotedAttributeValue =
            "unexpected-character-in-unquoted-attribute-value"),
          (e.eofBeforeTagName = "eof-before-tag-name"),
          (e.eofInTag = "eof-in-tag"),
          (e.missingAttributeValue = "missing-attribute-value"),
          (e.missingWhitespaceBetweenAttributes =
            "missing-whitespace-between-attributes"),
          (e.missingWhitespaceAfterDoctypePublicKeyword =
            "missing-whitespace-after-doctype-public-keyword"),
          (e.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers =
            "missing-whitespace-between-doctype-public-and-system-identifiers"),
          (e.missingWhitespaceAfterDoctypeSystemKeyword =
            "missing-whitespace-after-doctype-system-keyword"),
          (e.missingQuoteBeforeDoctypePublicIdentifier =
            "missing-quote-before-doctype-public-identifier"),
          (e.missingQuoteBeforeDoctypeSystemIdentifier =
            "missing-quote-before-doctype-system-identifier"),
          (e.missingDoctypePublicIdentifier =
            "missing-doctype-public-identifier"),
          (e.missingDoctypeSystemIdentifier =
            "missing-doctype-system-identifier"),
          (e.abruptDoctypePublicIdentifier = "abrupt-doctype-public-identifier"),
          (e.abruptDoctypeSystemIdentifier = "abrupt-doctype-system-identifier"),
          (e.cdataInHtmlContent = "cdata-in-html-content"),
          (e.incorrectlyOpenedComment = "incorrectly-opened-comment"),
          (e.eofInScriptHtmlCommentLikeText =
            "eof-in-script-html-comment-like-text"),
          (e.eofInDoctype = "eof-in-doctype"),
          (e.nestedComment = "nested-comment"),
          (e.abruptClosingOfEmptyComment = "abrupt-closing-of-empty-comment"),
          (e.eofInComment = "eof-in-comment"),
          (e.incorrectlyClosedComment = "incorrectly-closed-comment"),
          (e.eofInCdata = "eof-in-cdata"),
          (e.absenceOfDigitsInNumericCharacterReference =
            "absence-of-digits-in-numeric-character-reference"),
          (e.nullCharacterReference = "null-character-reference"),
          (e.surrogateCharacterReference = "surrogate-character-reference"),
          (e.characterReferenceOutsideUnicodeRange =
            "character-reference-outside-unicode-range"),
          (e.controlCharacterReference = "control-character-reference"),
          (e.noncharacterCharacterReference = "noncharacter-character-reference"),
          (e.missingWhitespaceBeforeDoctypeName =
            "missing-whitespace-before-doctype-name"),
          (e.missingDoctypeName = "missing-doctype-name"),
          (e.invalidCharacterSequenceAfterDoctypeName =
            "invalid-character-sequence-after-doctype-name"),
          (e.duplicateAttribute = "duplicate-attribute"),
          (e.nonConformingDoctype = "non-conforming-doctype"),
          (e.missingDoctype = "missing-doctype"),
          (e.misplacedDoctype = "misplaced-doctype"),
          (e.endTagWithoutMatchingOpenElement =
            "end-tag-without-matching-open-element"),
          (e.closingOfElementWithOpenChildElements =
            "closing-of-element-with-open-child-elements"),
          (e.disallowedContentInNoscriptInHead =
            "disallowed-content-in-noscript-in-head"),
          (e.openElementsLeftAfterEof = "open-elements-left-after-eof"),
          (e.abandonedHeadElementChild = "abandoned-head-element-child"),
          (e.misplacedStartTagForHeadElement =
            "misplaced-start-tag-for-head-element"),
          (e.nestedNoscriptInHead = "nested-noscript-in-head"),
          (e.eofInElementThatCanContainOnlyText =
            "eof-in-element-that-can-contain-only-text");
      })((Ft = Ft || (Ft = {})));
      class Ht {
        constructor(e) {
          (this.handler = e),
            (this.html = ""),
            (this.pos = -1),
            (this.lastGapPos = -2),
            (this.gapStack = []),
            (this.skipNextNewLine = !1),
            (this.lastChunkWritten = !1),
            (this.endOfChunkHit = !1),
            (this.bufferWaterline = 65536),
            (this.isEol = !1),
            (this.lineStartPos = 0),
            (this.droppedBufferSize = 0),
            (this.line = 1),
            (this.lastErrOffset = -1);
        }
        get col() {
          return (
            this.pos - this.lineStartPos + Number(this.lastGapPos !== this.pos)
          );
        }
        get offset() {
          return this.droppedBufferSize + this.pos;
        }
        getError(e) {
          const { line: t, col: r, offset: i } = this;
          return {
            code: e,
            startLine: t,
            endLine: t,
            startCol: r,
            endCol: r,
            startOffset: i,
            endOffset: i,
          };
        }
        _err(e) {
          this.handler.onParseError &&
            this.lastErrOffset !== this.offset &&
            ((this.lastErrOffset = this.offset),
            this.handler.onParseError(this.getError(e)));
        }
        _addGap() {
          this.gapStack.push(this.lastGapPos), (this.lastGapPos = this.pos);
        }
        _processSurrogate(e) {
          if (this.pos !== this.html.length - 1) {
            const t = this.html.charCodeAt(this.pos + 1);
            if (
              (function (e) {
                return e >= 56320 && e <= 57343;
              })(t)
            )
              return this.pos++, this._addGap(), 1024 * (e - 55296) + 9216 + t;
          } else if (!this.lastChunkWritten)
            return (this.endOfChunkHit = !0), Nt.EOF;
          return this._err(Ft.surrogateInInputStream), e;
        }
        willDropParsedChunk() {
          return this.pos > this.bufferWaterline;
        }
        dropParsedChunk() {
          this.willDropParsedChunk() &&
            ((this.html = this.html.substring(this.pos)),
            (this.lineStartPos -= this.pos),
            (this.droppedBufferSize += this.pos),
            (this.pos = 0),
            (this.lastGapPos = -2),
            (this.gapStack.length = 0));
        }
        write(e, t) {
          this.html.length > 0 ? (this.html += e) : (this.html = e),
            (this.endOfChunkHit = !1),
            (this.lastChunkWritten = t);
        }
        insertHtmlAtCurrentPos(e) {
          (this.html =
            this.html.substring(0, this.pos + 1) +
            e +
            this.html.substring(this.pos + 1)),
            (this.endOfChunkHit = !1);
        }
        startsWith(e, t) {
          if (this.pos + e.length > this.html.length)
            return (this.endOfChunkHit = !this.lastChunkWritten), !1;
          if (t) return this.html.startsWith(e, this.pos);
          for (let t = 0; t < e.length; t++) {
            if ((32 | this.html.charCodeAt(this.pos + t)) !== e.charCodeAt(t))
              return !1;
          }
          return !0;
        }
        peek(e) {
          const t = this.pos + e;
          if (t >= this.html.length)
            return (this.endOfChunkHit = !this.lastChunkWritten), Nt.EOF;
          const r = this.html.charCodeAt(t);
          return r === Nt.CARRIAGE_RETURN ? Nt.LINE_FEED : r;
        }
        advance() {
          if (
            (this.pos++,
            this.isEol &&
              ((this.isEol = !1), this.line++, (this.lineStartPos = this.pos)),
            this.pos >= this.html.length)
          )
            return (this.endOfChunkHit = !this.lastChunkWritten), Nt.EOF;
          let e = this.html.charCodeAt(this.pos);
          if (e === Nt.CARRIAGE_RETURN)
            return (this.isEol = !0), (this.skipNextNewLine = !0), Nt.LINE_FEED;
          if (e === Nt.LINE_FEED && ((this.isEol = !0), this.skipNextNewLine))
            return (
              this.line--,
              (this.skipNextNewLine = !1),
              this._addGap(),
              this.advance()
            );
          (this.skipNextNewLine = !1), Pt(e) && (e = this._processSurrogate(e));
          return (
            null === this.handler.onParseError ||
              (e > 31 && e < 127) ||
              e === Nt.LINE_FEED ||
              e === Nt.CARRIAGE_RETURN ||
              (e > 159 && e < 64976) ||
              this._checkForProblematicCharacters(e),
            e
          );
        }
        _checkForProblematicCharacters(e) {
          Ut(e)
            ? this._err(Ft.controlCharacterInInputStream)
            : Mt(e) && this._err(Ft.noncharacterInInputStream);
        }
        retreat(e) {
          for (this.pos -= e; this.pos < this.lastGapPos; )
            (this.lastGapPos = this.gapStack.pop()), this.pos--;
          this.isEol = !1;
        }
      }
      var Qt;
      !(function (e) {
        (e[(e.CHARACTER = 0)] = "CHARACTER"),
          (e[(e.NULL_CHARACTER = 1)] = "NULL_CHARACTER"),
          (e[(e.WHITESPACE_CHARACTER = 2)] = "WHITESPACE_CHARACTER"),
          (e[(e.START_TAG = 3)] = "START_TAG"),
          (e[(e.END_TAG = 4)] = "END_TAG"),
          (e[(e.COMMENT = 5)] = "COMMENT"),
          (e[(e.DOCTYPE = 6)] = "DOCTYPE"),
          (e[(e.EOF = 7)] = "EOF"),
          (e[(e.HIBERNATION = 8)] = "HIBERNATION");
      })((Qt = Qt || (Qt = {})));
      const Vt = new Uint16Array(
          '<\0\0\0\0\0\0EMabcfglmnoprstu\\bfmsligP&cutereve;iyx}rc;r;ravepha;acr;d;gpon;f;plyFunction;ingcsr;ign;ildemlaceforsucrkslash;;ed;y;crtause;noullis;a;r;pf;eve;cmpeq;HOacdefhilorsucy;PYcpyute;;italDifferentialD;leys;aeioron;dilrc;nint;ot;dnilla;terDot;i;rcleDMPTot;inus;lus;imes;ocskwiseContourIntegral;eCurlyDQoubleQuote;uote;lnpuon;e;gitruent;nt;ourIntegral;fr;oduct;nterClockwiseContourIntegral;oss;cr;p;Cap;DJSZacefios;otrahd;cy;cy;cy;grsger;r;hv;ayron;;l;ta;r;afcmriticalADGTcute;o;bleAcute;rave;ilde;ond;ferentialD;\0\0\0\0f;;DEot;qual;bleCDLRUVontourIntegrao\0\0nArrow;eoftARTrrow;ightArrow;engLReftARrrow;ightArrow;ightArrow;ightATrrow;ee;p\0\0rrow;ownArrow;erticalBar;nABLRTarrow;BUar;pArrow;reve;eft\0\0ightVector;eeVector;ector;Bar;ight\0eeVector;ector;Bar;ee;Arrow;ctr;rok;NTacdfglmopqstuxG;Hcuteaiyron;rc;ot;r;raveement;apcr;ty\0\0mallSquare;erySmallSquare;gpon;f;silon;uail;Tilde;librium;cir;m;a;mlipsts;onentialE;cfiosy;r;lled\0\0mallSquare;erySmallSquare;\0\0\0f;All;riertrf;cJTabcdfgorstcy;>mma;d;reve;eiydil;rc;;ot;r;;pf;eaterEFGLSTqual;Less;ullEqual;reater;ess;lantEqual;ilde;cr;;AacfiosuRDcy;ctek;;irc;r;lbertSpace;\0f;izontalLine;ctrok;mpownHumqual;EJOacdfgmnostucy;lig;cy;cuteiyrc;ot;r;rave;apcgr;inaryI;lie\0;egrral;section;isibleCTomma;imes;gpton;f;a;cr;ilde;\0cy;lcfosuiyrc;;r;pf;\0r;rcy;kcy;HJacfoscy;cy;ppa;eydil;;r;pf;cr;JTaceflmostcy;<cmnprute;bda;g;lacetrf;r;aeyron;dil;;fstACDFRTUVarnrgleBracket;row;BRar;ightArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ightAVrrow;ector;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;ightsEFGLSTqualGreater;ullEqual;reater;ess;lantEqual;ilde;r;;eftarrow;idot;npwgLRlreftARrrow;ightArrow;ightArrow;eftarightightf;erLReftArrow;ightArrow;cht;rok;;acefiosup;y;dliumSpace;lintrf;r;nusPlus;pf;c;Jacefostucy;cute;aeyron;dil;;gswativeMTVediumSpace;hicneryThitedGLreaterGreateessLesLine;r;Bnptreak;BreakingSpace;f;;CDEGHLNPRSTVoungruent;pCap;oubleVerticalBar;lqxement;ual;Tilde;ists;reater;EFGLSTqual;ullEqual;reater;ess;lantEqual;ilde;umpownHump;qual;efstTriangle;BEar;qual;s;EGLSTqual;reater;ess;lantEqual;ilde;estedGLreaterGreater;essLess;recedes;ESqual;lantEqual;eiverseElement;ghtTriangle;BEar;qual;quuareSubpset;Equal;erset;Equal;bcpset;Equal;ceeds;ESTqual;lantEqual;ilde;erset;Equal;ilde;EFTqual;ullEqual;ilde;erticalBar;cr;ilde;Eacdfgmoprstuvlig;cuteiyrc;blac;r;raveaeicr;ga;cron;pf;enCurlyDQoubleQuote;uote;;clr;ashidees;mlerBParr;acek;et;arenthesis;acfhilorsrtialD;y;r;i;;usMinus;ipncareplanf;;eiocedes;ESTqual;lantEqual;ilde;me;dpuct;ortion;al;cir;;UfosOT"r;pf;cr;BEacefhiorsuarr;Gcnrute;g;r;tl;aeyron;dil;;;verseEUlqement;uilibrium;pEquilibrium;ro;ghtACDFTUVanrgleBracket;row;BLar;eftArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;puf;ndImplies;ightarrow;chr;;leDelayed;HOacfhimoqstuCcHcy;y;FTcy;cute;;aeiyron;dil;rc;;r;ortDLRUownArroweftArrowightArrowpArrow;gma;allCircle;pf;\0\0t;are;ISUntersection;ubpset;Equal;erset;Equal;nion;cr;ar;bcmp;set;Equal;cheeds;ESTqual;lantEqual;ilde;Th;;esrset;Equal;etHRSacfhiorsORNADE;Hccy;y;bu;;aeyron;dil;;r;ei\0efore;a;cnkSpace;Space;lde;EFTqual;ullEqual;ilde;pf;ipleDot;ctr;rok;\0\0\0\0\0\0\0cruter;ocir;r\0y;ve;iyrc;blac;r;raveacr;dierBParr;acek;et;arenthesis;on;Plus;gpon;f;ADETadpsrrow;BDar;ownArrow;ownArrow;quilibrium;ee;Arrow;ownerLReftArrow;ightArrow;i;lon;ing;cr;ilde;mlDbcdefosvash;ar;y;ash;l;er;btyar;;icalBLSTar;ine;eparator;ilde;ThinSpace;r;pf;cr;dash;cefosirc;dge;r;pf;cr;fiosr;;pf;cr;AIUacfosucy;cy;cy;cuteiyrc;;r;pf;cr;ml;Hacdefoscy;cute;ayron;;ot;\0oWidta;r;pf;cr;\0\0\0\0\0\0\0cutereve;;Ediuy;;rcte;lig;r;raveepfpsym;ha;apcclr;g;\0\0;adsvnd;;lope;;;elmrsz;esd;a;;;;;;;;t;vb;d;pth;arr;gpon;f;;Eaeiop;cir;;d;s;rox;eingctyr;;mp;eildemlcioninnt;Nabcdefiklnoprsuot;crkcepsong;psilon;rime;im;eq;ee;ed;gerk;tbrk;oy;quo;cmprtaus;eptyv;snoahw;;een;r;gcostuvwaiurc;pdptot;lus;imes;\0\0cup;ar;riangleduown;p;plus;earow;akocnklstozenge;riangle;dlrown;eft;ight;k;\0\0;;4;ck;eo;q=uiv;t;ptwxf;;tomtie;DHUVbdhmptuvLRlr;;;;;DUdu;;;;LRlr;;;;;HLRhlr;;;;;;ox;LRlr;;;;;DUdu;;;;inus;lus;imes;LRlr;;;;;HLRhlr;;;;;;evbarceior;mi;m;el;bh;sub;l;etp;Ee;;q\0\0\0\0\0\0\0\0\0\0cprute;;abcdsnd;rcup;aup;p;ot;;eot;aeiu\0s;on;dilrc;ps;sm;ot;dmnilptyv;t;err;ceiy;ck;mark;r;Ecefms;;elq;e\0\0rrowlreft;ight;RSacd;st;irc;ash;nint;id;cir;ubs;uit\0on;e;q\0\0a;t;;flemxente\0;dot;nfry;o;sr;aorr;ss;cur;bp;e;;e;dot;delprvwarrlr;;\0\0r;c;arr;p;;bcdosrcap;aup;p;ot;r;;alrvrr;m;yevwq\0\0reuee;edge;enearrowlreftightecioninnt;lcty;AHabcdefhijlorstuwzrar;glrsger;eth;h;varow;aayron;;;aogrr;tseq;glmta;ptyv;irsht;;arlraegsvm;osnd;suit;amma;in;;iode;ontimes;ncy;c\0\0rn;op;lptuwlar;f;;empsq;dot;inus;lus;quare;blebarwedgnadhownarrowarpoonlrefighkaro\0\0rn;op;cotry;;l;rok;drot;i;fahraangle;ciy;grarr;DacdefglmnopqrstuxDoocsuteter;aioyron;r;clon;;ot;Drot;;;rsave;dot;;ilsnters;;;dot;apscr;ty;svetp1;;;gs;p;gpon;f;alsr;sl;us;i;lvon;csuviorc\0\0antgltressaeils;st;v;DD;parsl;Daot;rr;cdir;oah;mrlo;cipl;seoctationential\0\0\0\0\0\0\0llingdotsey;male;ilrlig;\0\0g;ig;;lig;lig;fjaltt;ig;ns;of;\0f;ak;v;artint;aocs\0\0;;;;\0;;\0\0;;5;\0;;8;l;wn;cr;Eabcdefgijlnorstv;l;cmpute;ma;d;reve;iyrc;;ot;;lqs;qslan;cdlc;ot;o;l;;es;r;;gmel;cy;;Eaj;;;Eaes;p;prox;q;qim;pf;cir;m;el;;>;cdlqrci;r;ot;Par;uest;adels\0pror;qlqlesienrtneqq;Aabcefkosyrilmrrsfildrcy;;cwir;;ar;irc;alrrts;uitlip;con;r;sewarow;arow;amoprrr;tht;klreftarrow;ightarrow;f;bar;cltr;asrok;bpull;hen\0\0\0\0\0\0cute;iyrc;cxy;clfr;rave;inoinnt;t;fin;ta;lig;aopcgtr;elpinarh;f;ed;;cfotare;in;tie;do;celpal;grerarhk;rod;cgpty;on;f;a;uestcir;n;Edsv;ot;;v;;ilde;\0cy;lcfmosuiyrc;;r;ath;pf;\0r;rcy;kcy;acfghjosppa;v;eydil;;r;reen;cy;cy;pf;cr;ABEHabcdefghjlmnoprstuvartrail;arr;;g;ar;\0\0\0\0\0\0\0\0\0ute;mptyv;rabda;g;dl;;uor;bfhlpst;fs;s;p;l;im;l;;aeil;;s;abrrr;rk;akcek;;es;ldu;;aeuyron;diil;;cqrsa;uo;rduhar;shar;h;;fgqstahlrtrrow;taarpoonduownpeftarrows;ightahsrrow;sarpoonquigarrohreetimes;;qslan;cdgsc;ot;o;r;;es;adegspproot;qgqgtiilrsht;;;E;rdu;l;lk;cy;;achtrorneard;ri;iodot;ust;acheEaes;p;prox;q;qim;abnoptwznrg;r;rglmreftarightapsto;ightparrowlrefight;aflr;;us;imes;st;;efngear;lt;achmtrornear;d;;ri;achiqtquo;r;m;eg;;buo;r;rok;<;cdhilqrci;r;remes;arr;uest;Piar;;efrdushar;har;enrtneqq;DacdefhilnopsuDot;clprret;;ese;sto;dluowefker;oymma;;ash;asuredangler;o;cdnro;acdsir;otus;bd;u;p;dpels;f;ctr;pos;lmtimap;GLRVabcdefghijlmoprstuvwgt;;veltftarrrow;ightarrow;;;vightarrow;Ddash;ash;bcnptlaute;g;;Eiop;d;s;rour;al;s\0pmp;eaeouy\0;on;dil;ng;dot;p;;ash;;Aadqsxrr;rhrk;;oot;uieiar;ist;sr;Eest;qs;qslani;rAaprrr;ar;;sv;d;cy;AEadestr;rr;r;;fqstarrroightarro;qslan;si;ri;eiptf;;inn;Edv;ot;;;i;v;;aorr;astllel;;lint;;ceu;c;eAaitrrr;cw;;ghtarrowri;echimpqu;ceru;ort\0\0arm;e;qsubpbcp;Ees;et;eq;qc;e;Ees;et;eq;qgilrldeianglelreft;eight;e;m;esro;p;DHadgilrsash;arr;p;ash;et;;>nfin;Aetrr;;;r<ie;Atrr;rie;im;Aanrr;rhrk;;oear;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0csuteiyr;c;abioslac;v;old;lig;crir;;\0\0\0n;ave;bmar;acitrirr;oss;n;aeicr;ga;cdnron;;pf;aelr;rp;;adiosvr;efmr;ofgof;r;lope;;cloashl;idees;as;mlbar;\0\0\0\0\0\0\0\0\0r;ast;lle\0\0m;;y;rcimptnt;od;il;enk;r;imo;v;mane;;tvchfork;aunckk;h;s;abcdemstcir;ir;ou;;nim;wo;ipuntint;f;nd;Eaceinosu;p;u;c;acenspprourlyeaespprox;qq;im;ime;sEasdfpalslar;ine;urf;;trel;cir;;ncsp;fiopsur;pf;rime;cr;aeoteirnionnt;st;eABHabcdefhilmnoprstuxartrail;arar;cdenqrteu;te;imptyv;g;del;;uor;abcfhlpstwp;;fs;;s;l;im;l;;aiil;o;nalabrrrk;akcek;;es;ldu;;aeuyron;diil;;clqsa;dhar;uo;rh;acgl;ipsnart;ilrsht;;aordu;l;;v;gnshtahlrstrrow;taarpoonduowpeftahrrowarpoonightarrows;quigarrohreetimes;g;ingdotseahmra;oust;achemid;abptnrg;r;raflr;;us;imes;apr;gt;olint;arachqquo;r;buo;rhirremes;i;efltri;luhar;;\0\0\0\0\0\0\0cute;qu;Eaceinpsy;\0;on;u;dil;rc;Eas;p;im;olint;i;ot;be;Aacmstxrr;rhr;oti;war;minnut;r;oacoyrp;hycy;;rt\0\0iaragmma;fv;;deglnprot;;q;E;;E;e;lus;arr;araeitlslsetmhp;parsl;dle;;e;s;flptcy;;b;ar;f;adres;uitcsuaup;s;p;s;ubp;eset;e;eset;e;afrarcemtr;tmiararr;fanighteppsilohsbcmnp;Edemnprs;ot;;dot;ult;Ee;;lus;arr;eiut;enq;qeq;qm;bp;;c;acenspprourlyeaespproqg;123;Edehlmnps;ost;ub;;dot;soul;b;arr;ult;Ee;;lus;eiut;enq;qeq;qm;bp;;Aanrr;rhr;owar;lig\0\0\0\0\0\0\0\0\0\0\0\0get;;raeyron;dil;;lrec;r;eiko\0e4fa;svym;cnkaspproimsasrnes;bd;ar;;eps;bcfot;ir;;ork;rime;aipdadempstngle;dlqrowneft;e;ight;eot;inus;lus;b;ime;ezium;chtry;;cy;rok;ioxheadlreftarroightarrowAHabcdfghlmoprstuwrar;cruter\0y;ve;iyrc;abhrlac;airsht;;raverlrlk;ct\0\0rn;erop;ri;alcr;gpon;f;adhlsuownarpoonlrefighi;hlonparrows;cit\0\0rn;erop;ng;ri;cr;dirot;lde;i;famrlangle;ABDacdeflnoprszrar;v;asnrgrt;eknprstappothinhirop;hiugmbpsetneq;q;setneq;q;hretianglelreftighty;ashelr;bear;q;lip;btar;trsubppf;rotrcur;bpnEenEeigzag;cefoprsirc;dibgar;e;q;erp;r;pf;;eatcr;\0\0\0\0\0\0\0trr;Aarr;Aarrais;dptfl;imAarrcqr;ptracefiosucuyte;iyrc;;nr;cy;pf;cr;cmy;lacdefhioswcute;ayron;;ot;ettra;r;cy;grarr;pf;cr;jn;j;'
            .split("")
            .map((e) => e.charCodeAt(0))
        ),
        zt = new Uint16Array(
          "aglq\t\0\0p;os;t;t;uot;"
            .split("")
            .map((e) => e.charCodeAt(0))
        );
      var qt;
      const Gt = new Map([
          [0, 65533],
          [128, 8364],
          [130, 8218],
          [131, 402],
          [132, 8222],
          [133, 8230],
          [134, 8224],
          [135, 8225],
          [136, 710],
          [137, 8240],
          [138, 352],
          [139, 8249],
          [140, 338],
          [142, 381],
          [145, 8216],
          [146, 8217],
          [147, 8220],
          [148, 8221],
          [149, 8226],
          [150, 8211],
          [151, 8212],
          [152, 732],
          [153, 8482],
          [154, 353],
          [155, 8250],
          [156, 339],
          [158, 382],
          [159, 376],
        ]),
        jt =
          null !== (qt = String.fromCodePoint) && void 0 !== qt
            ? qt
            : function (e) {
                let t = "";
                return (
                  e > 65535 &&
                    ((e -= 65536),
                    (t += String.fromCharCode(((e >>> 10) & 1023) | 55296)),
                    (e = 56320 | (1023 & e))),
                  (t += String.fromCharCode(e)),
                  t
                );
              };
      function Wt(e) {
        var t;
        return (e >= 55296 && e <= 57343) || e > 1114111
          ? 65533
          : null !== (t = Gt.get(e)) && void 0 !== t
          ? t
          : e;
      }
      var Yt;
      !(function (e) {
        (e[(e.NUM = 35)] = "NUM"),
          (e[(e.SEMI = 59)] = "SEMI"),
          (e[(e.EQUALS = 61)] = "EQUALS"),
          (e[(e.ZERO = 48)] = "ZERO"),
          (e[(e.NINE = 57)] = "NINE"),
          (e[(e.LOWER_A = 97)] = "LOWER_A"),
          (e[(e.LOWER_F = 102)] = "LOWER_F"),
          (e[(e.LOWER_X = 120)] = "LOWER_X"),
          (e[(e.LOWER_Z = 122)] = "LOWER_Z"),
          (e[(e.UPPER_A = 65)] = "UPPER_A"),
          (e[(e.UPPER_F = 70)] = "UPPER_F"),
          (e[(e.UPPER_Z = 90)] = "UPPER_Z");
      })(Yt || (Yt = {}));
      var Xt, Kt, Jt;
      function Zt(e) {
        return e >= Yt.ZERO && e <= Yt.NINE;
      }
      function $t(e) {
        return (
          e === Yt.EQUALS ||
          (function (e) {
            return (
              (e >= Yt.UPPER_A && e <= Yt.UPPER_Z) ||
              (e >= Yt.LOWER_A && e <= Yt.LOWER_Z) ||
              Zt(e)
            );
          })(e)
        );
      }
      !(function (e) {
        (e[(e.VALUE_LENGTH = 49152)] = "VALUE_LENGTH"),
          (e[(e.BRANCH_LENGTH = 16256)] = "BRANCH_LENGTH"),
          (e[(e.JUMP_TABLE = 127)] = "JUMP_TABLE");
      })(Xt || (Xt = {})),
        (function (e) {
          (e[(e.EntityStart = 0)] = "EntityStart"),
            (e[(e.NumericStart = 1)] = "NumericStart"),
            (e[(e.NumericDecimal = 2)] = "NumericDecimal"),
            (e[(e.NumericHex = 3)] = "NumericHex"),
            (e[(e.NamedEntity = 4)] = "NamedEntity");
        })(Kt || (Kt = {})),
        (function (e) {
          (e[(e.Legacy = 0)] = "Legacy"),
            (e[(e.Strict = 1)] = "Strict"),
            (e[(e.Attribute = 2)] = "Attribute");
        })(Jt || (Jt = {}));
      class er {
        constructor(e, t, r) {
          (this.decodeTree = e),
            (this.emitCodePoint = t),
            (this.errors = r),
            (this.state = Kt.EntityStart),
            (this.consumed = 1),
            (this.result = 0),
            (this.treeIndex = 0),
            (this.excess = 1),
            (this.decodeMode = Jt.Strict);
        }
        startEntity(e) {
          (this.decodeMode = e),
            (this.state = Kt.EntityStart),
            (this.result = 0),
            (this.treeIndex = 0),
            (this.excess = 1),
            (this.consumed = 1);
        }
        write(e, t) {
          switch (this.state) {
            case Kt.EntityStart:
              return e.charCodeAt(t) === Yt.NUM
                ? ((this.state = Kt.NumericStart),
                  (this.consumed += 1),
                  this.stateNumericStart(e, t + 1))
                : ((this.state = Kt.NamedEntity), this.stateNamedEntity(e, t));
            case Kt.NumericStart:
              return this.stateNumericStart(e, t);
            case Kt.NumericDecimal:
              return this.stateNumericDecimal(e, t);
            case Kt.NumericHex:
              return this.stateNumericHex(e, t);
            case Kt.NamedEntity:
              return this.stateNamedEntity(e, t);
          }
        }
        stateNumericStart(e, t) {
          return t >= e.length
            ? -1
            : (32 | e.charCodeAt(t)) === Yt.LOWER_X
            ? ((this.state = Kt.NumericHex),
              (this.consumed += 1),
              this.stateNumericHex(e, t + 1))
            : ((this.state = Kt.NumericDecimal), this.stateNumericDecimal(e, t));
        }
        addToNumericResult(e, t, r, i) {
          if (t !== r) {
            const s = r - t;
            (this.result =
              this.result * Math.pow(i, s) + parseInt(e.substr(t, s), i)),
              (this.consumed += s);
          }
        }
        stateNumericHex(e, t) {
          const r = t;
          for (; t < e.length; ) {
            const s = e.charCodeAt(t);
            if (
              !(
                Zt(s) ||
                ((i = s),
                (i >= Yt.UPPER_A && i <= Yt.UPPER_F) ||
                  (i >= Yt.LOWER_A && i <= Yt.LOWER_F))
              )
            )
              return (
                this.addToNumericResult(e, r, t, 16), this.emitNumericEntity(s, 3)
              );
            t += 1;
          }
          var i;
          return this.addToNumericResult(e, r, t, 16), -1;
        }
        stateNumericDecimal(e, t) {
          const r = t;
          for (; t < e.length; ) {
            const i = e.charCodeAt(t);
            if (!Zt(i))
              return (
                this.addToNumericResult(e, r, t, 10), this.emitNumericEntity(i, 2)
              );
            t += 1;
          }
          return this.addToNumericResult(e, r, t, 10), -1;
        }
        emitNumericEntity(e, t) {
          var r;
          if (this.consumed <= t)
            return (
              null === (r = this.errors) ||
                void 0 === r ||
                r.absenceOfDigitsInNumericCharacterReference(this.consumed),
              0
            );
          if (e === Yt.SEMI) this.consumed += 1;
          else if (this.decodeMode === Jt.Strict) return 0;
          return (
            this.emitCodePoint(Wt(this.result), this.consumed),
            this.errors &&
              (e !== Yt.SEMI &&
                this.errors.missingSemicolonAfterCharacterReference(),
              this.errors.validateNumericCharacterReference(this.result)),
            this.consumed
          );
        }
        stateNamedEntity(e, t) {
          const { decodeTree: r } = this;
          let i = r[this.treeIndex],
            s = (i & Xt.VALUE_LENGTH) >> 14;
          for (; t < e.length; t++, this.excess++) {
            const n = e.charCodeAt(t);
            if (
              ((this.treeIndex = rr(r, i, this.treeIndex + Math.max(1, s), n)),
              this.treeIndex < 0)
            )
              return 0 === this.result ||
                (this.decodeMode === Jt.Attribute && (0 === s || $t(n)))
                ? 0
                : this.emitNotTerminatedNamedEntity();
            if (
              ((i = r[this.treeIndex]),
              (s = (i & Xt.VALUE_LENGTH) >> 14),
              0 !== s)
            ) {
              if (n === Yt.SEMI)
                return this.emitNamedEntityData(
                  this.treeIndex,
                  s,
                  this.consumed + this.excess
                );
              this.decodeMode !== Jt.Strict &&
                ((this.result = this.treeIndex),
                (this.consumed += this.excess),
                (this.excess = 0));
            }
          }
          return -1;
        }
        emitNotTerminatedNamedEntity() {
          var e;
          const { result: t, decodeTree: r } = this,
            i = (r[t] & Xt.VALUE_LENGTH) >> 14;
          return (
            this.emitNamedEntityData(t, i, this.consumed),
            null === (e = this.errors) ||
              void 0 === e ||
              e.missingSemicolonAfterCharacterReference(),
            this.consumed
          );
        }
        emitNamedEntityData(e, t, r) {
          const { decodeTree: i } = this;
          return (
            this.emitCodePoint(1 === t ? i[e] & ~Xt.VALUE_LENGTH : i[e + 1], r),
            3 === t && this.emitCodePoint(i[e + 2], r),
            r
          );
        }
        end() {
          var e;
          switch (this.state) {
            case Kt.NamedEntity:
              return 0 === this.result ||
                (this.decodeMode === Jt.Attribute &&
                  this.result !== this.treeIndex)
                ? 0
                : this.emitNotTerminatedNamedEntity();
            case Kt.NumericDecimal:
              return this.emitNumericEntity(0, 2);
            case Kt.NumericHex:
              return this.emitNumericEntity(0, 3);
            case Kt.NumericStart:
              return (
                null === (e = this.errors) ||
                  void 0 === e ||
                  e.absenceOfDigitsInNumericCharacterReference(this.consumed),
                0
              );
            case Kt.EntityStart:
              return 0;
          }
        }
      }
      function tr(e) {
        let t = "";
        const r = new er(e, (e) => (t += jt(e)));
        return function (e, i) {
          let s = 0,
            n = 0;
          for (; (n = e.indexOf("&", n)) >= 0; ) {
            (t += e.slice(s, n)), r.startEntity(i);
            const a = r.write(e, n + 1);
            if (a < 0) {
              s = n + r.end();
              break;
            }
            (s = n + a), (n = 0 === a ? s + 1 : s);
          }
          const a = t + e.slice(s);
          return (t = ""), a;
        };
      }
      function rr(e, t, r, i) {
        const s = (t & Xt.BRANCH_LENGTH) >> 7,
          n = t & Xt.JUMP_TABLE;
        if (0 === s) return 0 !== n && i === n ? r : -1;
        if (n) {
          const t = i - n;
          return t < 0 || t >= s ? -1 : e[r + t] - 1;
        }
        let a = r,
          o = a + s - 1;
        for (; a <= o; ) {
          const t = (a + o) >>> 1,
            r = e[t];
          if (r < i) a = t + 1;
          else {
            if (!(r > i)) return e[t + s];
            o = t - 1;
          }
        }
        return -1;
      }
      tr(Vt), tr(zt);
      var ir, sr, nr, ar, or;
      !(function (e) {
        (e.HTML = "http://www.w3.org/1999/xhtml"),
          (e.MATHML = "http://www.w3.org/1998/Math/MathML"),
          (e.SVG = "http://www.w3.org/2000/svg"),
          (e.XLINK = "http://www.w3.org/1999/xlink"),
          (e.XML = "http://www.w3.org/XML/1998/namespace"),
          (e.XMLNS = "http://www.w3.org/2000/xmlns/");
      })((ir = ir || (ir = {}))),
        (function (e) {
          (e.TYPE = "type"),
            (e.ACTION = "action"),
            (e.ENCODING = "encoding"),
            (e.PROMPT = "prompt"),
            (e.NAME = "name"),
            (e.COLOR = "color"),
            (e.FACE = "face"),
            (e.SIZE = "size");
        })((sr = sr || (sr = {}))),
        (function (e) {
          (e.NO_QUIRKS = "no-quirks"),
            (e.QUIRKS = "quirks"),
            (e.LIMITED_QUIRKS = "limited-quirks");
        })((nr = nr || (nr = {}))),
        (function (e) {
          (e.A = "a"),
            (e.ADDRESS = "address"),
            (e.ANNOTATION_XML = "annotation-xml"),
            (e.APPLET = "applet"),
            (e.AREA = "area"),
            (e.ARTICLE = "article"),
            (e.ASIDE = "aside"),
            (e.B = "b"),
            (e.BASE = "base"),
            (e.BASEFONT = "basefont"),
            (e.BGSOUND = "bgsound"),
            (e.BIG = "big"),
            (e.BLOCKQUOTE = "blockquote"),
            (e.BODY = "body"),
            (e.BR = "br"),
            (e.BUTTON = "button"),
            (e.CAPTION = "caption"),
            (e.CENTER = "center"),
            (e.CODE = "code"),
            (e.COL = "col"),
            (e.COLGROUP = "colgroup"),
            (e.DD = "dd"),
            (e.DESC = "desc"),
            (e.DETAILS = "details"),
            (e.DIALOG = "dialog"),
            (e.DIR = "dir"),
            (e.DIV = "div"),
            (e.DL = "dl"),
            (e.DT = "dt"),
            (e.EM = "em"),
            (e.EMBED = "embed"),
            (e.FIELDSET = "fieldset"),
            (e.FIGCAPTION = "figcaption"),
            (e.FIGURE = "figure"),
            (e.FONT = "font"),
            (e.FOOTER = "footer"),
            (e.FOREIGN_OBJECT = "foreignObject"),
            (e.FORM = "form"),
            (e.FRAME = "frame"),
            (e.FRAMESET = "frameset"),
            (e.H1 = "h1"),
            (e.H2 = "h2"),
            (e.H3 = "h3"),
            (e.H4 = "h4"),
            (e.H5 = "h5"),
            (e.H6 = "h6"),
            (e.HEAD = "head"),
            (e.HEADER = "header"),
            (e.HGROUP = "hgroup"),
            (e.HR = "hr"),
            (e.HTML = "html"),
            (e.I = "i"),
            (e.IMG = "img"),
            (e.IMAGE = "image"),
            (e.INPUT = "input"),
            (e.IFRAME = "iframe"),
            (e.KEYGEN = "keygen"),
            (e.LABEL = "label"),
            (e.LI = "li"),
            (e.LINK = "link"),
            (e.LISTING = "listing"),
            (e.MAIN = "main"),
            (e.MALIGNMARK = "malignmark"),
            (e.MARQUEE = "marquee"),
            (e.MATH = "math"),
            (e.MENU = "menu"),
            (e.META = "meta"),
            (e.MGLYPH = "mglyph"),
            (e.MI = "mi"),
            (e.MO = "mo"),
            (e.MN = "mn"),
            (e.MS = "ms"),
            (e.MTEXT = "mtext"),
            (e.NAV = "nav"),
            (e.NOBR = "nobr"),
            (e.NOFRAMES = "noframes"),
            (e.NOEMBED = "noembed"),
            (e.NOSCRIPT = "noscript"),
            (e.OBJECT = "object"),
            (e.OL = "ol"),
            (e.OPTGROUP = "optgroup"),
            (e.OPTION = "option"),
            (e.P = "p"),
            (e.PARAM = "param"),
            (e.PLAINTEXT = "plaintext"),
            (e.PRE = "pre"),
            (e.RB = "rb"),
            (e.RP = "rp"),
            (e.RT = "rt"),
            (e.RTC = "rtc"),
            (e.RUBY = "ruby"),
            (e.S = "s"),
            (e.SCRIPT = "script"),
            (e.SECTION = "section"),
            (e.SELECT = "select"),
            (e.SOURCE = "source"),
            (e.SMALL = "small"),
            (e.SPAN = "span"),
            (e.STRIKE = "strike"),
            (e.STRONG = "strong"),
            (e.STYLE = "style"),
            (e.SUB = "sub"),
            (e.SUMMARY = "summary"),
            (e.SUP = "sup"),
            (e.TABLE = "table"),
            (e.TBODY = "tbody"),
            (e.TEMPLATE = "template"),
            (e.TEXTAREA = "textarea"),
            (e.TFOOT = "tfoot"),
            (e.TD = "td"),
            (e.TH = "th"),
            (e.THEAD = "thead"),
            (e.TITLE = "title"),
            (e.TR = "tr"),
            (e.TRACK = "track"),
            (e.TT = "tt"),
            (e.U = "u"),
            (e.UL = "ul"),
            (e.SVG = "svg"),
            (e.VAR = "var"),
            (e.WBR = "wbr"),
            (e.XMP = "xmp");
        })((ar = ar || (ar = {}))),
        (function (e) {
          (e[(e.UNKNOWN = 0)] = "UNKNOWN"),
            (e[(e.A = 1)] = "A"),
            (e[(e.ADDRESS = 2)] = "ADDRESS"),
            (e[(e.ANNOTATION_XML = 3)] = "ANNOTATION_XML"),
            (e[(e.APPLET = 4)] = "APPLET"),
            (e[(e.AREA = 5)] = "AREA"),
            (e[(e.ARTICLE = 6)] = "ARTICLE"),
            (e[(e.ASIDE = 7)] = "ASIDE"),
            (e[(e.B = 8)] = "B"),
            (e[(e.BASE = 9)] = "BASE"),
            (e[(e.BASEFONT = 10)] = "BASEFONT"),
            (e[(e.BGSOUND = 11)] = "BGSOUND"),
            (e[(e.BIG = 12)] = "BIG"),
            (e[(e.BLOCKQUOTE = 13)] = "BLOCKQUOTE"),
            (e[(e.BODY = 14)] = "BODY"),
            (e[(e.BR = 15)] = "BR"),
            (e[(e.BUTTON = 16)] = "BUTTON"),
            (e[(e.CAPTION = 17)] = "CAPTION"),
            (e[(e.CENTER = 18)] = "CENTER"),
            (e[(e.CODE = 19)] = "CODE"),
            (e[(e.COL = 20)] = "COL"),
            (e[(e.COLGROUP = 21)] = "COLGROUP"),
            (e[(e.DD = 22)] = "DD"),
            (e[(e.DESC = 23)] = "DESC"),
            (e[(e.DETAILS = 24)] = "DETAILS"),
            (e[(e.DIALOG = 25)] = "DIALOG"),
            (e[(e.DIR = 26)] = "DIR"),
            (e[(e.DIV = 27)] = "DIV"),
            (e[(e.DL = 28)] = "DL"),
            (e[(e.DT = 29)] = "DT"),
            (e[(e.EM = 30)] = "EM"),
            (e[(e.EMBED = 31)] = "EMBED"),
            (e[(e.FIELDSET = 32)] = "FIELDSET"),
            (e[(e.FIGCAPTION = 33)] = "FIGCAPTION"),
            (e[(e.FIGURE = 34)] = "FIGURE"),
            (e[(e.FONT = 35)] = "FONT"),
            (e[(e.FOOTER = 36)] = "FOOTER"),
            (e[(e.FOREIGN_OBJECT = 37)] = "FOREIGN_OBJECT"),
            (e[(e.FORM = 38)] = "FORM"),
            (e[(e.FRAME = 39)] = "FRAME"),
            (e[(e.FRAMESET = 40)] = "FRAMESET"),
            (e[(e.H1 = 41)] = "H1"),
            (e[(e.H2 = 42)] = "H2"),
            (e[(e.H3 = 43)] = "H3"),
            (e[(e.H4 = 44)] = "H4"),
            (e[(e.H5 = 45)] = "H5"),
            (e[(e.H6 = 46)] = "H6"),
            (e[(e.HEAD = 47)] = "HEAD"),
            (e[(e.HEADER = 48)] = "HEADER"),
            (e[(e.HGROUP = 49)] = "HGROUP"),
            (e[(e.HR = 50)] = "HR"),
            (e[(e.HTML = 51)] = "HTML"),
            (e[(e.I = 52)] = "I"),
            (e[(e.IMG = 53)] = "IMG"),
            (e[(e.IMAGE = 54)] = "IMAGE"),
            (e[(e.INPUT = 55)] = "INPUT"),
            (e[(e.IFRAME = 56)] = "IFRAME"),
            (e[(e.KEYGEN = 57)] = "KEYGEN"),
            (e[(e.LABEL = 58)] = "LABEL"),
            (e[(e.LI = 59)] = "LI"),
            (e[(e.LINK = 60)] = "LINK"),
            (e[(e.LISTING = 61)] = "LISTING"),
            (e[(e.MAIN = 62)] = "MAIN"),
            (e[(e.MALIGNMARK = 63)] = "MALIGNMARK"),
            (e[(e.MARQUEE = 64)] = "MARQUEE"),
            (e[(e.MATH = 65)] = "MATH"),
            (e[(e.MENU = 66)] = "MENU"),
            (e[(e.META = 67)] = "META"),
            (e[(e.MGLYPH = 68)] = "MGLYPH"),
            (e[(e.MI = 69)] = "MI"),
            (e[(e.MO = 70)] = "MO"),
            (e[(e.MN = 71)] = "MN"),
            (e[(e.MS = 72)] = "MS"),
            (e[(e.MTEXT = 73)] = "MTEXT"),
            (e[(e.NAV = 74)] = "NAV"),
            (e[(e.NOBR = 75)] = "NOBR"),
            (e[(e.NOFRAMES = 76)] = "NOFRAMES"),
            (e[(e.NOEMBED = 77)] = "NOEMBED"),
            (e[(e.NOSCRIPT = 78)] = "NOSCRIPT"),
            (e[(e.OBJECT = 79)] = "OBJECT"),
            (e[(e.OL = 80)] = "OL"),
            (e[(e.OPTGROUP = 81)] = "OPTGROUP"),
            (e[(e.OPTION = 82)] = "OPTION"),
            (e[(e.P = 83)] = "P"),
            (e[(e.PARAM = 84)] = "PARAM"),
            (e[(e.PLAINTEXT = 85)] = "PLAINTEXT"),
            (e[(e.PRE = 86)] = "PRE"),
            (e[(e.RB = 87)] = "RB"),
            (e[(e.RP = 88)] = "RP"),
            (e[(e.RT = 89)] = "RT"),
            (e[(e.RTC = 90)] = "RTC"),
            (e[(e.RUBY = 91)] = "RUBY"),
            (e[(e.S = 92)] = "S"),
            (e[(e.SCRIPT = 93)] = "SCRIPT"),
            (e[(e.SECTION = 94)] = "SECTION"),
            (e[(e.SELECT = 95)] = "SELECT"),
            (e[(e.SOURCE = 96)] = "SOURCE"),
            (e[(e.SMALL = 97)] = "SMALL"),
            (e[(e.SPAN = 98)] = "SPAN"),
            (e[(e.STRIKE = 99)] = "STRIKE"),
            (e[(e.STRONG = 100)] = "STRONG"),
            (e[(e.STYLE = 101)] = "STYLE"),
            (e[(e.SUB = 102)] = "SUB"),
            (e[(e.SUMMARY = 103)] = "SUMMARY"),
            (e[(e.SUP = 104)] = "SUP"),
            (e[(e.TABLE = 105)] = "TABLE"),
            (e[(e.TBODY = 106)] = "TBODY"),
            (e[(e.TEMPLATE = 107)] = "TEMPLATE"),
            (e[(e.TEXTAREA = 108)] = "TEXTAREA"),
            (e[(e.TFOOT = 109)] = "TFOOT"),
            (e[(e.TD = 110)] = "TD"),
            (e[(e.TH = 111)] = "TH"),
            (e[(e.THEAD = 112)] = "THEAD"),
            (e[(e.TITLE = 113)] = "TITLE"),
            (e[(e.TR = 114)] = "TR"),
            (e[(e.TRACK = 115)] = "TRACK"),
            (e[(e.TT = 116)] = "TT"),
            (e[(e.U = 117)] = "U"),
            (e[(e.UL = 118)] = "UL"),
            (e[(e.SVG = 119)] = "SVG"),
            (e[(e.VAR = 120)] = "VAR"),
            (e[(e.WBR = 121)] = "WBR"),
            (e[(e.XMP = 122)] = "XMP");
        })((or = or || (or = {})));
      const cr = new Map([
        [ar.A, or.A],
        [ar.ADDRESS, or.ADDRESS],
        [ar.ANNOTATION_XML, or.ANNOTATION_XML],
        [ar.APPLET, or.APPLET],
        [ar.AREA, or.AREA],
        [ar.ARTICLE, or.ARTICLE],
        [ar.ASIDE, or.ASIDE],
        [ar.B, or.B],
        [ar.BASE, or.BASE],
        [ar.BASEFONT, or.BASEFONT],
        [ar.BGSOUND, or.BGSOUND],
        [ar.BIG, or.BIG],
        [ar.BLOCKQUOTE, or.BLOCKQUOTE],
        [ar.BODY, or.BODY],
        [ar.BR, or.BR],
        [ar.BUTTON, or.BUTTON],
        [ar.CAPTION, or.CAPTION],
        [ar.CENTER, or.CENTER],
        [ar.CODE, or.CODE],
        [ar.COL, or.COL],
        [ar.COLGROUP, or.COLGROUP],
        [ar.DD, or.DD],
        [ar.DESC, or.DESC],
        [ar.DETAILS, or.DETAILS],
        [ar.DIALOG, or.DIALOG],
        [ar.DIR, or.DIR],
        [ar.DIV, or.DIV],
        [ar.DL, or.DL],
        [ar.DT, or.DT],
        [ar.EM, or.EM],
        [ar.EMBED, or.EMBED],
        [ar.FIELDSET, or.FIELDSET],
        [ar.FIGCAPTION, or.FIGCAPTION],
        [ar.FIGURE, or.FIGURE],
        [ar.FONT, or.FONT],
        [ar.FOOTER, or.FOOTER],
        [ar.FOREIGN_OBJECT, or.FOREIGN_OBJECT],
        [ar.FORM, or.FORM],
        [ar.FRAME, or.FRAME],
        [ar.FRAMESET, or.FRAMESET],
        [ar.H1, or.H1],
        [ar.H2, or.H2],
        [ar.H3, or.H3],
        [ar.H4, or.H4],
        [ar.H5, or.H5],
        [ar.H6, or.H6],
        [ar.HEAD, or.HEAD],
        [ar.HEADER, or.HEADER],
        [ar.HGROUP, or.HGROUP],
        [ar.HR, or.HR],
        [ar.HTML, or.HTML],
        [ar.I, or.I],
        [ar.IMG, or.IMG],
        [ar.IMAGE, or.IMAGE],
        [ar.INPUT, or.INPUT],
        [ar.IFRAME, or.IFRAME],
        [ar.KEYGEN, or.KEYGEN],
        [ar.LABEL, or.LABEL],
        [ar.LI, or.LI],
        [ar.LINK, or.LINK],
        [ar.LISTING, or.LISTING],
        [ar.MAIN, or.MAIN],
        [ar.MALIGNMARK, or.MALIGNMARK],
        [ar.MARQUEE, or.MARQUEE],
        [ar.MATH, or.MATH],
        [ar.MENU, or.MENU],
        [ar.META, or.META],
        [ar.MGLYPH, or.MGLYPH],
        [ar.MI, or.MI],
        [ar.MO, or.MO],
        [ar.MN, or.MN],
        [ar.MS, or.MS],
        [ar.MTEXT, or.MTEXT],
        [ar.NAV, or.NAV],
        [ar.NOBR, or.NOBR],
        [ar.NOFRAMES, or.NOFRAMES],
        [ar.NOEMBED, or.NOEMBED],
        [ar.NOSCRIPT, or.NOSCRIPT],
        [ar.OBJECT, or.OBJECT],
        [ar.OL, or.OL],
        [ar.OPTGROUP, or.OPTGROUP],
        [ar.OPTION, or.OPTION],
        [ar.P, or.P],
        [ar.PARAM, or.PARAM],
        [ar.PLAINTEXT, or.PLAINTEXT],
        [ar.PRE, or.PRE],
        [ar.RB, or.RB],
        [ar.RP, or.RP],
        [ar.RT, or.RT],
        [ar.RTC, or.RTC],
        [ar.RUBY, or.RUBY],
        [ar.S, or.S],
        [ar.SCRIPT, or.SCRIPT],
        [ar.SECTION, or.SECTION],
        [ar.SELECT, or.SELECT],
        [ar.SOURCE, or.SOURCE],
        [ar.SMALL, or.SMALL],
        [ar.SPAN, or.SPAN],
        [ar.STRIKE, or.STRIKE],
        [ar.STRONG, or.STRONG],
        [ar.STYLE, or.STYLE],
        [ar.SUB, or.SUB],
        [ar.SUMMARY, or.SUMMARY],
        [ar.SUP, or.SUP],
        [ar.TABLE, or.TABLE],
        [ar.TBODY, or.TBODY],
        [ar.TEMPLATE, or.TEMPLATE],
        [ar.TEXTAREA, or.TEXTAREA],
        [ar.TFOOT, or.TFOOT],
        [ar.TD, or.TD],
        [ar.TH, or.TH],
        [ar.THEAD, or.THEAD],
        [ar.TITLE, or.TITLE],
        [ar.TR, or.TR],
        [ar.TRACK, or.TRACK],
        [ar.TT, or.TT],
        [ar.U, or.U],
        [ar.UL, or.UL],
        [ar.SVG, or.SVG],
        [ar.VAR, or.VAR],
        [ar.WBR, or.WBR],
        [ar.XMP, or.XMP],
      ]);
      function lr(e) {
        var t;
        return null !== (t = cr.get(e)) && void 0 !== t ? t : or.UNKNOWN;
      }
      const hr = or;
      ir.HTML,
        new Set([
          hr.ADDRESS,
          hr.APPLET,
          hr.AREA,
          hr.ARTICLE,
          hr.ASIDE,
          hr.BASE,
          hr.BASEFONT,
          hr.BGSOUND,
          hr.BLOCKQUOTE,
          hr.BODY,
          hr.BR,
          hr.BUTTON,
          hr.CAPTION,
          hr.CENTER,
          hr.COL,
          hr.COLGROUP,
          hr.DD,
          hr.DETAILS,
          hr.DIR,
          hr.DIV,
          hr.DL,
          hr.DT,
          hr.EMBED,
          hr.FIELDSET,
          hr.FIGCAPTION,
          hr.FIGURE,
          hr.FOOTER,
          hr.FORM,
          hr.FRAME,
          hr.FRAMESET,
          hr.H1,
          hr.H2,
          hr.H3,
          hr.H4,
          hr.H5,
          hr.H6,
          hr.HEAD,
          hr.HEADER,
          hr.HGROUP,
          hr.HR,
          hr.HTML,
          hr.IFRAME,
          hr.IMG,
          hr.INPUT,
          hr.LI,
          hr.LINK,
          hr.LISTING,
          hr.MAIN,
          hr.MARQUEE,
          hr.MENU,
          hr.META,
          hr.NAV,
          hr.NOEMBED,
          hr.NOFRAMES,
          hr.NOSCRIPT,
          hr.OBJECT,
          hr.OL,
          hr.P,
          hr.PARAM,
          hr.PLAINTEXT,
          hr.PRE,
          hr.SCRIPT,
          hr.SECTION,
          hr.SELECT,
          hr.SOURCE,
          hr.STYLE,
          hr.SUMMARY,
          hr.TABLE,
          hr.TBODY,
          hr.TD,
          hr.TEMPLATE,
          hr.TEXTAREA,
          hr.TFOOT,
          hr.TH,
          hr.THEAD,
          hr.TITLE,
          hr.TR,
          hr.TRACK,
          hr.UL,
          hr.WBR,
          hr.XMP,
        ]),
        ir.MATHML,
        new Set([hr.MI, hr.MO, hr.MN, hr.MS, hr.MTEXT, hr.ANNOTATION_XML]),
        ir.SVG,
        new Set([hr.TITLE, hr.FOREIGN_OBJECT, hr.DESC]),
        ir.XLINK,
        new Set(),
        ir.XML,
        new Set(),
        ir.XMLNS,
        new Set();
      new Set([
        ar.STYLE,
        ar.SCRIPT,
        ar.XMP,
        ar.IFRAME,
        ar.NOEMBED,
        ar.NOFRAMES,
        ar.PLAINTEXT,
      ]);
      const ur = new Map([
        [128, 8364],
        [130, 8218],
        [131, 402],
        [132, 8222],
        [133, 8230],
        [134, 8224],
        [135, 8225],
        [136, 710],
        [137, 8240],
        [138, 352],
        [139, 8249],
        [140, 338],
        [142, 381],
        [145, 8216],
        [146, 8217],
        [147, 8220],
        [148, 8221],
        [149, 8226],
        [150, 8211],
        [151, 8212],
        [152, 732],
        [153, 8482],
        [154, 353],
        [155, 8250],
        [156, 339],
        [158, 382],
        [159, 376],
      ]);
      var dr;
      !(function (e) {
        (e[(e.DATA = 0)] = "DATA"),
          (e[(e.RCDATA = 1)] = "RCDATA"),
          (e[(e.RAWTEXT = 2)] = "RAWTEXT"),
          (e[(e.SCRIPT_DATA = 3)] = "SCRIPT_DATA"),
          (e[(e.PLAINTEXT = 4)] = "PLAINTEXT"),
          (e[(e.TAG_OPEN = 5)] = "TAG_OPEN"),
          (e[(e.END_TAG_OPEN = 6)] = "END_TAG_OPEN"),
          (e[(e.TAG_NAME = 7)] = "TAG_NAME"),
          (e[(e.RCDATA_LESS_THAN_SIGN = 8)] = "RCDATA_LESS_THAN_SIGN"),
          (e[(e.RCDATA_END_TAG_OPEN = 9)] = "RCDATA_END_TAG_OPEN"),
          (e[(e.RCDATA_END_TAG_NAME = 10)] = "RCDATA_END_TAG_NAME"),
          (e[(e.RAWTEXT_LESS_THAN_SIGN = 11)] = "RAWTEXT_LESS_THAN_SIGN"),
          (e[(e.RAWTEXT_END_TAG_OPEN = 12)] = "RAWTEXT_END_TAG_OPEN"),
          (e[(e.RAWTEXT_END_TAG_NAME = 13)] = "RAWTEXT_END_TAG_NAME"),
          (e[(e.SCRIPT_DATA_LESS_THAN_SIGN = 14)] = "SCRIPT_DATA_LESS_THAN_SIGN"),
          (e[(e.SCRIPT_DATA_END_TAG_OPEN = 15)] = "SCRIPT_DATA_END_TAG_OPEN"),
          (e[(e.SCRIPT_DATA_END_TAG_NAME = 16)] = "SCRIPT_DATA_END_TAG_NAME"),
          (e[(e.SCRIPT_DATA_ESCAPE_START = 17)] = "SCRIPT_DATA_ESCAPE_START"),
          (e[(e.SCRIPT_DATA_ESCAPE_START_DASH = 18)] =
            "SCRIPT_DATA_ESCAPE_START_DASH"),
          (e[(e.SCRIPT_DATA_ESCAPED = 19)] = "SCRIPT_DATA_ESCAPED"),
          (e[(e.SCRIPT_DATA_ESCAPED_DASH = 20)] = "SCRIPT_DATA_ESCAPED_DASH"),
          (e[(e.SCRIPT_DATA_ESCAPED_DASH_DASH = 21)] =
            "SCRIPT_DATA_ESCAPED_DASH_DASH"),
          (e[(e.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN = 22)] =
            "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN"),
          (e[(e.SCRIPT_DATA_ESCAPED_END_TAG_OPEN = 23)] =
            "SCRIPT_DATA_ESCAPED_END_TAG_OPEN"),
          (e[(e.SCRIPT_DATA_ESCAPED_END_TAG_NAME = 24)] =
            "SCRIPT_DATA_ESCAPED_END_TAG_NAME"),
          (e[(e.SCRIPT_DATA_DOUBLE_ESCAPE_START = 25)] =
            "SCRIPT_DATA_DOUBLE_ESCAPE_START"),
          (e[(e.SCRIPT_DATA_DOUBLE_ESCAPED = 26)] = "SCRIPT_DATA_DOUBLE_ESCAPED"),
          (e[(e.SCRIPT_DATA_DOUBLE_ESCAPED_DASH = 27)] =
            "SCRIPT_DATA_DOUBLE_ESCAPED_DASH"),
          (e[(e.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH = 28)] =
            "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH"),
          (e[(e.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN = 29)] =
            "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN"),
          (e[(e.SCRIPT_DATA_DOUBLE_ESCAPE_END = 30)] =
            "SCRIPT_DATA_DOUBLE_ESCAPE_END"),
          (e[(e.BEFORE_ATTRIBUTE_NAME = 31)] = "BEFORE_ATTRIBUTE_NAME"),
          (e[(e.ATTRIBUTE_NAME = 32)] = "ATTRIBUTE_NAME"),
          (e[(e.AFTER_ATTRIBUTE_NAME = 33)] = "AFTER_ATTRIBUTE_NAME"),
          (e[(e.BEFORE_ATTRIBUTE_VALUE = 34)] = "BEFORE_ATTRIBUTE_VALUE"),
          (e[(e.ATTRIBUTE_VALUE_DOUBLE_QUOTED = 35)] =
            "ATTRIBUTE_VALUE_DOUBLE_QUOTED"),
          (e[(e.ATTRIBUTE_VALUE_SINGLE_QUOTED = 36)] =
            "ATTRIBUTE_VALUE_SINGLE_QUOTED"),
          (e[(e.ATTRIBUTE_VALUE_UNQUOTED = 37)] = "ATTRIBUTE_VALUE_UNQUOTED"),
          (e[(e.AFTER_ATTRIBUTE_VALUE_QUOTED = 38)] =
            "AFTER_ATTRIBUTE_VALUE_QUOTED"),
          (e[(e.SELF_CLOSING_START_TAG = 39)] = "SELF_CLOSING_START_TAG"),
          (e[(e.BOGUS_COMMENT = 40)] = "BOGUS_COMMENT"),
          (e[(e.MARKUP_DECLARATION_OPEN = 41)] = "MARKUP_DECLARATION_OPEN"),
          (e[(e.COMMENT_START = 42)] = "COMMENT_START"),
          (e[(e.COMMENT_START_DASH = 43)] = "COMMENT_START_DASH"),
          (e[(e.COMMENT = 44)] = "COMMENT"),
          (e[(e.COMMENT_LESS_THAN_SIGN = 45)] = "COMMENT_LESS_THAN_SIGN"),
          (e[(e.COMMENT_LESS_THAN_SIGN_BANG = 46)] =
            "COMMENT_LESS_THAN_SIGN_BANG"),
          (e[(e.COMMENT_LESS_THAN_SIGN_BANG_DASH = 47)] =
            "COMMENT_LESS_THAN_SIGN_BANG_DASH"),
          (e[(e.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH = 48)] =
            "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH"),
          (e[(e.COMMENT_END_DASH = 49)] = "COMMENT_END_DASH"),
          (e[(e.COMMENT_END = 50)] = "COMMENT_END"),
          (e[(e.COMMENT_END_BANG = 51)] = "COMMENT_END_BANG"),
          (e[(e.DOCTYPE = 52)] = "DOCTYPE"),
          (e[(e.BEFORE_DOCTYPE_NAME = 53)] = "BEFORE_DOCTYPE_NAME"),
          (e[(e.DOCTYPE_NAME = 54)] = "DOCTYPE_NAME"),
          (e[(e.AFTER_DOCTYPE_NAME = 55)] = "AFTER_DOCTYPE_NAME"),
          (e[(e.AFTER_DOCTYPE_PUBLIC_KEYWORD = 56)] =
            "AFTER_DOCTYPE_PUBLIC_KEYWORD"),
          (e[(e.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER = 57)] =
            "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER"),
          (e[(e.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED = 58)] =
            "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED"),
          (e[(e.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED = 59)] =
            "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED"),
          (e[(e.AFTER_DOCTYPE_PUBLIC_IDENTIFIER = 60)] =
            "AFTER_DOCTYPE_PUBLIC_IDENTIFIER"),
          (e[(e.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS = 61)] =
            "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS"),
          (e[(e.AFTER_DOCTYPE_SYSTEM_KEYWORD = 62)] =
            "AFTER_DOCTYPE_SYSTEM_KEYWORD"),
          (e[(e.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER = 63)] =
            "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER"),
          (e[(e.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED = 64)] =
            "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED"),
          (e[(e.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED = 65)] =
            "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED"),
          (e[(e.AFTER_DOCTYPE_SYSTEM_IDENTIFIER = 66)] =
            "AFTER_DOCTYPE_SYSTEM_IDENTIFIER"),
          (e[(e.BOGUS_DOCTYPE = 67)] = "BOGUS_DOCTYPE"),
          (e[(e.CDATA_SECTION = 68)] = "CDATA_SECTION"),
          (e[(e.CDATA_SECTION_BRACKET = 69)] = "CDATA_SECTION_BRACKET"),
          (e[(e.CDATA_SECTION_END = 70)] = "CDATA_SECTION_END"),
          (e[(e.CHARACTER_REFERENCE = 71)] = "CHARACTER_REFERENCE"),
          (e[(e.NAMED_CHARACTER_REFERENCE = 72)] = "NAMED_CHARACTER_REFERENCE"),
          (e[(e.AMBIGUOUS_AMPERSAND = 73)] = "AMBIGUOUS_AMPERSAND"),
          (e[(e.NUMERIC_CHARACTER_REFERENCE = 74)] =
            "NUMERIC_CHARACTER_REFERENCE"),
          (e[(e.HEXADEMICAL_CHARACTER_REFERENCE_START = 75)] =
            "HEXADEMICAL_CHARACTER_REFERENCE_START"),
          (e[(e.HEXADEMICAL_CHARACTER_REFERENCE = 76)] =
            "HEXADEMICAL_CHARACTER_REFERENCE"),
          (e[(e.DECIMAL_CHARACTER_REFERENCE = 77)] =
            "DECIMAL_CHARACTER_REFERENCE"),
          (e[(e.NUMERIC_CHARACTER_REFERENCE_END = 78)] =
            "NUMERIC_CHARACTER_REFERENCE_END");
      })(dr || (dr = {}));
      const pr = {
        DATA: dr.DATA,
        RCDATA: dr.RCDATA,
        RAWTEXT: dr.RAWTEXT,
        SCRIPT_DATA: dr.SCRIPT_DATA,
        PLAINTEXT: dr.PLAINTEXT,
        CDATA_SECTION: dr.CDATA_SECTION,
      };
      function fr(e) {
        return e >= Nt.DIGIT_0 && e <= Nt.DIGIT_9;
      }
      function gr(e) {
        return e >= Nt.LATIN_CAPITAL_A && e <= Nt.LATIN_CAPITAL_Z;
      }
      function mr(e) {
        return (
          (function (e) {
            return e >= Nt.LATIN_SMALL_A && e <= Nt.LATIN_SMALL_Z;
          })(e) || gr(e)
        );
      }
      function yr(e) {
        return mr(e) || fr(e);
      }
      function Ar(e) {
        return e >= Nt.LATIN_CAPITAL_A && e <= Nt.LATIN_CAPITAL_F;
      }
      function wr(e) {
        return e >= Nt.LATIN_SMALL_A && e <= Nt.LATIN_SMALL_F;
      }
      function Er(e) {
        return e + 32;
      }
      function br(e) {
        return (
          e === Nt.SPACE ||
          e === Nt.LINE_FEED ||
          e === Nt.TABULATION ||
          e === Nt.FORM_FEED
        );
      }
      function vr(e) {
        return br(e) || e === Nt.SOLIDUS || e === Nt.GREATER_THAN_SIGN;
      }
      class Ir {
        constructor(e, t) {
          (this.options = e),
            (this.handler = t),
            (this.paused = !1),
            (this.inLoop = !1),
            (this.inForeignNode = !1),
            (this.lastStartTagName = ""),
            (this.active = !1),
            (this.state = dr.DATA),
            (this.returnState = dr.DATA),
            (this.charRefCode = -1),
            (this.consumedAfterSnapshot = -1),
            (this.currentCharacterToken = null),
            (this.currentToken = null),
            (this.currentAttr = { name: "", value: "" }),
            (this.preprocessor = new Ht(t)),
            (this.currentLocation = this.getCurrentLocation(-1));
        }
        _err(e) {
          var t, r;
          null === (r = (t = this.handler).onParseError) ||
            void 0 === r ||
            r.call(t, this.preprocessor.getError(e));
        }
        getCurrentLocation(e) {
          return this.options.sourceCodeLocationInfo
            ? {
                startLine: this.preprocessor.line,
                startCol: this.preprocessor.col - e,
                startOffset: this.preprocessor.offset - e,
                endLine: -1,
                endCol: -1,
                endOffset: -1,
              }
            : null;
        }
        _runParsingLoop() {
          if (!this.inLoop) {
            for (this.inLoop = !0; this.active && !this.paused; ) {
              this.consumedAfterSnapshot = 0;
              const e = this._consume();
              this._ensureHibernation() || this._callState(e);
            }
            this.inLoop = !1;
          }
        }
        pause() {
          this.paused = !0;
        }
        resume(e) {
          if (!this.paused) throw new Error("Parser was already resumed");
          (this.paused = !1),
            this.inLoop ||
              (this._runParsingLoop(), this.paused || null == e || e());
        }
        write(e, t, r) {
          (this.active = !0),
            this.preprocessor.write(e, t),
            this._runParsingLoop(),
            this.paused || null == r || r();
        }
        insertHtmlAtCurrentPos(e) {
          (this.active = !0),
            this.preprocessor.insertHtmlAtCurrentPos(e),
            this._runParsingLoop();
        }
        _ensureHibernation() {
          return (
            !!this.preprocessor.endOfChunkHit &&
            (this._unconsume(this.consumedAfterSnapshot), (this.active = !1), !0)
          );
        }
        _consume() {
          return this.consumedAfterSnapshot++, this.preprocessor.advance();
        }
        _unconsume(e) {
          (this.consumedAfterSnapshot -= e), this.preprocessor.retreat(e);
        }
        _reconsumeInState(e, t) {
          (this.state = e), this._callState(t);
        }
        _advanceBy(e) {
          this.consumedAfterSnapshot += e;
          for (let t = 0; t < e; t++) this.preprocessor.advance();
        }
        _consumeSequenceIfMatch(e, t) {
          return (
            !!this.preprocessor.startsWith(e, t) &&
            (this._advanceBy(e.length - 1), !0)
          );
        }
        _createStartTagToken() {
          this.currentToken = {
            type: Qt.START_TAG,
            tagName: "",
            tagID: or.UNKNOWN,
            selfClosing: !1,
            ackSelfClosing: !1,
            attrs: [],
            location: this.getCurrentLocation(1),
          };
        }
        _createEndTagToken() {
          this.currentToken = {
            type: Qt.END_TAG,
            tagName: "",
            tagID: or.UNKNOWN,
            selfClosing: !1,
            ackSelfClosing: !1,
            attrs: [],
            location: this.getCurrentLocation(2),
          };
        }
        _createCommentToken(e) {
          this.currentToken = {
            type: Qt.COMMENT,
            data: "",
            location: this.getCurrentLocation(e),
          };
        }
        _createDoctypeToken(e) {
          this.currentToken = {
            type: Qt.DOCTYPE,
            name: e,
            forceQuirks: !1,
            publicId: null,
            systemId: null,
            location: this.currentLocation,
          };
        }
        _createCharacterToken(e, t) {
          this.currentCharacterToken = {
            type: e,
            chars: t,
            location: this.currentLocation,
          };
        }
        _createAttr(e) {
          (this.currentAttr = { name: e, value: "" }),
            (this.currentLocation = this.getCurrentLocation(0));
        }
        _leaveAttrName() {
          var e, t;
          const r = this.currentToken;
          if (
            null ===
            (function (e, t) {
              for (let r = e.attrs.length - 1; r >= 0; r--)
                if (e.attrs[r].name === t) return e.attrs[r].value;
              return null;
            })(r, this.currentAttr.name)
          ) {
            if (
              (r.attrs.push(this.currentAttr), r.location && this.currentLocation)
            ) {
              ((null !== (e = (t = r.location).attrs) && void 0 !== e
                ? e
                : (t.attrs = Object.create(null)))[this.currentAttr.name] =
                this.currentLocation),
                this._leaveAttrValue();
            }
          } else this._err(Ft.duplicateAttribute);
        }
        _leaveAttrValue() {
          this.currentLocation &&
            ((this.currentLocation.endLine = this.preprocessor.line),
            (this.currentLocation.endCol = this.preprocessor.col),
            (this.currentLocation.endOffset = this.preprocessor.offset));
        }
        prepareToken(e) {
          this._emitCurrentCharacterToken(e.location),
            (this.currentToken = null),
            e.location &&
              ((e.location.endLine = this.preprocessor.line),
              (e.location.endCol = this.preprocessor.col + 1),
              (e.location.endOffset = this.preprocessor.offset + 1)),
            (this.currentLocation = this.getCurrentLocation(-1));
        }
        emitCurrentTagToken() {
          const e = this.currentToken;
          this.prepareToken(e),
            (e.tagID = lr(e.tagName)),
            e.type === Qt.START_TAG
              ? ((this.lastStartTagName = e.tagName), this.handler.onStartTag(e))
              : (e.attrs.length > 0 && this._err(Ft.endTagWithAttributes),
                e.selfClosing && this._err(Ft.endTagWithTrailingSolidus),
                this.handler.onEndTag(e)),
            this.preprocessor.dropParsedChunk();
        }
        emitCurrentComment(e) {
          this.prepareToken(e),
            this.handler.onComment(e),
            this.preprocessor.dropParsedChunk();
        }
        emitCurrentDoctype(e) {
          this.prepareToken(e),
            this.handler.onDoctype(e),
            this.preprocessor.dropParsedChunk();
        }
        _emitCurrentCharacterToken(e) {
          if (this.currentCharacterToken) {
            switch (
              (e &&
                this.currentCharacterToken.location &&
                ((this.currentCharacterToken.location.endLine = e.startLine),
                (this.currentCharacterToken.location.endCol = e.startCol),
                (this.currentCharacterToken.location.endOffset = e.startOffset)),
              this.currentCharacterToken.type)
            ) {
              case Qt.CHARACTER:
                this.handler.onCharacter(this.currentCharacterToken);
                break;
              case Qt.NULL_CHARACTER:
                this.handler.onNullCharacter(this.currentCharacterToken);
                break;
              case Qt.WHITESPACE_CHARACTER:
                this.handler.onWhitespaceCharacter(this.currentCharacterToken);
            }
            this.currentCharacterToken = null;
          }
        }
        _emitEOFToken() {
          const e = this.getCurrentLocation(0);
          e &&
            ((e.endLine = e.startLine),
            (e.endCol = e.startCol),
            (e.endOffset = e.startOffset)),
            this._emitCurrentCharacterToken(e),
            this.handler.onEof({ type: Qt.EOF, location: e }),
            (this.active = !1);
        }
        _appendCharToCurrentCharacterToken(e, t) {
          if (this.currentCharacterToken) {
            if (this.currentCharacterToken.type === e)
              return void (this.currentCharacterToken.chars += t);
            (this.currentLocation = this.getCurrentLocation(0)),
              this._emitCurrentCharacterToken(this.currentLocation),
              this.preprocessor.dropParsedChunk();
          }
          this._createCharacterToken(e, t);
        }
        _emitCodePoint(e) {
          const t = br(e)
            ? Qt.WHITESPACE_CHARACTER
            : e === Nt.NULL
            ? Qt.NULL_CHARACTER
            : Qt.CHARACTER;
          this._appendCharToCurrentCharacterToken(t, String.fromCodePoint(e));
        }
        _emitChars(e) {
          this._appendCharToCurrentCharacterToken(Qt.CHARACTER, e);
        }
        _matchNamedCharacterReference(e) {
          let t = null,
            r = 0,
            i = !1;
          for (
            let n = 0, a = Vt[0];
            n >= 0 && ((n = rr(Vt, a, n + 1, e)), !(n < 0));
            e = this._consume()
          ) {
            (r += 1), (a = Vt[n]);
            const o = a & Xt.VALUE_LENGTH;
            if (o) {
              const a = (o >> 14) - 1;
              if (
                (e !== Nt.SEMICOLON &&
                this._isCharacterReferenceInAttribute() &&
                ((s = this.preprocessor.peek(1)) === Nt.EQUALS_SIGN || yr(s))
                  ? ((t = [Nt.AMPERSAND]), (n += a))
                  : ((t =
                      0 === a
                        ? [Vt[n] & ~Xt.VALUE_LENGTH]
                        : 1 === a
                        ? [Vt[++n]]
                        : [Vt[++n], Vt[++n]]),
                    (r = 0),
                    (i = e !== Nt.SEMICOLON)),
                0 === a)
              ) {
                this._consume();
                break;
              }
            }
          }
          var s;
          return (
            this._unconsume(r),
            i &&
              !this.preprocessor.endOfChunkHit &&
              this._err(Ft.missingSemicolonAfterCharacterReference),
            this._unconsume(1),
            t
          );
        }
        _isCharacterReferenceInAttribute() {
          return (
            this.returnState === dr.ATTRIBUTE_VALUE_DOUBLE_QUOTED ||
            this.returnState === dr.ATTRIBUTE_VALUE_SINGLE_QUOTED ||
            this.returnState === dr.ATTRIBUTE_VALUE_UNQUOTED
          );
        }
        _flushCodePointConsumedAsCharacterReference(e) {
          this._isCharacterReferenceInAttribute()
            ? (this.currentAttr.value += String.fromCodePoint(e))
            : this._emitCodePoint(e);
        }
        _callState(e) {
          switch (this.state) {
            case dr.DATA:
              this._stateData(e);
              break;
            case dr.RCDATA:
              this._stateRcdata(e);
              break;
            case dr.RAWTEXT:
              this._stateRawtext(e);
              break;
            case dr.SCRIPT_DATA:
              this._stateScriptData(e);
              break;
            case dr.PLAINTEXT:
              this._statePlaintext(e);
              break;
            case dr.TAG_OPEN:
              this._stateTagOpen(e);
              break;
            case dr.END_TAG_OPEN:
              this._stateEndTagOpen(e);
              break;
            case dr.TAG_NAME:
              this._stateTagName(e);
              break;
            case dr.RCDATA_LESS_THAN_SIGN:
              this._stateRcdataLessThanSign(e);
              break;
            case dr.RCDATA_END_TAG_OPEN:
              this._stateRcdataEndTagOpen(e);
              break;
            case dr.RCDATA_END_TAG_NAME:
              this._stateRcdataEndTagName(e);
              break;
            case dr.RAWTEXT_LESS_THAN_SIGN:
              this._stateRawtextLessThanSign(e);
              break;
            case dr.RAWTEXT_END_TAG_OPEN:
              this._stateRawtextEndTagOpen(e);
              break;
            case dr.RAWTEXT_END_TAG_NAME:
              this._stateRawtextEndTagName(e);
              break;
            case dr.SCRIPT_DATA_LESS_THAN_SIGN:
              this._stateScriptDataLessThanSign(e);
              break;
            case dr.SCRIPT_DATA_END_TAG_OPEN:
              this._stateScriptDataEndTagOpen(e);
              break;
            case dr.SCRIPT_DATA_END_TAG_NAME:
              this._stateScriptDataEndTagName(e);
              break;
            case dr.SCRIPT_DATA_ESCAPE_START:
              this._stateScriptDataEscapeStart(e);
              break;
            case dr.SCRIPT_DATA_ESCAPE_START_DASH:
              this._stateScriptDataEscapeStartDash(e);
              break;
            case dr.SCRIPT_DATA_ESCAPED:
              this._stateScriptDataEscaped(e);
              break;
            case dr.SCRIPT_DATA_ESCAPED_DASH:
              this._stateScriptDataEscapedDash(e);
              break;
            case dr.SCRIPT_DATA_ESCAPED_DASH_DASH:
              this._stateScriptDataEscapedDashDash(e);
              break;
            case dr.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN:
              this._stateScriptDataEscapedLessThanSign(e);
              break;
            case dr.SCRIPT_DATA_ESCAPED_END_TAG_OPEN:
              this._stateScriptDataEscapedEndTagOpen(e);
              break;
            case dr.SCRIPT_DATA_ESCAPED_END_TAG_NAME:
              this._stateScriptDataEscapedEndTagName(e);
              break;
            case dr.SCRIPT_DATA_DOUBLE_ESCAPE_START:
              this._stateScriptDataDoubleEscapeStart(e);
              break;
            case dr.SCRIPT_DATA_DOUBLE_ESCAPED:
              this._stateScriptDataDoubleEscaped(e);
              break;
            case dr.SCRIPT_DATA_DOUBLE_ESCAPED_DASH:
              this._stateScriptDataDoubleEscapedDash(e);
              break;
            case dr.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH:
              this._stateScriptDataDoubleEscapedDashDash(e);
              break;
            case dr.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN:
              this._stateScriptDataDoubleEscapedLessThanSign(e);
              break;
            case dr.SCRIPT_DATA_DOUBLE_ESCAPE_END:
              this._stateScriptDataDoubleEscapeEnd(e);
              break;
            case dr.BEFORE_ATTRIBUTE_NAME:
              this._stateBeforeAttributeName(e);
              break;
            case dr.ATTRIBUTE_NAME:
              this._stateAttributeName(e);
              break;
            case dr.AFTER_ATTRIBUTE_NAME:
              this._stateAfterAttributeName(e);
              break;
            case dr.BEFORE_ATTRIBUTE_VALUE:
              this._stateBeforeAttributeValue(e);
              break;
            case dr.ATTRIBUTE_VALUE_DOUBLE_QUOTED:
              this._stateAttributeValueDoubleQuoted(e);
              break;
            case dr.ATTRIBUTE_VALUE_SINGLE_QUOTED:
              this._stateAttributeValueSingleQuoted(e);
              break;
            case dr.ATTRIBUTE_VALUE_UNQUOTED:
              this._stateAttributeValueUnquoted(e);
              break;
            case dr.AFTER_ATTRIBUTE_VALUE_QUOTED:
              this._stateAfterAttributeValueQuoted(e);
              break;
            case dr.SELF_CLOSING_START_TAG:
              this._stateSelfClosingStartTag(e);
              break;
            case dr.BOGUS_COMMENT:
              this._stateBogusComment(e);
              break;
            case dr.MARKUP_DECLARATION_OPEN:
              this._stateMarkupDeclarationOpen(e);
              break;
            case dr.COMMENT_START:
              this._stateCommentStart(e);
              break;
            case dr.COMMENT_START_DASH:
              this._stateCommentStartDash(e);
              break;
            case dr.COMMENT:
              this._stateComment(e);
              break;
            case dr.COMMENT_LESS_THAN_SIGN:
              this._stateCommentLessThanSign(e);
              break;
            case dr.COMMENT_LESS_THAN_SIGN_BANG:
              this._stateCommentLessThanSignBang(e);
              break;
            case dr.COMMENT_LESS_THAN_SIGN_BANG_DASH:
              this._stateCommentLessThanSignBangDash(e);
              break;
            case dr.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH:
              this._stateCommentLessThanSignBangDashDash(e);
              break;
            case dr.COMMENT_END_DASH:
              this._stateCommentEndDash(e);
              break;
            case dr.COMMENT_END:
              this._stateCommentEnd(e);
              break;
            case dr.COMMENT_END_BANG:
              this._stateCommentEndBang(e);
              break;
            case dr.DOCTYPE:
              this._stateDoctype(e);
              break;
            case dr.BEFORE_DOCTYPE_NAME:
              this._stateBeforeDoctypeName(e);
              break;
            case dr.DOCTYPE_NAME:
              this._stateDoctypeName(e);
              break;
            case dr.AFTER_DOCTYPE_NAME:
              this._stateAfterDoctypeName(e);
              break;
            case dr.AFTER_DOCTYPE_PUBLIC_KEYWORD:
              this._stateAfterDoctypePublicKeyword(e);
              break;
            case dr.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER:
              this._stateBeforeDoctypePublicIdentifier(e);
              break;
            case dr.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED:
              this._stateDoctypePublicIdentifierDoubleQuoted(e);
              break;
            case dr.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED:
              this._stateDoctypePublicIdentifierSingleQuoted(e);
              break;
            case dr.AFTER_DOCTYPE_PUBLIC_IDENTIFIER:
              this._stateAfterDoctypePublicIdentifier(e);
              break;
            case dr.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS:
              this._stateBetweenDoctypePublicAndSystemIdentifiers(e);
              break;
            case dr.AFTER_DOCTYPE_SYSTEM_KEYWORD:
              this._stateAfterDoctypeSystemKeyword(e);
              break;
            case dr.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER:
              this._stateBeforeDoctypeSystemIdentifier(e);
              break;
            case dr.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED:
              this._stateDoctypeSystemIdentifierDoubleQuoted(e);
              break;
            case dr.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED:
              this._stateDoctypeSystemIdentifierSingleQuoted(e);
              break;
            case dr.AFTER_DOCTYPE_SYSTEM_IDENTIFIER:
              this._stateAfterDoctypeSystemIdentifier(e);
              break;
            case dr.BOGUS_DOCTYPE:
              this._stateBogusDoctype(e);
              break;
            case dr.CDATA_SECTION:
              this._stateCdataSection(e);
              break;
            case dr.CDATA_SECTION_BRACKET:
              this._stateCdataSectionBracket(e);
              break;
            case dr.CDATA_SECTION_END:
              this._stateCdataSectionEnd(e);
              break;
            case dr.CHARACTER_REFERENCE:
              this._stateCharacterReference(e);
              break;
            case dr.NAMED_CHARACTER_REFERENCE:
              this._stateNamedCharacterReference(e);
              break;
            case dr.AMBIGUOUS_AMPERSAND:
              this._stateAmbiguousAmpersand(e);
              break;
            case dr.NUMERIC_CHARACTER_REFERENCE:
              this._stateNumericCharacterReference(e);
              break;
            case dr.HEXADEMICAL_CHARACTER_REFERENCE_START:
              this._stateHexademicalCharacterReferenceStart(e);
              break;
            case dr.HEXADEMICAL_CHARACTER_REFERENCE:
              this._stateHexademicalCharacterReference(e);
              break;
            case dr.DECIMAL_CHARACTER_REFERENCE:
              this._stateDecimalCharacterReference(e);
              break;
            case dr.NUMERIC_CHARACTER_REFERENCE_END:
              this._stateNumericCharacterReferenceEnd(e);
              break;
            default:
              throw new Error("Unknown state");
          }
        }
        _stateData(e) {
          switch (e) {
            case Nt.LESS_THAN_SIGN:
              this.state = dr.TAG_OPEN;
              break;
            case Nt.AMPERSAND:
              (this.returnState = dr.DATA), (this.state = dr.CHARACTER_REFERENCE);
              break;
            case Nt.NULL:
              this._err(Ft.unexpectedNullCharacter), this._emitCodePoint(e);
              break;
            case Nt.EOF:
              this._emitEOFToken();
              break;
            default:
              this._emitCodePoint(e);
          }
        }
        _stateRcdata(e) {
          switch (e) {
            case Nt.AMPERSAND:
              (this.returnState = dr.RCDATA),
                (this.state = dr.CHARACTER_REFERENCE);
              break;
            case Nt.LESS_THAN_SIGN:
              this.state = dr.RCDATA_LESS_THAN_SIGN;
              break;
            case Nt.NULL:
              this._err(Ft.unexpectedNullCharacter), this._emitChars(xt);
              break;
            case Nt.EOF:
              this._emitEOFToken();
              break;
            default:
              this._emitCodePoint(e);
          }
        }
        _stateRawtext(e) {
          switch (e) {
            case Nt.LESS_THAN_SIGN:
              this.state = dr.RAWTEXT_LESS_THAN_SIGN;
              break;
            case Nt.NULL:
              this._err(Ft.unexpectedNullCharacter), this._emitChars(xt);
              break;
            case Nt.EOF:
              this._emitEOFToken();
              break;
            default:
              this._emitCodePoint(e);
          }
        }
        _stateScriptData(e) {
          switch (e) {
            case Nt.LESS_THAN_SIGN:
              this.state = dr.SCRIPT_DATA_LESS_THAN_SIGN;
              break;
            case Nt.NULL:
              this._err(Ft.unexpectedNullCharacter), this._emitChars(xt);
              break;
            case Nt.EOF:
              this._emitEOFToken();
              break;
            default:
              this._emitCodePoint(e);
          }
        }
        _statePlaintext(e) {
          switch (e) {
            case Nt.NULL:
              this._err(Ft.unexpectedNullCharacter), this._emitChars(xt);
              break;
            case Nt.EOF:
              this._emitEOFToken();
              break;
            default:
              this._emitCodePoint(e);
          }
        }
        _stateTagOpen(e) {
          if (mr(e))
            this._createStartTagToken(),
              (this.state = dr.TAG_NAME),
              this._stateTagName(e);
          else
            switch (e) {
              case Nt.EXCLAMATION_MARK:
                this.state = dr.MARKUP_DECLARATION_OPEN;
                break;
              case Nt.SOLIDUS:
                this.state = dr.END_TAG_OPEN;
                break;
              case Nt.QUESTION_MARK:
                this._err(Ft.unexpectedQuestionMarkInsteadOfTagName),
                  this._createCommentToken(1),
                  (this.state = dr.BOGUS_COMMENT),
                  this._stateBogusComment(e);
                break;
              case Nt.EOF:
                this._err(Ft.eofBeforeTagName),
                  this._emitChars("<"),
                  this._emitEOFToken();
                break;
              default:
                this._err(Ft.invalidFirstCharacterOfTagName),
                  this._emitChars("<"),
                  (this.state = dr.DATA),
                  this._stateData(e);
            }
        }
        _stateEndTagOpen(e) {
          if (mr(e))
            this._createEndTagToken(),
              (this.state = dr.TAG_NAME),
              this._stateTagName(e);
          else
            switch (e) {
              case Nt.GREATER_THAN_SIGN:
                this._err(Ft.missingEndTagName), (this.state = dr.DATA);
                break;
              case Nt.EOF:
                this._err(Ft.eofBeforeTagName),
                  this._emitChars("</"),
                  this._emitEOFToken();
                break;
              default:
                this._err(Ft.invalidFirstCharacterOfTagName),
                  this._createCommentToken(2),
                  (this.state = dr.BOGUS_COMMENT),
                  this._stateBogusComment(e);
            }
        }
        _stateTagName(e) {
          const t = this.currentToken;
          switch (e) {
            case Nt.SPACE:
            case Nt.LINE_FEED:
            case Nt.TABULATION:
            case Nt.FORM_FEED:
              this.state = dr.BEFORE_ATTRIBUTE_NAME;
              break;
            case Nt.SOLIDUS:
              this.state = dr.SELF_CLOSING_START_TAG;
              break;
            case Nt.GREATER_THAN_SIGN:
              (this.state = dr.DATA), this.emitCurrentTagToken();
              break;
            case Nt.NULL:
              this._err(Ft.unexpectedNullCharacter), (t.tagName += xt);
              break;
            case Nt.EOF:
              this._err(Ft.eofInTag), this._emitEOFToken();
              break;
            default:
              t.tagName += String.fromCodePoint(gr(e) ? Er(e) : e);
          }
        }
        _stateRcdataLessThanSign(e) {
          e === Nt.SOLIDUS
            ? (this.state = dr.RCDATA_END_TAG_OPEN)
            : (this._emitChars("<"),
              (this.state = dr.RCDATA),
              this._stateRcdata(e));
        }
        _stateRcdataEndTagOpen(e) {
          mr(e)
            ? ((this.state = dr.RCDATA_END_TAG_NAME),
              this._stateRcdataEndTagName(e))
            : (this._emitChars("</"),
              (this.state = dr.RCDATA),
              this._stateRcdata(e));
        }
        handleSpecialEndTag(e) {
          if (!this.preprocessor.startsWith(this.lastStartTagName, !1))
            return !this._ensureHibernation();
          this._createEndTagToken();
          this.currentToken.tagName = this.lastStartTagName;
          switch (this.preprocessor.peek(this.lastStartTagName.length)) {
            case Nt.SPACE:
            case Nt.LINE_FEED:
            case Nt.TABULATION:
            case Nt.FORM_FEED:
              return (
                this._advanceBy(this.lastStartTagName.length),
                (this.state = dr.BEFORE_ATTRIBUTE_NAME),
                !1
              );
            case Nt.SOLIDUS:
              return (
                this._advanceBy(this.lastStartTagName.length),
                (this.state = dr.SELF_CLOSING_START_TAG),
                !1
              );
            case Nt.GREATER_THAN_SIGN:
              return (
                this._advanceBy(this.lastStartTagName.length),
                this.emitCurrentTagToken(),
                (this.state = dr.DATA),
                !1
              );
            default:
              return !this._ensureHibernation();
          }
        }
        _stateRcdataEndTagName(e) {
          this.handleSpecialEndTag(e) &&
            (this._emitChars("</"),
            (this.state = dr.RCDATA),
            this._stateRcdata(e));
        }
        _stateRawtextLessThanSign(e) {
          e === Nt.SOLIDUS
            ? (this.state = dr.RAWTEXT_END_TAG_OPEN)
            : (this._emitChars("<"),
              (this.state = dr.RAWTEXT),
              this._stateRawtext(e));
        }
        _stateRawtextEndTagOpen(e) {
          mr(e)
            ? ((this.state = dr.RAWTEXT_END_TAG_NAME),
              this._stateRawtextEndTagName(e))
            : (this._emitChars("</"),
              (this.state = dr.RAWTEXT),
              this._stateRawtext(e));
        }
        _stateRawtextEndTagName(e) {
          this.handleSpecialEndTag(e) &&
            (this._emitChars("</"),
            (this.state = dr.RAWTEXT),
            this._stateRawtext(e));
        }
        _stateScriptDataLessThanSign(e) {
          switch (e) {
            case Nt.SOLIDUS:
              this.state = dr.SCRIPT_DATA_END_TAG_OPEN;
              break;
            case Nt.EXCLAMATION_MARK:
              (this.state = dr.SCRIPT_DATA_ESCAPE_START), this._emitChars("<!");
              break;
            default:
              this._emitChars("<"),
                (this.state = dr.SCRIPT_DATA),
                this._stateScriptData(e);
          }
        }
        _stateScriptDataEndTagOpen(e) {
          mr(e)
            ? ((this.state = dr.SCRIPT_DATA_END_TAG_NAME),
              this._stateScriptDataEndTagName(e))
            : (this._emitChars("</"),
              (this.state = dr.SCRIPT_DATA),
              this._stateScriptData(e));
        }
        _stateScriptDataEndTagName(e) {
          this.handleSpecialEndTag(e) &&
            (this._emitChars("</"),
            (this.state = dr.SCRIPT_DATA),
            this._stateScriptData(e));
        }
        _stateScriptDataEscapeStart(e) {
          e === Nt.HYPHEN_MINUS
            ? ((this.state = dr.SCRIPT_DATA_ESCAPE_START_DASH),
              this._emitChars("-"))
            : ((this.state = dr.SCRIPT_DATA), this._stateScriptData(e));
        }
        _stateScriptDataEscapeStartDash(e) {
          e === Nt.HYPHEN_MINUS
            ? ((this.state = dr.SCRIPT_DATA_ESCAPED_DASH_DASH),
              this._emitChars("-"))
            : ((this.state = dr.SCRIPT_DATA), this._stateScriptData(e));
        }
        _stateScriptDataEscaped(e) {
          switch (e) {
            case Nt.HYPHEN_MINUS:
              (this.state = dr.SCRIPT_DATA_ESCAPED_DASH), this._emitChars("-");
              break;
            case Nt.LESS_THAN_SIGN:
              this.state = dr.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
              break;
            case Nt.NULL:
              this._err(Ft.unexpectedNullCharacter), this._emitChars(xt);
              break;
            case Nt.EOF:
              this._err(Ft.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
              break;
            default:
              this._emitCodePoint(e);
          }
        }
        _stateScriptDataEscapedDash(e) {
          switch (e) {
            case Nt.HYPHEN_MINUS:
              (this.state = dr.SCRIPT_DATA_ESCAPED_DASH_DASH),
                this._emitChars("-");
              break;
            case Nt.LESS_THAN_SIGN:
              this.state = dr.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
              break;
            case Nt.NULL:
              this._err(Ft.unexpectedNullCharacter),
                (this.state = dr.SCRIPT_DATA_ESCAPED),
                this._emitChars(xt);
              break;
            case Nt.EOF:
              this._err(Ft.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
              break;
            default:
              (this.state = dr.SCRIPT_DATA_ESCAPED), this._emitCodePoint(e);
          }
        }
        _stateScriptDataEscapedDashDash(e) {
          switch (e) {
            case Nt.HYPHEN_MINUS:
              this._emitChars("-");
              break;
            case Nt.LESS_THAN_SIGN:
              this.state = dr.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
              break;
            case Nt.GREATER_THAN_SIGN:
              (this.state = dr.SCRIPT_DATA), this._emitChars(">");
              break;
            case Nt.NULL:
              this._err(Ft.unexpectedNullCharacter),
                (this.state = dr.SCRIPT_DATA_ESCAPED),
                this._emitChars(xt);
              break;
            case Nt.EOF:
              this._err(Ft.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
              break;
            default:
              (this.state = dr.SCRIPT_DATA_ESCAPED), this._emitCodePoint(e);
          }
        }
        _stateScriptDataEscapedLessThanSign(e) {
          e === Nt.SOLIDUS
            ? (this.state = dr.SCRIPT_DATA_ESCAPED_END_TAG_OPEN)
            : mr(e)
            ? (this._emitChars("<"),
              (this.state = dr.SCRIPT_DATA_DOUBLE_ESCAPE_START),
              this._stateScriptDataDoubleEscapeStart(e))
            : (this._emitChars("<"),
              (this.state = dr.SCRIPT_DATA_ESCAPED),
              this._stateScriptDataEscaped(e));
        }
        _stateScriptDataEscapedEndTagOpen(e) {
          mr(e)
            ? ((this.state = dr.SCRIPT_DATA_ESCAPED_END_TAG_NAME),
              this._stateScriptDataEscapedEndTagName(e))
            : (this._emitChars("</"),
              (this.state = dr.SCRIPT_DATA_ESCAPED),
              this._stateScriptDataEscaped(e));
        }
        _stateScriptDataEscapedEndTagName(e) {
          this.handleSpecialEndTag(e) &&
            (this._emitChars("</"),
            (this.state = dr.SCRIPT_DATA_ESCAPED),
            this._stateScriptDataEscaped(e));
        }
        _stateScriptDataDoubleEscapeStart(e) {
          if (
            this.preprocessor.startsWith(Dt, !1) &&
            vr(this.preprocessor.peek(Dt.length))
          ) {
            this._emitCodePoint(e);
            for (let e = 0; e < Dt.length; e++)
              this._emitCodePoint(this._consume());
            this.state = dr.SCRIPT_DATA_DOUBLE_ESCAPED;
          } else
            this._ensureHibernation() ||
              ((this.state = dr.SCRIPT_DATA_ESCAPED),
              this._stateScriptDataEscaped(e));
        }
        _stateScriptDataDoubleEscaped(e) {
          switch (e) {
            case Nt.HYPHEN_MINUS:
              (this.state = dr.SCRIPT_DATA_DOUBLE_ESCAPED_DASH),
                this._emitChars("-");
              break;
            case Nt.LESS_THAN_SIGN:
              (this.state = dr.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN),
                this._emitChars("<");
              break;
            case Nt.NULL:
              this._err(Ft.unexpectedNullCharacter), this._emitChars(xt);
              break;
            case Nt.EOF:
              this._err(Ft.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
              break;
            default:
              this._emitCodePoint(e);
          }
        }
        _stateScriptDataDoubleEscapedDash(e) {
          switch (e) {
            case Nt.HYPHEN_MINUS:
              (this.state = dr.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH),
                this._emitChars("-");
              break;
            case Nt.LESS_THAN_SIGN:
              (this.state = dr.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN),
                this._emitChars("<");
              break;
            case Nt.NULL:
              this._err(Ft.unexpectedNullCharacter),
                (this.state = dr.SCRIPT_DATA_DOUBLE_ESCAPED),
                this._emitChars(xt);
              break;
            case Nt.EOF:
              this._err(Ft.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
              break;
            default:
              (this.state = dr.SCRIPT_DATA_DOUBLE_ESCAPED),
                this._emitCodePoint(e);
          }
        }
        _stateScriptDataDoubleEscapedDashDash(e) {
          switch (e) {
            case Nt.HYPHEN_MINUS:
              this._emitChars("-");
              break;
            case Nt.LESS_THAN_SIGN:
              (this.state = dr.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN),
                this._emitChars("<");
              break;
            case Nt.GREATER_THAN_SIGN:
              (this.state = dr.SCRIPT_DATA), this._emitChars(">");
              break;
            case Nt.NULL:
              this._err(Ft.unexpectedNullCharacter),
                (this.state = dr.SCRIPT_DATA_DOUBLE_ESCAPED),
                this._emitChars(xt);
              break;
            case Nt.EOF:
              this._err(Ft.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
              break;
            default:
              (this.state = dr.SCRIPT_DATA_DOUBLE_ESCAPED),
                this._emitCodePoint(e);
          }
        }
        _stateScriptDataDoubleEscapedLessThanSign(e) {
          e === Nt.SOLIDUS
            ? ((this.state = dr.SCRIPT_DATA_DOUBLE_ESCAPE_END),
              this._emitChars("/"))
            : ((this.state = dr.SCRIPT_DATA_DOUBLE_ESCAPED),
              this._stateScriptDataDoubleEscaped(e));
        }
        _stateScriptDataDoubleEscapeEnd(e) {
          if (
            this.preprocessor.startsWith(Dt, !1) &&
            vr(this.preprocessor.peek(Dt.length))
          ) {
            this._emitCodePoint(e);
            for (let e = 0; e < Dt.length; e++)
              this._emitCodePoint(this._consume());
            this.state = dr.SCRIPT_DATA_ESCAPED;
          } else
            this._ensureHibernation() ||
              ((this.state = dr.SCRIPT_DATA_DOUBLE_ESCAPED),
              this._stateScriptDataDoubleEscaped(e));
        }
        _stateBeforeAttributeName(e) {
          switch (e) {
            case Nt.SPACE:
            case Nt.LINE_FEED:
            case Nt.TABULATION:
            case Nt.FORM_FEED:
              break;
            case Nt.SOLIDUS:
            case Nt.GREATER_THAN_SIGN:
            case Nt.EOF:
              (this.state = dr.AFTER_ATTRIBUTE_NAME),
                this._stateAfterAttributeName(e);
              break;
            case Nt.EQUALS_SIGN:
              this._err(Ft.unexpectedEqualsSignBeforeAttributeName),
                this._createAttr("="),
                (this.state = dr.ATTRIBUTE_NAME);
              break;
            default:
              this._createAttr(""),
                (this.state = dr.ATTRIBUTE_NAME),
                this._stateAttributeName(e);
          }
        }
        _stateAttributeName(e) {
          switch (e) {
            case Nt.SPACE:
            case Nt.LINE_FEED:
            case Nt.TABULATION:
            case Nt.FORM_FEED:
            case Nt.SOLIDUS:
            case Nt.GREATER_THAN_SIGN:
            case Nt.EOF:
              this._leaveAttrName(),
                (this.state = dr.AFTER_ATTRIBUTE_NAME),
                this._stateAfterAttributeName(e);
              break;
            case Nt.EQUALS_SIGN:
              this._leaveAttrName(), (this.state = dr.BEFORE_ATTRIBUTE_VALUE);
              break;
            case Nt.QUOTATION_MARK:
            case Nt.APOSTROPHE:
            case Nt.LESS_THAN_SIGN:
              this._err(Ft.unexpectedCharacterInAttributeName),
                (this.currentAttr.name += String.fromCodePoint(e));
              break;
            case Nt.NULL:
              this._err(Ft.unexpectedNullCharacter),
                (this.currentAttr.name += xt);
              break;
            default:
              this.currentAttr.name += String.fromCodePoint(gr(e) ? Er(e) : e);
          }
        }
        _stateAfterAttributeName(e) {
          switch (e) {
            case Nt.SPACE:
            case Nt.LINE_FEED:
            case Nt.TABULATION:
            case Nt.FORM_FEED:
              break;
            case Nt.SOLIDUS:
              this.state = dr.SELF_CLOSING_START_TAG;
              break;
            case Nt.EQUALS_SIGN:
              this.state = dr.BEFORE_ATTRIBUTE_VALUE;
              break;
            case Nt.GREATER_THAN_SIGN:
              (this.state = dr.DATA), this.emitCurrentTagToken();
              break;
            case Nt.EOF:
              this._err(Ft.eofInTag), this._emitEOFToken();
              break;
            default:
              this._createAttr(""),
                (this.state = dr.ATTRIBUTE_NAME),
                this._stateAttributeName(e);
          }
        }
        _stateBeforeAttributeValue(e) {
          switch (e) {
            case Nt.SPACE:
            case Nt.LINE_FEED:
            case Nt.TABULATION:
            case Nt.FORM_FEED:
              break;
            case Nt.QUOTATION_MARK:
              this.state = dr.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
              break;
            case Nt.APOSTROPHE:
              this.state = dr.ATTRIBUTE_VALUE_SINGLE_QUOTED;
              break;
            case Nt.GREATER_THAN_SIGN:
              this._err(Ft.missingAttributeValue),
                (this.state = dr.DATA),
                this.emitCurrentTagToken();
              break;
            default:
              (this.state = dr.ATTRIBUTE_VALUE_UNQUOTED),
                this._stateAttributeValueUnquoted(e);
          }
        }
        _stateAttributeValueDoubleQuoted(e) {
          switch (e) {
            case Nt.QUOTATION_MARK:
              this.state = dr.AFTER_ATTRIBUTE_VALUE_QUOTED;
              break;
            case Nt.AMPERSAND:
              (this.returnState = dr.ATTRIBUTE_VALUE_DOUBLE_QUOTED),
                (this.state = dr.CHARACTER_REFERENCE);
              break;
            case Nt.NULL:
              this._err(Ft.unexpectedNullCharacter),
                (this.currentAttr.value += xt);
              break;
            case Nt.EOF:
              this._err(Ft.eofInTag), this._emitEOFToken();
              break;
            default:
              this.currentAttr.value += String.fromCodePoint(e);
          }
        }
        _stateAttributeValueSingleQuoted(e) {
          switch (e) {
            case Nt.APOSTROPHE:
              this.state = dr.AFTER_ATTRIBUTE_VALUE_QUOTED;
              break;
            case Nt.AMPERSAND:
              (this.returnState = dr.ATTRIBUTE_VALUE_SINGLE_QUOTED),
                (this.state = dr.CHARACTER_REFERENCE);
              break;
            case Nt.NULL:
              this._err(Ft.unexpectedNullCharacter),
                (this.currentAttr.value += xt);
              break;
            case Nt.EOF:
              this._err(Ft.eofInTag), this._emitEOFToken();
              break;
            default:
              this.currentAttr.value += String.fromCodePoint(e);
          }
        }
        _stateAttributeValueUnquoted(e) {
          switch (e) {
            case Nt.SPACE:
            case Nt.LINE_FEED:
            case Nt.TABULATION:
            case Nt.FORM_FEED:
              this._leaveAttrValue(), (this.state = dr.BEFORE_ATTRIBUTE_NAME);
              break;
            case Nt.AMPERSAND:
              (this.returnState = dr.ATTRIBUTE_VALUE_UNQUOTED),
                (this.state = dr.CHARACTER_REFERENCE);
              break;
            case Nt.GREATER_THAN_SIGN:
              this._leaveAttrValue(),
                (this.state = dr.DATA),
                this.emitCurrentTagToken();
              break;
            case Nt.NULL:
              this._err(Ft.unexpectedNullCharacter),
                (this.currentAttr.value += xt);
              break;
            case Nt.QUOTATION_MARK:
            case Nt.APOSTROPHE:
            case Nt.LESS_THAN_SIGN:
            case Nt.EQUALS_SIGN:
            case Nt.GRAVE_ACCENT:
              this._err(Ft.unexpectedCharacterInUnquotedAttributeValue),
                (this.currentAttr.value += String.fromCodePoint(e));
              break;
            case Nt.EOF:
              this._err(Ft.eofInTag), this._emitEOFToken();
              break;
            default:
              this.currentAttr.value += String.fromCodePoint(e);
          }
        }
        _stateAfterAttributeValueQuoted(e) {
          switch (e) {
            case Nt.SPACE:
            case Nt.LINE_FEED:
            case Nt.TABULATION:
            case Nt.FORM_FEED:
              this._leaveAttrValue(), (this.state = dr.BEFORE_ATTRIBUTE_NAME);
              break;
            case Nt.SOLIDUS:
              this._leaveAttrValue(), (this.state = dr.SELF_CLOSING_START_TAG);
              break;
            case Nt.GREATER_THAN_SIGN:
              this._leaveAttrValue(),
                (this.state = dr.DATA),
                this.emitCurrentTagToken();
              break;
            case Nt.EOF:
              this._err(Ft.eofInTag), this._emitEOFToken();
              break;
            default:
              this._err(Ft.missingWhitespaceBetweenAttributes),
                (this.state = dr.BEFORE_ATTRIBUTE_NAME),
                this._stateBeforeAttributeName(e);
          }
        }
        _stateSelfClosingStartTag(e) {
          switch (e) {
            case Nt.GREATER_THAN_SIGN:
              (this.currentToken.selfClosing = !0),
                (this.state = dr.DATA),
                this.emitCurrentTagToken();
              break;
            case Nt.EOF:
              this._err(Ft.eofInTag), this._emitEOFToken();
              break;
            default:
              this._err(Ft.unexpectedSolidusInTag),
                (this.state = dr.BEFORE_ATTRIBUTE_NAME),
                this._stateBeforeAttributeName(e);
          }
        }
        _stateBogusComment(e) {
          const t = this.currentToken;
          switch (e) {
            case Nt.GREATER_THAN_SIGN:
              (this.state = dr.DATA), this.emitCurrentComment(t);
              break;
            case Nt.EOF:
              this.emitCurrentComment(t), this._emitEOFToken();
              break;
            case Nt.NULL:
              this._err(Ft.unexpectedNullCharacter), (t.data += xt);
              break;
            default:
              t.data += String.fromCodePoint(e);
          }
        }
        _stateMarkupDeclarationOpen(e) {
          this._consumeSequenceIfMatch(kt, !0)
            ? (this._createCommentToken(kt.length + 1),
              (this.state = dr.COMMENT_START))
            : this._consumeSequenceIfMatch(Bt, !1)
            ? ((this.currentLocation = this.getCurrentLocation(Bt.length + 1)),
              (this.state = dr.DOCTYPE))
            : this._consumeSequenceIfMatch(Rt, !0)
            ? this.inForeignNode
              ? (this.state = dr.CDATA_SECTION)
              : (this._err(Ft.cdataInHtmlContent),
                this._createCommentToken(Rt.length + 1),
                (this.currentToken.data = "[CDATA["),
                (this.state = dr.BOGUS_COMMENT))
            : this._ensureHibernation() ||
              (this._err(Ft.incorrectlyOpenedComment),
              this._createCommentToken(2),
              (this.state = dr.BOGUS_COMMENT),
              this._stateBogusComment(e));
        }
        _stateCommentStart(e) {
          switch (e) {
            case Nt.HYPHEN_MINUS:
              this.state = dr.COMMENT_START_DASH;
              break;
            case Nt.GREATER_THAN_SIGN: {
              this._err(Ft.abruptClosingOfEmptyComment), (this.state = dr.DATA);
              const e = this.currentToken;
              this.emitCurrentComment(e);
              break;
            }
            default:
              (this.state = dr.COMMENT), this._stateComment(e);
          }
        }
        _stateCommentStartDash(e) {
          const t = this.currentToken;
          switch (e) {
            case Nt.HYPHEN_MINUS:
              this.state = dr.COMMENT_END;
              break;
            case Nt.GREATER_THAN_SIGN:
              this._err(Ft.abruptClosingOfEmptyComment),
                (this.state = dr.DATA),
                this.emitCurrentComment(t);
              break;
            case Nt.EOF:
              this._err(Ft.eofInComment),
                this.emitCurrentComment(t),
                this._emitEOFToken();
              break;
            default:
              (t.data += "-"), (this.state = dr.COMMENT), this._stateComment(e);
          }
        }
        _stateComment(e) {
          const t = this.currentToken;
          switch (e) {
            case Nt.HYPHEN_MINUS:
              this.state = dr.COMMENT_END_DASH;
              break;
            case Nt.LESS_THAN_SIGN:
              (t.data += "<"), (this.state = dr.COMMENT_LESS_THAN_SIGN);
              break;
            case Nt.NULL:
              this._err(Ft.unexpectedNullCharacter), (t.data += xt);
              break;
            case Nt.EOF:
              this._err(Ft.eofInComment),
                this.emitCurrentComment(t),
                this._emitEOFToken();
              break;
            default:
              t.data += String.fromCodePoint(e);
          }
        }
        _stateCommentLessThanSign(e) {
          const t = this.currentToken;
          switch (e) {
            case Nt.EXCLAMATION_MARK:
              (t.data += "!"), (this.state = dr.COMMENT_LESS_THAN_SIGN_BANG);
              break;
            case Nt.LESS_THAN_SIGN:
              t.data += "<";
              break;
            default:
              (this.state = dr.COMMENT), this._stateComment(e);
          }
        }
        _stateCommentLessThanSignBang(e) {
          e === Nt.HYPHEN_MINUS
            ? (this.state = dr.COMMENT_LESS_THAN_SIGN_BANG_DASH)
            : ((this.state = dr.COMMENT), this._stateComment(e));
        }
        _stateCommentLessThanSignBangDash(e) {
          e === Nt.HYPHEN_MINUS
            ? (this.state = dr.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH)
            : ((this.state = dr.COMMENT_END_DASH), this._stateCommentEndDash(e));
        }
        _stateCommentLessThanSignBangDashDash(e) {
          e !== Nt.GREATER_THAN_SIGN &&
            e !== Nt.EOF &&
            this._err(Ft.nestedComment),
            (this.state = dr.COMMENT_END),
            this._stateCommentEnd(e);
        }
        _stateCommentEndDash(e) {
          const t = this.currentToken;
          switch (e) {
            case Nt.HYPHEN_MINUS:
              this.state = dr.COMMENT_END;
              break;
            case Nt.EOF:
              this._err(Ft.eofInComment),
                this.emitCurrentComment(t),
                this._emitEOFToken();
              break;
            default:
              (t.data += "-"), (this.state = dr.COMMENT), this._stateComment(e);
          }
        }
        _stateCommentEnd(e) {
          const t = this.currentToken;
          switch (e) {
            case Nt.GREATER_THAN_SIGN:
              (this.state = dr.DATA), this.emitCurrentComment(t);
              break;
            case Nt.EXCLAMATION_MARK:
              this.state = dr.COMMENT_END_BANG;
              break;
            case Nt.HYPHEN_MINUS:
              t.data += "-";
              break;
            case Nt.EOF:
              this._err(Ft.eofInComment),
                this.emitCurrentComment(t),
                this._emitEOFToken();
              break;
            default:
              (t.data += "--"), (this.state = dr.COMMENT), this._stateComment(e);
          }
        }
        _stateCommentEndBang(e) {
          const t = this.currentToken;
          switch (e) {
            case Nt.HYPHEN_MINUS:
              (t.data += "--!"), (this.state = dr.COMMENT_END_DASH);
              break;
            case Nt.GREATER_THAN_SIGN:
              this._err(Ft.incorrectlyClosedComment),
                (this.state = dr.DATA),
                this.emitCurrentComment(t);
              break;
            case Nt.EOF:
              this._err(Ft.eofInComment),
                this.emitCurrentComment(t),
                this._emitEOFToken();
              break;
            default:
              (t.data += "--!"), (this.state = dr.COMMENT), this._stateComment(e);
          }
        }
        _stateDoctype(e) {
          switch (e) {
            case Nt.SPACE:
            case Nt.LINE_FEED:
            case Nt.TABULATION:
            case Nt.FORM_FEED:
              this.state = dr.BEFORE_DOCTYPE_NAME;
              break;
            case Nt.GREATER_THAN_SIGN:
              (this.state = dr.BEFORE_DOCTYPE_NAME),
                this._stateBeforeDoctypeName(e);
              break;
            case Nt.EOF: {
              this._err(Ft.eofInDoctype), this._createDoctypeToken(null);
              const e = this.currentToken;
              (e.forceQuirks = !0),
                this.emitCurrentDoctype(e),
                this._emitEOFToken();
              break;
            }
            default:
              this._err(Ft.missingWhitespaceBeforeDoctypeName),
                (this.state = dr.BEFORE_DOCTYPE_NAME),
                this._stateBeforeDoctypeName(e);
          }
        }
        _stateBeforeDoctypeName(e) {
          if (gr(e))
            this._createDoctypeToken(String.fromCharCode(Er(e))),
              (this.state = dr.DOCTYPE_NAME);
          else
            switch (e) {
              case Nt.SPACE:
              case Nt.LINE_FEED:
              case Nt.TABULATION:
              case Nt.FORM_FEED:
                break;
              case Nt.NULL:
                this._err(Ft.unexpectedNullCharacter),
                  this._createDoctypeToken(xt),
                  (this.state = dr.DOCTYPE_NAME);
                break;
              case Nt.GREATER_THAN_SIGN: {
                this._err(Ft.missingDoctypeName), this._createDoctypeToken(null);
                const e = this.currentToken;
                (e.forceQuirks = !0),
                  this.emitCurrentDoctype(e),
                  (this.state = dr.DATA);
                break;
              }
              case Nt.EOF: {
                this._err(Ft.eofInDoctype), this._createDoctypeToken(null);
                const e = this.currentToken;
                (e.forceQuirks = !0),
                  this.emitCurrentDoctype(e),
                  this._emitEOFToken();
                break;
              }
              default:
                this._createDoctypeToken(String.fromCodePoint(e)),
                  (this.state = dr.DOCTYPE_NAME);
            }
        }
        _stateDoctypeName(e) {
          const t = this.currentToken;
          switch (e) {
            case Nt.SPACE:
            case Nt.LINE_FEED:
            case Nt.TABULATION:
            case Nt.FORM_FEED:
              this.state = dr.AFTER_DOCTYPE_NAME;
              break;
            case Nt.GREATER_THAN_SIGN:
              (this.state = dr.DATA), this.emitCurrentDoctype(t);
              break;
            case Nt.NULL:
              this._err(Ft.unexpectedNullCharacter), (t.name += xt);
              break;
            case Nt.EOF:
              this._err(Ft.eofInDoctype),
                (t.forceQuirks = !0),
                this.emitCurrentDoctype(t),
                this._emitEOFToken();
              break;
            default:
              t.name += String.fromCodePoint(gr(e) ? Er(e) : e);
          }
        }
        _stateAfterDoctypeName(e) {
          const t = this.currentToken;
          switch (e) {
            case Nt.SPACE:
            case Nt.LINE_FEED:
            case Nt.TABULATION:
            case Nt.FORM_FEED:
              break;
            case Nt.GREATER_THAN_SIGN:
              (this.state = dr.DATA), this.emitCurrentDoctype(t);
              break;
            case Nt.EOF:
              this._err(Ft.eofInDoctype),
                (t.forceQuirks = !0),
                this.emitCurrentDoctype(t),
                this._emitEOFToken();
              break;
            default:
              this._consumeSequenceIfMatch(Ot, !1)
                ? (this.state = dr.AFTER_DOCTYPE_PUBLIC_KEYWORD)
                : this._consumeSequenceIfMatch(Lt, !1)
                ? (this.state = dr.AFTER_DOCTYPE_SYSTEM_KEYWORD)
                : this._ensureHibernation() ||
                  (this._err(Ft.invalidCharacterSequenceAfterDoctypeName),
                  (t.forceQuirks = !0),
                  (this.state = dr.BOGUS_DOCTYPE),
                  this._stateBogusDoctype(e));
          }
        }
        _stateAfterDoctypePublicKeyword(e) {
          const t = this.currentToken;
          switch (e) {
            case Nt.SPACE:
            case Nt.LINE_FEED:
            case Nt.TABULATION:
            case Nt.FORM_FEED:
              this.state = dr.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER;
              break;
            case Nt.QUOTATION_MARK:
              this._err(Ft.missingWhitespaceAfterDoctypePublicKeyword),
                (t.publicId = ""),
                (this.state = dr.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED);
              break;
            case Nt.APOSTROPHE:
              this._err(Ft.missingWhitespaceAfterDoctypePublicKeyword),
                (t.publicId = ""),
                (this.state = dr.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED);
              break;
            case Nt.GREATER_THAN_SIGN:
              this._err(Ft.missingDoctypePublicIdentifier),
                (t.forceQuirks = !0),
                (this.state = dr.DATA),
                this.emitCurrentDoctype(t);
              break;
            case Nt.EOF:
              this._err(Ft.eofInDoctype),
                (t.forceQuirks = !0),
                this.emitCurrentDoctype(t),
                this._emitEOFToken();
              break;
            default:
              this._err(Ft.missingQuoteBeforeDoctypePublicIdentifier),
                (t.forceQuirks = !0),
                (this.state = dr.BOGUS_DOCTYPE),
                this._stateBogusDoctype(e);
          }
        }
        _stateBeforeDoctypePublicIdentifier(e) {
          const t = this.currentToken;
          switch (e) {
            case Nt.SPACE:
            case Nt.LINE_FEED:
            case Nt.TABULATION:
            case Nt.FORM_FEED:
              break;
            case Nt.QUOTATION_MARK:
              (t.publicId = ""),
                (this.state = dr.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED);
              break;
            case Nt.APOSTROPHE:
              (t.publicId = ""),
                (this.state = dr.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED);
              break;
            case Nt.GREATER_THAN_SIGN:
              this._err(Ft.missingDoctypePublicIdentifier),
                (t.forceQuirks = !0),
                (this.state = dr.DATA),
                this.emitCurrentDoctype(t);
              break;
            case Nt.EOF:
              this._err(Ft.eofInDoctype),
                (t.forceQuirks = !0),
                this.emitCurrentDoctype(t),
                this._emitEOFToken();
              break;
            default:
              this._err(Ft.missingQuoteBeforeDoctypePublicIdentifier),
                (t.forceQuirks = !0),
                (this.state = dr.BOGUS_DOCTYPE),
                this._stateBogusDoctype(e);
          }
        }
        _stateDoctypePublicIdentifierDoubleQuoted(e) {
          const t = this.currentToken;
          switch (e) {
            case Nt.QUOTATION_MARK:
              this.state = dr.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
              break;
            case Nt.NULL:
              this._err(Ft.unexpectedNullCharacter), (t.publicId += xt);
              break;
            case Nt.GREATER_THAN_SIGN:
              this._err(Ft.abruptDoctypePublicIdentifier),
                (t.forceQuirks = !0),
                this.emitCurrentDoctype(t),
                (this.state = dr.DATA);
              break;
            case Nt.EOF:
              this._err(Ft.eofInDoctype),
                (t.forceQuirks = !0),
                this.emitCurrentDoctype(t),
                this._emitEOFToken();
              break;
            default:
              t.publicId += String.fromCodePoint(e);
          }
        }
        _stateDoctypePublicIdentifierSingleQuoted(e) {
          const t = this.currentToken;
          switch (e) {
            case Nt.APOSTROPHE:
              this.state = dr.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
              break;
            case Nt.NULL:
              this._err(Ft.unexpectedNullCharacter), (t.publicId += xt);
              break;
            case Nt.GREATER_THAN_SIGN:
              this._err(Ft.abruptDoctypePublicIdentifier),
                (t.forceQuirks = !0),
                this.emitCurrentDoctype(t),
                (this.state = dr.DATA);
              break;
            case Nt.EOF:
              this._err(Ft.eofInDoctype),
                (t.forceQuirks = !0),
                this.emitCurrentDoctype(t),
                this._emitEOFToken();
              break;
            default:
              t.publicId += String.fromCodePoint(e);
          }
        }
        _stateAfterDoctypePublicIdentifier(e) {
          const t = this.currentToken;
          switch (e) {
            case Nt.SPACE:
            case Nt.LINE_FEED:
            case Nt.TABULATION:
            case Nt.FORM_FEED:
              this.state = dr.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS;
              break;
            case Nt.GREATER_THAN_SIGN:
              (this.state = dr.DATA), this.emitCurrentDoctype(t);
              break;
            case Nt.QUOTATION_MARK:
              this._err(
                Ft.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers
              ),
                (t.systemId = ""),
                (this.state = dr.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED);
              break;
            case Nt.APOSTROPHE:
              this._err(
                Ft.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers
              ),
                (t.systemId = ""),
                (this.state = dr.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED);
              break;
            case Nt.EOF:
              this._err(Ft.eofInDoctype),
                (t.forceQuirks = !0),
                this.emitCurrentDoctype(t),
                this._emitEOFToken();
              break;
            default:
              this._err(Ft.missingQuoteBeforeDoctypeSystemIdentifier),
                (t.forceQuirks = !0),
                (this.state = dr.BOGUS_DOCTYPE),
                this._stateBogusDoctype(e);
          }
        }
        _stateBetweenDoctypePublicAndSystemIdentifiers(e) {
          const t = this.currentToken;
          switch (e) {
            case Nt.SPACE:
            case Nt.LINE_FEED:
            case Nt.TABULATION:
            case Nt.FORM_FEED:
              break;
            case Nt.GREATER_THAN_SIGN:
              this.emitCurrentDoctype(t), (this.state = dr.DATA);
              break;
            case Nt.QUOTATION_MARK:
              (t.systemId = ""),
                (this.state = dr.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED);
              break;
            case Nt.APOSTROPHE:
              (t.systemId = ""),
                (this.state = dr.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED);
              break;
            case Nt.EOF:
              this._err(Ft.eofInDoctype),
                (t.forceQuirks = !0),
                this.emitCurrentDoctype(t),
                this._emitEOFToken();
              break;
            default:
              this._err(Ft.missingQuoteBeforeDoctypeSystemIdentifier),
                (t.forceQuirks = !0),
                (this.state = dr.BOGUS_DOCTYPE),
                this._stateBogusDoctype(e);
          }
        }
        _stateAfterDoctypeSystemKeyword(e) {
          const t = this.currentToken;
          switch (e) {
            case Nt.SPACE:
            case Nt.LINE_FEED:
            case Nt.TABULATION:
            case Nt.FORM_FEED:
              this.state = dr.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER;
              break;
            case Nt.QUOTATION_MARK:
              this._err(Ft.missingWhitespaceAfterDoctypeSystemKeyword),
                (t.systemId = ""),
                (this.state = dr.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED);
              break;
            case Nt.APOSTROPHE:
              this._err(Ft.missingWhitespaceAfterDoctypeSystemKeyword),
                (t.systemId = ""),
                (this.state = dr.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED);
              break;
            case Nt.GREATER_THAN_SIGN:
              this._err(Ft.missingDoctypeSystemIdentifier),
                (t.forceQuirks = !0),
                (this.state = dr.DATA),
                this.emitCurrentDoctype(t);
              break;
            case Nt.EOF:
              this._err(Ft.eofInDoctype),
                (t.forceQuirks = !0),
                this.emitCurrentDoctype(t),
                this._emitEOFToken();
              break;
            default:
              this._err(Ft.missingQuoteBeforeDoctypeSystemIdentifier),
                (t.forceQuirks = !0),
                (this.state = dr.BOGUS_DOCTYPE),
                this._stateBogusDoctype(e);
          }
        }
        _stateBeforeDoctypeSystemIdentifier(e) {
          const t = this.currentToken;
          switch (e) {
            case Nt.SPACE:
            case Nt.LINE_FEED:
            case Nt.TABULATION:
            case Nt.FORM_FEED:
              break;
            case Nt.QUOTATION_MARK:
              (t.systemId = ""),
                (this.state = dr.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED);
              break;
            case Nt.APOSTROPHE:
              (t.systemId = ""),
                (this.state = dr.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED);
              break;
            case Nt.GREATER_THAN_SIGN:
              this._err(Ft.missingDoctypeSystemIdentifier),
                (t.forceQuirks = !0),
                (this.state = dr.DATA),
                this.emitCurrentDoctype(t);
              break;
            case Nt.EOF:
              this._err(Ft.eofInDoctype),
                (t.forceQuirks = !0),
                this.emitCurrentDoctype(t),
                this._emitEOFToken();
              break;
            default:
              this._err(Ft.missingQuoteBeforeDoctypeSystemIdentifier),
                (t.forceQuirks = !0),
                (this.state = dr.BOGUS_DOCTYPE),
                this._stateBogusDoctype(e);
          }
        }
        _stateDoctypeSystemIdentifierDoubleQuoted(e) {
          const t = this.currentToken;
          switch (e) {
            case Nt.QUOTATION_MARK:
              this.state = dr.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
              break;
            case Nt.NULL:
              this._err(Ft.unexpectedNullCharacter), (t.systemId += xt);
              break;
            case Nt.GREATER_THAN_SIGN:
              this._err(Ft.abruptDoctypeSystemIdentifier),
                (t.forceQuirks = !0),
                this.emitCurrentDoctype(t),
                (this.state = dr.DATA);
              break;
            case Nt.EOF:
              this._err(Ft.eofInDoctype),
                (t.forceQuirks = !0),
                this.emitCurrentDoctype(t),
                this._emitEOFToken();
              break;
            default:
              t.systemId += String.fromCodePoint(e);
          }
        }
        _stateDoctypeSystemIdentifierSingleQuoted(e) {
          const t = this.currentToken;
          switch (e) {
            case Nt.APOSTROPHE:
              this.state = dr.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
              break;
            case Nt.NULL:
              this._err(Ft.unexpectedNullCharacter), (t.systemId += xt);
              break;
            case Nt.GREATER_THAN_SIGN:
              this._err(Ft.abruptDoctypeSystemIdentifier),
                (t.forceQuirks = !0),
                this.emitCurrentDoctype(t),
                (this.state = dr.DATA);
              break;
            case Nt.EOF:
              this._err(Ft.eofInDoctype),
                (t.forceQuirks = !0),
                this.emitCurrentDoctype(t),
                this._emitEOFToken();
              break;
            default:
              t.systemId += String.fromCodePoint(e);
          }
        }
        _stateAfterDoctypeSystemIdentifier(e) {
          const t = this.currentToken;
          switch (e) {
            case Nt.SPACE:
            case Nt.LINE_FEED:
            case Nt.TABULATION:
            case Nt.FORM_FEED:
              break;
            case Nt.GREATER_THAN_SIGN:
              this.emitCurrentDoctype(t), (this.state = dr.DATA);
              break;
            case Nt.EOF:
              this._err(Ft.eofInDoctype),
                (t.forceQuirks = !0),
                this.emitCurrentDoctype(t),
                this._emitEOFToken();
              break;
            default:
              this._err(Ft.unexpectedCharacterAfterDoctypeSystemIdentifier),
                (this.state = dr.BOGUS_DOCTYPE),
                this._stateBogusDoctype(e);
          }
        }
        _stateBogusDoctype(e) {
          const t = this.currentToken;
          switch (e) {
            case Nt.GREATER_THAN_SIGN:
              this.emitCurrentDoctype(t), (this.state = dr.DATA);
              break;
            case Nt.NULL:
              this._err(Ft.unexpectedNullCharacter);
              break;
            case Nt.EOF:
              this.emitCurrentDoctype(t), this._emitEOFToken();
          }
        }
        _stateCdataSection(e) {
          switch (e) {
            case Nt.RIGHT_SQUARE_BRACKET:
              this.state = dr.CDATA_SECTION_BRACKET;
              break;
            case Nt.EOF:
              this._err(Ft.eofInCdata), this._emitEOFToken();
              break;
            default:
              this._emitCodePoint(e);
          }
        }
        _stateCdataSectionBracket(e) {
          e === Nt.RIGHT_SQUARE_BRACKET
            ? (this.state = dr.CDATA_SECTION_END)
            : (this._emitChars("]"),
              (this.state = dr.CDATA_SECTION),
              this._stateCdataSection(e));
        }
        _stateCdataSectionEnd(e) {
          switch (e) {
            case Nt.GREATER_THAN_SIGN:
              this.state = dr.DATA;
              break;
            case Nt.RIGHT_SQUARE_BRACKET:
              this._emitChars("]");
              break;
            default:
              this._emitChars("]]"),
                (this.state = dr.CDATA_SECTION),
                this._stateCdataSection(e);
          }
        }
        _stateCharacterReference(e) {
          e === Nt.NUMBER_SIGN
            ? (this.state = dr.NUMERIC_CHARACTER_REFERENCE)
            : yr(e)
            ? ((this.state = dr.NAMED_CHARACTER_REFERENCE),
              this._stateNamedCharacterReference(e))
            : (this._flushCodePointConsumedAsCharacterReference(Nt.AMPERSAND),
              this._reconsumeInState(this.returnState, e));
        }
        _stateNamedCharacterReference(e) {
          const t = this._matchNamedCharacterReference(e);
          if (this._ensureHibernation());
          else if (t) {
            for (let e = 0; e < t.length; e++)
              this._flushCodePointConsumedAsCharacterReference(t[e]);
            this.state = this.returnState;
          } else
            this._flushCodePointConsumedAsCharacterReference(Nt.AMPERSAND),
              (this.state = dr.AMBIGUOUS_AMPERSAND);
        }
        _stateAmbiguousAmpersand(e) {
          yr(e)
            ? this._flushCodePointConsumedAsCharacterReference(e)
            : (e === Nt.SEMICOLON && this._err(Ft.unknownNamedCharacterReference),
              this._reconsumeInState(this.returnState, e));
        }
        _stateNumericCharacterReference(e) {
          (this.charRefCode = 0),
            e === Nt.LATIN_SMALL_X || e === Nt.LATIN_CAPITAL_X
              ? (this.state = dr.HEXADEMICAL_CHARACTER_REFERENCE_START)
              : fr(e)
              ? ((this.state = dr.DECIMAL_CHARACTER_REFERENCE),
                this._stateDecimalCharacterReference(e))
              : (this._err(Ft.absenceOfDigitsInNumericCharacterReference),
                this._flushCodePointConsumedAsCharacterReference(Nt.AMPERSAND),
                this._flushCodePointConsumedAsCharacterReference(Nt.NUMBER_SIGN),
                this._reconsumeInState(this.returnState, e));
        }
        _stateHexademicalCharacterReferenceStart(e) {
          !(function (e) {
            return fr(e) || Ar(e) || wr(e);
          })(e)
            ? (this._err(Ft.absenceOfDigitsInNumericCharacterReference),
              this._flushCodePointConsumedAsCharacterReference(Nt.AMPERSAND),
              this._flushCodePointConsumedAsCharacterReference(Nt.NUMBER_SIGN),
              this._unconsume(2),
              (this.state = this.returnState))
            : ((this.state = dr.HEXADEMICAL_CHARACTER_REFERENCE),
              this._stateHexademicalCharacterReference(e));
        }
        _stateHexademicalCharacterReference(e) {
          Ar(e)
            ? (this.charRefCode = 16 * this.charRefCode + e - 55)
            : wr(e)
            ? (this.charRefCode = 16 * this.charRefCode + e - 87)
            : fr(e)
            ? (this.charRefCode = 16 * this.charRefCode + e - 48)
            : e === Nt.SEMICOLON
            ? (this.state = dr.NUMERIC_CHARACTER_REFERENCE_END)
            : (this._err(Ft.missingSemicolonAfterCharacterReference),
              (this.state = dr.NUMERIC_CHARACTER_REFERENCE_END),
              this._stateNumericCharacterReferenceEnd(e));
        }
        _stateDecimalCharacterReference(e) {
          fr(e)
            ? (this.charRefCode = 10 * this.charRefCode + e - 48)
            : e === Nt.SEMICOLON
            ? (this.state = dr.NUMERIC_CHARACTER_REFERENCE_END)
            : (this._err(Ft.missingSemicolonAfterCharacterReference),
              (this.state = dr.NUMERIC_CHARACTER_REFERENCE_END),
              this._stateNumericCharacterReferenceEnd(e));
        }
        _stateNumericCharacterReferenceEnd(e) {
          if (this.charRefCode === Nt.NULL)
            this._err(Ft.nullCharacterReference),
              (this.charRefCode = Nt.REPLACEMENT_CHARACTER);
          else if (this.charRefCode > 1114111)
            this._err(Ft.characterReferenceOutsideUnicodeRange),
              (this.charRefCode = Nt.REPLACEMENT_CHARACTER);
          else if (Pt(this.charRefCode))
            this._err(Ft.surrogateCharacterReference),
              (this.charRefCode = Nt.REPLACEMENT_CHARACTER);
          else if (Mt(this.charRefCode))
            this._err(Ft.noncharacterCharacterReference);
          else if (
            Ut(this.charRefCode) ||
            this.charRefCode === Nt.CARRIAGE_RETURN
          ) {
            this._err(Ft.controlCharacterReference);
            const e = ur.get(this.charRefCode);
            void 0 !== e && (this.charRefCode = e);
          }
          this._flushCodePointConsumedAsCharacterReference(this.charRefCode),
            this._reconsumeInState(this.returnState, e);
        }
      }
      const Sr = new Set([
        or.DD,
        or.DT,
        or.LI,
        or.OPTGROUP,
        or.OPTION,
        or.P,
        or.RB,
        or.RP,
        or.RT,
        or.RTC,
      ]);
      new Set([
        ...Sr,
        or.CAPTION,
        or.COLGROUP,
        or.TBODY,
        or.TD,
        or.TFOOT,
        or.TH,
        or.THEAD,
        or.TR,
      ]),
        new Map([
          [or.APPLET, ir.HTML],
          [or.CAPTION, ir.HTML],
          [or.HTML, ir.HTML],
          [or.MARQUEE, ir.HTML],
          [or.OBJECT, ir.HTML],
          [or.TABLE, ir.HTML],
          [or.TD, ir.HTML],
          [or.TEMPLATE, ir.HTML],
          [or.TH, ir.HTML],
          [or.ANNOTATION_XML, ir.MATHML],
          [or.MI, ir.MATHML],
          [or.MN, ir.MATHML],
          [or.MO, ir.MATHML],
          [or.MS, ir.MATHML],
          [or.MTEXT, ir.MATHML],
          [or.DESC, ir.SVG],
          [or.FOREIGN_OBJECT, ir.SVG],
          [or.TITLE, ir.SVG],
        ]),
        or.H1,
        or.H2,
        or.H3,
        or.H4,
        or.H5,
        or.H6,
        or.TR,
        or.TEMPLATE,
        or.HTML,
        or.TBODY,
        or.TFOOT,
        or.THEAD,
        or.TEMPLATE,
        or.HTML,
        or.TABLE,
        or.TEMPLATE,
        or.HTML,
        or.TD,
        or.TH;
      var Tr;
      !(function (e) {
        (e[(e.Marker = 0)] = "Marker"), (e[(e.Element = 1)] = "Element");
      })((Tr = Tr || (Tr = {})));
      Tr.Marker;
      const _r = [
          "+//silmaril//dtd html pro v0r11 19970101//",
          "-//as//dtd html 3.0 aswedit + extensions//",
          "-//advasoft ltd//dtd html 3.0 aswedit + extensions//",
          "-//ietf//dtd html 2.0 level 1//",
          "-//ietf//dtd html 2.0 level 2//",
          "-//ietf//dtd html 2.0 strict level 1//",
          "-//ietf//dtd html 2.0 strict level 2//",
          "-//ietf//dtd html 2.0 strict//",
          "-//ietf//dtd html 2.0//",
          "-//ietf//dtd html 2.1e//",
          "-//ietf//dtd html 3.0//",
          "-//ietf//dtd html 3.2 final//",
          "-//ietf//dtd html 3.2//",
          "-//ietf//dtd html 3//",
          "-//ietf//dtd html level 0//",
          "-//ietf//dtd html level 1//",
          "-//ietf//dtd html level 2//",
          "-//ietf//dtd html level 3//",
          "-//ietf//dtd html strict level 0//",
          "-//ietf//dtd html strict level 1//",
          "-//ietf//dtd html strict level 2//",
          "-//ietf//dtd html strict level 3//",
          "-//ietf//dtd html strict//",
          "-//ietf//dtd html//",
          "-//metrius//dtd metrius presentational//",
          "-//microsoft//dtd internet explorer 2.0 html strict//",
          "-//microsoft//dtd internet explorer 2.0 html//",
          "-//microsoft//dtd internet explorer 2.0 tables//",
          "-//microsoft//dtd internet explorer 3.0 html strict//",
          "-//microsoft//dtd internet explorer 3.0 html//",
          "-//microsoft//dtd internet explorer 3.0 tables//",
          "-//netscape comm. corp.//dtd html//",
          "-//netscape comm. corp.//dtd strict html//",
          "-//o'reilly and associates//dtd html 2.0//",
          "-//o'reilly and associates//dtd html extended 1.0//",
          "-//o'reilly and associates//dtd html extended relaxed 1.0//",
          "-//sq//dtd html 2.0 hotmetal + extensions//",
          "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//",
          "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//",
          "-//spyglass//dtd html 2.0 extended//",
          "-//sun microsystems corp.//dtd hotjava html//",
          "-//sun microsystems corp.//dtd hotjava strict html//",
          "-//w3c//dtd html 3 1995-03-24//",
          "-//w3c//dtd html 3.2 draft//",
          "-//w3c//dtd html 3.2 final//",
          "-//w3c//dtd html 3.2//",
          "-//w3c//dtd html 3.2s draft//",
          "-//w3c//dtd html 4.0 frameset//",
          "-//w3c//dtd html 4.0 transitional//",
          "-//w3c//dtd html experimental 19960712//",
          "-//w3c//dtd html experimental 970421//",
          "-//w3c//dtd w3 html//",
          "-//w3o//dtd w3 html 3.0//",
          "-//webtechs//dtd mozilla html 2.0//",
          "-//webtechs//dtd mozilla html//",
        ],
        Cr =
          (new Set([
            "-//w3o//dtd w3 html strict 3.0//en//",
            "-/w3c/dtd html 4.0 transitional/en",
            "html",
          ]),
          [
            "-//w3c//dtd xhtml 1.0 frameset//",
            "-//w3c//dtd xhtml 1.0 transitional//",
          ]);
      const xr = {
          TEXT_HTML: "text/html",
          APPLICATION_XML: "application/xhtml+xml",
        },
        Nr = new Map(
          [
            "attributeName",
            "attributeType",
            "baseFrequency",
            "baseProfile",
            "calcMode",
            "clipPathUnits",
            "diffuseConstant",
            "edgeMode",
            "filterUnits",
            "glyphRef",
            "gradientTransform",
            "gradientUnits",
            "kernelMatrix",
            "kernelUnitLength",
            "keyPoints",
            "keySplines",
            "keyTimes",
            "lengthAdjust",
            "limitingConeAngle",
            "markerHeight",
            "markerUnits",
            "markerWidth",
            "maskContentUnits",
            "maskUnits",
            "numOctaves",
            "pathLength",
            "patternContentUnits",
            "patternTransform",
            "patternUnits",
            "pointsAtX",
            "pointsAtY",
            "pointsAtZ",
            "preserveAlpha",
            "preserveAspectRatio",
            "primitiveUnits",
            "refX",
            "refY",
            "repeatCount",
            "repeatDur",
            "requiredExtensions",
            "requiredFeatures",
            "specularConstant",
            "specularExponent",
            "spreadMethod",
            "startOffset",
            "stdDeviation",
            "stitchTiles",
            "surfaceScale",
            "systemLanguage",
            "tableValues",
            "targetX",
            "targetY",
            "textLength",
            "viewBox",
            "viewTarget",
            "xChannelSelector",
            "yChannelSelector",
            "zoomAndPan",
          ].map((e) => [e.toLowerCase(), e])
        ),
        kr = new Map([
          [
            "xlink:actuate",
            { prefix: "xlink", name: "actuate", namespace: ir.XLINK },
          ],
          [
            "xlink:arcrole",
            { prefix: "xlink", name: "arcrole", namespace: ir.XLINK },
          ],
          ["xlink:href", { prefix: "xlink", name: "href", namespace: ir.XLINK }],
          ["xlink:role", { prefix: "xlink", name: "role", namespace: ir.XLINK }],
          ["xlink:show", { prefix: "xlink", name: "show", namespace: ir.XLINK }],
          [
            "xlink:title",
            { prefix: "xlink", name: "title", namespace: ir.XLINK },
          ],
          ["xlink:type", { prefix: "xlink", name: "type", namespace: ir.XLINK }],
          ["xml:base", { prefix: "xml", name: "base", namespace: ir.XML }],
          ["xml:lang", { prefix: "xml", name: "lang", namespace: ir.XML }],
          ["xml:space", { prefix: "xml", name: "space", namespace: ir.XML }],
          ["xmlns", { prefix: "", name: "xmlns", namespace: ir.XMLNS }],
          [
            "xmlns:xlink",
            { prefix: "xmlns", name: "xlink", namespace: ir.XMLNS },
          ],
        ]),
        Rr = new Map(
          [
            "altGlyph",
            "altGlyphDef",
            "altGlyphItem",
            "animateColor",
            "animateMotion",
            "animateTransform",
            "clipPath",
            "feBlend",
            "feColorMatrix",
            "feComponentTransfer",
            "feComposite",
            "feConvolveMatrix",
            "feDiffuseLighting",
            "feDisplacementMap",
            "feDistantLight",
            "feFlood",
            "feFuncA",
            "feFuncB",
            "feFuncG",
            "feFuncR",
            "feGaussianBlur",
            "feImage",
            "feMerge",
            "feMergeNode",
            "feMorphology",
            "feOffset",
            "fePointLight",
            "feSpecularLighting",
            "feSpotLight",
            "feTile",
            "feTurbulence",
            "foreignObject",
            "glyphRef",
            "linearGradient",
            "radialGradient",
            "textPath",
          ].map((e) => [e.toLowerCase(), e])
        ),
        Br = new Set([
          or.B,
          or.BIG,
          or.BLOCKQUOTE,
          or.BODY,
          or.BR,
          or.CENTER,
          or.CODE,
          or.DD,
          or.DIV,
          or.DL,
          or.DT,
          or.EM,
          or.EMBED,
          or.H1,
          or.H2,
          or.H3,
          or.H4,
          or.H5,
          or.H6,
          or.HEAD,
          or.HR,
          or.I,
          or.IMG,
          or.LI,
          or.LISTING,
          or.MENU,
          or.META,
          or.NOBR,
          or.OL,
          or.P,
          or.PRE,
          or.RUBY,
          or.S,
          or.SMALL,
          or.SPAN,
          or.STRONG,
          or.STRIKE,
          or.SUB,
          or.SUP,
          or.TABLE,
          or.TT,
          or.U,
          or.UL,
          or.VAR,
        ]);
      function Dr(e) {
        const t = Rr.get(e.tagName);
        null != t && ((e.tagName = t), (e.tagID = lr(e.tagName)));
      }
      function Or(e, t, r, i) {
        return (
          ((!i || i === ir.HTML) &&
            (function (e, t, r) {
              if (t === ir.MATHML && e === or.ANNOTATION_XML)
                for (let e = 0; e < r.length; e++)
                  if (r[e].name === sr.ENCODING) {
                    const t = r[e].value.toLowerCase();
                    return t === xr.TEXT_HTML || t === xr.APPLICATION_XML;
                  }
              return (
                t === ir.SVG &&
                (e === or.FOREIGN_OBJECT || e === or.DESC || e === or.TITLE)
              );
            })(e, t, r)) ||
          ((!i || i === ir.MATHML) &&
            (function (e, t) {
              return (
                t === ir.MATHML &&
                (e === or.MI ||
                  e === or.MO ||
                  e === or.MN ||
                  e === or.MS ||
                  e === or.MTEXT)
              );
            })(e, t))
        );
      }
      var Lr;
      !(function (e) {
        (e[(e.INITIAL = 0)] = "INITIAL"),
          (e[(e.BEFORE_HTML = 1)] = "BEFORE_HTML"),
          (e[(e.BEFORE_HEAD = 2)] = "BEFORE_HEAD"),
          (e[(e.IN_HEAD = 3)] = "IN_HEAD"),
          (e[(e.IN_HEAD_NO_SCRIPT = 4)] = "IN_HEAD_NO_SCRIPT"),
          (e[(e.AFTER_HEAD = 5)] = "AFTER_HEAD"),
          (e[(e.IN_BODY = 6)] = "IN_BODY"),
          (e[(e.TEXT = 7)] = "TEXT"),
          (e[(e.IN_TABLE = 8)] = "IN_TABLE"),
          (e[(e.IN_TABLE_TEXT = 9)] = "IN_TABLE_TEXT"),
          (e[(e.IN_CAPTION = 10)] = "IN_CAPTION"),
          (e[(e.IN_COLUMN_GROUP = 11)] = "IN_COLUMN_GROUP"),
          (e[(e.IN_TABLE_BODY = 12)] = "IN_TABLE_BODY"),
          (e[(e.IN_ROW = 13)] = "IN_ROW"),
          (e[(e.IN_CELL = 14)] = "IN_CELL"),
          (e[(e.IN_SELECT = 15)] = "IN_SELECT"),
          (e[(e.IN_SELECT_IN_TABLE = 16)] = "IN_SELECT_IN_TABLE"),
          (e[(e.IN_TEMPLATE = 17)] = "IN_TEMPLATE"),
          (e[(e.AFTER_BODY = 18)] = "AFTER_BODY"),
          (e[(e.IN_FRAMESET = 19)] = "IN_FRAMESET"),
          (e[(e.AFTER_FRAMESET = 20)] = "AFTER_FRAMESET"),
          (e[(e.AFTER_AFTER_BODY = 21)] = "AFTER_AFTER_BODY"),
          (e[(e.AFTER_AFTER_FRAMESET = 22)] = "AFTER_AFTER_FRAMESET");
      })(Lr || (Lr = {}));
      new Set([or.TABLE, or.TBODY, or.TFOOT, or.THEAD, or.TR]);
      new Set([
        or.CAPTION,
        or.COL,
        or.COLGROUP,
        or.TBODY,
        or.TD,
        or.TFOOT,
        or.TH,
        or.THEAD,
        or.TR,
      ]);
      const Pr = new Map([
        [34, "&quot;"],
        [38, "&amp;"],
        [39, "&apos;"],
        [60, "&lt;"],
        [62, "&gt;"],
      ]);
      String.prototype.codePointAt;
      function Ur(e, t) {
        return function (r) {
          let i,
            s = 0,
            n = "";
          for (; (i = e.exec(r)); )
            s !== i.index && (n += r.substring(s, i.index)),
              (n += t.get(i[0].charCodeAt(0))),
              (s = i.index + 1);
          return n + r.substring(s);
        };
      }
      Ur(/[&<>'"]/g, Pr),
        Ur(
          /["&\u00A0]/g,
          new Map([
            [34, "&quot;"],
            [38, "&amp;"],
            [160, "&nbsp;"],
          ])
        ),
        Ur(
          /[&<>\u00A0]/g,
          new Map([
            [38, "&amp;"],
            [60, "&lt;"],
            [62, "&gt;"],
            [160, "&nbsp;"],
          ])
        ),
        new Set([
          ar.AREA,
          ar.BASE,
          ar.BASEFONT,
          ar.BGSOUND,
          ar.BR,
          ar.COL,
          ar.EMBED,
          ar.FRAME,
          ar.HR,
          ar.IMG,
          ar.INPUT,
          ar.KEYGEN,
          ar.LINK,
          ar.META,
          ar.PARAM,
          ar.SOURCE,
          ar.TRACK,
          ar.WBR,
        ]);
      var Mr = r(8310);
      class Fr extends Mr.Writable {
        _write(e, t, r) {
          r();
        }
      }
      const Hr = or;
      class Qr {
        constructor(e, t) {
          (this.handler = t),
            (this.namespaceStack = []),
            (this.inForeignContent = !1),
            (this.skipNextNewLine = !1),
            (this.tokenizer = new Ir(e, this)),
            this._enterNamespace(ir.HTML);
        }
        onNullCharacter(e) {
          (this.skipNextNewLine = !1),
            this.inForeignContent
              ? this.handler.onCharacter({
                  type: Qt.CHARACTER,
                  chars: "",
                  location: e.location,
                })
              : this.handler.onNullCharacter(e);
        }
        onWhitespaceCharacter(e) {
          if (this.skipNextNewLine && 10 === e.chars.charCodeAt(0)) {
            if (((this.skipNextNewLine = !1), 1 === e.chars.length)) return;
            e.chars = e.chars.substr(1);
          }
          this.handler.onWhitespaceCharacter(e);
        }
        onCharacter(e) {
          (this.skipNextNewLine = !1), this.handler.onCharacter(e);
        }
        onComment(e) {
          (this.skipNextNewLine = !1), this.handler.onComment(e);
        }
        onDoctype(e) {
          (this.skipNextNewLine = !1), this.handler.onDoctype(e);
        }
        onEof(e) {
          (this.skipNextNewLine = !1), this.handler.onEof(e);
        }
        _enterNamespace(e) {
          this.namespaceStack.unshift(e),
            (this.inForeignContent = e !== ir.HTML),
            (this.tokenizer.inForeignNode = this.inForeignContent);
        }
        _leaveCurrentNamespace() {
          this.namespaceStack.shift(),
            (this.inForeignContent = this.namespaceStack[0] !== ir.HTML),
            (this.tokenizer.inForeignNode = this.inForeignContent);
        }
        _ensureTokenizerMode(e) {
          switch (e) {
            case Hr.TEXTAREA:
            case Hr.TITLE:
              this.tokenizer.state = pr.RCDATA;
              break;
            case Hr.PLAINTEXT:
              this.tokenizer.state = pr.PLAINTEXT;
              break;
            case Hr.SCRIPT:
              this.tokenizer.state = pr.SCRIPT_DATA;
              break;
            case Hr.STYLE:
            case Hr.IFRAME:
            case Hr.XMP:
            case Hr.NOEMBED:
            case Hr.NOFRAMES:
            case Hr.NOSCRIPT:
              this.tokenizer.state = pr.RAWTEXT;
          }
        }
        onStartTag(e) {
          let t = e.tagID;
          switch (t) {
            case Hr.SVG:
              this._enterNamespace(ir.SVG);
              break;
            case Hr.MATH:
              this._enterNamespace(ir.MATHML);
          }
          if (this.inForeignContent)
            if (
              (function (e) {
                const t = e.tagID;
                return (
                  (t === or.FONT &&
                    e.attrs.some(
                      ({ name: e }) =>
                        e === sr.COLOR || e === sr.SIZE || e === sr.FACE
                    )) ||
                  Br.has(t)
                );
              })(e)
            )
              this._leaveCurrentNamespace();
            else {
              const r = this.namespaceStack[0];
              r === ir.MATHML
                ? (function (e) {
                    for (let t = 0; t < e.attrs.length; t++)
                      if ("definitionurl" === e.attrs[t].name) {
                        e.attrs[t].name = "definitionURL";
                        break;
                      }
                  })(e)
                : r === ir.SVG &&
                  (Dr(e),
                  (function (e) {
                    for (let t = 0; t < e.attrs.length; t++) {
                      const r = Nr.get(e.attrs[t].name);
                      null != r && (e.attrs[t].name = r);
                    }
                  })(e)),
                (function (e) {
                  for (let t = 0; t < e.attrs.length; t++) {
                    const r = kr.get(e.attrs[t].name);
                    r &&
                      ((e.attrs[t].prefix = r.prefix),
                      (e.attrs[t].name = r.name),
                      (e.attrs[t].namespace = r.namespace));
                  }
                })(e),
                (t = e.tagID),
                !e.selfClosing &&
                  Or(t, r, e.attrs) &&
                  this._enterNamespace(ir.HTML);
            }
          else {
            switch (t) {
              case Hr.PRE:
              case Hr.TEXTAREA:
              case Hr.LISTING:
                this.skipNextNewLine = !0;
                break;
              case Hr.IMAGE:
                (e.tagName = ar.IMG), (e.tagID = Hr.IMG);
            }
            this._ensureTokenizerMode(t);
          }
          this.handler.onStartTag(e);
        }
        onEndTag(e) {
          let t = e.tagID;
          if (this.inForeignContent)
            ((t === Hr.SVG && this.namespaceStack[0] === ir.SVG) ||
              (t === Hr.MATH && this.namespaceStack[0] === ir.MATHML)) &&
              this._leaveCurrentNamespace();
          else {
            const r = this.namespaceStack[1];
            if (r === ir.SVG) {
              const r = Rr.get(e.tagName);
              r && (t = lr(r));
            }
            Or(t, r, e.attrs) && this._leaveCurrentNamespace();
          }
          this.namespaceStack[0] === ir.SVG && Dr(e), this.handler.onEndTag(e);
        }
      }
      class Vr extends Mr.Transform {
        constructor(e = {}) {
          super({ encoding: "utf8", decodeStrings: !1 }),
            (this.pendingText = null),
            (this.lastChunkWritten = !1),
            (this.stopped = !1),
            (this.options = { sourceCodeLocationInfo: !1, ...e }),
            (this.parserFeedbackSimulator = new Qr(this.options, this)),
            (this.tokenizer = this.parserFeedbackSimulator.tokenizer),
            this.pipe(new Fr());
        }
        _transform(e, t, r) {
          if ("string" != typeof e)
            throw new TypeError("Parser can work only with string streams.");
          r(null, this._transformChunk(e));
        }
        _final(e) {
          (this.lastChunkWritten = !0), e(null, this._transformChunk(""));
        }
        stop() {
          (this.stopped = !0), this.tokenizer.pause();
        }
        _transformChunk(e) {
          return (
            this.stopped || this.tokenizer.write(e, this.lastChunkWritten), e
          );
        }
        onCharacter({ chars: e, location: t }) {
          if (null === this.pendingText)
            this.pendingText = { text: e, sourceCodeLocation: t };
          else if (
            ((this.pendingText.text += e),
            t && this.pendingText.sourceCodeLocation)
          ) {
            const { endLine: e, endCol: r, endOffset: i } = t;
            this.pendingText.sourceCodeLocation = {
              ...this.pendingText.sourceCodeLocation,
              endLine: e,
              endCol: r,
              endOffset: i,
            };
          }
          this.tokenizer.preprocessor.willDropParsedChunk() &&
            this._emitPendingText();
        }
        onWhitespaceCharacter(e) {
          this.onCharacter(e);
        }
        onNullCharacter(e) {
          this.onCharacter(e);
        }
        onEof() {
          this._emitPendingText(), (this.stopped = !0);
        }
        onStartTag(e) {
          this._emitPendingText();
          const t = {
            tagName: e.tagName,
            attrs: e.attrs,
            selfClosing: e.selfClosing,
            sourceCodeLocation: e.location,
          };
          this.emitIfListenerExists("startTag", t);
        }
        onEndTag(e) {
          this._emitPendingText();
          const t = { tagName: e.tagName, sourceCodeLocation: e.location };
          this.emitIfListenerExists("endTag", t);
        }
        onDoctype(e) {
          this._emitPendingText();
          const t = {
            name: e.name,
            publicId: e.publicId,
            systemId: e.systemId,
            sourceCodeLocation: e.location,
          };
          this.emitIfListenerExists("doctype", t);
        }
        onComment(e) {
          this._emitPendingText();
          const t = { text: e.data, sourceCodeLocation: e.location };
          this.emitIfListenerExists("comment", t);
        }
        emitIfListenerExists(e, t) {
          return 0 !== this.listenerCount(e) && (this._emitToken(e, t), !0);
        }
        _emitToken(e, t) {
          this.emit(e, t);
        }
        _emitPendingText() {
          null !== this.pendingText &&
            (this.emitIfListenerExists("text", this.pendingText),
            (this.pendingText = null));
        }
      }
      new TextEncoder(), new TextDecoder();
      var zr = r(1668),
        qr = r(4342);
      function Gr(e, t, r) {
        let i, s;
        switch ((r || {}, t)) {
          case "RFC3548":
          case "RFC4648":
            "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", !0;
            break;
          case "RFC4648-HEX":
            "0123456789ABCDEFGHIJKLMNOPQRSTUV", !0;
            break;
          case "Crockford":
            "0123456789ABCDEFGHJKMNPQRSTVWXYZ", !1;
            break;
          default:
            throw new Error("Unknown base32 variant: " + t);
        }
        const n = void 0 !== r.padding ? r.padding : s,
          a = (function (e) {
            if (
              e instanceof Int8Array ||
              e instanceof Uint8Array ||
              e instanceof Uint8ClampedArray
            )
              return new DataView(e.buffer, e.byteOffset, e.byteLength);
            if (e instanceof ArrayBuffer) return new DataView(e);
            throw new TypeError(
              "Expected `data` to be an ArrayBuffer, Buffer, Int8Array, Uint8Array or Uint8ClampedArray"
            );
          })(e);
        let o = 0,
          c = 0,
          l = "";
        for (let e = 0; e < a.byteLength; e++)
          for ((c << 8) | a.getUint8(e), 8; o >= 5; ) i[(c >>> (o - 5)) & 31], 5;
        if ((o > 0 && i[(c << (5 - o)) & 31], n)) for (; l.length % 8 != 0; ) "=";
        return l;
      }
      /*!
       * hash-wasm (https://www.npmjs.com/package/hash-wasm)
       * (c) Dani Biro
       * @license MIT
       */
      function jr(e, t, r, i) {
        return new (r || (r = Promise))(function (s, n) {
          function a(e) {
            try {
              c(i.next(e));
            } catch (e) {
              n(e);
            }
          }
          function o(e) {
            try {
              c(i.throw(e));
            } catch (e) {
              n(e);
            }
          }
          function c(e) {
            var t;
            e.done
              ? s(e.value)
              : ((t = e.value),
                t instanceof r
                  ? t
                  : new r(function (e) {
                      e(t);
                    })).then(a, o);
          }
          c((i = i.apply(e, t || [])).next());
        });
      }
      "function" == typeof SuppressedError && SuppressedError;
      class Wr {
        constructor() {
          this.mutex = Promise.resolve();
        }
        lock() {
          let e = () => {};
          return (
            (this.mutex = this.mutex.then(() => new Promise(e))),
            new Promise((t) => {
              e = t;
            })
          );
        }
        dispatch(e) {
          return jr(this, void 0, void 0, function* () {
            const t = yield this.lock();
            try {
              return yield Promise.resolve(e());
            } finally {
              t();
            }
          });
        }
      }
      var Yr;
      const Xr =
          "undefined" != typeof globalThis
            ? globalThis
            : "undefined" != typeof self
            ? self
            : "undefined" != typeof window
            ? window
            : r.g,
        Kr = null !== (Yr = Xr.Buffer) && void 0 !== Yr ? Yr : null,
        Jr = Xr.TextEncoder ? new Xr.TextEncoder() : null;
      function Zr(e, t) {
        return (
          (((15 & e) + ((e >> 6) | ((e >> 3) & 8))) << 4) |
          ((15 & t) + ((t >> 6) | ((t >> 3) & 8)))
        );
      }
      function $r(e, t) {
        const r = t.length >> 1;
        for (let i = 0; i < r; i++) {
          const r = i << 1;
          e[i] = Zr(t.charCodeAt(r), t.charCodeAt(r + 1));
        }
      }
      const ei = "a".charCodeAt(0) - 10,
        ti = "0".charCodeAt(0);
      function ri(e, t, r) {
        let i = 0;
        for (let s = 0; s < r; s++) {
          let r = t[s] >>> 4;
          (e[i++] = r > 9 ? r + ei : r + ti),
            (r = 15 & t[s]),
            (e[i++] = r > 9 ? r + ei : r + ti);
        }
        return String.fromCharCode.apply(null, e);
      }
      const ii =
          null !== Kr
            ? (e) => {
                if ("string" == typeof e) {
                  const t = Kr.from(e, "utf8");
                  return new Uint8Array(t.buffer, t.byteOffset, t.length);
                }
                if (Kr.isBuffer(e))
                  return new Uint8Array(e.buffer, e.byteOffset, e.length);
                if (ArrayBuffer.isView(e))
                  return new Uint8Array(e.buffer, e.byteOffset, e.byteLength);
                throw new Error("Invalid data type!");
              }
            : (e) => {
                if ("string" == typeof e) return Jr.encode(e);
                if (ArrayBuffer.isView(e))
                  return new Uint8Array(e.buffer, e.byteOffset, e.byteLength);
                throw new Error("Invalid data type!");
              },
        si = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
        ni = new Uint8Array(256);
      for (let e = 0; e < si.length; e++) ni[si.charCodeAt(e)] = e;
      function ai(e) {
        let t = Math.floor(0.75 * e.length);
        const r = e.length;
        return "=" === e[r - 1] && ((t -= 1), "=" === e[r - 2] && (t -= 1)), t;
      }
      function oi(e) {
        const t = ai(e),
          r = e.length,
          i = new Uint8Array(t);
        let s = 0;
        for (let t = 0; t < r; t += 4) {
          const r = ni[e.charCodeAt(t)],
            n = ni[e.charCodeAt(t + 1)],
            a = ni[e.charCodeAt(t + 2)],
            o = ni[e.charCodeAt(t + 3)];
          (i[s] = (r << 2) | (n >> 4)),
            (s += 1),
            (i[s] = ((15 & n) << 4) | (a >> 2)),
            (s += 1),
            (i[s] = ((3 & a) << 6) | (63 & o)),
            (s += 1);
        }
        return i;
      }
      const ci = 16384,
        li = 4,
        hi = new Wr(),
        ui = new Map();
      function di(e, t) {
        return jr(this, void 0, void 0, function* () {
          let r = null,
            i = null,
            s = !1;
          if ("undefined" == typeof WebAssembly)
            throw new Error("WebAssembly is not supported in this environment!");
          const n = () =>
              new DataView(r.exports.memory.buffer).getUint32(
                r.exports.STATE_SIZE,
                !0
              ),
            a = hi.dispatch(() =>
              jr(this, void 0, void 0, function* () {
                if (!ui.has(e.name)) {
                  const t = oi(e.data),
                    r = WebAssembly.compile(t);
                  ui.set(e.name, r);
                }
                const t = yield ui.get(e.name);
                r = yield WebAssembly.instantiate(t, {});
              })
            ),
            o = (e = null) => {
              (s = !0), r.exports.Hash_Init(e);
            },
            c = (e) => {
              if (!s) throw new Error("update() called before init()");
              ((e) => {
                let t = 0;
                for (; t < e.length; ) {
                  const s = e.subarray(t, t + ci);
                  (t += s.length), i.set(s), r.exports.Hash_Update(s.length);
                }
              })(ii(e));
            },
            l = new Uint8Array(2 * t),
            h = (e, n = null) => {
              if (!s) throw new Error("digest() called before init()");
              return (
                (s = !1),
                r.exports.Hash_Final(n),
                "binary" === e ? i.slice(0, t) : ri(l, i, t)
              );
            },
            u = (e) =>
              "string" == typeof e ? e.length < ci / 4 : e.byteLength < ci;
          let d = u;
          switch (e.name) {
            case "argon2":
            case "scrypt":
              d = () => !0;
              break;
            case "blake2b":
            case "blake2s":
              d = (e, t) => t <= 512 && u(e);
              break;
            case "blake3":
              d = (e, t) => 0 === t && u(e);
              break;
            case "xxhash64":
            case "xxhash3":
            case "xxhash128":
              d = () => !1;
          }
          return (
            yield (() =>
              jr(this, void 0, void 0, function* () {
                r || (yield a);
                const e = r.exports.Hash_GetBuffer(),
                  t = r.exports.memory.buffer;
                i = new Uint8Array(t, e, ci);
              }))(),
            {
              getMemory: () => i,
              writeMemory: (e, t = 0) => {
                i.set(e, t);
              },
              getExports: () => r.exports,
              setMemorySize: (e) => {
                r.exports.Hash_SetMemorySize(e);
                const t = r.exports.Hash_GetBuffer(),
                  s = r.exports.memory.buffer;
                i = new Uint8Array(s, t, e);
              },
              init: o,
              update: c,
              digest: h,
              save: () => {
                if (!s)
                  throw new Error(
                    "save() can only be called after init() and before digest()"
                  );
                const t = r.exports.Hash_GetState(),
                  i = n(),
                  a = r.exports.memory.buffer,
                  o = new Uint8Array(a, t, i),
                  c = new Uint8Array(li + i);
                return $r(c, e.hash), c.set(o, li), c;
              },
              load: (t) => {
                if (!(t instanceof Uint8Array))
                  throw new Error(
                    "load() expects an Uint8Array generated by save()"
                  );
                const i = r.exports.Hash_GetState(),
                  a = n(),
                  o = li + a,
                  c = r.exports.memory.buffer;
                if (t.length !== o)
                  throw new Error(
                    `Bad state length (expected ${o} bytes, got ${t.length})`
                  );
                if (
                  !(function (e, t) {
                    if (e.length !== 2 * t.length) return !1;
                    for (let r = 0; r < t.length; r++) {
                      const i = r << 1;
                      if (t[r] !== Zr(e.charCodeAt(i), e.charCodeAt(i + 1)))
                        return !1;
                    }
                    return !0;
                  })(e.hash, t.subarray(0, li))
                )
                  throw new Error(
                    "This state was written by an incompatible hash implementation"
                  );
                const l = t.subarray(li);
                new Uint8Array(c, i, a).set(l), (s = !0);
              },
              calculate: (e, s = null, n = null) => {
                if (!d(e, s)) return o(s), c(e), h("hex", n);
                const a = ii(e);
                return (
                  i.set(a), r.exports.Hash_Calculate(a.length, s, n), ri(l, i, t)
                );
              },
              hashLength: t,
            }
          );
        });
      }
      new Wr();
      new Wr();
      new DataView(new ArrayBuffer(4));
      new Wr();
      new Wr();
      new Wr();
      new Wr();
      new Wr();
      new Wr();
      var pi = {
        name: "sha1",
        data: "AGFzbQEAAAABEQRgAAF/YAF/AGAAAGACf38AAwkIAAECAwECAAEFBAEBAgIGDgJ/AUHgiQULfwBBgAgLB3AIBm1lbW9yeQIADkhhc2hfR2V0QnVmZmVyAAAJSGFzaF9Jbml0AAILSGFzaF9VcGRhdGUABApIYXNoX0ZpbmFsAAUNSGFzaF9HZXRTdGF0ZQAGDkhhc2hfQ2FsY3VsYXRlAAcKU1RBVEVfU0laRQMBCpoqCAUAQYAJC68iCgF+An8BfgF/AX4DfwF+AX8Bfkd/QQAgACkDECIBQiCIpyICQRh0IAJBgP4DcUEIdHIgAUIoiKdBgP4DcSABQjiIp3JyIgMgACkDCCIEQiCIpyICQRh0IAJBgP4DcUEIdHIgBEIoiKdBgP4DcSAEQjiIp3JyIgVzIAApAygiBkIgiKciAkEYdCACQYD+A3FBCHRyIAZCKIinQYD+A3EgBkI4iKdyciIHcyAEpyICQRh0IAJBgP4DcUEIdHIgAkEIdkGA/gNxIAJBGHZyciIIIAApAwAiBKciAkEYdCACQYD+A3FBCHRyIAJBCHZBgP4DcSACQRh2cnIiCXMgACkDICIKpyICQRh0IAJBgP4DcUEIdHIgAkEIdkGA/gNxIAJBGHZyciILcyAAKQMwIgxCIIinIgJBGHQgAkGA/gNxQQh0ciAMQiiIp0GA/gNxIAxCOIincnIiAnNBAXciDXNBAXciDiAFIARCIIinIg9BGHQgD0GA/gNxQQh0ciAEQiiIp0GA/gNxIARCOIincnIiEHMgCkIgiKciD0EYdCAPQYD+A3FBCHRyIApCKIinQYD+A3EgCkI4iKdyciIRcyAAKQM4IgSnIg9BGHQgD0GA/gNxQQh0ciAPQQh2QYD+A3EgD0EYdnJyIg9zQQF3IhJzIAcgEXMgEnMgCyAAKQMYIgqnIgBBGHQgAEGA/gNxQQh0ciAAQQh2QYD+A3EgAEEYdnJyIhNzIA9zIA5zQQF3IgBzQQF3IhRzIA0gD3MgAHMgAiAHcyAOcyAGpyIVQRh0IBVBgP4DcUEIdHIgFUEIdkGA/gNxIBVBGHZyciIWIAtzIA1zIApCIIinIhVBGHQgFUGA/gNxQQh0ciAKQiiIp0GA/gNxIApCOIincnIiFyADcyACcyABpyIVQRh0IBVBgP4DcUEIdHIgFUEIdkGA/gNxIBVBGHZyciIYIAhzIBZzIARCIIinIhVBGHQgFUGA/gNxQQh0ciAEQiiIp0GA/gNxIARCOIincnIiFXNBAXciGXNBAXciGnNBAXciG3NBAXciHHNBAXciHXNBAXciHiASIBVzIBEgF3MgFXMgEyAYcyAMpyIfQRh0IB9BgP4DcUEIdHIgH0EIdkGA/gNxIB9BGHZyciIgcyASc0EBdyIfc0EBdyIhcyAPICBzIB9zIBRzQQF3IiJzQQF3IiNzIBQgIXMgI3MgACAfcyAicyAec0EBdyIkc0EBdyIlcyAdICJzICRzIBwgFHMgHnMgGyAAcyAdcyAaIA5zIBxzIBkgDXMgG3MgFSACcyAacyAgIBZzIBlzICFzQQF3IiZzQQF3IidzQQF3IihzQQF3IilzQQF3IipzQQF3IitzQQF3IixzQQF3Ii0gIyAncyAhIBpzICdzIB8gGXMgJnMgI3NBAXciLnNBAXciL3MgIiAmcyAucyAlc0EBdyIwc0EBdyIxcyAlIC9zIDFzICQgLnMgMHMgLXNBAXciMnNBAXciM3MgLCAwcyAycyArICVzIC1zICogJHMgLHMgKSAecyArcyAoIB1zICpzICcgHHMgKXMgJiAbcyAocyAvc0EBdyI0c0EBdyI1c0EBdyI2c0EBdyI3c0EBdyI4c0EBdyI5c0EBdyI6c0EBdyI7IDEgNXMgLyApcyA1cyAuIChzIDRzIDFzQQF3IjxzQQF3Ij1zIDAgNHMgPHMgM3NBAXciPnNBAXciP3MgMyA9cyA/cyAyIDxzID5zIDtzQQF3IkBzQQF3IkFzIDogPnMgQHMgOSAzcyA7cyA4IDJzIDpzIDcgLXMgOXMgNiAscyA4cyA1ICtzIDdzIDQgKnMgNnMgPXNBAXciQnNBAXciQ3NBAXciRHNBAXciRXNBAXciRnNBAXciR3NBAXciSHNBAXciSSA+IEJzIDwgNnMgQnMgP3NBAXciSnMgQXNBAXciSyA9IDdzIENzIEpzQQF3IkwgRCA5IDIgMSA0ICkgHSAUIB8gFSAWQQAoAoCJASJNQQV3QQAoApCJASJOaiAJakEAKAKMiQEiT0EAKAKIiQEiCXNBACgChIkBIlBxIE9zakGZ84nUBWoiUUEedyJSIANqIFBBHnciAyAFaiBPIAMgCXMgTXEgCXNqIBBqIFFBBXdqQZnzidQFaiIQIFIgTUEedyIFc3EgBXNqIAkgCGogUSADIAVzcSADc2ogEEEFd2pBmfOJ1AVqIlFBBXdqQZnzidQFaiJTIFFBHnciAyAQQR53IghzcSAIc2ogBSAYaiBRIAggUnNxIFJzaiBTQQV3akGZ84nUBWoiBUEFd2pBmfOJ1AVqIhhBHnciUmogU0EedyIWIAtqIAggE2ogBSAWIANzcSADc2ogGEEFd2pBmfOJ1AVqIgggUiAFQR53IgtzcSALc2ogAyAXaiAYIAsgFnNxIBZzaiAIQQV3akGZ84nUBWoiBUEFd2pBmfOJ1AVqIhMgBUEedyIWIAhBHnciA3NxIANzaiALIBFqIAUgAyBSc3EgUnNqIBNBBXdqQZnzidQFaiIRQQV3akGZ84nUBWoiUkEedyILaiACIBNBHnciFWogByADaiARIBUgFnNxIBZzaiBSQQV3akGZ84nUBWoiByALIBFBHnciAnNxIAJzaiAgIBZqIFIgAiAVc3EgFXNqIAdBBXdqQZnzidQFaiIRQQV3akGZ84nUBWoiFiARQR53IhUgB0EedyIHc3EgB3NqIA8gAmogESAHIAtzcSALc2ogFkEFd2pBmfOJ1AVqIgtBBXdqQZnzidQFaiIRQR53IgJqIBIgFWogESALQR53Ig8gFkEedyISc3EgEnNqIA0gB2ogCyASIBVzcSAVc2ogEUEFd2pBmfOJ1AVqIg1BBXdqQZnzidQFaiIVQR53Ih8gDUEedyIHcyAZIBJqIA0gAiAPc3EgD3NqIBVBBXdqQZnzidQFaiINc2ogDiAPaiAVIAcgAnNxIAJzaiANQQV3akGZ84nUBWoiAkEFd2pBodfn9gZqIg5BHnciD2ogACAfaiACQR53IgAgDUEedyINcyAOc2ogGiAHaiANIB9zIAJzaiAOQQV3akGh1+f2BmoiAkEFd2pBodfn9gZqIg5BHnciEiACQR53IhRzICEgDWogDyAAcyACc2ogDkEFd2pBodfn9gZqIgJzaiAbIABqIBQgD3MgDnNqIAJBBXdqQaHX5/YGaiIAQQV3akGh1+f2BmoiDUEedyIOaiAcIBJqIABBHnciDyACQR53IgJzIA1zaiAmIBRqIAIgEnMgAHNqIA1BBXdqQaHX5/YGaiIAQQV3akGh1+f2BmoiDUEedyISIABBHnciFHMgIiACaiAOIA9zIABzaiANQQV3akGh1+f2BmoiAHNqICcgD2ogFCAOcyANc2ogAEEFd2pBodfn9gZqIgJBBXdqQaHX5/YGaiINQR53Ig5qICggEmogAkEedyIPIABBHnciAHMgDXNqICMgFGogACAScyACc2ogDUEFd2pBodfn9gZqIgJBBXdqQaHX5/YGaiINQR53IhIgAkEedyIUcyAeIABqIA4gD3MgAnNqIA1BBXdqQaHX5/YGaiIAc2ogLiAPaiAUIA5zIA1zaiAAQQV3akGh1+f2BmoiAkEFd2pBodfn9gZqIg1BHnciDmogKiAAQR53IgBqIA4gAkEedyIPcyAkIBRqIAAgEnMgAnNqIA1BBXdqQaHX5/YGaiIUc2ogLyASaiAPIABzIA1zaiAUQQV3akGh1+f2BmoiDUEFd2pBodfn9gZqIgAgDUEedyICciAUQR53IhJxIAAgAnFyaiAlIA9qIBIgDnMgDXNqIABBBXdqQaHX5/YGaiINQQV3akHc+e74eGoiDkEedyIPaiA1IABBHnciAGogKyASaiANIAByIAJxIA0gAHFyaiAOQQV3akHc+e74eGoiEiAPciANQR53Ig1xIBIgD3FyaiAwIAJqIA4gDXIgAHEgDiANcXJqIBJBBXdqQdz57vh4aiIAQQV3akHc+e74eGoiAiAAQR53Ig5yIBJBHnciEnEgAiAOcXJqICwgDWogACASciAPcSAAIBJxcmogAkEFd2pB3Pnu+HhqIgBBBXdqQdz57vh4aiINQR53Ig9qIDwgAkEedyICaiA2IBJqIAAgAnIgDnEgACACcXJqIA1BBXdqQdz57vh4aiISIA9yIABBHnciAHEgEiAPcXJqIC0gDmogDSAAciACcSANIABxcmogEkEFd2pB3Pnu+HhqIgJBBXdqQdz57vh4aiINIAJBHnciDnIgEkEedyIScSANIA5xcmogNyAAaiACIBJyIA9xIAIgEnFyaiANQQV3akHc+e74eGoiAEEFd2pB3Pnu+HhqIgJBHnciD2ogMyANQR53Ig1qID0gEmogACANciAOcSAAIA1xcmogAkEFd2pB3Pnu+HhqIhIgD3IgAEEedyIAcSASIA9xcmogOCAOaiACIAByIA1xIAIgAHFyaiASQQV3akHc+e74eGoiAkEFd2pB3Pnu+HhqIg0gAkEedyIOciASQR53IhJxIA0gDnFyaiBCIABqIAIgEnIgD3EgAiAScXJqIA1BBXdqQdz57vh4aiIAQQV3akHc+e74eGoiAkEedyIPaiBDIA5qIAIgAEEedyIUciANQR53Ig1xIAIgFHFyaiA+IBJqIAAgDXIgDnEgACANcXJqIAJBBXdqQdz57vh4aiIAQQV3akHc+e74eGoiAkEedyISIABBHnciDnMgOiANaiAAIA9yIBRxIAAgD3FyaiACQQV3akHc+e74eGoiAHNqID8gFGogAiAOciAPcSACIA5xcmogAEEFd2pB3Pnu+HhqIgJBBXdqQdaDi9N8aiINQR53Ig9qIEogEmogAkEedyIUIABBHnciAHMgDXNqIDsgDmogACAScyACc2ogDUEFd2pB1oOL03xqIgJBBXdqQdaDi9N8aiINQR53Ig4gAkEedyIScyBFIABqIA8gFHMgAnNqIA1BBXdqQdaDi9N8aiIAc2ogQCAUaiASIA9zIA1zaiAAQQV3akHWg4vTfGoiAkEFd2pB1oOL03xqIg1BHnciD2ogQSAOaiACQR53IhQgAEEedyIAcyANc2ogRiASaiAAIA5zIAJzaiANQQV3akHWg4vTfGoiAkEFd2pB1oOL03xqIg1BHnciDiACQR53IhJzIEIgOHMgRHMgTHNBAXciFSAAaiAPIBRzIAJzaiANQQV3akHWg4vTfGoiAHNqIEcgFGogEiAPcyANc2ogAEEFd2pB1oOL03xqIgJBBXdqQdaDi9N8aiINQR53Ig9qIEggDmogAkEedyIUIABBHnciAHMgDXNqIEMgOXMgRXMgFXNBAXciGSASaiAAIA5zIAJzaiANQQV3akHWg4vTfGoiAkEFd2pB1oOL03xqIg1BHnciDiACQR53IhJzID8gQ3MgTHMgS3NBAXciGiAAaiAPIBRzIAJzaiANQQV3akHWg4vTfGoiAHNqIEQgOnMgRnMgGXNBAXciGyAUaiASIA9zIA1zaiAAQQV3akHWg4vTfGoiAkEFd2pB1oOL03xqIg1BHnciDyBOajYCkIkBQQAgTyBKIERzIBVzIBpzQQF3IhQgEmogAEEedyIAIA5zIAJzaiANQQV3akHWg4vTfGoiEkEedyIVajYCjIkBQQAgCSBFIDtzIEdzIBtzQQF3IA5qIAJBHnciAiAAcyANc2ogEkEFd2pB1oOL03xqIg1BHndqNgKIiQFBACBQIEAgSnMgS3MgSXNBAXcgAGogDyACcyASc2ogDUEFd2pB1oOL03xqIgBqNgKEiQFBACBNIEwgRXMgGXMgFHNBAXdqIAJqIBUgD3MgDXNqIABBBXdqQdaDi9N8ajYCgIkBCzoAQQBC/rnrxemOlZkQNwKIiQFBAEKBxpS6lvHq5m83AoCJAUEAQvDDy54MNwKQiQFBAEEANgKYiQELqAMBCH9BACECQQBBACgClIkBIgMgAUEDdGoiBDYClIkBQQBBACgCmIkBIAQgA0lqIAFBHXZqNgKYiQECQCADQQN2QT9xIgUgAWpBwABJDQBBwAAgBWsiAkEDcSEGQQAhAwJAIAVBP3NBA0kNACAFQYCJAWohByACQfwAcSEIQQAhAwNAIAcgA2oiBEEcaiAAIANqIgktAAA6AAAgBEEdaiAJQQFqLQAAOgAAIARBHmogCUECai0AADoAACAEQR9qIAlBA2otAAA6AAAgCCADQQRqIgNHDQALCwJAIAZFDQAgACADaiEEIAMgBWpBnIkBaiEDA0AgAyAELQAAOgAAIARBAWohBCADQQFqIQMgBkF/aiIGDQALC0GciQEQASAFQf8AcyEDQQAhBSADIAFPDQADQCAAIAJqEAEgAkH/AGohAyACQcAAaiIEIQIgAyABSQ0ACyAEIQILAkAgASACRg0AIAEgAmshCSAAIAJqIQIgBUGciQFqIQNBACEEA0AgAyACLQAAOgAAIAJBAWohAiADQQFqIQMgCSAEQQFqIgRB/wFxSw0ACwsLCQBBgAkgABADC6YDAQJ/IwBBEGsiACQAIABBgAE6AAcgAEEAKAKYiQEiAUEYdCABQYD+A3FBCHRyIAFBCHZBgP4DcSABQRh2cnI2AAggAEEAKAKUiQEiAUEYdCABQYD+A3FBCHRyIAFBCHZBgP4DcSABQRh2cnI2AAwgAEEHakEBEAMCQEEAKAKUiQFB+ANxQcADRg0AA0AgAEEAOgAHIABBB2pBARADQQAoApSJAUH4A3FBwANHDQALCyAAQQhqQQgQA0EAQQAoAoCJASIBQRh0IAFBgP4DcUEIdHIgAUEIdkGA/gNxIAFBGHZycjYCgAlBAEEAKAKEiQEiAUEYdCABQYD+A3FBCHRyIAFBCHZBgP4DcSABQRh2cnI2AoQJQQBBACgCiIkBIgFBGHQgAUGA/gNxQQh0ciABQQh2QYD+A3EgAUEYdnJyNgKICUEAQQAoAoyJASIBQRh0IAFBgP4DcUEIdHIgAUEIdkGA/gNxIAFBGHZycjYCjAlBAEEAKAKQiQEiAUEYdCABQYD+A3FBCHRyIAFBCHZBgP4DcSABQRh2cnI2ApAJIABBEGokAAsGAEGAiQELQwBBAEL+uevF6Y6VmRA3AoiJAUEAQoHGlLqW8ermbzcCgIkBQQBC8MPLngw3ApCJAUEAQQA2ApiJAUGACSAAEAMQBQsLCwEAQYAICwRcAAAA",
        hash: "6b530c24",
      };
      new Wr();
      new Wr();
      new Wr();
      var fi = {
        name: "sha256",
        data: "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c2pBx6KerX1qIhkgASADcyACcSABIANxcyABQR53IAFBE3dzIAFBCndzaiAaaiICaiIJIBMgEnNxIBJzaiAJQRp3IAlBFXdzIAlBB3dzakHRxqk2aiIaIAIgAXMgA3EgAiABcXMgAkEedyACQRN3cyACQQp3c2ogGGoiA2oiESAJIBNzcSATc2ogEUEadyARQRV3cyARQQd3c2pB59KkoQFqIhggAyACcyABcSADIAJxcyADQR53IANBE3dzIANBCndzaiAUaiIBaiISIBEgCXNxIAlzaiASQRp3IBJBFXdzIBJBB3dzakGFldy9AmoiFCABIANzIAJxIAEgA3FzIAFBHncgAUETd3MgAUEKd3NqIBdqIgJqIhMgI2ogJiASaiAiIBFqICUgCWogEyASIBFzcSARc2ogE0EadyATQRV3cyATQQd3c2pBuMLs8AJqIhcgAiABcyADcSACIAFxcyACQR53IAJBE3dzIAJBCndzaiAZaiIDaiIJIBMgEnNxIBJzaiAJQRp3IAlBFXdzIAlBB3dzakH827HpBGoiGSADIAJzIAFxIAMgAnFzIANBHncgA0ETd3MgA0EKd3NqIBpqIgFqIhEgCSATc3EgE3NqIBFBGncgEUEVd3MgEUEHd3NqQZOa4JkFaiIaIAEgA3MgAnEgASADcXMgAUEedyABQRN3cyABQQp3c2ogGGoiAmoiEiARIAlzcSAJc2ogEkEadyASQRV3cyASQQd3c2pB1OapqAZqIhggAiABcyADcSACIAFxcyACQR53IAJBE3dzIAJBCndzaiAUaiIDaiITaiAoIBJqICQgEWogJyAJaiATIBIgEXNxIBFzaiATQRp3IBNBFXdzIBNBB3dzakG7laizB2oiFCADIAJzIAFxIAMgAnFzIANBHncgA0ETd3MgA0EKd3NqIBdqIgFqIgkgEyASc3EgEnNqIAlBGncgCUEVd3MgCUEHd3NqQa6Si454aiIXIAEgA3MgAnEgASADcXMgAUEedyABQRN3cyABQQp3c2ogGWoiAmoiESAJIBNzcSATc2ogEUEadyARQRV3cyARQQd3c2pBhdnIk3lqIhkgAiABcyADcSACIAFxcyACQR53IAJBE3dzIAJBCndzaiAaaiIDaiISIBEgCXNxIAlzaiASQRp3IBJBFXdzIBJBB3dzakGh0f+VemoiGiADIAJz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",
        hash: "64f06674",
      };
      new Wr();
      new Wr();
      function gi() {
        return di(fi, 32).then((e) => {
          e.init(256);
          const t = {
            init: () => (e.init(256), t),
            update: (r) => (e.update(r), t),
            digest: (t) => e.digest(t),
            save: () => e.save(),
            load: (r) => (e.load(r), t),
            blockSize: 64,
            digestSize: 32,
          };
          return t;
        });
      }
      new Wr();
      new Wr();
      new Wr();
      new Wr();
      new ArrayBuffer(8);
      new Wr();
      new ArrayBuffer(8);
      new Wr();
      new ArrayBuffer(8);
      new Wr();
      new Wr();
      new Wr();
      function mi(e) {
        let t;
        t =
          "string" == typeof e
            ? e
            : e && e.length
            ? e.reduce((e, t) => (e += String.fromCharCode(t)), "")
            : e
            ? e.toString()
            : "";
        try {
          return "__wb_post_data=" + btoa(t);
        } catch {
          return "__wb_post_data=";
        }
      }
      function yi(e) {
        return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
      function Ai(e) {
        try {
          if (!e.startsWith("https:") && !e.startsWith("http:")) return e;
          let t = (e = e.replace(/^(https?:\/\/)www\d*\./, "$1")).toLowerCase(),
            r = new URL(t),
            i = r.hostname.split(".").reverse().join(",");
          if (
            (r.port && (i += ":" + r.port),
            (i += ")"),
            (i += r.pathname),
            r.search)
          ) {
            r.searchParams.sort(), (i += r.search);
            for (let [e, s] of r.searchParams.entries())
              if (!s) {
                let r = new RegExp(`(?<=[&?])${yi(e)}=(?=&|$)`);
                r.exec(t) || (i = i.replace(r, e));
              }
          }
          return i;
        } catch {
          return e;
        }
      }
      function wi(e) {
        let { method: t, headers: r, postData: i } = e;
        if ("GET" === t) return !1;
        function s(e) {
          return e instanceof Uint8Array && (e = new TextDecoder().decode(e)), e;
        }
        let n = "";
        switch ((r.get("content-type") || "").split(";")[0]) {
          case "application/x-www-form-urlencoded":
            n = s(i);
            break;
          case "application/json":
            n = vi(s(i));
            break;
          case "text/plain":
            try {
              n = vi(s(i), !1);
            } catch {
              n = mi(i);
            }
            break;
          case "multipart/form-data": {
            let e = r.get("content-type");
            if (!e)
              throw new Error(
                "utils cannot call postToGetURL when missing content-type header"
              );
            n = (function (e, t) {
              return (function (e, t) {
                let r = new URLSearchParams();
                e instanceof Uint8Array && (e = new TextDecoder().decode(e));
                try {
                  let i = t.split("boundary=")[1],
                    s = e.split(new RegExp("-*" + i + "-*", "mi"));
                  for (let e of s) {
                    let t = e.trim().match(/name="([^"]+)"\r\n\r\n(.*)/im);
                    t && r.set(t[1], t[2]);
                  }
                } catch {}
                return r;
              })(e, t).toString();
            })(s(i), e);
            break;
          }
          default:
            n = mi(i);
        }
        return (
          null !== n &&
          ((e.url = Ei(e.url, n, e.method)),
          (e.method = "GET"),
          (e.requestBody = n),
          !0)
        );
      }
      function Ei(e, t, r) {
        if (!r) return e;
        let i = e.indexOf("?") > 0 ? "&" : "?";
        return `${e}${i}__wb_method=${r}&${t}`;
      }
      function bi(e, t = !0) {
        if ("string" == typeof e)
          try {
            e = JSON.parse(e);
          } catch {
            e = {};
          }
        let r = new URLSearchParams(),
          i = {};
        try {
          JSON.stringify(
            e,
            (e, t) => (
              ["object", "function"].includes(typeof t) ||
                r.set(
                  ((e) =>
                    r.has(e)
                      ? (e in i || (i[e] = 1), e + "." + ++i[e] + "_")
                      : e)(e),
                  t
                ),
              t
            )
          );
        } catch (e) {
          if (!t) throw e;
        }
        return r;
      }
      function vi(e, t = !0) {
        return bi(e, t).toString();
      }
      function Ii(e, t) {
        if (1 === e.length) return e[0];
        let r = new Uint8Array(t),
          i = 0;
        for (let t of e) r.set(t, i), (i += t.byteLength);
        return r;
      }
      function Si(e, t) {
        return [e.slice(0, t), e.slice(t)];
      }
      var Ti = new TextDecoder("utf-8"),
        _i = class extends zr.Inflate {
          constructor(e, t) {
            super(e), (this.ended = !1), (this.chunks = []), (this.reader = t);
          }
          onEnd(e) {
            (this.err = e),
              this.err || (this.reader._rawOffset += this.strm.total_in);
          }
        },
        Ci = class e {
          static async readFully(e) {
            let t = [],
              r = 0;
            for await (let i of e) t.push(i), (r += i.byteLength);
            return Ii(t, r);
          }
          getReadableStream() {
            let e = this[Symbol.asyncIterator]();
            return new ReadableStream({
              pull: (t) =>
                e.next().then((e) => {
                  e.done || !e.value ? t.close() : t.enqueue(e.value);
                }),
            });
          }
          async readFully() {
            return await e.readFully(this);
          }
          async readline(e = 0) {
            let t = await this.readlineRaw(e);
            return t ? Ti.decode(t) : "";
          }
          async *iterLines(e = 0) {
            let t = null;
            for (; (t = await this.readline(e)); ) yield t;
          }
        };
      var xi = class e extends Ci {
          constructor(t, r = "gzip", i = !1) {
            let s;
            if (
              (super(),
              (this.compressed = r),
              (this.opts = { raw: "deflateRaw" === r }),
              (this.inflator = r ? new _i(this.opts, this) : null),
              (function (e) {
                return e && Symbol.asyncIterator in Object(e);
              })(t))
            )
              s = t;
            else if (
              "object" == typeof t &&
              "read" in t &&
              "function" == typeof t.read
            )
              s = e.fromReadable(t);
            else if (t instanceof ReadableStream)
              s = e.fromReadable(t.getReader());
            else {
              if (
                !(function (e) {
                  return e && Symbol.iterator in Object(e);
                })(t)
              )
                throw new TypeError("Invalid Stream Source");
              s = e.fromIter(t);
            }
            (this._sourceIter = i ? this.dechunk(s) : s[Symbol.asyncIterator]()),
              (this.lastValue = null),
              (this.errored = !1),
              (this._savedChunk = null),
              (this._rawOffset = 0),
              (this._readOffset = 0),
              (this.numChunks = 0);
          }
          async _loadNext() {
            let e = await this._sourceIter.next();
            return e.done ? null : e.value;
          }
          async *dechunk(t) {
            let r = t instanceof e ? t : new e(t, null),
              i = -1,
              s = !0;
            for (; 0 != i; ) {
              let e = await r.readlineRaw(64),
                t = new Uint8Array();
              if (((i = e ? parseInt(Ti.decode(e), 16) : 0), !i || i > 2 ** 32)) {
                if (Number.isNaN(i) || i > 2 ** 32) {
                  s || (this.errored = !0), yield e;
                  break;
                }
              } else if (((t = await r.readSize(i)), t.length != i)) {
                s ? yield e : (this.errored = !0), yield t;
                break;
              }
              let n = await r.readSize(2);
              if (13 != n[0] || 10 != n[1]) {
                s ? yield e : (this.errored = !0), yield t, yield n;
                break;
              }
              if (((s = !1), !t || 0 === i)) return;
              yield t;
            }
            yield* r;
          }
          unread(e) {
            e.length &&
              ((this._readOffset -= e.length),
              this._savedChunk && console.log("Already have chunk!"),
              (this._savedChunk = e));
          }
          async _next() {
            if (this._savedChunk) {
              let e = this._savedChunk;
              return (this._savedChunk = null), e;
            }
            if (this.compressed) {
              let e = this._getNextChunk();
              if (e) return e;
            }
            let e = await this._loadNext();
            for (; this.compressed && e; ) {
              this._push(e);
              let t = this._getNextChunk(e);
              if (t) return t;
              e = await this._loadNext();
            }
            return e;
          }
          _push(e) {
            if (!this.inflator)
              throw new Error(
                "AsyncIterReader cannot call _push when this.compressed is null"
              );
            (this.lastValue = e),
              this.inflator.ended && (this.inflator = new _i(this.opts, this)),
              this.inflator.push(e),
              this.inflator.err &&
                this.inflator.ended &&
                "deflate" === this.compressed &&
                !1 === this.opts.raw &&
                0 === this.numChunks &&
                ((this.opts.raw = !0),
                (this.compressed = "deflateRaw"),
                (this.inflator = new _i(this.opts, this)),
                this.inflator.push(e));
          }
          _getNextChunk(e) {
            if (!this.inflator)
              throw new Error(
                "AsyncIterReader cannot call _getNextChunk when this.compressed is null"
              );
            for (;;) {
              if (this.inflator.chunks.length > 0)
                return this.numChunks++, this.inflator.chunks.shift();
              if (this.inflator.ended) {
                if (0 !== this.inflator.err) return (this.compressed = null), e;
                let t = this.inflator.strm.avail_in;
                if (t && this.lastValue) {
                  this._push(this.lastValue.slice(-t));
                  continue;
                }
              }
              return null;
            }
          }
          async *[Symbol.asyncIterator]() {
            let e = null;
            for (; (e = await this._next()); )
              (this._readOffset += e.length), yield e;
          }
          async readlineRaw(e) {
            let t = [],
              r = 0,
              i = -1,
              s = null;
            for await (let n of this) {
              if (e && r + n.byteLength > e) {
                (s = n), (i = e - r - 1);
                let t = n.slice(0, i + 1).indexOf(10);
                t >= 0 && (i = t);
                break;
              }
              if (((i = n.indexOf(10)), i >= 0)) {
                s = n;
                break;
              }
              t.push(n), (r += n.byteLength);
            }
            if (s) {
              let [e, n] = Si(s, i + 1);
              t.push(e), (r += e.byteLength), this.unread(n);
            } else if (!t.length) return null;
            return Ii(t, r);
          }
          async readFully() {
            return (await this._readOrSkip())[1];
          }
          async readSize(e) {
            return (await this._readOrSkip(e))[1];
          }
          async skipSize(e) {
            return (await this._readOrSkip(e, !0))[0];
          }
          async _readOrSkip(e = -1, t = !1) {
            let r = [],
              i = 0;
            for await (let s of this) {
              if (e >= 0) {
                if (s.length > e) {
                  let [n, a] = Si(s, e);
                  t || r.push(n), (i += n.byteLength), this.unread(a);
                  break;
                }
                if (s.length === e) {
                  t || r.push(s), (i += s.byteLength), (e = 0);
                  break;
                }
                e -= s.length;
              }
              t || r.push(s), (i += s.byteLength);
            }
            return t ? [i, new Uint8Array()] : [i, Ii(r, i)];
          }
          getReadOffset() {
            return this._readOffset;
          }
          getRawOffset() {
            return this.compressed ? this._rawOffset : this._readOffset;
          }
          getRawLength(e) {
            return this.compressed
              ? this.inflator.strm.total_in
              : this._readOffset - e;
          }
          static fromReadable(e) {
            return {
              async *[Symbol.asyncIterator]() {
                let t = null;
                for (; (t = await e.read()) && !t.done; ) yield t.value;
              },
            };
          }
          static fromIter(e) {
            return {
              async *[Symbol.asyncIterator]() {
                for (let t of e) yield t;
              },
            };
          }
        },
        Ni = class extends Ci {
          constructor(e, t, r = 0) {
            super(),
              (this.sourceIter = e),
              (this.length = t),
              (this.limit = t),
              (this.skip = r);
          }
          setLimitSkip(e, t = 0) {
            (this.limit = e), (this.skip = t);
          }
          async *[Symbol.asyncIterator]() {
            if (!(this.limit <= 0))
              for await (let e of this.sourceIter) {
                if (this.skip > 0) {
                  if (!(e.length >= this.skip)) {
                    this.skip -= e.length;
                    continue;
                  }
                  {
                    let [, t] = Si(e, this.skip);
                    (e = t), (this.skip = 0);
                  }
                }
                if (e.length > this.limit) {
                  let [t, r] = Si(e, this.limit);
                  (e = t), this.sourceIter.unread && this.sourceIter.unread(r);
                }
                if (
                  (e.length && ((this.limit -= e.length), yield e),
                  this.limit <= 0)
                )
                  break;
              }
          }
          async readlineRaw(e) {
            if (this.limit <= 0) return null;
            let t = await this.sourceIter.readlineRaw(
              e ? Math.min(e, this.limit) : this.limit
            );
            return (this.limit -= t?.length || 0), t;
          }
          async skipFully() {
            let e = this.limit;
            for (; this.limit > 0; )
              this.limit -= await this.sourceIter.skipSize(this.limit);
            return e;
          }
        },
        ki = new Uint8Array([13, 10]),
        Ri = new Uint8Array([13, 10, 13, 10]),
        Bi = new TextDecoder("utf-8"),
        Di = class {
          constructor({ statusline: e, headers: t }) {
            (this.statusline = e), (this.headers = t);
          }
          toString() {
            let e = [this.statusline];
            for (let [t, r] of this.headers) e.push(`${t}: ${r}`);
            return e.join("\r\n") + "\r\n";
          }
          async *iterSerialize(e) {
            yield e.encode(this.statusline), yield ki;
            for (let [t, r] of this.headers) yield e.encode(`${t}: ${r}\r\n`);
          }
          _parseResponseStatusLine() {
            let e = (function (e, t, r) {
              let i = e.split(t),
                s = i.slice(0, r);
              return i.slice(r).length > 0 && s.push(i.slice(r).join(t)), s;
            })(this.statusline, " ", 2);
            (this._protocol = e[0] ?? ""),
              (this._statusCode = e.length > 1 ? Number(e[1]) : ""),
              (this._statusText = e.length > 2 ? e[2] : "");
          }
          get statusCode() {
            return (
              void 0 === this._statusCode && this._parseResponseStatusLine(),
              this._statusCode
            );
          }
          get protocol() {
            return (
              void 0 === this._protocol && this._parseResponseStatusLine(),
              this._protocol
            );
          }
          get statusText() {
            return (
              void 0 === this._statusText && this._parseResponseStatusLine(),
              this._statusText
            );
          }
          _parseRequestStatusLine() {
            let e = this.statusline.split(" ", 2);
            (this._method = e[0] ?? ""),
              (this._requestPath = e.length > 1 ? e[1] : "");
          }
          get method() {
            return (
              void 0 === this._method && this._parseRequestStatusLine(),
              this._method
            );
          }
          get requestPath() {
            return (
              void 0 === this._requestPath && this._parseRequestStatusLine(),
              this._requestPath
            );
          }
        },
        Oi = class {
          async parse(
            e,
            { headersClass: t, firstLine: r } = { headersClass: Map }
          ) {
            let i = r || (await e.readline());
            if (!i) return null;
            let s = i.trimEnd();
            if (!s) return null;
            let n,
              a,
              o,
              c,
              l = new t(),
              h = l instanceof Headers,
              u = await (async function (e) {
                let t = [],
                  r = 0,
                  i = 0,
                  s = null,
                  n = e[Symbol.asyncIterator]();
                for await (let e of n) {
                  if ((([i, e] = await Li(e, n)), i >= 0)) {
                    s = e;
                    break;
                  }
                  t.push(e), (r += e.byteLength);
                }
                if (s) {
                  let [n, a] = Si(s, i + 1);
                  t.push(n), (r += n.byteLength), e.unread(a);
                } else if (!t.length) return "";
                return Bi.decode(Ii(t, r));
              })(e),
              d = 0,
              p = "";
            for (; d < u.length; ) {
              if (
                ((o = u.indexOf("\n", d)), !c || (" " !== u[d] && "\t" !== u[d]))
              ) {
                if (c) {
                  try {
                    h && "set-cookie" === p.toLowerCase()
                      ? l.append(p, c)
                      : l.set(p, c);
                  } catch {}
                  c = null;
                }
                (n = u.indexOf(":", d)),
                  (a = n < 0 ? d : n + 1),
                  n >= 0 && n < o
                    ? ((p = u.slice(d, n).trimStart()),
                      (c = u.slice(a, o < 0 ? void 0 : o).trim()))
                    : (c = null);
              } else c += u.slice(d, o < 0 ? void 0 : o).trimEnd();
              if (o < 0) break;
              d = o + 1;
            }
            if (c)
              try {
                h && "set-cookie" === p.toLowerCase()
                  ? l.append(p, c)
                  : l.set(p, c);
              } catch {}
            return new Di({ statusline: s, headers: l });
          }
        };
      async function Li(e, t) {
        let r = 0;
        for (let i = 0; i < e.length - 4; i++) {
          let i = e.indexOf(13, r);
          if (i < 0) break;
          if (i + 3 >= e.length) {
            let { value: r } = await t.next();
            if (!r) break;
            let i = new Uint8Array(r.length + e.length);
            i.set(e, 0), i.set(r, e.length), (e = i);
          }
          if (10 === e[i + 1] && 13 === e[i + 2] && 10 === e[i + 3])
            return [i + 3, e];
          r = i + 1;
        }
        return [-1, e];
      }
      var Pi = new TextDecoder("utf-8"),
        Ui = new TextEncoder(),
        Mi = "WARC/1.0",
        Fi = {
          warcinfo: "application/warc-fields",
          response: "application/http; msgtype=response",
          revisit: "application/http; msgtype=response",
          request: "application/http; msgtype=request",
          metadata: "application/warc-fields",
        },
        Hi = class e extends Ci {
          constructor({ warcHeaders: e, reader: t }) {
            super(),
              (this._offset = 0),
              (this._length = 0),
              (this.method = ""),
              (this.requestBody = ""),
              (this._urlkey = ""),
              (this.warcHeaders = e),
              (this._reader = t),
              (this._contentReader = null),
              (this.payload = null),
              (this.httpHeaders = null),
              (this.consumed = ""),
              this.fixUp();
          }
          static create(
            {
              url: t,
              date: r,
              type: i,
              warcHeaders: s = {},
              filename: n = "",
              httpHeaders: a = {},
              statusline: o = "HTTP/1.1 200 OK",
              warcVersion: c = Mi,
              keepHeadersCase: l = !0,
              refersToUrl: h,
              refersToDate: u,
            } = {},
            d
          ) {
            function p(e) {
              let t = e;
              return (
                c === Mi &&
                  "Z" != (e = e.split(".")[0]).charAt(t.length - 1) &&
                  (e += "Z"),
                e
              );
            }
            (r = p(r || new Date().toISOString())),
              (s = { ...s }),
              "warcinfo" === i
                ? n && (s["WARC-Filename"] = n)
                : t && (s["WARC-Target-URI"] = t),
              (s["WARC-Date"] = r),
              i && (s["WARC-Type"] = i),
              "revisit" === i &&
                ((s["WARC-Profile"] =
                  "WARC/1.1" === c
                    ? "http://netpreserve.org/warc/1.1/revisit/identical-payload-digest"
                    : "http://netpreserve.org/warc/1.0/revisit/identical-payload-digest"),
                h &&
                  ((s["WARC-Refers-To-Target-URI"] = h),
                  (s["WARC-Refers-To-Date"] = p(u || new Date().toISOString()))));
            let f = new Di({
              statusline: c,
              headers: new Map(Object.entries(s)),
            });
            f.headers.get("WARC-Record-ID") ||
              f.headers.set("WARC-Record-ID", `<urn:uuid:${qr()}>`),
              f.headers.get("Content-Type") ||
                f.headers.set(
                  "Content-Type",
                  (i && Fi[i]) || "application/octet-stream"
                ),
              d || (d = Qi());
            let g = new e({ warcHeaders: f, reader: d }),
              m = null,
              y = [];
            switch (i) {
              case "response":
              case "request":
              case "revisit":
                (y = Object.entries(a)),
                  (m = l ? new Map(y) : new Headers(a)),
                  (y.length > 0 || "revisit" !== i) &&
                    (g.httpHeaders = new Di({ statusline: o, headers: m }));
            }
            return g;
          }
          static createWARCInfo(t = {}, r) {
            return (
              (t.type = "warcinfo"),
              e.create(
                t,
                (async function* () {
                  for (let [e, t] of Object.entries(r))
                    yield Ui.encode(`${e}: ${t}\r\n`);
                })()
              )
            );
          }
          getResponseInfo() {
            let e = this.httpHeaders;
            return e
              ? {
                  headers: e.headers,
                  status: e.statusCode,
                  statusText: e.statusText,
                }
              : null;
          }
          fixUp() {
            let e = this.warcHeaders.headers.get("WARC-Target-URI");
            e &&
              e.startsWith("<") &&
              e.endsWith(">") &&
              this.warcHeaders.headers.set("WARC-Target-URI", e.slice(1, -1));
          }
          async readFully(e = !1) {
            if (this.httpHeaders) {
              if (this.payload && !this.payload.length) return this.payload;
              if (this._contentReader && !e)
                throw new TypeError(
                  "WARC Record decoding already started, but requesting raw payload"
                );
              if (e && "raw" === this.consumed && this.payload)
                return await this._createDecodingReader([
                  this.payload,
                ]).readFully();
            }
            return (
              this.payload ||
                (e
                  ? ((this.payload = await super.readFully()),
                    (this.consumed = "content"))
                  : ((this.payload = await Ci.readFully(this._reader)),
                    (this.consumed = "raw"))),
              this.payload
            );
          }
          get reader() {
            if (this.payload && !this.payload.length) return Qi();
            if (this._contentReader)
              throw new TypeError(
                "WARC Record decoding already started, but requesting raw payload"
              );
            return this._reader;
          }
          get contentReader() {
            return this.httpHeaders
              ? (this._contentReader ||
                  (this._contentReader = this._createDecodingReader(
                    this._reader
                  )),
                this._contentReader)
              : this._reader;
          }
          _createDecodingReader(e) {
            if (!this.httpHeaders)
              throw new Error(
                "WARCRecord cannot call _createDecodingReader when this.httpHeaders === null"
              );
            let t = this.httpHeaders.headers.get("Content-Encoding"),
              r = this.httpHeaders.headers.get("Transfer-Encoding"),
              i = "chunked" === r;
            return !t && !i && (t = r), new xi(e, t, i);
          }
          async readlineRaw(e) {
            if (this.consumed)
              throw new Error(
                "Record already consumed.. Perhaps a promise was not awaited?"
              );
            if (this.contentReader instanceof Ci)
              return this.contentReader.readlineRaw(e);
            throw new Error(
              "WARCRecord cannot call readlineRaw on this.contentReader if it does not extend BaseAsyncIterReader"
            );
          }
          async contentText() {
            let e = await this.readFully(!0);
            return Pi.decode(e);
          }
          async *[Symbol.asyncIterator]() {
            for await (let e of this.contentReader)
              if ((yield e, this.consumed))
                throw new Error(
                  "Record already consumed.. Perhaps a promise was not awaited?"
                );
            this.consumed = "content";
          }
          async skipFully() {
            if (!this.consumed) {
              if (this._reader instanceof Ni) {
                let e = await this._reader.skipFully();
                return (this.consumed = "skipped"), e;
              }
              throw new Error(
                "WARCRecord cannot call skipFully on this._reader if it is not a LimitReader"
              );
            }
          }
          warcHeader(e) {
            return this.warcHeaders.headers.get(e);
          }
          get warcType() {
            return this.warcHeaders.headers.get("WARC-Type");
          }
          get warcTargetURI() {
            return this.warcHeaders.headers.get("WARC-Target-URI");
          }
          get warcDate() {
            return this.warcHeaders.headers.get("WARC-Date");
          }
          get warcRefersToTargetURI() {
            return this.warcHeaders.headers.get("WARC-Refers-To-Target-URI");
          }
          get warcRefersToDate() {
            return this.warcHeaders.headers.get("WARC-Refers-To-Date");
          }
          get warcPayloadDigest() {
            return this.warcHeaders.headers.get("WARC-Payload-Digest");
          }
          get warcBlockDigest() {
            return this.warcHeaders.headers.get("WARC-Block-Digest");
          }
          get warcContentType() {
            return this.warcHeaders.headers.get("Content-Type");
          }
          get warcContentLength() {
            return Number(this.warcHeaders.headers.get("Content-Length"));
          }
        };
      async function* Qi() {}
      var Vi = new TextDecoder(),
        zi = new Uint8Array([]),
        qi = class e {
          static parse(t, r) {
            return new e(t, r).parse();
          }
          static iterRecords(t, r) {
            return new e(t, r)[Symbol.asyncIterator]();
          }
          constructor(e, { keepHeadersCase: t = !1, parseHttp: r = !0 } = {}) {
            (this._offset = 0),
              (this._warcHeadersLength = 0),
              (this._headersClass = t ? Map : Headers),
              (this._parseHttp = r),
              (this._reader = e instanceof xi ? e : new xi(e)),
              (this._record = null);
          }
          async readToNextRecord() {
            if (!this._reader || !this._record) return zi;
            await this._record.skipFully(),
              this._reader.compressed &&
                (this._offset = this._reader.getRawOffset());
            let e = await this._reader.readlineRaw(),
              t = 0;
            if (e) {
              if (
                ((t = e.byteLength - 1),
                9 === t && Vi.decode(e).startsWith("WARC/"))
              )
                return e;
              for (; t > 0; ) {
                let r = e[t - 1];
                if (10 !== r && 13 !== r) break;
                t--;
              }
              t &&
                console.warn(
                  `Content-Length Too Small: Record not followed by newline, Remainder Length: ${t}, Offset: ${
                    this._reader.getRawOffset() - e.byteLength
                  }`
                );
            } else e = zi;
            if (this._reader.compressed) await this._reader.skipSize(2), (e = zi);
            else {
              for (
                e = await this._reader.readlineRaw();
                e && 2 === e.byteLength;
  
              )
                e = await this._reader.readlineRaw();
              (this._offset = this._reader.getRawOffset()),
                e && (this._offset -= e.length);
            }
            return e;
          }
          _initRecordReader(e) {
            return new Ni(
              this._reader,
              Number(e.headers.get("Content-Length") || 0)
            );
          }
          async parse() {
            let e = await this.readToNextRecord(),
              t = e ? Vi.decode(e) : "",
              r = new Oi(),
              i = await r.parse(this._reader, {
                firstLine: t,
                headersClass: this._headersClass,
              });
            if (!i) return null;
            this._warcHeadersLength = this._reader.getReadOffset();
            let s = new Hi({ warcHeaders: i, reader: this._initRecordReader(i) });
            if (((this._record = s), this._parseHttp))
              switch (s.warcType) {
                case "response":
                case "request":
                  await this._addHttpHeaders(s, r);
                  break;
                case "revisit":
                  s.warcContentLength > 0 && (await this._addHttpHeaders(s, r));
              }
            return s;
          }
          get offset() {
            return this._offset;
          }
          get recordLength() {
            return this._reader.getRawLength(this._offset);
          }
          async *[Symbol.asyncIterator]() {
            let e = null;
            for (; null !== (e = await this.parse()); ) yield e;
            this._record = null;
          }
          async _addHttpHeaders(e, t) {
            let r = await t.parse(this._reader, {
              headersClass: this._headersClass,
            });
            e.httpHeaders = r;
            let i = this._reader.getReadOffset() - this._warcHeadersLength;
            e.reader instanceof Ni &&
              e.reader.setLimitSkip(e.warcContentLength - i);
          }
        },
        Gi = new TextEncoder(),
        ji = class {},
        Wi = class extends ji {
          constructor() {
            super(...arguments), (this.buffers = []);
          }
          write(e) {
            this.buffers.push(e);
          }
          async *readAll() {
            for (let e of this.buffers) yield e;
          }
        },
        Yi = (Symbol.asyncIterator, ["offset", "warc-type", "warc-target-uri"]),
        Xi = class {
          constructor(e = {}) {
            (this.opts = e),
              (this.fields = e && e.fields ? e.fields.split(",") : Yi),
              (this.parseHttp = !1);
          }
          serialize(e) {
            return JSON.stringify(e) + "\n";
          }
          write(e, t) {
            t.write(this.serialize(e));
          }
          async writeAll(e, t) {
            for await (let r of this.iterIndex(e)) this.write(r, t);
          }
          async *iterIndex(e) {
            let t = { strictHeaders: !0, parseHttp: this.parseHttp };
            for (let { filename: r, reader: i } of e) {
              let e = new qi(i, t);
              yield* this.iterRecords(e, r);
            }
          }
          async *iterRecords(e, t) {
            for await (let r of e) {
              await r.skipFully();
              let i = this.indexRecord(r, e, t);
              i && (yield i);
            }
          }
          indexRecord(e, t, r) {
            if (this.filterRecord && !this.filterRecord(e)) return null;
            let i = {},
              { offset: s, recordLength: n } = t,
              a = { offset: s, length: n, filename: r };
            for (let t of this.fields)
              t in a ? (i[t] = a[t]) : this.setField(t, e, i);
            return i;
          }
          setField(e, t, r) {
            let i = this.getField(e, t);
            null !== i && (r[e] = i);
          }
          getField(e, t) {
            if ("http:status" === e)
              return !t.httpHeaders ||
                ("response" !== t.warcType && "revisit" !== t.warcType)
                ? null
                : t.httpHeaders.statusCode;
            if (e.startsWith("http:")) {
              if (t.httpHeaders) {
                let r = t.httpHeaders.headers;
                return (
                  r instanceof Map && (r = new Headers(Object.fromEntries(r))),
                  r.get(e.slice(5))
                );
              }
              return null;
            }
            return t.warcHeaders.headers.get(e) || null;
          }
        },
        Ki = class extends Xi {
          constructor(e) {
            super(e);
            for (let e of this.fields)
              if (e.startsWith("http:")) {
                this.parseHttp = !0;
                break;
              }
          }
        },
        Ji =
          "urlkey,timestamp,url,mime,status,digest,length,offset,filename".split(
            ","
          ),
        Zi =
          "urlkey,timestamp,url,mime,status,digest,redirect,meta,length,offset,filename".split(
            ","
          ),
        $i = class extends Ki {
          constructor(e) {
            switch (
              (super(e),
              (this.includeAll = !!e?.all),
              (this.overrideIndexForAll = !!e?.all),
              (this.fields = Ji),
              (this.parseHttp = !0),
              (this.noSurt = !!e?.noSurt),
              (this._lastRecord = null),
              e?.format)
            ) {
              case "cdxj":
                this.serialize = this.serializeCDXJ;
                break;
              case "cdx":
                this.serialize = this.serializeCDX11;
            }
          }
          async *iterRecords(e, t) {
            this._lastRecord = null;
            for await (let r of e) {
              await r.readFully();
              let i = this.indexRecord(r, e, t);
              i && (yield i);
            }
            let r = this.indexRecord(null, e, t);
            r && (yield r);
          }
          filterRecord(e) {
            if (this.includeAll) return !0;
            let t = e.warcType;
            return !(
              "request" === t ||
              "warcinfo" === t ||
              (("metadata" === t || "resource" === t) &&
                "application/warc-fields" === e.warcContentType)
            );
          }
          indexRecord(e, t, r) {
            if (this.overrideIndexForAll)
              return e ? super.indexRecord(e, t, r) : null;
            let i = this._lastRecord;
            if (
              ((this._lastRecord = e),
              e && ((e._offset = t.offset), (e._length = t.recordLength)),
              !i)
            )
              return null;
            if (!e || i.warcTargetURI != e.warcTargetURI)
              return this.indexRecordPair(i, null, t, r);
            let s = e.warcType,
              n = i.warcType;
            return "request" !== s || ("response" !== n && "revisit" !== n)
              ? ("response" !== s && "revisit" !== s) || "request" !== n
                ? this.indexRecordPair(i, null, t, r)
                : ((this._lastRecord = null), this.indexRecordPair(e, i, t, r))
              : ((this._lastRecord = null), this.indexRecordPair(i, e, t, r));
          }
          indexRecordPair(e, t, r, i) {
            let s,
              n,
              a = e.warcTargetURI || "";
            if (t && t.httpHeaders && "GET" !== t.httpHeaders.method) {
              let r = {
                url: a,
                method: t.httpHeaders.method,
                headers: t.httpHeaders.headers,
                postData: t.payload,
              };
              (s = r.method),
                wi(r) &&
                  ((n = r.requestBody),
                  (e.method = s),
                  (e.requestBody = n),
                  (a = r.url));
            }
            e._urlkey = a;
            let o = super.indexRecord(e, r, i);
            return (
              o &&
                (e &&
                  void 0 !== e._offset &&
                  ((o.offset = e._offset), (o.length = e._length)),
                s && (o.method = s),
                n && (o.requestBody = n)),
              o
            );
          }
          serializeCDXJ(e) {
            let { urlkey: t, timestamp: r } = e;
            return (
              delete e.urlkey,
              delete e.timestamp,
              `${t} ${r} ${JSON.stringify(e)}\n`
            );
          }
          serializeCDX11(e) {
            let t = [];
            for (let r of Zi) t.push(null != e[r] ? e[r] : "-");
            return t.join(" ") + "\n";
          }
          getField(e, t) {
            let r = null;
            switch (e) {
              case "urlkey":
                return (
                  (r = t._urlkey || t.warcTargetURI || null),
                  this.noSurt || null === r ? r : Ai(r)
                );
              case "timestamp":
                return (
                  (r = t.warcDate ?? ""), r.replace(/[-:T]/g, "").slice(0, 14)
                );
              case "url":
                return t.warcTargetURI;
              case "mime":
                switch (t.warcType) {
                  case "revisit":
                    return "warc/revisit";
                  case "response":
                  case "request":
                    e = "http:content-type";
                    break;
                  default:
                    e = "content-type";
                }
                return (
                  (r = super.getField(e, t)),
                  r ? r.toString().split(";", 1)[0]?.trim() : null
                );
              case "status":
                return super.getField("http:status", t);
              case "digest":
                return (r = t.warcPayloadDigest), r ? r.split(":", 2)[1] : null;
              default:
                return null;
            }
          }
        },
        es = {
          202: "Accepted",
          502: "Bad Gateway",
          400: "Bad Request",
          409: "Conflict",
          100: "Continue",
          201: "Created",
          417: "Expectation Failed",
          424: "Failed Dependency",
          403: "Forbidden",
          504: "Gateway Timeout",
          410: "Gone",
          505: "HTTP Version Not Supported",
          418: "I'm a teapot",
          419: "Insufficient Space on Resource",
          507: "Insufficient Storage",
          500: "Internal Server Error",
          411: "Length Required",
          423: "Locked",
          420: "Method Failure",
          405: "Method Not Allowed",
          301: "Moved Permanently",
          302: "Moved Temporarily",
          207: "Multi-Status",
          300: "Multiple Choices",
          511: "Network Authentication Required",
          204: "No Content",
          203: "Non Authoritative Information",
          406: "Not Acceptable",
          404: "Not Found",
          501: "Not Implemented",
          304: "Not Modified",
          200: "OK",
          206: "Partial Content",
          402: "Payment Required",
          308: "Permanent Redirect",
          412: "Precondition Failed",
          428: "Precondition Required",
          102: "Processing",
          103: "Early Hints",
          426: "Upgrade Required",
          407: "Proxy Authentication Required",
          431: "Request Header Fields Too Large",
          408: "Request Timeout",
          413: "Request Entity Too Large",
          414: "Request-URI Too Long",
          416: "Requested Range Not Satisfiable",
          205: "Reset Content",
          303: "See Other",
          503: "Service Unavailable",
          101: "Switching Protocols",
          307: "Temporary Redirect",
          429: "Too Many Requests",
          401: "Unauthorized",
          451: "Unavailable For Legal Reasons",
          422: "Unprocessable Entity",
          415: "Unsupported Media Type",
          305: "Use Proxy",
          421: "Misdirected Request",
        };
      function ts(e) {
        var t = es[e.toString()];
        if (!t) throw new Error("Status code does not exist: " + e);
        return t;
      }
      const rs = 262144;
      function is(e) {
        return e.replace(/[-:T]/g, "").slice(0, 14);
      }
      function ss(e) {
        if (!e) return new Date();
        e.length < 17 && (e += "00000101000000000".substr(e.length));
        const t =
          e.substring(0, 4) +
          "-" +
          e.substring(4, 6) +
          "-" +
          e.substring(6, 8) +
          "T" +
          e.substring(8, 10) +
          ":" +
          e.substring(10, 12) +
          ":" +
          e.substring(12, 14) +
          "." +
          e.substring(14) +
          "Z";
        return new Date(t);
      }
      function ns(e) {
        return Array.from(new Uint8Array(e))
          .map((e) => e.toString(16).padStart(2, "0"))
          .join("");
      }
      async function as(e, t, r = null) {
        const i = "string" == typeof e ? new TextEncoder().encode(e) : e,
          s = await crypto.subtle.digest(t, i);
        return "" === r ? ns(s) : (r || t) + ":" + ns(s);
      }
      function os(e) {
        let t = "";
        for (let r = 0; r < e.length; r++) t += String.fromCharCode(e[r]);
        return t;
      }
      function cs() {
        return (
          Math.random().toString(36).substring(2, 15) +
          Math.random().toString(36).substring(2, 15)
        );
      }
      function ls(e) {
        try {
          return new Headers(e);
        } catch (t) {
          for (let t of Object.keys(e)) {
            const r = e[t],
              i = r.replace(/[\r\n]+/g, ", ");
            r != i && (e[t] = i);
          }
          return new Headers(e);
        }
      }
      const hs = [101, 204, 205, 304];
      function us(e) {
        return hs.includes(e);
      }
      function ds(e) {
        try {
          return ts(e);
        } catch (e) {
          return "Unknown Status";
        }
      }
      async function ps(e, t) {
        if (e instanceof gs) {
          const r = await self.clients.matchAll({ type: "window" });
          for (const i of r) {
            new URL(i.url).searchParams.get("source") === t.sourceUrl &&
              i.postMessage({
                source: t.sourceUrl,
                coll: t.dbname.slice(3),
                type: "authneeded",
                fileHandle: e.info && e.info.fileHandle,
              });
          }
          return !0;
        }
        return !1;
      }
      class fs {
        constructor(e = {}) {
          this.info = e;
        }
        toString() {
          return JSON.stringify(this.info);
        }
      }
      class gs extends fs {}
      class ms extends fs {}
      class ys {}
      function As(e) {
        return new Promise((t) => setTimeout(t, e));
      }
      var ws = r(8287);
      const Es = new TextEncoder(),
        bs = new TextDecoder();
      class vs {
        static fromResponse({
          url: e,
          response: t,
          date: r,
          noRW: i,
          isLive: s,
          archivePrefix: n,
        }) {
          const a = t.body ? new xi(t.body.getReader(), !1) : null,
            o = Number(t.headers.get("x-redirect-status") || t.status),
            c = t.headers.get("x-redirect-statusText") || t.statusText;
          let l = new Headers(t.headers),
            h = l.get("x-orig-location");
          if (h) {
            if (
              (h.startsWith(self.location.origin) &&
                (h = h.slice(self.location.origin.length)),
              n && h.startsWith(n))
            ) {
              const e = h.indexOf("/http");
              e > 0 && (h = h.slice(e + 1));
            }
            l.set("location", h),
              l.delete("x-orig-location"),
              l.delete("x-redirect-status"),
              l.delete("x-redirect-statusText");
          }
          let u = null;
          const d = l.get("x-orig-ts");
          d && ((r = ss(d)), l.delete("x-orig-ts"), d && h && (u = d));
          const p = l.get("memento-datetime");
          p && (r = new Date(p));
          const f = l.get("x-proxy-set-cookie");
          if (f) {
            const e = [];
            f.split(",").forEach((t) => {
              const r = t.split(";", 1)[0].trim();
              r.indexOf("=") > 0 && e.push(r);
            }),
              l.delete("x-proxy-set-cookie"),
              e.length && l.set("x-wabac-preset-cookie", e.join(";"));
          }
          return new vs({
            payload: a,
            status: o,
            statusText: c,
            headers: l,
            url: e,
            date: r,
            noRW: i,
            isLive: s,
            updateTS: u,
          });
        }
        constructor({
          payload: e,
          status: t,
          statusText: r,
          headers: i,
          url: s,
          date: n,
          extraOpts: a = null,
          noRW: o = !1,
          isLive: c = !1,
          updateTS: l = null,
        }) {
          (this.reader = null),
            (this.buffer = null),
            e && (e[Symbol.asyncIterator] || e instanceof Ci)
              ? (this.reader = e)
              : (this.buffer = e),
            (this.status = t),
            (this.statusText = r),
            (this.headers = i),
            (this.url = s),
            (this.date = n),
            (this.extraOpts = a),
            (this.noRW = o),
            (this.isLive = c),
            (this.updateTS = l);
        }
        async getText(e = !1) {
          let t = await this.getBuffer();
          return "string" == typeof t
            ? { bomFound: !1, text: t }
            : 239 === t[0] && 187 === t[1] && 191 === t[2]
            ? { bomFound: !0, text: bs.decode(t.slice(3)) }
            : 254 === t[0] && 255 === t[1]
            ? {
                bomFound: !0,
                text: ws.Buffer.from(t.slice(2)).swap16().toString("utf16le"),
              }
            : 255 === t[0] && 254 === t[1]
            ? {
                bomFound: !0,
                text: ws.Buffer.from(t.slice(2)).toString("utf16le"),
              }
            : { bomFound: !1, text: e ? bs.decode(t) : os(t) };
        }
        setText(e, t = !1) {
          this.setBuffer(
            t
              ? Es.encode(e)
              : (function (e) {
                  const t = new Uint8Array(e.length);
                  for (let r = 0; r < e.length; r++) t[r] = 255 & e.charCodeAt(r);
                  return t;
                })(e)
          );
        }
        async getBuffer() {
          return (
            this.buffer || (this.buffer = await this.reader.readFully()),
            this.buffer
          );
        }
        setBuffer(e) {
          (this.buffer = e), (this.reader = null);
        }
        setReader(e) {
          e instanceof Ci
            ? ((this.reader = e), (this.buffer = null))
            : e.getReader &&
              ((this.reader = new xi(e.getReader())), (this.buffer = null));
        }
        expectedLength() {
          return this.buffer
            ? this.buffer.length
            : this.reader && this.reader.reader
            ? this.reader.reader.length
            : void 0;
        }
        createIter() {
          const e = this.buffer,
            t = this.reader;
          return (async function* () {
            if (e)
              for (let t = 0; t < e.length; t += rs) yield e.slice(t, t + rs);
            else t && (yield* t);
          })();
        }
        async *[Symbol.asyncIterator]() {
          yield* this.createIter();
        }
        setRange(e) {
          if (206 === this.status) {
            const e = this.headers.get("Content-Range");
            if (e && !e.startsWith("bytes 0-")) return !1;
          }
          const t = e.match(/^bytes=(\d+)-(\d+)?$/);
          let r = 0;
          if (this.buffer) r = this.buffer.length;
          else if (
            this.reader &&
            ((r = Number(this.headers.get("content-length"))), !r)
          )
            return !1;
          if (!t)
            return (
              (this.status = 416),
              (this.statusText = "Range Not Satisfiable"),
              this.headers.set("Content-Range", `*/${r}`),
              !1
            );
          const i = Number(t[1]),
            s = Number(t[2]) || r - 1;
          if (this.buffer) this.buffer = this.buffer.slice(i, s + 1);
          else if (this.reader) {
            if (!this.reader.setLimitSkip) return !1;
            0 !== i || s !== r - 1
              ? this.reader.setLimitSkip(s - i + 1, i)
              : this.reader.setRangeAll && this.reader.setRangeAll(r);
          }
          return (
            this.headers.set("Content-Range", `bytes ${i}-${s}/${r}`),
            this.headers.set("Content-Length", s - i + 1),
            (this.status = 206),
            (this.statusText = "Partial Content"),
            !0
          );
        }
        makeResponse(e = !1, t = !1) {
          let r = null;
          us(this.status) ||
            (r =
              this.buffer || !this.reader
                ? this.buffer
                : this.reader.getReadableStream());
          const i = new Response(r, {
            status: this.status,
            statusText: this.statusText,
            headers: this.headers,
          });
          return (
            (i.date = this.date),
            e &&
              (i.headers.set("Cross-Origin-Opener-Policy", "same-origin"),
              i.headers.set("Cross-Origin-Embedder-Policy", "require-corp")),
            t && i.headers.set("content-disposition", "inline"),
            i
          );
        }
      }
      new C(
        class extends x {
          constructor(e) {
            super(),
              (this.extraRules = e),
              (this.firstBuff = this.initLocalDecl(It)),
              (this.lastBuff = "\n\n}");
          }
          initLocalDecl(e) {
            const t = "_____WB$wombat$assign$function_____";
            let r = `var ${t} = function(name) {return (self._wb_wombat && self._wb_wombat.local_init && self._wb_wombat.local_init(name)) || self[name]; };\nif (!self.__WB_pmw) { self.__WB_pmw = function(obj) { this.__WB_source = obj; return this; } }\n{\n`;
            for (let i of e) r += `let ${i} = ${t}("${i}");\n`;
            return (r += "let arguments;\n"), r + "\n";
          }
          getModuleDecl(e, t) {
            return `import { ${e.join(", ")} } from "${t}__wb_module_decl.js";\n`;
          }
          detectIsModule(e) {
            return (
              !!(e.indexOf("import") >= 0 && e.match(wt)) ||
              !!(e.indexOf("export") >= 0 && e.match(Et))
            );
          }
          parseGlobals(e) {
            const t = ye.parse(e, { ecmaVersion: "latest" });
            let r = !1;
            const i = [],
              s = new Set();
            for (const e of t.body) {
              const { type: t } = e;
              if ("VariableDeclaration" === t) {
                const { kind: t, declarations: r } = e;
                for (const e of r)
                  if (
                    e &&
                    "VariableDeclarator" === e.type &&
                    e.id &&
                    "Identifier" === e.id.type
                  ) {
                    const r = e.id.name;
                    It.includes(r)
                      ? s.add(r)
                      : ("const" !== t && "let" !== t) ||
                        i.push(`self.${r} = ${r};`);
                  }
              } else if (!r && "ExpressionStatement" === t) {
                const { expression: t } = e;
                if (t && "CallExpression" === t.type) {
                  const { callee: e } = t;
                  if (e && "MemberExpression" === e.type) {
                    const { object: t, property: i } = e;
                    "Identifier" === t.type &&
                      "document" === t.name &&
                      "Identifier" === i.type &&
                      "write" === i.name &&
                      (r = !0);
                  }
                }
              }
            }
            if (s.size) {
              const e = It.filter((e) => !s.has(e));
              this.firstBuff = this.initLocalDecl(e);
            }
            return (
              r && (this.lastBuff = ";document.close();" + this.lastBuff),
              i.length ? "\n" + i.join("\n") : ""
            );
          }
          rewrite(e, t) {
            (void 0 !== (t = t || {}).isModule && null !== t.isModule) ||
              (t.isModule = this.detectIsModule(e, t));
            let r = _t;
            t.isModule && (r = [...r, this.getESMImportRule()]),
              this.extraRules && this.extraRules.length
                ? (this.rules = [...r, ...this.extraRules])
                : (this.rules = r),
              this.compileRules();
            let i = super.rewrite(e, t);
            if (t.isModule) return this.getModuleDecl(It, t.prefix) + i;
            const s = Tt.exec(e);
            if ((t.inline && (i = i.replace(/\n/g, " ")), s)) {
              let e = "";
              if (i)
                try {
                  e = this.parseGlobals(i);
                } catch (e) {
                  console.warn(`acorn parsing failed, script len ${i.length}`);
                }
              (i = this.firstBuff + i + e + this.lastBuff),
                t.inline && (i = i.replace(/\n/g, " "));
            }
            return i;
          }
          getESMImportRule() {
            return [
              bt,
              (e, t) => {
                const r = t.prefix.replace("mp_/", "esm_/");
                return e.replace(vt, (e, i, s, n) => {
                  try {
                    (s = new URL(s, t.baseUrl).href), (s = r + s);
                  } catch (e) {}
                  return i + s + n;
                });
              },
            ];
          }
        }
      );
      const Is = new C(x),
        Ss = new C(x, I);
      function Ts(e, t) {
        return (t ? Ss : Is).getCustomRewriter(e);
      }
      const _s = "content-length",
        Cs = "content-type",
        xs = ["content-encoding", "transfer-encoding"],
        Ns = new TextEncoder();
      class ks {
        constructor(e) {
          (this._created = new Date()),
            (this.requestId = e),
            (this.ts = null),
            (this.method = null),
            (this.url = null),
            (this.protocol = "HTTP/1.1"),
            (this.requestHeaders = null),
            (this.requestHeadersText = null),
            (this.postData = null),
            (this.hasPostData = !1),
            (this.status = 0),
            (this.statusText = null),
            (this.responseHeaders = null),
            (this.responseHeadersList = null),
            (this.responseHeadersText = null),
            (this.payload = null),
            (this.fromServiceWorker = !1),
            (this.fetch = !1),
            (this.resourceType = null),
            (this.extraOpts = {});
        }
        fillRequest(e) {
          (this.url = e.request.url),
            (this.method = e.request.method),
            this.requestHeaders || (this.requestHeaders = e.request.headers),
            (this.postData = e.request.postData),
            (this.hasPostData = e.request.hasPostData),
            e.type && (this.resourceType = e.type);
        }
        fillFetchRequestPaused(e) {
          this.fillRequest(e),
            (this.status = e.responseStatusCode),
            (this.statusText = ds(this.status)),
            (this.responseHeadersList = e.responseHeaders),
            (this.fetch = !0),
            (this.resourceType = e.resourceType);
        }
        fillResponseRedirect(e) {
          this._fillResponse(e.redirectResponse);
        }
        isSelfRedirect() {
          if (this.status < 300 || this.status >= 400 || 304 === this.status)
            return !1;
          try {
            const e = new URL(this.responseHeaders.location, this.url).href;
            return this.url === e;
          } catch (e) {
            return !1;
          }
        }
        fillResponseReceived(e) {
          const t = e.response;
          (304 == t.status && this.status && 304 != this.status && this.url) ||
            ((this.url = t.url.split("#")[0]), this._fillResponse(t));
        }
        _fillResponse(e) {
          if (
            ((this.status = e.status),
            (this.statusText = e.statusText || ds(this.status)),
            (this.protocol = e.protocol),
            e.requestHeaders && (this.requestHeaders = e.requestHeaders),
            e.requestHeadersText &&
              (this.requestHeadersText = e.requestHeadersText),
              // * Changed by jingyz
              // Reason: Directly assigning this.reasponseHeaders as e.headers will eliminate headers exist before
              // One important example is the 'set-cookie' since redirecte won't have the 'set-cookie' again
              (this.responseHeaders = { ...{}, ...e.headers, ...this.responseHeaders}),
              // * End of change
            e.headersText && (this.responseHeadersText = e.headersText),
            (this.fromServiceWorker = !!e.fromServiceWorker),
            e.securityDetails)
          ) {
            const t = e.securityDetails.issuer || "",
              r =
                "compliant" ===
                e.securityDetails.certificateTransparencyCompliance
                  ? "1"
                  : "0";
            this.extraOpts.cert = { issuer: t, ctc: r };
          }
        }
        fillResponseReceivedExtraInfo(e) {
          (this.responseHeaders = e.headers),
            e.headersText && (this.responseHeadersText = e.headersText);
        }
        toDBRecord(e, t) {
          if (
            "OPTIONS" === this.method ||
            "HEAD" === this.method ||
            304 == this.status ||
            206 === this.status
          )
            return null;
          if (
            !this.url ||
            (!this.url.startsWith("https:") && !this.url.startsWith("http:"))
          )
            return;
          if (!t.id)
            return console.log("Skipping No Page Id for: " + this.url), null;
          e || (e = new Uint8Array([])), (this.ts = new Date().getTime());
          const r = this.getResponseHeadersDict(e.length),
            i = this.getRequestHeadersDict(),
            s = (r.headers.get(Cs) || "").split(";")[0],
            n = i.headers.get("cookie");
          n && (r.headersDict["x-wabac-preset-cookie"] = n);
          const a = this.url;
          if (this.method && "GET" !== this.method) {
            const e = {
              url: this.url,
              headers: i.headers,
              method: this.method,
              postData: this.postData || "",
            };
            if (wi(e))
              if (Ts(this.url, "text/html" === s)) this.url = e.url;
              else {
                try {
                  const t = new URL(e.url);
                  for (const [e, r] of t.searchParams.entries())
                    r && r.length > 512 && t.searchParams.set(e, r.slice(0, 512));
                  e.url = t.href;
                } catch (e) {}
                this.url = e.url.slice(0, 4096);
              }
          }
          const o = {
            url: this.url,
            ts: this.ts,
            status: this.status,
            statusText: this.statusText,
            pageId: t.id,
            payload: e,
            mime: s,
            respHeaders: r.headersDict,
            reqHeaders: i.headersDict,
            extraOpts: this.extraOpts,
          };
          return (
            "GET" !== this.method &&
              ((o.method = this.method),
              this.postData &&
                ("string" == typeof this.postData
                  ? (o.requestBody = Ns.encode(this.postData))
                  : (o.requestBody = this.postData),
                (o.requestUrl = a))),
            o
          );
        }
        fillFromDBRecord(e) {
          (this.url = e.url),
            (this.ts = e.ts),
            (this.status = e.status),
            (this.statusText = e.statusText),
            (this.payload = e.payload),
            (this.requestHeaders = e.reqHeaders || {}),
            (this.responseHeaders = e.respHeaders || {});
        }
        getResponseHeadersText() {
          let e = `${this.protocol} ${this.status} ${this.statusText}\r\n`;
          for (const t of Object.keys(this.responseHeaders))
            e += `${t}: ${this.responseHeaders[t].replace(/\n/g, ", ")}\r\n`;
          return (e += "\r\n"), e;
        }
        hasRequest() {
          return this.method && (this.requestHeaders || this.requestHeadersText);
        }
        getRequestHeadersDict() {
          return this._getHeadersDict(this.requestHeaders, null);
        }
        getResponseHeadersDict(e) {
          return this._getHeadersDict(
            this.responseHeaders,
            this.responseHeadersList,
            e
          );
        }
        _getHeadersDict(e, t, r) {
          if (!e && t) {
            e = {};
            for (const i of t) {
              const t = i.name.toLowerCase();
              xs.includes(t) ||
                (e[t] = r && t === _s ? "" + r : i.value.replace(/\n/g, ", "));
            }
          }
          let i = null;
          if (!e) return { headers: new Headers(), headersDict: {} };
          try {
            i = new Headers(e);
          } catch (t) {
            for (const t of Object.keys(e)) {
              if (":" === t[0]) {
                delete e[t];
                continue;
              }
              const i = t.toLowerCase();
              xs.includes(i) ||
                (e[t] = r && i === _s ? "" + r : e[t].replace(/\n/g, ", "));
            }
            try {
              i = new Headers(e);
            } catch (e) {
              console.warn(e), (i = new Headers());
            }
          }
          return { headers: i, headersDict: e };
        }
        isValidBinary() {
          if (!this.payload) return !1;
          const e = this.payload.length,
            { headers: t } = this.getResponseHeadersDict(),
            r = t.get(Cs),
            i = t.get(_s);
          return Number(i) === e && (!r || !r.startsWith("text/html"));
        }
      }
      const Rs = new TextEncoder("utf-8"),
        Bs = "__awp_main_inject__",
        Ds = "__bx_log";
      function Os(e) {
        return new Promise((t) => setTimeout(() => t(), e));
      }
      class Ls {
        constructor() {
          (this.flatMode = !1),
            (this.collId = ""),
            (this.pendingRequests = {}),
            (this.numPending = 0),
            (this.running = !1),
            (this.stopping = !1),
            (this.frameId = null),
            (this.pageInfo = { size: 0 }),
            (this.firstPageStarted = !1),
            (this.sizeNew = 0),
            (this.sizeTotal = 0),
            (this.numPages = 0),
            (this.numUrls = 0),
            (this.historyMap = {}),
            (this._promises = {}),
            (this._fetchPending = new Map()),
            (this._fetchQueue = []),
            (this._fetchUrls = new Set()),
            (this._bindings = {}),
            (this.pdfLoadURL = null),
            (this.pixelRatio = 1),
            (this.failureMsg = null),
            (this.id = 1),
            (this.sessionSet = new Set()),
            (this._cachePageInfo = null),
            (this._cacheSessionNew = 0),
            (this._cacheSessionTotal = 0),
            (this.behaviorInitStr = JSON.stringify({
              autofetch: !0,
              autoplay: !0,
              autoscroll: !0,
              siteSpecific: !0,
              log: Ds,
            })),
            (this.behaviorState = t),
            (this.behaviorData = null),
            (this.autorun = !1),
            (this.defaultFetchOpts = { redirect: "manual" });
        }
        setAutoRunBehavior(e) {
          this.autorun = e;
        }
        addExternalInject(e) {
          return `\n    (function () {\n      window.addEventListener("DOMContentLoaded", () => {\n        const e = document.createElement("script");\n        e.src = "${this.getExternalInjectURL(
            e
          )}";\n        document.head.appendChild(e);\n      });\n    })();\n    `;
        }
        getInjectScript() {
          return (
            `/*! behaviors.js is part of Webrecorder project. Copyright (C) 2021-2024, Webrecorder Software. Licensed under the Affero General Public License v3. */(()=>{var t={480:(t,e,i)=>{"use strict";function o(t,e=document,i=null){return s(t,!0,e,i)}function s(t,e,i,o=null){t=function(t){function e(){o&&(a.length>0&&/^[~+>]$/.test(a[a.length-1])&&a.push(" "),a.push(o))}var i,o,s,n,a=[],r=[0],l=0,c=/(?:[^\\\\]|(?:^|[^\\\\])(?:\\\\\\\\)+)$/,h=/^\\s+$/,d=[/\\s+|\\/\\*|["'>~+[(]/g,/\\s+|\\/\\*|["'[\\]()]/g,/\\s+|\\/\\*|["'[\\]()]/g,null,/\\*\\//g];for(t=t.trim();;){if(o="",(s=d[r[r.length-1]]).lastIndex=l,!(i=s.exec(t))){o=t.substr(l),e();break}if((n=l)<(l=s.lastIndex)-i[0].length&&(o=t.substring(n,l-i[0].length)),r[r.length-1]<3){if(e(),"["===i[0])r.push(1);else if("("===i[0])r.push(2);else if(/^["']$/.test(i[0]))r.push(3),d[3]=new RegExp(i[0],"g");else if("/*"===i[0])r.push(4);else if(/^[\\])]$/.test(i[0])&&r.length>0)r.pop();else if(/^(?:\\s+|[~+>])$/.test(i[0])&&(a.length>0&&!h.test(a[a.length-1])&&0===r[r.length-1]&&a.push(" "),1===r[r.length-1]&&5===a.length&&"="===a[2].charAt(a[2].length-1)&&(a[4]=" "+a[4]),h.test(i[0])))continue;a.push(i[0])}else a[a.length-1]+=o,c.test(a[a.length-1])&&(4===r[r.length-1]&&(a.length<2||h.test(a[a.length-2])?a.pop():a[a.length-1]=" ",i[0]=""),r.pop()),a[a.length-1]+=i[0]}return a.join("").trim()}(t);let s=i.querySelector(t);if(document.head.createShadowRoot||document.head.attachShadow){if(!e&&s)return s;return n(t,",").reduce(((t,s)=>{if(!e&&t)return t;const l=n(s.replace(/^\\s+/g,"").replace(/\\s*([>+~]+)\\s*/g,"$1")," ").filter((t=>!!t)).map((t=>n(t,">"))),c=l.length-1,h=function(t=null,e,i=null){let o=[];if(i)o=i;else{const t=function(e){for(let i=0;i<e.length;i++){const s=e[i];o.push(s),s.shadowRoot&&t(s.shadowRoot.querySelectorAll("*"))}};e.shadowRoot&&t(e.shadowRoot.querySelectorAll("*")),t(e.querySelectorAll("*"))}return t?o.filter((e=>e.matches(t))):o}(l[c][l[c].length-1],i,o),d=function(t,e,i){return o=>{let s=e,n=o,l=!1;for(;n&&!a(n);){let e=!0;if(1===t[s].length)e=n.matches(t[s]);else{const o=[].concat(t[s]).reverse();let a=n;for(const t of o){if(!a||!a.matches(t)){e=!1;break}a=r(a,i)}}if(e&&0===s){l=!0;break}e&&s--,n=r(n,i)}return l}}(l,c,i);return e?t=t.concat(h.filter(d)):(t=h.find(d))||null}),e?[]:null)}return e?i.querySelectorAll(t):s}function n(t,e){return t.match(/\\\\?.|^$/g).reduce(((t,i)=>('"'!==i||t.sQuote?"'"!==i||t.quote?t.quote||t.sQuote||i!==e?t.a[t.a.length-1]+=i:t.a.push(""):(t.sQuote^=1,t.a[t.a.length-1]+=i):(t.quote^=1,t.a[t.a.length-1]+=i),t)),{a:[""]}).a}function a(t){return t.nodeType===Node.DOCUMENT_FRAGMENT_NODE||t.nodeType===Node.DOCUMENT_NODE}function r(t,e){const i=t.parentNode;return i&&i.host&&11===i.nodeType?i.host:i===e?null:i}i.d(e,{Jp:()=>o})},894:(t,e,i)=>{"use strict";i.r(e),i.d(e,{AutoFetcher:()=>c});var o=i(480),s=i(841),n=i(721);const a=/\\s*(\\S*\\s+[\\d.]+[wx]),|(?:\\s*,(?:\\s+|(?=https?:)))/,r=/(url\\s*\\(\\s*[\\\\"']*)([^)'"]+)([\\\\"']*\\s*\\))/gi,l=/(@import\\s*[\\\\"']*)([^)'";]+)([\\\\"']*\\s*;?)/gi;class c extends s.BackgroundBehavior{constructor(t=!1,e=null,i=!1){super(),this.urlSet=new Set,this.pendingQueue=[],this.waitQueue=[],this.numPending=0,this.numDone=0,this.running=!1,this.headers=e||{},this._donePromise=new Promise((t=>this._markDone=t)),this.active=t,this.active&&i&&document.addEventListener("DOMContentLoaded",(()=>this.initObserver()))}get numFetching(){return this.numDone+this.numPending+this.pendingQueue.length}async start(){this.active&&(this.initObserver(),this.run(),(0,n.sleep)(500).then((()=>{this.pendingQueue.length||this.numPending||this._markDone(null)})))}done(){return this._donePromise}async run(){this.running=!0;for(const t of this.waitQueue)this.doFetch(t);this.waitQueue=[],this.extractSrcSrcSetAll(document),this.extractStyleSheets(),this.extractDataAttributes(document)}isValidUrl(t){return t&&(t.startsWith("http:")||t.startsWith("https:"))}queueUrl(t,e=!1){try{t=new URL(t,document.baseURI).href}catch(t){return!1}return!!this.isValidUrl(t)&&(!this.urlSet.has(t)&&(this.urlSet.add(t),this.running||e?this.doFetch(t):this.waitQueue.push(t),!0))}async doFetchStream(t){try{const e=await fetch(t,{credentials:"include",referrerPolicy:"origin-when-cross-origin"});this.debug(\`Autofetch: started \${t}\`);const i=e.body.getReader();let o=null;for(;(o=await i.read())&&!o.done;);return this.debug(\`Autofetch: finished \${t}\`),!0}catch(t){return this.debug(t),!1}}async doFetchNonCors(t){try{const e=new AbortController;await fetch(t,{mode:"no-cors",credentials:"include",referrerPolicy:"origin-when-cross-origin",headers:this.headers,abort:e}),e.abort(),this.debug(\`Autofetch: started non-cors stream for \${t}\`)}catch(e){this.debug(\`Autofetch: failed non-cors for \${t}\`)}}async doFetch(t){if(this.pendingQueue.push(t),this.numPending<=6){for(;this.pendingQueue.length>0;){const t=this.pendingQueue.shift();this.numPending++,!1||await this.doFetchNonCors(t),this.numPending--,this.numDone++}this.numPending||this._markDone(null)}}initObserver(){this.mutationObserver||(this.mutationObserver=new MutationObserver((t=>this.observeChange(t))),this.mutationObserver.observe(document.documentElement,{characterData:!1,characterDataOldValue:!1,attributes:!0,attributeOldValue:!0,subtree:!0,childList:!0,attributeFilter:["srcset","loading"]}))}processChangedNode(t){switch(t.nodeType){case Node.ATTRIBUTE_NODE:if("srcset"===t.nodeName&&this.extractSrcSetAttr(t.nodeValue),"loading"===t.nodeName&&"lazy"===t.nodeValue){const e=t.parentNode;"IMG"===e.tagName&&e.setAttribute("loading","eager")}break;case Node.TEXT_NODE:t.parentNode&&"STYLE"===t.parentNode.tagName&&this.extractStyleText(t.nodeValue);break;case Node.ELEMENT_NODE:t.sheet&&this.extractStyleSheet(t.sheet),this.extractSrcSrcSet(t),setTimeout((()=>this.extractSrcSrcSetAll(t)),1e3),setTimeout((()=>this.extractDataAttributes(t)),1e3)}}observeChange(t){for(const e of t)if(this.processChangedNode(e.target),"childList"===e.type)for(const t of e.addedNodes)this.processChangedNode(t)}extractSrcSrcSetAll(t){const e=(0,o.Jp)("img[srcset], img[data-srcset], img[data-src], noscript > img[src], img[loading='lazy'], video[srcset], video[data-srcset], video[data-src], audio[srcset], audio[data-srcset], audio[data-src], picture > source[srcset], picture > source[data-srcset], picture > source[data-src], video > source[srcset], video > source[data-srcset], video > source[data-src], audio > source[srcset], audio > source[data-srcset], audio > source[data-src]",t);for(const t of e)this.extractSrcSrcSet(t)}extractSrcSrcSet(t){if(!t||t.nodeType!==Node.ELEMENT_NODE)return void console.warn("No elem to extract from");const e=t.getAttribute("data-src");e&&this.queueUrl(e),"lazy"===t.getAttribute("loading")&&t.setAttribute("loading","eager");const i=t.getAttribute("srcset");i&&this.extractSrcSetAttr(i);const o=t.getAttribute("data-srcset");o&&this.extractSrcSetAttr(o);const s=t.getAttribute("src");s&&"NOSCRIPT"===t.parentElement.tagName&&this.queueUrl(s)}extractSrcSetAttr(t){for(const e of t.split(a))if(e){const t=e.trim().split(" ");this.queueUrl(t[0])}}extractStyleSheets(t){t=t||document;for(const e of t.styleSheets)this.extractStyleSheet(e)}extractStyleSheet(t){let e;try{e=t.cssRules||t.rules}catch(t){return void this.debug("Can't access stylesheet")}for(const t of e)t.type===CSSRule.MEDIA_RULE&&this.extractStyleText(t.cssText)}extractStyleText(t){const e=(t,e,i,o)=>(this.queueUrl(i),e+i+o);t.replace(r,e).replace(l,e)}extractDataAttributes(t){for(const e of(0,n.xpathNodes)("//@*[starts-with(name(), 'data-') and (starts-with(., 'http') or starts-with(., '/') or starts-with(., './') or starts-with(., '../'))]",t))this.queueUrl(e.value)}}c.id="AutoFetcher"},376:(t,e,i)=>{"use strict";i.r(e),i.d(e,{Autoplay:()=>a});var o=i(480),s=i(841),n=i(721);class a extends s.BackgroundBehavior{constructor(t,e=!1){super(),this.running=!1,this.polling=!1,this.mediaSet=new Set,this.autofetcher=t,this.numPlaying=0,this.promises=[],this._initDone=()=>null,this.promises.push(new Promise((t=>this._initDone=t))),e&&document.addEventListener("DOMContentLoaded",(()=>this.pollAudioVideo()))}async start(){this.running=!0,this.pollAudioVideo(),this._initDone()}async pollAudioVideo(){if(!this.polling){for(this.polling=!0;;){for(const[,t]of(0,o.Jp)("video, audio, picture").entries())if(!t.__bx_autoplay_found){if(!this.running){this.processFetchableUrl(t)&&(t.__bx_autoplay_found=!0);continue}await this.loadMedia(t),t.__bx_autoplay_found=!0}await(0,n.sleep)(500)}this.polling=!1}}fetchSrcUrl(t){const e=t.src||t.currentSrc;return!!e&&(!(!e.startsWith("http:")&&!e.startsWith("https:"))&&(this.mediaSet.has(e)||(this.debug("fetch media source URL: "+e),this.mediaSet.add(e),this.autofetcher.queueUrl(e)),!0))}processFetchableUrl(t){let e=this.fetchSrcUrl(t);const i=t.querySelectorAll("source");for(const t of i){const i=this.fetchSrcUrl(t);e=e||i}return e}async loadMedia(t){this.debug("processing media element: "+t.outerHTML);const e=this.processFetchableUrl(t);t.play?e?t.paused||(t.pause(),this.debug("media URL found, pausing playback")):t.paused||t.currentTime?(t.paused?this.debug("no src url found, attempting to click or play: "+t.outerHTML):this.debug("media already playing, waiting for full playback to finish: "+t.outerHTML),this.attemptMediaPlay(t).then((async e=>{let i=!0;for(e&&e.then((()=>i=!1));i;)this.processFetchableUrl(t)&&(i=!1),this.debug("Waiting for fixed URL or media to finish: "+t.currentSrc),await(0,n.sleep)(1e3)}))):t.currentSrc&&this.debug("media playing from non-URL source: "+t.currentSrc):this.debug("media not playable, skipping")}async attemptMediaPlay(t){let e;const i=new Promise((t=>{e=t}));let o;const s=new Promise((t=>{o=t}));if(s.then((()=>this.promises.push(i))),!t.paused&&t.currentTime>0&&o(),t.addEventListener("loadstart",(()=>{this.debug("media event: loadstart"),o(!0)})),t.addEventListener("playing",(()=>{this.debug("media event: playing"),o(!0)})),t.addEventListener("loadeddata",(()=>this.debug("media event: loadeddata"))),t.addEventListener("ended",(()=>{this.debug("media event: ended"),e()})),t.addEventListener("pause",(()=>{this.debug("media event: pause"),e()})),t.addEventListener("abort",(()=>{this.debug("media event: abort"),e()})),t.addEventListener("error",(()=>{this.debug("media event: error"),e()})),t.addEventListener("stalled",(()=>{this.debug("media event: stalled"),e()})),t.addEventListener("suspend",(()=>{this.debug("media event: suspend"),e()})),t.muted=!0,!t.paused&&t.currentTime>0)return i;return!t.closest("a")&&(t.click(),await Promise.race([s,(0,n.sleep)(1e3)]))?(this.debug("play started after media.click()"),i):(t.play(),await Promise.race([s,(0,n.sleep)(1e3)])&&this.debug("play started after media.play()"),i)}done(){return Promise.allSettled(this.promises)}}a.id="Autoplay"},234:(t,e,i)=>{"use strict";i.r(e),i.d(e,{AutoScroll:()=>n});var o=i(841),s=i(721);class n extends o.Behavior{constructor(t){super(),this.autoFetcher=t,this.showMoreQuery="//*[contains(text(), 'show more') or contains(text(), 'Show more')]",this.state={segments:1},this.lastScrollPos=-1,this.samePosCount=0,this.origPath=document.location.pathname}currScrollPos(){return Math.round(self.scrollY+self.innerHeight)}canScrollMore(){const t=self.document.scrollingElement||self.document.body;return this.currScrollPos()<Math.max(t.clientHeight,t.scrollHeight)}hasScrollEL(t){try{return!!self.getEventListeners(t).scroll}catch(t){return this.debug("getEventListeners() not available"),!0}}async shouldScroll(){if(!this.hasScrollEL(self.window)&&!this.hasScrollEL(self.document)&&!this.hasScrollEL(self.document.body))return!1;const t=self.document.scrollingElement.scrollHeight,e=this.autoFetcher.numFetching,i=.98*document.scrollingElement.scrollHeight-self.innerHeight;return window.scrollTo({top:i,left:0,behavior:"auto"}),await(0,s.sleep)(500),(t!==self.document.scrollingElement.scrollHeight||e<this.autoFetcher.numFetching)&&(window.scrollTo({top:0,left:0,behavior:"auto"}),!0)}shouldScrollUp(){return 0!==self.window.scrollY&&!((self.window.scrollY+self.scrollHeight)/self.document.scrollingElement.scrollHeight<.9)}async*[Symbol.asyncIterator](){this.shouldScrollUp()?yield*this.scrollUp():await this.shouldScroll()?yield*this.scrollDown():yield this.getState("Skipping autoscroll, page seems to not be responsive to scrolling events")}async*scrollDown(){let t=0,e=null,i=!1;const o={top:Math.min(.1*self.document.scrollingElement.clientHeight,30),left:0,behavior:"auto"};let n=self.document.scrollingElement.scrollHeight;for(;this.canScrollMore();){if(document.location.pathname!==this.origPath)return(0,s.behaviorLog)(\`Location Changed, stopping scroll: \${document.location.pathname} != \${this.origPath}\`,"info"),void(0,s.addLink)(document.location.href);const a=self.document.scrollingElement.scrollHeight;if(a>n&&(this.state.segments++,n=a),e||i||(e=(0,s.xpathNode)(this.showMoreQuery)),e&&(0,s.isInViewport)(e)&&(yield this.getState("Clicking 'Show More', awaiting more content"),e.click(),await(0,s.sleep)(s.waitUnit),await Promise.race([(0,s.waitUntil)((()=>self.document.scrollingElement.scrollHeight>a),500),(0,s.sleep)(3e4)]),self.document.scrollingElement.scrollHeight===a&&(i=!0),e=null),self.scrollBy(o),await(0,s.sleep)(75),1===this.state.segments)yield this.getState(\`Scrolling down by \${o.top} pixels every 0.075 seconds\`),t=2;else{const e=t/(this.state.segments-1);this.debug(\`Waiting up to \${e} seconds for more scroll segments\`);const i=Date.now();await Promise.race([(0,s.waitUntil)((()=>this.canScrollMore()),75),(0,s.sleep)(e)]),t+=2*(Date.now()-i)}const r=this.currScrollPos();if(r===this.lastScrollPos){if(++this.samePosCount>=2)break}else this.samePosCount=0;this.lastScrollPos=r}}async*scrollUp(){const t={top:-Math.min(.1*self.document.scrollingElement.clientHeight,30),left:0,behavior:"auto"};let e=self.document.scrollingElement.scrollHeight;for(;self.scrollY>0;){const i=self.document.scrollingElement.scrollHeight;i>e&&(this.state.segments++,e=i),self.scrollBy(t),await(0,s.sleep)(75),1===this.state.segments?yield this.getState(\`Scrolling up by \${t.top} pixels every 0.075 seconds\`):await Promise.race([(0,s.waitUntil)((()=>self.scrollY>0),75),(0,s.sleep)(2e3*(this.state.segments-1))])}}}n.id="Autoscroll"},607:(t,e,i)=>{"use strict";i.r(e),i.d(e,{BehaviorManager:()=>h});var o=i(894),s=i(376),n=i(234),a=i(721),r=i(841),l=i(954);const c={autofetch:!0,autoplay:!0,autoscroll:!0,siteSpecific:!0};class h{constructor(){this.behaviors=[],this.loadedBehaviors=l.default.reduce(((t,e)=>(t[e.id]=e,t)),{}),this.mainBehavior=null,this.inited=!1,this.started=!1,(0,a.behaviorLog)("Loaded behaviors for: "+self.location.href)}init(t=c,e=!1,i=null){if((!this.inited||e)&&(this.inited=!0,this.opts=t,self.window)){if(this.timeout=t.timeout,void 0!==t.log){let e=t.log;"string"==typeof e&&(e=self[e]),"function"==typeof e?(0,a._setLogFunc)(e):!1===e&&(0,a._setLogFunc)(null)}if(this.autofetch=new o.AutoFetcher(!!t.autofetch,t.fetchHeaders,t.startEarly),t.autofetch&&((0,a.behaviorLog)("Using AutoFetcher"),this.behaviors.push(this.autofetch)),t.autoplay&&((0,a.behaviorLog)("Using Autoplay"),this.behaviors.push(new s.Autoplay(this.autofetch,t.startEarly))),this.isInTopFrame()&&i)for(const t of i)try{this.load(t)}catch(e){(0,a.behaviorLog)(\`Failed to load custom behavior: \${e} \${t}\`)}}}selectMainBehavior(){if(this.mainBehavior)return;const t=this.opts;let e=!1;if(t.siteSpecific)for(const i in this.loadedBehaviors){const o=this.loadedBehaviors[i];if(o.isMatch()){(0,a.behaviorLog)("Using Site-Specific Behavior: "+i),this.mainBehaviorClass=o;const s="object"==typeof t.siteSpecific&&t.siteSpecific[i]||{};try{this.mainBehavior=new r.BehaviorRunner(o,s)}catch(t){(0,a.behaviorLog)(t.toString(),"error")}e=!0;break}}return!e&&t.autoscroll&&((0,a.behaviorLog)("Using Autoscroll"),this.mainBehaviorClass=n.AutoScroll,this.mainBehavior=new n.AutoScroll(this.autofetch)),this.mainBehavior&&(this.behaviors.push(this.mainBehavior),this.mainBehavior instanceof r.BehaviorRunner)?this.mainBehavior.behaviorProps.id:""}load(t){if("function"!=typeof t)return void(0,a.behaviorLog)(\`Must pass a class object, got \${t}\`,"error");if("string"!=typeof t.id)return void(0,a.behaviorLog)('Behavior class must have a string string "id" property',"error");if("function"!=typeof t.isMatch||"function"!=typeof t.init)return void(0,a.behaviorLog)("Behavior class must have an is \`isMatch()\` and \`init()\` static methods","error");const e=t.id;(0,a.behaviorLog)(\`Loading external class \${e}: \${t}\`,"debug"),this.loadedBehaviors[e]=t}async resolve(t){const e=await i(75)(\`\${t}\`);if(Array.isArray(e))for(const t of e)this.load(t);else this.load(e)}async awaitPageLoad(){this.selectMainBehavior(),this.mainBehavior?.awaitPageLoad&&await this.mainBehavior.awaitPageLoad()}async run(t=c,e=!1){if(e&&(this.started=!1),this.started)return void this.unpause();this.init(t,e),this.selectMainBehavior(),await(0,a.awaitLoad)(),this.behaviors.forEach((t=>{(0,a.behaviorLog)("Starting behavior: "+t.constructor.id||0),t.start()})),this.started=!0,await(0,a.sleep)(500);let i=Promise.allSettled(this.behaviors.map((t=>t.done())));this.timeout?((0,a.behaviorLog)(\`Waiting for behaviors to finish or \${this.timeout}ms timeout\`),await Promise.race([i,(0,a.sleep)(this.timeout)])):((0,a.behaviorLog)("Waiting for behaviors to finish"),await i),(0,a.behaviorLog)("All Behaviors Done for "+self.location.href),this.mainBehavior&&this.mainBehaviorClass.cleanup&&this.mainBehavior.cleanup()}async runOne(t,e={}){const i=l.default.find((e=>e.name===t));if(void 0===i)return void console.error(\`No behavior of name \${t} found\`);const o=new r.BehaviorRunner(i,e);o.start(),console.log(\`Running behavior: \${t}\`),await o.done(),console.log(\`Behavior \${t} completed\`)}pause(){(0,a.behaviorLog)("Pausing Main Behavior"+this.mainBehaviorClass.name),this.behaviors.forEach((t=>t.pause()))}unpause(){this.behaviors.forEach((t=>t.unpause()))}doAsyncFetch(t){return(0,a.behaviorLog)("Queueing Async Fetch Url: "+t),this.autofetch.queueUrl(t,!0)}isInTopFrame(){return self.window.top===self.window||window.__WB_replay_top===self.window}}(0,a._setBehaviorManager)(h),(0,a.installBehaviors)(self)},841:(t,e,i)=>{"use strict";i.r(e),i.d(e,{BackgroundBehavior:()=>s,Behavior:()=>n,BehaviorRunner:()=>a});var o=i(721);class s{debug(t){(0,o.behaviorLog)(t,"debug")}log(t){(0,o.behaviorLog)(t,"info")}}class n extends s{constructor(){super(),this._running=null,this.paused=null,this._unpause=null,this.state={},this.scrollOpts={behavior:"smooth",block:"center",inline:"center"}}start(){this._running=this.run()}done(){return this._running?this._running:Promise.resolve()}async run(){try{for await(const t of this)this.log(t),this.paused&&await this.paused;this.log(this.getState("done!"))}catch(t){this.log(this.getState(t))}}pause(){this.paused||(this.paused=new Promise((t=>{this._unpause=t})))}unpause(){this._unpause&&(this._unpause(),this.paused=null,this._unpause=null)}getState(t,e){return e&&(void 0===this.state[e]?this.state[e]=1:this.state[e]++),{state:this.state,msg:t}}cleanup(){}async awaitPageLoad(){}static load(){self.__bx_behaviors?self.__bx_behaviors.load(this):console.warn(\`Could not load \${this.name} behavior: window.__bx_behaviors is not initialized\`)}async*[Symbol.asyncIterator](){yield}}class a extends s{constructor(t,e={}){if(super(),this.behaviorProps=t,this.inst=new t,"function"!=typeof this.inst.run||"AsyncGeneratorFunction"!==this.inst.run.constructor.name)throw Error("Invalid behavior: missing \`async run*\` instance method");let{state:i,opts:s}=t.init();i=i||{},s=s?{...s,...e}:e;const n=o.behaviorLog;this.ctx={Lib:o,state:i,opts:s,log:n},this._running=null,this.paused=null,this._unpause=null}start(){this._running=this.run()}done(){return this._running?this._running:Promise.resolve()}async run(){try{for await(const t of this.inst.run(this.ctx))this.log(t),this.paused&&await this.paused;this.log((0,o.getState)(this.ctx,"done!"))}catch(t){this.log((0,o.getState)(this.ctx,t))}}pause(){this.paused||(this.paused=new Promise((t=>{this._unpause=t})))}unpause(){this._unpause&&(this._unpause(),this.paused=null,this._unpause=null)}cleanup(){}async awaitPageLoad(){this.inst.awaitPageLoad&&await this.inst.awaitPageLoad(this.ctx)}static load(){self.__bx_behaviors?self.__bx_behaviors.load(this):console.warn(\`Could not load \${this.name} behavior: window.__bx_behaviors is not initialized\`)}}},721:(t,e,i)=>{"use strict";i.r(e),i.d(e,{HistoryState:()=>y,RestoreState:()=>b,_setBehaviorManager:()=>p,_setLogFunc:()=>g,addLink:()=>f,awaitLoad:()=>d,behaviorLog:()=>w,getState:()=>N,installBehaviors:()=>v,isInViewport:()=>_,iterChildElem:()=>P,iterChildMatches:()=>E,openWindow:()=>m,scrollAndClick:()=>a,scrollIntoView:()=>T,scrollToOffset:()=>k,sleep:()=>l,waitUnit:()=>r,waitUntil:()=>c,waitUntilNode:()=>h,xpathNode:()=>S,xpathNodes:()=>x,xpathString:()=>L});let o=console.log,s=null;const n={behavior:"smooth",block:"center",inline:"center"};async function a(t,e=500,i=n){t.scrollIntoView(i),await l(e),t.click()}const r=200;function l(t){return new Promise((e=>setTimeout(e,t)))}async function c(t,e=r){for(;!t();)await l(e)}async function h(t,e=document,i=null,o=1e3,s=r){let n=null,a=!1;const l=c((()=>(n=S(t,e),a||n!==i&&null!==n)),s),h=new Promise((t=>setTimeout((()=>{a=!0,t("TIMEOUT")}),o)));return await Promise.race([l,h]),n}function d(){return new Promise((t=>{"complete"===document.readyState?t(null):window.addEventListener("load",t)}))}function u(t,e){try{t(e)}catch(i){t(JSON.stringify(e))}}function w(t,e="debug"){o&&u(o,{data:t,type:e})}function f(t){self.__bx_addLink&&self.__bx_addLink(t)}async function m(t){if(self.__bx_open){const e=new Promise((t=>self.__bx_openResolve=t));u(self.__bx_open,{url:t});let i=null;try{if(i=await e,i)return i}catch(t){console.warn(t)}finally{delete self.__bx_openResolve}}return window.open(t)}function g(t){o=t}function p(t){s=t}function v(t){t.__bx_behaviors=new s}class b{constructor(t,e){this.matchValue=L(t,e)}async restore(t,e){let i=null;for(;i=S(t),!i;)await l(100);return S(e.replace("$1",this.matchValue),i)}}class y{constructor(t){this.loc=window.location.href,t()}get changed(){return window.location.href!==this.loc}goBack(t){if(!this.changed)return Promise.resolve(!0);const e=S(t);return new Promise((t=>{window.addEventListener("popstate",(()=>{t(null)}),{once:!0}),e?e.click():window.history.back()}))}}function S(t,e){return e=e||document,document.evaluate(t,e,null,XPathResult.FIRST_ORDERED_NODE_TYPE).singleNodeValue}function*x(t,e){e=e||document;let i=document.evaluate(t,e,null,XPathResult.ORDERED_NODE_ITERATOR_TYPE),o=null;for(;null!==(o=i.iterateNext());)yield o}function L(t,e){return e=e||document,document.evaluate(t,e,null,XPathResult.STRING_TYPE).stringValue}async function*P(t,e,i){let o=t.firstElementChild;for(;o;)yield o,o.nextElementSibling||await Promise.race([c((()=>!!o.nextElementSibling),e),l(i)]),o=o.nextElementSibling}async function*E(t,e,i=r,o=5e3){let s=S(\`.//\${t}\`,e);const n=e=>S(\`./following-sibling::\${t}\`,e);for(;s;){yield s;let t=n(s);t?s=t:(await Promise.race([c((()=>(t=n(s),t)),i),l(o)]),s=t)}}function _(t){var e=t.getBoundingClientRect();return e.top>=0&&e.left>=0&&e.bottom<=(window.innerHeight||document.documentElement.clientHeight)&&e.right<=(window.innerWidth||document.documentElement.clientWidth)}function k(t,e=0){const i=t.getBoundingClientRect().top+window.pageYOffset-e;window.scrollTo({top:i,behavior:"smooth"})}function T(t,e={behavior:"smooth",block:"center",inline:"center"}){t.scrollIntoView(e)}function N(t,e,i){return void 0===typeof t.state&&(t.state={}),i&&(void 0===t.state[i]?t.state[i]=1:t.state[i]++),{state:t.state,msg:e}}},121:(t,e,i)=>{"use strict";i.r(e),i.d(e,{FacebookTimelineBehavior:()=>s});const o={feed:"//div[@role='feed']",article:".//div[@role='article']",pageletPostList:"//div[@data-pagelet='page']/div[@role='main']//div[@role='main']/div",pageletProfilePostList:"//div[@data-pagelet='page']//div[@data-pagelet='ProfileTimeline']",articleToPostList:"//div[@role='article']/../../../../div",photosOrVideos:\`.//a[(contains(@href, '/photos/') or contains(@href, '/photo/?') or contains(@href, '/videos/')) and (starts-with(@href, '\${window.location.origin}/') or starts-with(@href, '/'))]\`,postQuery:".//a[contains(@href, '/posts/')]",extraLabel:"//*[starts-with(text(), '+')]",nextSlideQuery:"//div[@data-name='media-viewer-nav-container']/div[@data-visualcompletion][2]//div[@role='button']",nextSlide:"//div[@aria-hidden='false']//div[@role='button' and not(@aria-hidden) and @aria-label]",commentList:".//ul[(../h3) or (../h4)]",commentMoreReplies:"./div[2]/div[1]/div[2]/div[@role='button']",commentMoreComments:"./following-sibling::div/div/div[2][@role='button'][./span/span]",viewComments:".//h4/..//div[@role='button']",photoCommentList:"//ul[../h2]",firstPhotoThumbnail:"//div[@role='main']//div[3]//div[contains(@style, 'border-radius')]//div[contains(@style, 'max-width') and contains(@style, 'min-width')]//a[@role='link']",firstVideoThumbnail:"//div[@role='main']//div[contains(@style, 'z-index')]/following-sibling::div/div/div/div[last()]//a[contains(@href, '/videos/') and @aria-hidden!='true']",firstVideoSimple:"//div[@role='main']//a[contains(@href, '/videos/') and @aria-hidden!='true']",mainVideo:"//div[@data-pagelet='root']//div[@role='dialog']//div[@role='main']//video",nextVideo:"following::a[contains(@href, '/videos/') and @aria-hidden!='true']",isPhotoVideoPage:/^.*facebook\\.com\\/[^/]+\\/(photos|videos)\\/.+/,isPhotosPage:/^.*facebook\\.com\\/[^/]+\\/photos\\/?($|\\?)/,isVideosPage:/^.*facebook\\.com\\/[^/]+\\/videos\\/?($|\\?)/};class s{static isMatch(){return!!window.location.href.match(/https:\\/\\/(www\\.)?facebook\\.com\\//)}static init(){return{state:{}}}constructor(){this.extraWindow=null,this.allowNewWindow=!1}async*iterPostFeeds(t){const{iterChildElem:e,waitUnit:i,waitUntil:s,xpathNode:n,xpathNodes:a}=t.Lib,r=Array.from(a(o.feed));if(r&&r.length)for(const a of r)for await(const r of e(a,i,10*s))yield*this.viewPost(t,n(o.article,r));else{const a=n(o.pageletPostList)||n(o.pageletProfilePostList)||n(o.articleToPostList);if(!a)return;for await(const r of e(a,i,10*s))yield*this.viewPost(t,n(o.article,r))}this.extraWindow&&this.extraWindow.close()}async*viewPost(t,e,i=2){const{getState:s,scrollIntoView:n,sleep:a,waitUnit:r,xpathNode:l}=t.Lib;if(!e)return;const c=l(o.postQuery,e);let h=null;c&&(h=new URL(c.href,window.location.href),h.search=""),yield s(t,"Viewing post "+(h||""),"posts"),n(e),await a(2*r),l(".//video",e)&&(yield s(t,"Playing inline video","videos"),await a(2*r));let d=l(o.commentList,e);if(!d){const t=l(o.viewComments,e);t&&(t.click(),await a(2*r)),d=l(o.commentList,e)}yield*this.iterComments(t,d,i),await a(5*r)}async*viewPhotosOrVideos(t,e){const{getState:i,sleep:s,waitUnit:n,xpathNode:a,xpathNodes:r}=t.Lib,l=Array.from(r(o.photosOrVideos,e)),c=new Set;let h=0;for(const e of l){const r=new URL(e.href,window.location.href);if(-1===e.href.indexOf("?fbid")&&(r.search=""),c.has(r.href))continue;const d=e.href.indexOf("/video")>=0?"videos":"photos";++h,c.add(r.href),yield i(t,\`Viewing \${d} \${r.href}\`,d),e.scrollIntoView(),await s(5*n),e.click(),await s(10*n),this.allowNewWindow&&await this.openNewWindow(t,r.href),h===l.length&&(yield*this.viewExtraObjects(t,e,d,this.allowNewWindow));const u=a(o.nextSlide);u&&(u.click(),await s(2*n))}}async*viewExtraObjects(t,e,i,s){const{getState:n,sleep:a,waitUnit:r,waitUntil:l,xpathNode:c}=t.Lib,h=c(o.extraLabel,e);if(!h)return;const d=Number(h.innerText.slice(1));if(isNaN(d))return;let u;for(let e=0;e<d;e++){const e=c(o.nextSlideQuery);e&&(u=window.location.href,e.click(),await a(5*r),await l((()=>window.location.href!==u),2*r),yield n(t,\`Viewing extra \${i} \${window.location.href}\`),s&&await this.openNewWindow(t,window.location.href))}}async openNewWindow(t,e){this.extraWindow?this.extraWindow.location.href=e:this.extraWindow=await t.Lib.openWindow(e)}async*iterComments(t,e,i=2){const{getState:s,scrollIntoView:n,sleep:a,waitUnit:r,xpathNode:l}=t.Lib;if(!e)return void await a(5*r);let c=e.firstElementChild,h=null,d=0;for(;c&&d<i;){for(;c&&d<i;){yield s(t,"Loading comments","comments"),n(c),await a(2*r);const e=l(o.commentMoreReplies,c);e&&(e.click(),await a(5*r)),h=c,c=h.nextElementSibling,d++}if(d===i)break;let u=l(o.commentMoreComments,e);u&&(n(u),u.click(),await a(5*r),h&&(c=h.nextElementSibling,await a(5*r)))}await a(2*r)}async*iterPhotoSlideShow(t){const{getState:e,scrollIntoView:i,sleep:s,waitUnit:n,waitUntil:a,xpathNode:r}=t.Lib,l=r(o.firstPhotoThumbnail);if(!l)return;let c=window.location.href;i(l),l.click(),await s(5*n),await a((()=>window.location.href!==c),2*n);let h=null;for(;(h=r(o.nextSlideQuery))&&(c=window.location.href,await s(n),h.click(),await s(5*n),await Promise.race([a((()=>window.location.href!==c),2*n),s(3e3)]),window.location.href!==c);){yield e(t,\`Viewing photo \${window.location.href}\`,"photos");const i=r(o.photoCommentList);yield*this.iterComments(t,i,2),await s(5*n)}}async*iterAllVideos(t){const{getState:e,scrollIntoView:i,sleep:s,waitUnit:n,waitUntil:a,xpathNode:r,xpathNodes:l}=t.Lib,c=r("//video");c&&(i(c),await s(5*n));let h=r(o.firstVideoThumbnail)||r(o.firstVideoSimple);if(h)for(;h;){i(h);let c=window.location.href;h.click(),await a((()=>window.location.href!==c),2*n),yield e(t,"Viewing video: "+window.location.href,"videos"),await s(10*n),await Promise.race([a((()=>{for(const t of l("//video"))if(t.readyState>=3)return!0;return!1}),2*n),s(2e4)]),await s(10*n);const d=r(o.nextSlide);if(!d)break;c=window.location.href,d.click(),await a((()=>window.location.href!==c),2*n),h=r(o.nextVideo,h)}}async*run(t){const{getState:e,sleep:i,xpathNode:s}=t.Lib;if(yield e(t,"Starting..."),await i(2e3),o.isPhotosPage.exec(window.location.href))return t.state={photos:0,comments:0},void(yield*this.iterPhotoSlideShow(t));if(o.isVideosPage.exec(window.location.href))return t.state={videos:0,comments:0},void(yield*this.iterAllVideos(t));if(o.isPhotoVideoPage.exec(window.location.href)){t.state={comments:0};const e=s(o.photoCommentList);yield*this.iterComments(t,e,1e3)}else t.state={posts:0,comments:0,videos:0},yield*this.iterPostFeeds(t)}}s.id="Facebook"},954:(t,e,i)=>{"use strict";i.r(e),i.d(e,{default:()=>l});var o=i(121),s=i(741),n=i(667),a=i(739),r=i(714);const l=[s.InstagramPostsBehavior,a.TwitterTimelineBehavior,o.FacebookTimelineBehavior,n.TelegramBehavior,r.TikTokVideoBehavior,r.TikTokProfileBehavior]},741:(t,e,i)=>{"use strict";i.r(e),i.d(e,{InstagramPostsBehavior:()=>n});const o="//article[@role='presentation']//div[@role='presentation']/following-sibling::button",s={rootPath:"//main/div/div[2]/div",childMatchSelect:"string(.//a[starts-with(@href, '/')]/@href)",childMatch:"child::div[.//a[@href='$1']]",firstPostInRow:"div[1]/a",postCloseButton:"/html/body/div[last()]/div[1]/button[.//*[@aria-label]]",nextPost:"//button[.//*[local-name() = 'svg' and @aria-label='Next']]",postLoading:"//*[@aria-label='Loading...']",subpostNextOnlyChevron:o,subpostPrevNextChevron:o+"[2]",commentRoot:"//article[@role='presentation']/div[1]/div[2]//ul/div[last()]/div/div",viewReplies:"ul/li//button[span[not(count(*)) and contains(text(), '(')]]",loadMore:"//button[span[@aria-label]]",pageLoadWaitUntil:"//main"};class n{static isMatch(){return!!window.location.href.match(/https:\\/\\/(www\\.)?instagram\\.com\\/\\w[\\w.-]+/)}static init(){return{state:{posts:0,slides:0,rows:0,comments:0}}}constructor(){this.maxCommentsTime=1e4,this.postOnlyWindow=null}cleanup(){this.postOnlyWindow&&(this.postOnlyWindow.close(),this.postOnlyWindow=null)}async waitForNext(t,e){return e?(await t.Lib.sleep(t.Lib.waitUnit),e.nextElementSibling?e.nextElementSibling:null):null}async*iterRow(t){const{RestoreState:e,sleep:i,waitUnit:o,xpathNode:n}=t.Lib;let a=n(s.rootPath);if(!a)return;let r=a.firstElementChild;if(r)for(;r;){await i(o);const n=new e(s.childMatchSelect,r);n.matchValue&&(yield r,r=await n.restore(s.rootPath,s.childMatch)),r=await this.waitForNext(t,r)}}async*viewStandalonePost(t,e){const{getState:i,sleep:o,waitUnit:n,waitUntil:a,xpathNode:r,xpathString:l}=t.Lib;let c=r(s.rootPath);if(!c||!c.firstElementChild)return;const h=l(s.childMatchSelect,c.firstElementChild);yield i(t,"Loading single post view for first post: "+h),window.history.replaceState({},"",h),window.dispatchEvent(new PopStateEvent("popstate",{state:{}}));let d=null,u=null;await o(5*n),await a((()=>(d=r(s.rootPath))!==c&&d),5*n),await o(5*n),window.history.replaceState({},"",e),window.dispatchEvent(new PopStateEvent("popstate",{state:{}})),await a((()=>(u=r(s.rootPath))!==d&&u),5*n)}async*iterSubposts(t){const{getState:e,sleep:i,waitUnit:o,xpathNode:n}=t.Lib;let a=n(s.subpostNextOnlyChevron),r=1;for(;a;)a.click(),await i(5*o),yield e(t,\`Loading Slide \${++r} for \${window.location.href}\`,"slides"),a=n(s.subpostPrevNextChevron);await i(5*o)}async iterComments(t){const{scrollIntoView:e,sleep:i,waitUnit:o,waitUntil:n,xpathNode:a}=t.Lib,r=a(s.commentRoot);if(!r)return;let l=r.firstElementChild,c=!1;const h=t=>a(s.viewReplies,t);for(;l;){e(l),c=!0;let r=h(l);for(;r;){const e=r.textContent;r.click(),t.state.comments++,await i(2.5*o),await n((()=>e!==r.textContent),o),r=h(l)}if(l.nextElementSibling&&"LI"===l.nextElementSibling.tagName&&!l.nextElementSibling.nextElementSibling){let e=a(s.loadMore,l.nextElementSibling);e&&(e.click(),t.state.comments++,await i(5*o))}l=l.nextElementSibling,await i(2.5*o)}return c}async*iterPosts(t,e){const{getState:i,sleep:o,waitUnit:n,xpathNode:a}=t.Lib;let r=0;for(;e&&++r<=3;)for(e.click(),await o(10*n),yield i(t,"Loading Post: "+window.location.href,"posts"),await fetch(window.location.href),yield*this.iterSubposts(t),yield i(t,"Loaded Comments","comments"),await Promise.race([this.iterComments(t),o(this.maxCommentsTime)]),e=a(s.nextPost);!e&&a(s.postLoading);)await o(2.5*n);await o(5*n)}async*run(t){const{getState:e,scrollIntoView:i,sleep:o,waitUnit:n,xpathNode:a}=t.Lib;for await(const r of this.iterRow(t)){i(r),await o(2.5*n),yield e(t,"Loading Row","rows");const l=a(s.firstPostInRow,r);yield*this.iterPosts(t,l);const c=a(s.postCloseButton);c&&c.click(),await o(5*n)}}async awaitPageLoad(t){const{Lib:e,log:i}=t,{waitUntilNode:o}=e;i("Waiting for Instagram to fully load","info"),await o(s.pageLoadWaitUntil,document,null,3e4)}}n.id="Instagram"},667:(t,e,i)=>{"use strict";i.r(e),i.d(e,{TelegramBehavior:()=>a});const o="//main//section[@class='tgme_channel_history js-message_history']",s="string(./div[@data-post]/@data-post)",n="string(.//a[@class='tgme_widget_message_link_preview' and @href]/@href)";class a{static isMatch(){return!!window.location.href.match(/https:\\/\\/t.me\\/s\\/\\w[\\w]+/)}static init(){return{state:{messages:0}}}async waitForPrev(t,e){return e?(await t.Lib.sleep(5*t.Lib.waitUnit),e.previousElementSibling?e.previousElementSibling:null):null}async*run(t){const{getState:e,scrollIntoView:i,sleep:a,waitUnit:r,xpathNode:l,xpathString:c}=t.Lib;let h=l(o);if(!h)return;let d=h.lastElementChild;for(;d;){i(d);const o=c(s,d)||"unknown",l=c(n,d);if(l&&l.endsWith(".jpg")||l.endsWith(".png")){yield e(t,"Loading External Image: "+l);const i=new Image;i.src=l,document.body.appendChild(i),await a(2.5*r),document.body.removeChild(i)}yield e(t,"Loading Message: "+o,"messages"),d=await this.waitForPrev(t,d)}}}a.id="Telegram"},714:(t,e,i)=>{"use strict";i.r(e),i.d(e,{BREADTH_ALL:()=>h,TikTokProfileBehavior:()=>u,TikTokVideoBehavior:()=>d});const o="//div[contains(@class, 'CommentListContainer')]",s="div[contains(@class, 'CommentItemContainer')]",n=".//p[contains(@class, 'ReplyActionText')]",a=".//p[starts-with(@data-e2e, 'view-more') and string-length(text()) > 0]",r="//div[starts-with(@data-e2e, 'user-post-item-list')]",l="div[contains(@class, 'DivItemContainerV2')]",c="button[contains(@class, 'StyledCloseIconContainer')]",h=Symbol("BREADTH_ALL");class d{static init(){return{state:{comments:0},opts:{breadth:h}}}static isMatch(){return!!window.location.href.match(/https:\\/\\/(www\\.)?tiktok\\.com\\/@.+\\/video\\/\\d+\\/?.*/)}breadthComplete({opts:{breadth:t}},e){return t!==h&&t<=e}async*crawlThread(t,e,i=null,o=0){const{waitUntilNode:s,scrollAndClick:n,getState:r}=t.Lib,l=await s(a,e,i);l&&!this.breadthComplete(t,o)&&(await n(l,500),yield r(t,"View more replies","comments"),yield*this.crawlThread(t,e,l,o+1))}async*expandThread(t,e){const{xpathNode:i,scrollAndClick:o,getState:s}=t.Lib,a=i(n,e);a&&(await o(a,500),yield s(t,"View comment","comments"),yield*this.crawlThread(t,e,null,1))}async*run(t){const{xpathNode:e,iterChildMatches:i,scrollIntoView:n,getState:a}=t.Lib,r=e(o),l=i(s,r);for await(const e of l)n(e),yield a(t,"View comment","comments"),this.breadthComplete(t,0)||(yield*this.expandThread(t,e));yield a(t,"TikTok Video Behavior Complete")}}d.id="TikTokVideo";class u{static isMatch(){return!!window.location.href.match(/https:\\/\\/(www\\.)?tiktok\\.com\\/@[a-zA-Z0-9]+(\\/?$|\\/\\?.*)/)}static init(){return{state:{videos:0,comments:0},opts:{breadth:h}}}async*openVideo(t,e){const{HistoryState:i,xpathNode:o,sleep:s}=t.Lib,n=o(".//a",e);if(!n)return;const a=new i((()=>n.click()));if(await s(500),a.changed){const e=new d;yield*e.run(t),await s(500),await a.goBack(c)}}async*run(t){const{xpathNode:e,iterChildMatches:i,scrollIntoView:o,getState:s,sleep:n}=t.Lib,a=e(r),c=i(l,a);for await(const e of c)o(e),yield s(t,"View video","videos"),yield*this.openVideo(t,e),await n(500);yield s(t,"TikTok Profile Behavior Complete")}}u.id="TikTokProfile"},739:(t,e,i)=>{"use strict";i.r(e),i.d(e,{TwitterTimelineBehavior:()=>p});const o="//h1[@role='heading' and @aria-level='1']/following-sibling::div[@aria-label]//div[@style]",s=".//article",n="string(.//article//a[starts-with(@href, '/') and @aria-label]/@href)",a="child::div[.//a[@href='$1']]",r=".//div[@role='button' and not(@aria-haspopup) and not(@data-testid)]",l=".//div[@role='blockquote' and @aria-haspopup='false']",c=".//a[@role='link' and starts-with(@href, '/') and contains(@href, '/photo/')]",h="//div[@aria-roledescription='carousel']/div[2]/div[1]//div[@role='button']",d="//div[@aria-roledescription='carousel']/div[2]/div[2]//div[@role='button']",u="//div[@role='presentation']/div[@role='button' and @aria-label]",w="//div[@data-testid='titleContainer']//div[@role='button']",f=".//a[@href='/settings/content_you_see']/parent::div/parent::div/parent::div//div[@role='button']",m=".//*[@role='progressbar']",g=".//div[data-testid='placementTracking']";class p{static isMatch(){return!!window.location.href.match(/https:\\/\\/(www\\.)?twitter\\.com\\//)}static init(){return{state:{tweets:0,images:0,videos:0},opts:{maxDepth:0}}}constructor(){this.seenTweets=new Set,this.seenMediaTweets=new Set}showingProgressBar(t,e){const{xpathNode:i}=t.Lib,o=i(m,e);return!!o&&o.clientHeight>10}async waitForNext(t,e){const{sleep:i,waitUnit:o}=t.Lib;if(!e)return null;if(await i(2*o),!e.nextElementSibling)return null;for(;this.showingProgressBar(t,e.nextElementSibling);)await i(o);return e.nextElementSibling}async expandMore(t,e){const{sleep:i,waitUnit:o,xpathNode:s}=t.Lib,n=s(r,e);if(!n)return e;const a=e.previousElementSibling;for(n.click(),await i(o);this.showingProgressBar(t,a.nextElementSibling);)await i(o);return e=a.nextElementSibling}async*infScroll(t){const{scrollIntoView:e,RestoreState:i,sleep:l,waitUnit:c,xpathNode:h}=t.Lib;let d=h(o);if(!d)return;let u=d.firstElementChild;if(u)for(;u;){let d=h(s,u);if(!d&&r&&(u=await this.expandMore(t,u),d=h(s,u)),u&&u.innerText&&e(u),u&&d){await l(c);const t=new i(n,u);yield d,t.matchValue&&(u=await t.restore(o,a))}u=await this.waitForNext(t,u)}}async*mediaPlaying(t,e){const{getState:i,sleep:o,xpathNode:s,xpathString:a}=t.Lib,r=s("(.//video | .//audio)",e);if(!r||r.paused)return;let l,c=null;try{c=new URL(a(n,e.parentElement),window.location.origin).href}catch(t){console.warn(t)}if(r.src.startsWith("https://")&&r.src.indexOf(".mp4")>0)return void(yield i(t,\`Loading video for \${c||"unknown"}\`,"videos"));if(c){if(this.seenMediaTweets.has(c))return;l=\`Waiting for media playback for \${c} to finish\`,this.seenMediaTweets.add(c)}else l="Loading video";yield i(t,l,"videos");const h=new Promise((t=>{r.addEventListener("ended",(()=>t(null))),r.addEventListener("abort",(()=>t(null))),r.addEventListener("error",(()=>t(null))),r.addEventListener("pause",(()=>t(null)))}));await Promise.race([h,o(6e4)])}async*clickImages(t,e){const{getState:i,HistoryState:o,sleep:s,waitUnit:n,xpathNode:a}=t.Lib,r=a(c,e);if(r){const e=new o((()=>r.click()));yield i(t,"Loading Image: "+window.location.href,"images"),await s(5*n);let l=a(h),c=window.location.href;for(;l;){if(l.click(),await s(2*n),window.location.href===c){await s(5*n);break}c=window.location.href,yield i(t,"Loading Image: "+window.location.href,"images"),await s(5*n),l=a(d)}await e.goBack(u)}}async*clickTweet(t,e,i){const{getState:o,HistoryState:s,sleep:n,waitUnit:a}=t.Lib,r=new s((()=>e.click()));if(await n(a),r.changed){yield o(t,"Capturing Tweet: "+window.location.href,"tweets");i<t.opts.maxDepth&&!this.seenTweets.has(window.location.href)&&(yield*this.iterTimeline(t,i+1)),this.seenTweets.add(window.location.href),await n(2*a),await r.goBack(w),await n(a)}}async*iterTimeline(t,e=0){const{getState:i,sleep:o,waitUnit:s,xpathNode:n}=t.Lib;if(!this.seenTweets.has(window.location.href)){yield i(t,"Capturing thread: "+window.location.href,"threads");for await(const i of this.infScroll(t)){if(n(g,i))continue;await o(2.5*s);const a=n(f,i);a&&(a.click(),await o(2.5*s)),yield*this.clickImages(t,i);const r=n(l,i);r&&(yield*this.clickTweet(t,r,1e3)),yield*this.mediaPlaying(t,i),yield*this.clickTweet(t,i,e),await o(5*s)}}}async*run(t){yield*this.iterTimeline(t,0)}}p.id="Twitter"},75:(t,e,i)=>{var o={".":607,"./":607,"./autofetcher":894,"./autofetcher.ts":894,"./autoplay":376,"./autoplay.ts":376,"./autoscroll":234,"./autoscroll.ts":234,"./index":607,"./index.ts":607,"./lib/behavior":841,"./lib/behavior.ts":841,"./lib/utils":721,"./lib/utils.ts":721,"./site":954,"./site/":954,"./site/facebook":121,"./site/facebook.ts":121,"./site/index":954,"./site/index.ts":954,"./site/instagram":741,"./site/instagram.ts":741,"./site/telegram":667,"./site/telegram.ts":667,"./site/tiktok":714,"./site/tiktok.ts":714,"./site/twitter":739,"./site/twitter.ts":739};function s(t){return Promise.resolve().then((()=>{if(!i.o(o,t)){var e=new Error("Cannot find module '"+t+"'");throw e.code="MODULE_NOT_FOUND",e}var s=o[t];return i(s)}))}s.keys=()=>Object.keys(o),s.id=75,t.exports=s}},e={};function i(o){var s=e[o];if(void 0!==s)return s.exports;var n=e[o]={exports:{}};return t[o](n,n.exports,i),n.exports}i.d=(t,e)=>{for(var o in e)i.o(e,o)&&!i.o(t,o)&&Object.defineProperty(t,o,{enumerable:!0,get:e[o]})},i.e=()=>Promise.resolve(),i.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),i.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},(()=>{"use strict";i(607)})()})();;\n    self.__bx_behaviors.init(${this.behaviorInitStr});\n\n    window.addEventListener("beforeunload", () => {});` +
            this.getFlashInjectScript()
          );
        }
        getFlashInjectScript() {
          return (
            '\n    (() => {\n      const description = "Shockwave Flash 32.0 r0";\n      const enabledPlugin = { description };\n      navigator.plugins["Shockwave Flash"] = { description };\n      function addPlugin(type, suffixes) {\n        const mime = { enabledPlugin, description: "", type, suffixes};\n        navigator.mimeTypes[type] = mime;\n        navigator.mimeTypes[navigator.mimeTypes.length] = mime;\n      }\n      addPlugin("application/futuresplash", "sp1");\n      addPlugin("application/x-shockwave-flash2-preview", "swf");\n      addPlugin("application/x-shockwave-flash", "swf");\n      addPlugin("application/vnd.adobe.flash-movie", "swf");\n    })();\n    ' +
            this.addExternalInject("ruffle/ruffle.js")
          );
        }
        async detach() {
          if (!this.running) return;
          this.stopping = !0;
          const e = await this.getFullText(!0);
          this.behaviorState === a && this.toggleBehaviors();
          try {
            await Promise.race([
              Promise.all(this._fetchPending.values()),
              Os(15e3),
            ]);
          } catch (e) {
            console.log(e);
          }
          try {
            await this._doDetach();
          } catch (e) {
            console.log(e);
          }
          await this._stop(e);
        }
        async _stop(e = null) {
          clearInterval(this._updateStatusId),
            clearInterval(this._loopId),
            clearInterval(this._bgFetchId),
            this.flushPending(),
            (this.running = !1),
            (this.pendingRequests = {}),
            (this.numPending = 0),
            await this.commitPage(this.pageInfo, e, !0),
            this._cleaningUp
              ? await this._cleanupStaleWait
              : await this.doUpdateLoop(),
            this._doStop();
        }
        async attach() {
          this.running
            ? console.warn("Already Attached!")
            : (await this._doAttach(),
              (this.running = !0),
              (this.stopping = !1),
              (this._cachePageInfo = null),
              (this._cacheSessionNew = 0),
              (this._cacheSessionTotal = 0),
              (this._cleaningUp = !1),
              (this._cleanupStaleWait = null),
              (this._updateStatusId = setInterval(
                () => this.updateStatus(),
                1e3
              )),
              (this._loopId = setInterval(() => this.updateLoop(), 1e4)),
              (this._bgFetchId = setInterval(
                () => this.doBackgroundFetch(),
                1e4
              )));
        }
        updateLoop() {
          this._cleaningUp || (this._cleanupStaleWait = this.doUpdateLoop());
        }
        async doUpdateLoop() {
          this._cleaningUp = !0;
          try {
            for (const e of Object.keys(this.pendingRequests)) {
              const t = this.pendingRequests[e];
              if (t && new Date() - t._created > 2e4) {
                if (this.noResponseForStatus(t.status))
                  console.log("Dropping stale: " + e);
                else {
                  if (t.awaitingPayload) {
                    console.log(`Waiting for payload for ${t.url}`);
                    continue;
                  }
                  console.log(`Committing stale ${t.status} ${t.url}`),
                    await this.fullCommit(t, []);
                }
                delete this.pendingRequests[e];
              }
            }
            this._cachePageInfo &&
              (await this._doAddPage(this._cachePageInfo),
              (this._cachePageInfo = null)),
              this._cacheSessionTotal > 0 &&
                (await this._doIncSizes(
                  this._cacheSessionTotal,
                  this._cacheSessionNew
                ),
                (this._cacheSessionTotal = 0),
                (this._cacheSessionNew = 0));
          } finally {
            this._cleaningUp = !1;
          }
        }
        updateStatus() {
          const e = Object.keys(this.pendingRequests).length;
          (this.numPending = e + this._fetchPending.size),
            0 === e && this._loadedDoneResolve && this._loadedDoneResolve(),
            this.doUpdateStatus();
        }
        getStatusMsg() {
          return {
            recording: this.running,
            firstPageStarted: this.firstPageStarted,
            behaviorState: this.behaviorState,
            behaviorData: this.behaviorData,
            autorun: this.autorun,
            sizeTotal: this.sizeTotal,
            sizeNew: this.sizeNew,
            numUrls: this.numUrls,
            numPages: this.numPages,
            numPending: this.numPending,
            pageUrl: this.pageInfo.url,
            pageTs: this.pageInfo.ts,
            failureMsg: this.failureMsg,
            collId: this.collId,
            stopping: this.stopping,
            type: "status",
          };
        }
        async _doInjectTopFrame() {
          await this.newDocEval(Bs, this.getInjectScript()),
            await this.exposeFunction(Ds, ({ data: e, type: t }) => {
              if ("info" === t) (this.behaviorData = e), this.updateStatus();
            });
        }
        async newDocEval(e, t) {
          (t += "\n\n//# sourceURL=" + e),
            await this.send("Page.addScriptToEvaluateOnNewDocument", {
              source: t,
            });
        }
        pageEval(e, t, r = []) {
          return (
            (t += "\n\n//# sourceURL=" + e),
            this.send(
              "Runtime.evaluate",
              {
                expression: t,
                userGesture: !0,
                includeCommandLineAPI: !0,
                allowUnsafeEvalBlockedByCSP: !0,
                awaitPromise: !0,
              },
              r
            )
          );
        }
        async _doInjectIframe(e) {
          try {
            await this.pageEval(
              "__awp_iframe_inject__",
              this.getInjectScript(),
              e
            );
          } catch (e) {
            console.warn(e);
          }
        }
        async toggleBehaviors() {
          switch (this.behaviorState) {
            case t:
            case o:
              break;
            case s:
              this.pageEval(
                "__awp_behavior_run__",
                "self.__bx_behaviors.run();"
              ).then(() => (this.behaviorState = o)),
                (this.behaviorState = a);
              break;
            case a:
              this.pageEval(
                "__awp_behavior_unpause__",
                "self.__bx_behaviors.pause();"
              ),
                (this.behaviorState = n);
              break;
            case n:
              this.pageEval(
                "__awp_behavior_unpause__",
                "self.__bx_behaviors.unpause();"
              ),
                (this.behaviorState = a);
          }
          this.updateStatus();
        }
        async exposeFunction(e, t, r = []) {
          (this._bindings[e] = t),
            await this.send("Runtime.addBinding", { name: e }, r);
        }
        loaded() {
          return (
            (this._loaded = new Promise((e) => (this._loadedDoneResolve = e))),
            this._loaded
          );
        }
        async start() {
          (this.firstPageStarted = !1),
            await this.send("Page.enable"),
            await this.send("Runtime.enable"),
            await this.send("DOMSnapshot.enable"),
            await this.initPixRatio(),
            await this._doInjectTopFrame(),
            await this.sessionInit([]),
            (this.failureMsg = null);
        }
        async initPixRatio() {
          const { result: e } = await this.pageEval(
            "__awp_get_pix_ratio",
            "window.devicePixelRatio"
          );
          e && "number" === e.type && (this.pixelRatio = e.value);
        }
        async sessionInit(e) {
          try {
            await this.send("Network.enable", null, e);
            try {
              await this.send(
                "Fetch.enable",
                { patterns: [{ urlPattern: "*", requestStage: "Response" }] },
                e
              );
            } catch (e) {
              console.log("No Fetch Available", e);
            }
            try {
              await this.send("Media.enable", null, e);
            } catch (e) {
              console.log("No media events available");
            }
            await this.send(
              "Target.setAutoAttach",
              {
                autoAttach: !0,
                waitForDebuggerOnStart: !0,
                flatten: this.flatMode,
              },
              e
            ),
              await this.send(
                "Network.setCacheDisabled",
                { cacheDisabled: !0 },
                e
              ),
              await this.send(
                "Network.setBypassServiceWorker",
                { bypass: !0 },
                e
              ),
              await this.send("Network.clearBrowserCache", null, e);
          } catch (e) {
            console.warn("Session Init Error: "), console.log(e);
          }
        }
        async sessionClose(e = []) {
          await this.send("Page.disable"),
            await this.send("Runtime.disable"),
            await this.send("DOMSnapshot.disable"),
            await this.send("Debugger.disable"),
            await this.send("Network.disable", null, e),
            await this.send("Fetch.disable", null, e);
          try {
            await this.send("Media.disable", null, e);
          } catch (e) {}
          await this.send("Target.setAutoAttach", {
            autoAttach: !1,
            waitForDebuggerOnStart: !1,
          }),
            await this.send("Network.setBypassServiceWorker", { bypass: !1 }, e);
        }
        pendingReqResp(e, t = !1) {
          if (this.pendingRequests[e])
            e !== this.pendingRequests[e].requestId &&
              console.error("Wrong Req Id!");
          else {
            if (t || !e) return null;
            this.pendingRequests[e] = new ks(e);
          }
          return this.pendingRequests[e];
        }
        removeReqResp(e) {
          const t = this.pendingRequests[e];
          return delete this.pendingRequests[e], t;
        }
        async processMessage(e, t, r) {
          switch (e) {
            case "Target.attachedToTarget":
              r.push(t.sessionId);
              try {
                this.sessionSet.add(t.sessionId);
                const e = t.targetInfo.type,
                  i = "service_worker" !== e;
                if (
                  (i && (await this.sessionInit(r)),
                  t.waitingForDebugger &&
                    (await this.send("Runtime.runIfWaitingForDebugger", null, r)),
                  i)
                )
                  console.log(
                    "Target Attached: " +
                      e +
                      " " +
                      t.targetInfo.url +
                      " " +
                      t.sessionId
                  ),
                    ("page" !== e && "iframe" !== e) ||
                      (await this._doInjectIframe(r));
                else {
                  console.log(
                    "Not allowed attach for: " +
                      e +
                      " " +
                      t.targetInfo.url +
                      " " +
                      t.sessionId
                  );
                  const i = this.flatMode
                    ? { sessionId: t.sessionId }
                    : { targetId: t.targetInfo.targetId };
                  await this.send("Runtime.runIfWaitingForDebugger", i, r);
                }
              } catch (e) {
                console.log(e),
                  console.warn(
                    "Error attaching target: " +
                      t.targetInfo.type +
                      " " +
                      t.targetInfo.url
                  );
              }
              break;
            case "Target.detachedFromTarget":
              console.log("Detaching from: " + t.sessionId),
                this.sessionSet.delete(t.sessionId);
              break;
            case "Target.receivedMessageFromTarget":
              if (!this.sessionSet.has(t.sessionId))
                return (
                  console.warn("no such session: " + t.sessionId),
                  void console.warn(t)
                );
              r.push(t.sessionId), this.receiveMessageFromTarget(t, r);
              break;
            case "Network.responseReceived":
              if (t.response) {
                const e = this.pendingReqResp(t.requestId, !0);
                e && e.fillResponseReceived(t);
              }
              break;
            case "Network.loadingFinished":
              await this.handleLoadingFinished(t, r);
              break;
            case "Network.loadingFailed": {
              const e = this.removeReqResp(t.requestId);
              e &&
                206 !== e.status &&
                ("Document" === t.type &&
                "net::ERR_ABORTED" === t.errorText &&
                e.isValidBinary()
                  ? this.fullCommit(e, r)
                  : console.log(`Loading Failed for: ${e.url} ${t.errorText}`));
              break;
            }
            case "Network.requestServedFromCache":
              this.removeReqResp(t.requestId);
              break;
            case "Network.responseReceivedExtraInfo":
              {
                const e = this.pendingReqResp(t.requestId, !0);
                e && e.fillResponseReceivedExtraInfo(t);
              }
              break;
            case "Network.requestWillBeSent":
              await this.handleRequestWillBeSent(t);
              break;
            case "Network.requestWillBeSentExtraInfo":
              this.shouldSkip(null, t.headers, null) ||
                (this.pendingReqResp(t.requestId).requestHeaders = t.headers);
              break;
            case "Fetch.requestPaused":
              await this.handlePaused(t, r);
              break;
            case "Page.frameNavigated":
              this.initPage(t, r);
              break;
            case "Page.loadEventFired":
              await this.updatePage(r);
              break;
            case "Page.navigatedWithinDocument":
              await this.updateHistory(r);
              break;
            case "Page.windowOpen":
              this.handleWindowOpen(t.url, r);
              break;
            case "Page.javascriptDialogOpening":
              this.behaviorState === a &&
                (await this.send("Page.handleJavaScriptDialog", { accept: !1 }));
              break;
            case "Debugger.paused":
              t.data &&
                "listener:beforeunload" === t.data.eventName &&
                (await this.unpauseAndFinish(t));
              break;
            case "Media.playerEventsAdded":
              this.parseMediaEventsAdded(t, r);
              break;
            case "Runtime.bindingCalled":
              this._bindings[t.name] &&
                this._bindings[t.name](JSON.parse(t.payload));
              break;
            default:
              return !1;
          }
          return !0;
        }
        handleWindowOpen(e, t) {
          const r = { Referer: this.pageInfo.url };
          this.doAsyncFetch({ url: e, headers: r, redirectOnly: !0 }, t);
        }
        isPagePDF() {
          return "application/pdf" === this.pageInfo.mime;
        }
        async extractPDFText() {
          let e = !1;
          if ((console.log("pdfLoadURL", this.pdfLoadURL), this.pdfLoadURL)) {
            const t = await this.pageEval(
              "__awp_pdf_extract__",
              `\n      async function getPDFText(url) {\n  url = url || window.location.href;\n\n  // eslint-disable-next-line no-undef\n  let doc = pdfjsLib.getDocument(url);\n  doc = await doc.promise;\n\n  const strings = [];\n\n  for (let i = 1; i <= doc.numPages; i++) {\n    const page = await doc.getPage(i);\n    const textContent = await page.getTextContent();\n    textContent.items.map(item => strings.push(item.str));\n    console.log("Processing Page: " + i);\n  }\n\n  return strings.join(" ").replace(/[\\W]+/g, " ");\n}\n\n// eslint-disable-next-line no-unused-vars\nasync function extractPDF(url, baseUrl) {\n  let pdfText = null;\n\n  try {\n    const res = await fetch(new URL("pdf/pdf.min.js", baseUrl).href);\n    eval(await res.text());\n    \n    //pdfjsLib should now exist\n    // eslint-disable-next-line no-undef\n    pdfjsLib.GlobalWorkerOptions.workerSrc = new URL("pdf/pdf.worker.min.js", baseUrl).href;\n    \n    if (url || document.querySelector("embed[type='application/pdf']")) {\n      pdfText = await getPDFText(url);\n    } else {\n      console.log("Not a pdf: " + window.location.href);\n    }\n  } catch (e) {\n    console.log(e);\n    pdfText = "";\n  }\n\n  return pdfText;\n}\n\n;\n\n      extractPDF("${
                this.pdfLoadURL
              }", "${this.getExternalInjectURL("")}");\n      `
            );
            if (t.result) {
              const { type: r, value: i } = t.result;
              "string" === r && ((this.pageInfo.text = i), (e = !0));
            }
          }
          return e;
        }
        async getFullText(e = !1) {
          if (!this.pageInfo || !this.pageInfo.url) return null;
          if (this.isPagePDF() && !e) return await this.extractPDFText(), null;
          try {
            return await Promise.race([
              this.send("DOMSnapshot.captureSnapshot", { computedStyles: [] }),
              Os(1e4),
            ]);
          } catch (e) {
            return console.log(e), null;
          }
        }
        async unpauseAndFinish(e) {
          let r = null;
          const i = e.callFrames[0].url === Bs;
          i && this.behaviorState !== t && (r = await this.getFullText(!0));
          const s = this.pageInfo;
          try {
            await this.send("Debugger.resume");
          } catch (e) {
            console.warn(e);
          }
          this.behaviorState === a && (await this.toggleBehaviors()),
            i &&
              this.behaviorState !== t &&
              (this.flushPending(), await this.commitPage(s, r, !0));
        }
        commitPage(e, t, r) {
          if (!e || !e.url || !e.ts || "about:blank" === e.url) return;
          t
            ? (e.text = this.parseTextFromDOMSnapshot(t))
            : e.text || console.warn("No Full Text Update"),
            (e.finished = r);
          const i = this._doAddPage(e);
          return e === this._cachePageInfo && (this._cachePageInfo = null), i;
        }
        async commitResource(e, t) {
          const r = e.payload.length;
          ((t = t || this.pageInfo).size += r),
            (this.sizeTotal += r),
            this.numUrls++;
          const i = await this._doAddResource(e);
          (this.sizeNew += i),
            (this._cachePageInfo = t),
            (this._cacheSessionTotal += r),
            (this._cacheSessionNew += i);
        }
        receiveMessageFromTarget(e, t) {
          const r = JSON.parse(e.message);
          if (null != r.id) {
            const e = this._promises[r.id];
            e &&
              (r.error ? e.reject(r.error) : e.resolve(r.result),
              delete this._promises[r.id]);
          } else null != r.params && this.processMessage(r.method, r.params, t);
        }
        newPageId() {
          return (
            Math.random().toString(36).substring(2, 15) +
            Math.random().toString(36).substring(2, 15)
          );
        }
        initPage(e, t) {
          if (e.frame.parentId) return !1;
          this.frameId != e.frame.id && (this.historyMap = {}),
            (this.frameId = e.frame.id),
            (this.loaderId = e.frame.loaderId),
            this._initNewPage(e.frame.url, e.frame.mimeType);
          const r = this.removeReqResp(this.loaderId);
          return r && this.fullCommit(r, t), !0;
        }
        async initFirstPage() {
          this.updateStatus(), (this.firstPageStarted = !0);
        }
        _initNewPage(e, r) {
          (this.pageInfo = {
            id: this.newPageId(),
            url: e,
            ts: 0,
            title: "",
            text: "",
            size: 0,
            finished: !1,
            favIconUrl: "",
            mime: r,
          }),
            (this.pdfLoadURL = null),
            (this.behaviorState = t),
            (this.behaviorData = null),
            this.numPages++,
            this._fetchUrls.clear(),
            this.firstPageStarted || this.initFirstPage(),
            (this.behaviorState = t);
        }
        loadFavIcon(e, t) {
          e &&
            this.pageInfo &&
            this.pageInfo.favIconUrl != e &&
            ((this.pageInfo.favIconUrl = e), this.doAsyncFetch({ url: e }, t));
        }
        async updatePage(e) {
          this.pageInfo || console.warn("no page info!");
          const t = await this.send("Page.getNavigationHistory"),
            r = t.currentIndex;
          (this.historyMap[r] = t.entries[r].url),
            (this.pageInfo.title = t.entries[r].title || t.entries[r].url);
          const i = this.pageInfo,
            [n, a] = await Promise.all([this.getFullText(), this.getFavIcon()]);
          a && this.loadFavIcon(a, e),
            await this.commitPage(this.pageInfo, n, !1),
            this.updateStatus(),
            await this.loaded(),
            i === this.pageInfo &&
              ((this.behaviorState = s),
              this.autorun && (await this.toggleBehaviors()));
        }
        async updateHistory(e) {
          if (e.length) return;
          const t = await this.send("Page.getNavigationHistory", null, e),
            r = t.currentIndex;
          r === t.entries.length - 1 &&
            this.historyMap[r] !== t.entries[r].url &&
            (this.historyMap[r] = t.entries[r].url);
        }
        shouldSkip(e, t, r) {
          return (
            t && !e && (e = t[":method"]),
            "OPTIONS" === e ||
              "HEAD" === e ||
              !!["EventSource", "WebSocket", "Ping"].includes(r) ||
              ("Other" === r && "POST" === e) ||
              !(
                !t ||
                ("text/event-stream" !== t.accept &&
                  "text/event-stream" !== t.Accept)
              )
          );
        }
        async handlePaused(e, t) {
          let r = !1,
            i = null,
            s = !1;
          this.shouldSkip(e.request.method, e.request.headers, e.resourceType)
            ? (s = !0)
            : e.responseStatusCode || e.responseErrorReason || (s = !0);
          try {
            if (!s) {
              i = await this.handleFetchResponse(e, t);
              try {
                i && i.payload && (r = await this.rewriteResponse(e, i, t));
              } catch (t) {
                console.error("Fetch rewrite failed for: " + e.request.url),
                  console.error(t);
              }
            }
          } catch (e) {
            console.warn(e);
          }
          if (!r)
            try {
              await this.send(
                "Fetch.continueResponse",
                { requestId: e.requestId },
                t
              );
            } catch (t) {
              console.warn("Continue failed for: " + e.request.url, t);
            }
          i &&
            i.payload &&
            i.payload.length &&
            e.frameId === this.frameId &&
            !isNaN(Number(i.requestId)) &&
            (this.removeReqResp(i.requestId), this.fullCommit(i, t));
        }
        async rewriteResponse(e, t, r) {
          if (!t || !t.payload) return !1;
          const i = t.payload;
          if (!i.length) return !1;
          let s = null,
            n = null;
          const { url: a, extraOpts: o } = t,
            c = this._getContentType(e.responseHeaders);
          switch (c) {
            case "application/x-mpegURL":
            case "application/vnd.apple.mpegurl":
              (n = i.toString("utf-8")),
                (s = (function (e, t) {
                  const r = /#EXT-X-STREAM-INF:(?:.*[,])?BANDWIDTH=([\d]+)/,
                    i = /RESOLUTION=([\d]+)x([\d]+)/,
                    { maxRes: s, maxBand: n } = A(t);
                  let a = [],
                    o = 0,
                    c = null,
                    l = 0,
                    h = 0,
                    u = e.trimEnd().split("\n");
                  for (const e of u) {
                    const d = e.match(r);
                    if (!d) {
                      t &&
                        t.rewriteUrl &&
                        !e.startsWith("#") &&
                        (u[o] = t.rewriteUrl(e)),
                        (o += 1);
                      continue;
                    }
                    a.push(o);
                    const p = Number(d[1]),
                      f = e.match(i),
                      g = f ? Number(f[1]) * Number(f[2]) : 0;
                    g && s
                      ? g <= s && g > h && ((h = g), (l = p), (c = o))
                      : p <= n && p > l && ((h = g), (l = p), (c = o)),
                      (o += 1);
                  }
                  a.reverse();
                  for (const e of a) e !== c && u.splice(e, 2);
                  return u.join("\n");
                })(n, { save: t.extraOpts }));
              break;
            case "application/dash+xml":
              (n = i.toString("utf-8")), (s = E(n, { save: t.extraOpts }));
              break;
            case "text/html":
            case "application/json":
            case "text/javascript":
            case "application/javascript":
            case "application/x-javascript": {
              const e = Ts(a, "text/html" === c);
              e &&
                ((n = i.toString()), (s = e.rewrite(n, { live: !0, save: o })));
            }
          }
          if (!s) return !1;
          s !== n &&
            ((t.extraOpts.rewritten = 1),
            (t.payload = Rs.encode(s)),
            console.log("Rewritten Response for: " + e.request.url));
          const l = ws.Buffer.from(s).toString("base64");
          try {
            return (
              await this.send(
                "Fetch.fulfillRequest",
                {
                  requestId: e.requestId,
                  responseCode: e.responseStatusCode,
                  responseHeaders: e.responseHeaders,
                  body: l,
                },
                r
              ),
              !0
            );
          } catch (t) {
            console.warn("Fulfill Failed for: " + e.request.url + " " + t);
          }
          return !1;
        }
        _getContentType(e) {
          for (let t of e)
            if ("content-type" === t.name.toLowerCase())
              return t.value.split(";")[0];
          return null;
        }
        noResponseForStatus(e) {
          return !e || 204 === e || (e >= 300 && e < 400);
        }
        isValidUrl(e) {
          return e && (e.startsWith("https:") || e.startsWith("http:"));
        }
        async handleLoadingFinished(e, t) {
          const r = this.removeReqResp(e.requestId);
          if (!r || !r.url) return;
          if (!this.isValidUrl(r.url)) return;
          let i = r.payload;
          if (!r.fetch && !i) {
            if (
              (e.encodedDataLength &&
                (i = await this.fetchPayloads(
                  e,
                  r,
                  t,
                  "Network.getResponseBody"
                )),
              !i || !i.length)
            )
              return;
            r.payload = i;
          }
          this.fullCommit(r, t);
        }
        async fullCommit(e, t) {
          try {
            const r = e.toDBRecord(e.payload, this.pageInfo);
            if (
              (r &&
                r.requestUrl &&
                r.requestUrl === this.pageInfo.url &&
                !t.length &&
                (this.pageInfo.url = r.url),
              r && !t.length && e.url === this.pageInfo.url)
            )
              if (
                ((this.pageInfo.ts = e.ts),
                "application/pdf" === r.mime && e.payload && this.pageInfo)
              )
                (this.pageInfo.mime = "application/pdf"),
                  (this.pdfLoadURL = e.url);
              else {
                r.extraOpts || (r.extraOpts = {}),
                  (r.extraOpts.pixelRatio = this.pixelRatio);
                const t = await this.getStorage(e.url);
                t && (r.extraOpts.storage = t);
              }
            r && (await this.commitResource(r));
          } catch (e) {
            console.log("error committing", e);
          }
        }
        async getStorage(e) {
          if (!this.recordStorage) return null;
          const t = { securityOrigin: new URL(e).origin, isLocalStorage: !0 },
            r = await this.send("DOMStorage.getDOMStorageItems", {
              storageId: t,
            });
          t.isLocalStorage = !1;
          const i = await this.send("DOMStorage.getDOMStorageItems", {
            storageId: t,
          });
          return JSON.stringify({ local: r.entries, session: i.entries });
        }
        async handleRequestWillBeSent(e) {
          if (this.shouldSkip(e.request.method, e.request.headers, e.type))
            return void this.removeReqResp(e.requestId);
          const t = this.pendingReqResp(e.requestId);
          let r = null;
          if (e.redirectResponse) {
            if (t.isSelfRedirect())
              return (
                console.warn(`Skip self redirect: ${t.url}`),
                void this.removeReqResp(e.requestId)
              );
            t.fillResponseRedirect(e), (r = t.toDBRecord(null, this.pageInfo));
          }
          t.fillRequest(e), r && (await this.commitResource(r));
        }
        async handleFetchResponse(e, t) {
          if ((e.networkId, this.pdfLoadURL && e.request.url === this.pdfLoadURL))
            return null;
          const r = e.networkId || e.requestId,
            i = this.pendingReqResp(r);
          return (
            i.fillFetchRequestPaused(e),
            (i.payload = await this.fetchPayloads(
              e,
              i,
              t,
              "Fetch.getResponseBody"
            )),
            206 === i.status && this.removeReqResp(r),
            i
          );
        }
        parseMediaEventsAdded(e, t) {
          if (this.pageInfo.id)
            for (const { value: r } of e.events)
              if (r.indexOf('"kLoad"') > 0) {
                const { url: e } = JSON.parse(r);
                this.doAsyncFetch({ url: e }, t);
                break;
              }
        }
        async attemptFetchRedirect(e, t) {
          if (e.redirectOnly && "opaqueredirect" === t.type) {
            const r = new AbortController();
            if (((t = await fetch(e.url, { abort: r })), r.abort(), t.redirected))
              return (
                console.warn(`Adding synthetic redirect ${e.url} -> ${t.url}`),
                Response.redirect(t.url, 302)
              );
          }
          return (
            console.warn(
              `async fetch error ${t.status}, opaque due to redirect, retrying in browser`
            ),
            await this.doAsyncFetchInBrowser(e, e.sessions, !0),
            null
          );
        }
        async doAsyncFetchInBrowser(e, t) {
          this._fetchUrls.add(e.url);
          const r = `self.__bx_behaviors.doAsyncFetch("${e.url}")`;
          console.log("Start Async Load: " + e.url),
            await this.pageEval("__awp_async_fetch__", r, t);
        }
        async doAsyncFetch(e, t) {
          e &&
            this.isValidUrl(e.url) &&
            (this._fetchUrls.has(e.url)
              ? console.log("Skipping, already fetching: " + e.url)
              : ((e.pageInfo = this.pageInfo),
                (e.sessions = t),
                this._fetchQueue.push(e),
                this.doBackgroundFetch()));
        }
        async doBackgroundFetch() {
          if (
            !this._fetchQueue.length ||
            this._fetchPending.size >= 6 ||
            this.stopping
          )
            return;
          const e = this._fetchQueue.shift();
          if (this._fetchUrls.has(e.url))
            return void console.log("Skipping, already fetching: " + e.url);
          let t;
          const r = "fetch-" + this.newPageId();
          try {
            console.log("Start Async Load: " + e.url), this._fetchUrls.add(e.url);
            const i = new Promise((e) => {
              t = e;
            });
            this._fetchPending.set(r, i);
            const s = { ...this.defaultFetchOpts };
            e.getRequestHeadersDict
              ? ((s.headers = e.getRequestHeadersDict().headers),
                s.headers.delete("range"))
              : e.headers && (s.headers = e.headers);
            let n = await fetch(e.url, s);
            if (0 === n.status) {
              if (((n = await this.attemptFetchRedirect(e, n)), !n)) return;
            } else if (
              n.status >= 400 &&
              (console.warn(
                `async fetch error ${n.status}, retrying without headers`
              ),
              (n = await fetch(e.url, this.defaultFetchOpts)),
              n.status >= 400)
            )
              return (
                console.warn(
                  `async fetch returned: ${n.status}, trying in-browser fetch`
                ),
                void (await this.doAsyncFetchInBrowser(e, e.sessions, !0))
              );
            const a = await n.arrayBuffer(),
              o = new ks(r);
            (o.status = n.status),
              (o.statusText = n.statusText),
              (o.responseHeaders = Object.fromEntries(n.headers)),
              (o.method = "GET"),
              (o.url = e.url),
              (o.payload = new Uint8Array(a));
            const c = o.toDBRecord(o.payload, e.pageInfo);
            c
              ? (await this.commitResource(c, e.pageInfo),
                console.log(`Done Async Load (${n.status}) ${e.url}`),
                this.pageInfo !== e.pageInfo &&
                  (await this.commitPage(e.pageInfo)))
              : console.warn(
                  "No Data Committed for: " + e.url + " Status: " + n.status
                );
          } catch (t) {
            console.log(t), this._fetchUrls.delete(e.url);
          } finally {
            t(), this._fetchPending.delete(r);
          }
        }
        async fetchPayloads(e, t, r, i) {
          let s;
          if (206 === t.status)
            return (
              Os(500).then(() => this.doAsyncFetch(t, r)),
              (t.payload = null),
              null
            );
          if (this.noResponseForStatus(t.status)) s = ws.Buffer.from([]);
          else
            try {
              (t.awaitingPayload = !0),
                (s = await this.send(i, { requestId: e.requestId }, r)),
                (s = s.base64Encoded
                  ? ws.Buffer.from(s.body, "base64")
                  : ws.Buffer.from(s.body, "utf-8"));
            } catch (e) {
              return (
                console.warn(
                  "no buffer for: " +
                    t.url +
                    " " +
                    t.status +
                    " " +
                    t.requestId +
                    " " +
                    i
                ),
                console.warn(e),
                null
              );
            } finally {
              t.awaitingPayload = !1;
            }
          if (t.hasPostData && !t.postData)
            try {
              let e = await this.send(
                "Network.getRequestPostData",
                { requestId: t.requestId },
                r
              );
              t.postData = ws.Buffer.from(e.postData, "utf-8");
            } catch (e) {
              console.warn("Error getting POST data: " + e);
            }
          return (t.payload = s), s;
        }
        flushPending() {
          const e = this.pendingRequests,
            t = this.pageInfo;
          if (((this.pendingRequests = {}), e))
            for (const [r, i] of Object.entries(e))
              if (i.payload) {
                console.log(`Committing Finished ${r} - ${i.url}`);
                const e = i.toDBRecord(i.payload, t);
                e && this.commitResource(e),
                  e && i.url === t.url && (t.ts = i.ts);
              } else console.log(`Discarding Payload-less ${i.url}`);
        }
        send(e, t = null, r = []) {
          let i = null;
          if (this.flatMode && r.length)
            return this._doSendCommandFlat(e, t, r[r.length - 1]);
          for (let s = r.length - 1; s >= 0; s--) {
            const n = this.id++,
              a = new Promise((t, r) => {
                this._promises[n] = { resolve: t, reject: r, method: e };
              });
            i || (i = a);
            const o = JSON.stringify({ id: n, method: e, params: t });
            (t = { sessionId: r[s], message: o }),
              (e = "Target.sendMessageToTarget");
          }
          return this._doSendCommand(e, t, i);
        }
        parseTextFromDOMSnapshot(e) {
          const t = [
              "SCRIPT",
              "STYLE",
              "HEADER",
              "FOOTER",
              "BANNER-DIV",
              "NOSCRIPT",
            ],
            { strings: r, documents: i } = e,
            s = [];
          for (const e of i) {
            const i = e.nodes.nodeValue,
              n = e.nodes.nodeName,
              a = e.nodes.nodeType,
              o = e.nodes.parentIndex;
            for (let e = 0; e < i.length; e++)
              if (-1 !== i[e] && 3 === a[e]) {
                const c = o[e];
                if (c >= 0 && 1 === a[c]) {
                  const a = r[n[c]];
                  if (!t.includes(a)) {
                    const t = r[i[e]].trim();
                    t && s.push(t);
                  }
                }
              }
            return s.join("\n");
          }
        }
      }
      const Ps = navigator.userAgent.includes("agregore-browser");
      class Us extends Ls {
        constructor(
          e,
          {
            collId: t,
            collLoader: r,
            waitForTabUpdate: i = !1,
            openUrl: s = null,
            port: n = null,
            openWinMap: a = null,
            autorun: o = !1,
          }
        ) {
          super(),
            (this.openUrl = s),
            (this.waitForTabUpdate = i),
            (this.debuggee = e),
            (this.tabId = e.tabId),
            (this.openWinMap = a),
            (this.autorun = o),
            (this.isAttached = !1),
            (this.flatMode = Ps),
            (this.collLoader = r),
            this.setCollId(t),
            (this.port = n),
            (this.recordStorage = !1),
            l("recordStorage").then((e) => (this.recordStorage = !!e)),
            (this._onDetached = (e, t) => {
              (e && this.tabId !== e.tabId) ||
                ((this.isAttached = !1),
                "target_closed" === t && (this.tabId = 0),
                this._stop());
            }),
            (this._onCanceled = (e) => {
              e && e.tabId == this.tabId && this.detach();
            }),
            (this._onEvent = async (e, t, r, i) => {
              if (this.tabId === e.tabId)
                try {
                  const e = i ? [i] : [];
                  await this.processMessage(t, r, e);
                } catch (e) {
                  console.warn(e), console.log(t), console.log(r);
                }
            });
        }
        getExternalInjectURL(e) {
          return chrome.runtime.getURL(e);
        }
        setCollId(e) {
          (e === this.collId && this.db) ||
            ((this.collId = e),
            (this.db = null),
            (this._initDB = this.collLoader.loadColl(this.collId)));
        }
        _doDetach() {
          let e = 0;
          for (const t of Object.values(self.recorders))
            t.tabId !== this.tabId && t.running && e++;
          return e > 0
            ? (console.log(
                `closing session, not detaching, ${e} other recording tab(s) left`
              ),
              this.sessionClose([]))
            : (console.log("detaching debugger, already tabs stopped"),
              new Promise((e) => {
                chrome.debugger.detach(this.debuggee, () => {
                  chrome.runtime.lastError &&
                    console.warn(chrome.runtime.lastError.message),
                    (this.isAttached = !1),
                    e();
                });
              }));
        }
        _doStop() {
          this.isAttached ||
            chrome.debugger.onDetach.removeListener(this._onDetached),
            chrome.debugger.onEvent.removeListener(this._onEvent),
            this.db && (this.db.close(), (this.db = null), (this._initDB = null)),
            this.tabId && this.doUpdateStatus();
        }
        async _doAttach() {
          (this.waitForTabUpdate = !1),
            this.isAttached ||
              chrome.debugger.onDetach.addListener(this._onDetached),
            chrome.debugger.onEvent.addListener(this._onEvent);
          const e = await this._initDB;
          if (!e) throw new Error("Collection Not Found");
          this.db = e.store;
          try {
            this.isAttached ||
              (await new Promise((e, t) => {
                chrome.debugger.attach(this.debuggee, "1.3", async () => {
                  chrome.runtime.lastError && t(chrome.runtime.lastError.message),
                    (this.isAttached = !0),
                    e();
                });
              })),
              await this.start(),
              (this.failureMsg = null),
              this.openUrl
                ? await this.send("Page.navigate", { url: this.openUrl })
                : await this.send("Page.reload", {
                    ignoreCache: !0,
                    scriptToEvaluateOnLoad: this.getInjectScript(),
                  }),
              this.doUpdateStatus();
          } catch (e) {
            throw (
              ((this.failureMsg = chrome.runtime.lastError
                ? chrome.runtime.lastError.message
                : e),
              this.doUpdateStatus(),
              e)
            );
          }
        }
        doUpdateStatus() {
          let e, t, r;
          const i = this.tabId;
          if (
            (this.running
              ? this.behaviorState === a
                ? ((e = "Archiving: Autopilot Running!"),
                  (t = "#3298dc"),
                  (r = " "))
                : 0 === this.numPending
                ? ((e = "Archiving: No URLs pending, can continue"),
                  (t = "#64e986"),
                  (r = " "))
                : ((e = `Archiving: ${this.numPending} URLs pending, please wait`),
                  (t = "#bb9f08"),
                  (r = "" + this.numPending))
              : this.failureMsg
              ? ((e = "Error: Can't Archive this page"), (r = "X"), (t = "#F00"))
              : ((e = "Not Archiving"), (r = ""), (t = "#64e986")),
            chrome.action.setTitle({ title: e, tabId: i }),
            chrome.action.setBadgeBackgroundColor({ color: t, tabId: i }),
            chrome.action.setBadgeText({ text: r, tabId: i }),
            this.port)
          ) {
            const e = this.getStatusMsg();
            this.port.postMessage(e);
          }
        }
        getFavIcon() {
          return new Promise((e) => {
            chrome.tabs.get(this.tabId, (t) => {
              e(t.favIconUrl);
            });
          });
        }
        async _doAddResource(e) {
          let t = 0;
          const r = e.payload.length;
          try {
            await this.db.initing, (await this.db.addResource(e)) && (t = r);
          } catch (t) {
            return (
              console.warn(`Commit error for ${e.url} @ ${e.ts} ${e.mime}`),
              void console.warn(t)
            );
          }
          return t;
        }
        _doAddPage(e) {
          if (e.url) return this.db ? this.db.addPage(e) : void 0;
          console.warn("Empty Page, Skipping");
        }
        _doIncSizes(e, t) {
          this.collLoader.updateSize(this.collId, e, t);
        }
        _doSendCommand(e, t, r) {
          let i;
          const s = new Promise((t, r) => {
            i = { resolve: t, reject: r, method: e };
          });
          r || (r = s);
          return (
            chrome.debugger.sendCommand(this.debuggee, e, t, (e) => {
              e
                ? i.resolve(e)
                : i.reject(
                    chrome.runtime.lastError
                      ? chrome.runtime.lastError.message
                      : ""
                  );
            }),
            r
          );
        }
        _doSendCommandFlat(e, t, r) {
          try {
            return chrome.debugger.sendCommand(this.debuggee, e, t, r);
          } catch (e) {
            console.warn(e);
          }
        }
        handleWindowOpen(e, t) {
          super.handleWindowOpen(e, t), this.openWinMap.set(e, this.collId);
        }
      }
      const Ms = (e, t) => t.some((t) => e instanceof t);
      let Fs, Hs;
      const Qs = new WeakMap(),
        Vs = new WeakMap(),
        zs = new WeakMap(),
        qs = new WeakMap(),
        Gs = new WeakMap();
      let js = {
        get(e, t, r) {
          if (e instanceof IDBTransaction) {
            if ("done" === t) return Vs.get(e);
            if ("objectStoreNames" === t) return e.objectStoreNames || zs.get(e);
            if ("store" === t)
              return r.objectStoreNames[1]
                ? void 0
                : r.objectStore(r.objectStoreNames[0]);
          }
          return Ks(e[t]);
        },
        set: (e, t, r) => ((e[t] = r), !0),
        has: (e, t) =>
          (e instanceof IDBTransaction && ("done" === t || "store" === t)) ||
          t in e,
      };
      function Ws(e) {
        js = e(js);
      }
      function Ys(e) {
        return e !== IDBDatabase.prototype.transaction ||
          "objectStoreNames" in IDBTransaction.prototype
          ? (
              Hs ||
              (Hs = [
                IDBCursor.prototype.advance,
                IDBCursor.prototype.continue,
                IDBCursor.prototype.continuePrimaryKey,
              ])
            ).includes(e)
            ? function (...t) {
                return e.apply(Js(this), t), Ks(Qs.get(this));
              }
            : function (...t) {
                return Ks(e.apply(Js(this), t));
              }
          : function (t, ...r) {
              const i = e.call(Js(this), t, ...r);
              return zs.set(i, t.sort ? t.sort() : [t]), Ks(i);
            };
      }
      function Xs(e) {
        return "function" == typeof e
          ? Ys(e)
          : (e instanceof IDBTransaction &&
              (function (e) {
                if (Vs.has(e)) return;
                const t = new Promise((t, r) => {
                  const i = () => {
                      e.removeEventListener("complete", s),
                        e.removeEventListener("error", n),
                        e.removeEventListener("abort", n);
                    },
                    s = () => {
                      t(), i();
                    },
                    n = () => {
                      r(e.error || new DOMException("AbortError", "AbortError")),
                        i();
                    };
                  e.addEventListener("complete", s),
                    e.addEventListener("error", n),
                    e.addEventListener("abort", n);
                });
                Vs.set(e, t);
              })(e),
            Ms(
              e,
              Fs ||
                (Fs = [
                  IDBDatabase,
                  IDBObjectStore,
                  IDBIndex,
                  IDBCursor,
                  IDBTransaction,
                ])
            )
              ? new Proxy(e, js)
              : e);
      }
      function Ks(e) {
        if (e instanceof IDBRequest)
          return (function (e) {
            const t = new Promise((t, r) => {
              const i = () => {
                  e.removeEventListener("success", s),
                    e.removeEventListener("error", n);
                },
                s = () => {
                  t(Ks(e.result)), i();
                },
                n = () => {
                  r(e.error), i();
                };
              e.addEventListener("success", s), e.addEventListener("error", n);
            });
            return (
              t
                .then((t) => {
                  t instanceof IDBCursor && Qs.set(t, e);
                })
                .catch(() => {}),
              Gs.set(t, e),
              t
            );
          })(e);
        if (qs.has(e)) return qs.get(e);
        const t = Xs(e);
        return t !== e && (qs.set(e, t), Gs.set(t, e)), t;
      }
      const Js = (e) => Gs.get(e);
      function Zs(
        e,
        t,
        { blocked: r, upgrade: i, blocking: s, terminated: n } = {}
      ) {
        const a = indexedDB.open(e, t),
          o = Ks(a);
        return (
          i &&
            a.addEventListener("upgradeneeded", (e) => {
              i(Ks(a.result), e.oldVersion, e.newVersion, Ks(a.transaction), e);
            }),
          r &&
            a.addEventListener("blocked", (e) =>
              r(e.oldVersion, e.newVersion, e)
            ),
          o
            .then((e) => {
              n && e.addEventListener("close", () => n()),
                s &&
                  e.addEventListener("versionchange", (e) =>
                    s(e.oldVersion, e.newVersion, e)
                  );
            })
            .catch(() => {}),
          o
        );
      }
      function $s(e, { blocked: t } = {}) {
        const r = indexedDB.deleteDatabase(e);
        return (
          t && r.addEventListener("blocked", (e) => t(e.oldVersion, e)),
          Ks(r).then(() => {})
        );
      }
      const en = ["get", "getKey", "getAll", "getAllKeys", "count"],
        tn = ["put", "add", "delete", "clear"],
        rn = new Map();
      function sn(e, t) {
        if (!(e instanceof IDBDatabase) || t in e || "string" != typeof t) return;
        if (rn.get(t)) return rn.get(t);
        const r = t.replace(/FromIndex$/, ""),
          i = t !== r,
          s = tn.includes(r);
        if (
          !(r in (i ? IDBIndex : IDBObjectStore).prototype) ||
          (!s && !en.includes(r))
        )
          return;
        const n = async function (e, ...t) {
          const n = this.transaction(e, s ? "readwrite" : "readonly");
          let a = n.store;
          return (
            i && (a = a.index(t.shift())),
            (await Promise.all([a[r](...t), s && n.done]))[0]
          );
        };
        return rn.set(t, n), n;
      }
      Ws((e) => ({
        ...e,
        get: (t, r, i) => sn(t, r) || e.get(t, r, i),
        has: (t, r) => !!sn(t, r) || e.has(t, r),
      }));
      const nn = ["continue", "continuePrimaryKey", "advance"],
        an = {},
        on = new WeakMap(),
        cn = new WeakMap(),
        ln = {
          get(e, t) {
            if (!nn.includes(t)) return e[t];
            let r = an[t];
            return (
              r ||
                (r = an[t] =
                  function (...e) {
                    on.set(this, cn.get(this)[t](...e));
                  }),
              r
            );
          },
        };
      async function* hn(...e) {
        let t = this;
        if ((t instanceof IDBCursor || (t = await t.openCursor(...e)), !t))
          return;
        const r = new Proxy(t, ln);
        for (cn.set(r, t), Gs.set(r, Js(t)); t; )
          yield r, (t = await (on.get(r) || t.continue())), on.delete(r);
      }
      function un(e, t) {
        return (
          (t === Symbol.asyncIterator &&
            Ms(e, [IDBIndex, IDBObjectStore, IDBCursor])) ||
          ("iterate" === t && Ms(e, [IDBIndex, IDBObjectStore]))
        );
      }
      Ws((e) => ({
        ...e,
        get: (t, r, i) => (un(t, r) ? hn : e.get(t, r, i)),
        has: (t, r) => un(t, r) || e.has(t, r),
      }));
      var dn = r(4668);
      const pn = 1024,
        fn = /\[\d]+/,
        gn = [
          {
            match:
              /\/\/.*(?:gcs-vimeo|vod|vod-progressive|vod-adaptive)\.akamaized\.net.*?\/([\d/]+\.mp4)/,
            fuzzyCanonReplace: "//vimeo-cdn.fuzzy.replayweb.page/$1",
            split: ".net",
          },
          {
            match: /\/\/.*player.vimeo.com\/(video\/[\d]+)\?.*/i,
            fuzzyCanonReplace: "//vimeo.fuzzy.replayweb.page/$1",
          },
          {
            match: /www.\washingtonpost\.com\/wp-apps\/imrs.php/,
            args: [["src"]],
          },
          {
            match: /(static.wixstatic.com\/.*\.[\w]+\/v1\/fill\/)(w_.*)/,
            replace: "$1?_args=$2",
            split: "/v1/fill",
          },
          {
            match: /(twimg.com\/profile_images\/[^/]+\/[^_]+)_([\w]+\.[\w]+)/,
            replace: "$1=_args=$2",
            split: "_",
            splitLast: !0,
          },
          {
            match: /^https?:\/\/(?:www\.)?(youtube\.com\/embed\/[^?]+)[?].*/i,
            replace: "$1",
          },
          {
            match: /^(https?:\/\/(?:www\.)?)(youtube\.com\/@[^?]+)[?].*/i,
            fuzzyCanonReplace: "$1$2",
          },
          {
            match: /\/\/(?:www\.)?youtube(?:-nocookie)?\.com\/(get_video_info)/i,
            fuzzyCanonReplace: "//youtube.fuzzy.replayweb.page/$1",
            args: [["video_id"]],
          },
          {
            match:
              /\/\/(?:www\.)?youtube(?:-nocookie)?\.com\/(youtubei\/v1\/[^?]+\?).*(videoId[^&]+).*/i,
            fuzzyCanonReplace: "//youtube.fuzzy.replayweb.page/$1$2",
            args: [["videoId"]],
          },
          {
            match: /\/\/.*googlevideo.com\/(videoplayback)/i,
            fuzzyCanonReplace: "//youtube.fuzzy.replayweb.page/$1",
            args: [["id", "itag"], ["id"]],
            fuzzyArgs: !0,
          },
          {
            match:
              /facebook\.com\/ajax\/pagelet\/generic.php\/photoviewerinitpagelet/i,
            args: [
              [
                {
                  arg: "data",
                  keys: ["query_type", "fbid", "v", "cursor", "data"],
                },
              ],
            ],
          },
          {
            match: /((?:twitter|x)\.com\/[^/]+\/status\/[^?]+)(\?.*)/,
            fuzzyCanonReplace: "$1",
          },
          {
            match: /((?:twitter|x)\.com\/i\/api\/graphql\/.*)/,
            args: [["cursor"]],
            fuzzyArgs: !0,
          },
          { match: /facebook\.com\/ajax\//i, fuzzySet: !0 },
          {
            match:
              ((mn = [
                "(callback=jsonp)[^&]+(?=&|$)",
                "((?:\\w+)=jquery)[\\d]+_[\\d]+",
                "utm_[^=]+=[^&]+(?=&|$)",
                "(_|cb|_ga|\\w*cache\\w*)=[\\d.-]+(?=$|&)",
              ]),
              new RegExp("[?&]" + mn.map((e) => "(" + e + ")").join("|"), "gi")),
            replace: "",
          },
          {
            match: /(\.(?:js|webm|mp4|gif|jpg|png|css|json|m3u8))\?.*/i,
            replace: "$1",
            maxResults: 2,
          },
        ];
      var mn;
      const yn = new (class {
          constructor(e) {
            this.rules = e || gn;
          }
          getRuleFor(e) {
            let t;
            const r = -1 === e.indexOf("?") ? e + "?" : e;
            for (const e of this.rules)
              if (r.length < 4096 && r.match(e.match)) {
                t = e;
                break;
              }
            let i = e;
            t &&
              t.fuzzyCanonReplace &&
              (i = e.replace(t.match, t.fuzzyCanonReplace));
            const s = (t && t.split) || "?",
              n = t && t.splitLast ? e.lastIndexOf(s) : e.indexOf(s);
            return {
              prefix: n > 0 ? e.slice(0, n + s.length) : e,
              rule: t,
              fuzzyCanonUrl: i,
            };
          }
          getFuzzyCanonsWithArgs(e) {
            let { fuzzyCanonUrl: t, prefix: r, rule: i } = this.getRuleFor(e);
            t === e && (t = r);
            const s = [];
            if (i && i.args) {
              const r = new URL(t),
                n = new URL(e);
              for (const e of i.args) {
                const t = new URLSearchParams();
                for (const r of e) t.set(r, n.searchParams.get(r) || "");
                (r.search = t.toString()), s.push(r.href);
              }
              return s;
            }
            return [t];
          }
          fuzzyCompareUrls(e, t, r) {
            if (!t || !t.length) return null;
            if (
              r &&
              void 0 !== r.replace &&
              void 0 !== r.match &&
              (!r.maxResults || t.length <= r.maxResults)
            ) {
              const i = r.match,
                s = r.replace,
                n = e.replace(i, s),
                a = [];
              for (const e of t) {
                const t = ("string" == typeof e ? e : e.url).replace(i, s);
                if (n === t) return e;
                (e.fuzzyMatchUrl = t), a.push(e);
              }
              (t = a), (e = n);
            }
            return this.fuzzyBestMatchQuery(e, t, r);
          }
          fuzzyBestMatchQuery(e, t, r) {
            try {
              e = new URL(e);
            } catch (e) {
              return 0;
            }
            const i = r && r.args && !r.fuzzyArgs ? new Set(r.args[0]) : null;
            let s = 0,
              n = null;
            const a = new URLSearchParams(e.search);
            for (const e of t) {
              if (204 === e.status || 304 === e.status) continue;
              let t = "string" == typeof e ? e : e.fuzzyMatchUrl || e.url;
              try {
                t = new URL(t);
              } catch (e) {
                continue;
              }
              const o = new URLSearchParams(t.search);
              let c = this.getMatch(a, o, i, r && r.fuzzySet);
              (c += this.getMatch(o, a, i)),
                (c /= 2),
                e.status > 200 && (c *= 10 ** (1e-4 * (200 - e.status))),
                c > s && ((s = c), (n = e));
            }
            return n;
          }
          getMatch(e, t, r = null, i = !1) {
            let s = 1,
              n = 1;
            const a = {};
            for (let [o, c] of e) {
              let e,
                l = t.get(o);
              if (r && r.has(o) && l !== c) return -1e3;
              (e = "_" === o[0] ? 0.1 : 10),
                null !== l &&
                  ((s += 0.5 * e), l.length > pn && (l = l.slice(0, pn))),
                c && c.length > pn && (c = c.slice(0, pn));
              const h = Number(c),
                u = Number(l);
              if (((n += e), i && this.addSetMatch(a, o, c, l), l === c))
                s += e * c.length;
              else if (null === l || null === c) s += 0;
              else if (isNaN(h) || isNaN(u))
                if (c.startsWith("{") && l.startsWith("{"))
                  try {
                    const t = bi(c),
                      r = bi(l);
                    s += this.getMatch(t, r) * e * 2;
                  } catch (t) {
                    s += 0.5 * e * this.levScore(c, l);
                  }
                else i || (s += e * this.levScore(c, l));
              else s += 10 - Math.log(Math.abs(h - u) + 1);
            }
            return s / n + (i ? this.paramSetMatch(a, 100) : 0);
          }
          addSetMatch(e, t, r, i) {
            if (!r || !i || "/" !== r[0] || "/" !== i[0]) return;
            const s = t.split(fn);
            if (s.length <= 1) return;
            const n = r.indexOf("?"),
              a = i.indexOf("?"),
              o = s[0],
              c = n > 0 ? r.slice(0, n) : r,
              l = a > 0 ? i.slice(0, a) : i;
            e[o] || (e[o] = { value: [], found: new Set() }),
              e[o].value.push(c),
              e[o].found.add(l);
          }
          paramSetMatch(e, t) {
            let r = 0;
            for (const i of Object.values(e)) {
              let e = t;
              for (const t of i.value) i.found.has(t) && (r += e), (e *= 0.33);
            }
            return r;
          }
          levScore(e, t) {
            const r = Math.min(e.length, t.length),
              i = dn(e, t);
            return i < r ? r - i : 0;
          }
        })(),
        An = new Date("9999-01-01").getTime(),
        wn = "warc/revisit";
      class En {
        constructor(e, t = {}) {
          (this.name = e), (this.db = null);
          const { minDedupSize: r, noRefCounts: i } = t;
          (this.minDedupSize = Number.isInteger(r) ? r : 1024),
            (this.version = 4),
            (this.autoHttpsCheck = !0),
            (this.useRefCounts = !i),
            (this.allowRepeats = !0),
            (this.repeatTracker = this.allowRepeats ? new bn() : null),
            (this.fuzzyPrefixSearch = !0),
            (this.initing = this.init());
        }
        async init() {
          let e = 0;
          (this.db = await Zs(this.name, this.version, {
            upgrade: (t, r, i, s) => {
              (e = r), this._initDB(t, r, i, s);
            },
            blocking: (e, t) => {
              t || this.close();
            },
          })),
            1 === e && (await this.convertCuratedPagesToV2(this.db));
        }
        _initDB(e, t) {
          if (!t) {
            const t = e.createObjectStore("pages", { keyPath: "id" });
            t.createIndex("url", "url"),
              t.createIndex("ts", "ts"),
              t.createIndex("state", "state"),
              e.createObjectStore("pageLists", {
                keyPath: "id",
                autoIncrement: !0,
              });
            e.createObjectStore("curatedPages", {
              keyPath: "id",
              autoIncrement: !0,
            }).createIndex("listPages", ["list", "pos"]);
            const r = e.createObjectStore("resources", {
              keyPath: ["url", "ts"],
            });
            r.createIndex("pageId", "pageId"),
              r.createIndex("mimeStatusUrl", ["mime", "status", "url"]),
              e.createObjectStore("payload", { keyPath: "digest", unique: !0 }),
              e.createObjectStore("digestRef", { keyPath: "digest", unique: !0 });
          }
        }
        async clearAll() {
          const e = ["pages", "resources", "payload", "digestRef"];
          for (const t of e) await this.db.clear(t);
        }
        close() {
          this.db && (this.db.close(), (this.db = null));
        }
        async delete() {
          this.close(),
            await $s(this.name, {
              blocked(e, t) {
                console.log("Unable to delete: " + t);
              },
            });
        }
        async addPage(e, t) {
          const r = e.url,
            i = e.title || e.url,
            s = e.id || this.newPageId(),
            n = e.state || 17;
          let a = e.ts;
          if ("number" != typeof a)
            if (e.timestamp) a = ss(e.timestamp).getTime();
            else {
              const t = e.ts || e.date || e.datetime;
              t && (a = new Date(t).getTime());
            }
          const o = { ...e, url: r, ts: a, title: i, id: s, state: n };
          return t ? (t.store.put(o), o.id) : await this.db.put("pages", o);
        }
        async addPages(e, t = "pages", r = !1) {
          const i = this.db.transaction(t, "readwrite");
          for (const t of e) r ? i.store.put(t) : this.addPage(t, i);
          try {
            await i.done;
          } catch (e) {
            console.warn("addPages tx", e.toString());
          }
        }
        async createPageList(e) {
          const t = {};
          return (
            (t.title = e.title),
            (t.desc = e.desc || e.description),
            (t.slug = e.id || e.slug),
            await this.db.put("pageLists", t)
          );
        }
        async addCuratedPageList(e, t) {
          const r = await this.createPageList(e);
          let i = 0;
          for (const e of t) (e.pos = i++), (e.list = r);
          await this.addPages(t, "curatedPages");
        }
        async addCuratedPageLists(e, t = "pages", r = "public") {
          for (const i of e) {
            if (r && !i[r]) continue;
            const e = i[t] || [];
            await this.addCuratedPageList(i, e);
          }
        }
        async convertCuratedPagesToV2(e) {
          const t = await e.getAll("curatedPages");
          if (!t || !t.length) return;
          const r = await e.getAll("pages"),
            i = new Map();
          for (const e of r) i.set(e.id, e);
          for (const e of t)
            if (e.page) {
              const t = i.get(e.page);
              t &&
                ((e.id = this.newPageId()),
                (e.url = t.url),
                (e.ts = t.ts),
                !e.title && t.title && (e.title = t.title)),
                delete e.page;
            }
          await e.clear("curatedPages");
          const s = e.transaction("curatedPages", "readwrite");
          for (const e of t) s.store.put(e);
          try {
            await s.done;
          } catch (e) {
            console.warn("Conversion Failed", e);
          }
        }
        async getCuratedPagesByList() {
          const e = await this.db.getAll("pageLists"),
            t = this.db.transaction("curatedPages", "readonly");
          for await (const r of t.store.index("listPages").iterate()) {
            const t = e[r.value.list - 1];
            t &&
              ((t.show = !0), t.pages || (t.pages = []), t.pages.push(r.value));
          }
          return e;
        }
        newPageId() {
          return cs();
        }
        async getAllPages() {
          return await this.db.getAll("pages");
        }
        async getPages(e) {
          const t = [];
          e.sort();
          for await (const r of this.matchAny("pages", null, e)) t.push(r);
          return t;
        }
        async getTimestampsByURL(e) {
          const t = this.db.transaction("resources"),
            r = IDBKeyRange.bound([e], [e, An]),
            i = [];
          for await (const e of t.store.iterate(r)) i.push(e.key[1]);
          return i;
        }
        async getPagesWithState(e) {
          return await this.db.getAllFromIndex("pages", "state", e);
        }
        async getVerifyInfo() {
          return {};
        }
        async addVerifyData() {}
        async addVerifyDataList() {}
        async dedupResource(e, t, r, i = 1) {
          const s = r.objectStore("digestRef"),
            n = await s.get(e);
          if (n) return ++n.count, n;
          if (t)
            try {
              r.objectStore("payload").put({ digest: e, payload: t });
              return { digest: e, count: i, size: t.length };
            } catch (e) {
              console.log(e);
            }
          return null;
        }
        async addResources(e) {
          const t = [],
            r = [],
            i = [],
            s = {},
            n = new Set(),
            a = this.db.transaction(["digestRef", "payload"], "readwrite");
          for (const o of e) {
            let e = 1;
            const c = o.status || 200,
              l = o.mime === wn ? t : c >= 300 ? r : i;
            l.push(o);
            const h = this.getFuzzyUrl(o);
            h && (l.push(h), (e = 2)),
              this.useRefCounts &&
                o.digest &&
                (s[o.digest]
                  ? ((s[o.digest].count += e), n.add(o.digest))
                  : (s[o.digest] = await this.dedupResource(
                      o.digest,
                      o.payload,
                      a,
                      e
                    )),
                delete o.payload);
          }
          if (this.useRefCounts) {
            const e = a.objectStore("digestRef");
            for (const t of n) e.put(s[t]);
          }
          try {
            await a.done;
          } catch (e) {
            console.error("Payload and Ref Count Bulk Add Failed: ", e);
          }
          const o = this.db.transaction("resources", "readwrite");
          for (const e of t) o.store.put(e);
          for (const e of r) o.store.put(e);
          for (const e of i) o.store.put(e);
          try {
            await o.done;
          } catch (e) {
            console.error("Resources Bulk Add Failed", e);
          }
        }
        getFuzzyUrl(e) {
          if (
            e.status >= 200 &&
            e.status < 400 &&
            304 !== e.status &&
            204 !== e.status
          ) {
            const { fuzzyCanonUrl: t } = yn.getRuleFor(e.url);
            if (!t || t === e.url) return null;
            return {
              url: t,
              ts: e.ts,
              origURL: e.url,
              origTS: e.ts,
              pageId: e.pageId,
              digest: e.digest,
            };
          }
          return null;
        }
        async addResource(e) {
          e.payload &&
            e.payload.length > this.minDedupSize &&
            (e.digest || (e.digest = await as(e.payload, "sha-256")));
          let t = null,
            r = !1;
          const i = this.db.transaction(
            ["resources", "digestRef", "payload"],
            "readwrite"
          );
          if (
            (e.payload && e.payload.length > this.minDedupSize
              ? ((t = await this.dedupResource(e.digest, e.payload, i)),
                (r = t && 1 === t.count),
                delete e.payload)
              : e.payload && (r = !0),
            e.mime !== wn)
          ) {
            i.objectStore("resources").put(e);
            const r = this.getFuzzyUrl(e);
            r && (i.objectStore("resources").put(r), t && t.count++);
          } else i.objectStore("resources").add(e);
          t && i.objectStore("digestRef").put(t);
          try {
            await i.done;
          } catch (t) {
            e.mime === wn
              ? console.log("Skip Duplicate revisit for: " + e.url)
              : console.log("Add Error for " + e.url),
              console.log(t);
          }
          return r;
        }
        async getResource(e, t, r, i = {}) {
          const s = ss(e.timestamp).getTime();
          let n = e.url,
            a = null;
          const o = this.repeatTracker
              ? this.repeatTracker.getSkipCount(r, n, e.request.method)
              : 0,
            c = { ...i, skip: o };
          if (n.startsWith("//")) {
            let t = !1;
            (a = await this.lookupUrl("https:" + n, s, c)),
              a ||
                ((a = await this.lookupUrl("http:" + n, s, c)),
                (a || e.request.referrer.indexOf("/http://", 2) > 0) && (t = !0)),
              (n = (t ? "http:" : "https:") + n);
          } else if (
            ((a = await this.lookupUrl(n, s, c)),
            !a && this.autoHttpsCheck && n.startsWith("http://"))
          ) {
            const e = n.replace("http://", "https://");
            (a = await this.lookupUrl(e, s, c)), a && (n = e);
          }
          if (
            (a ||
              !this.fuzzyPrefixSearch ||
              i.noFuzzyCheck ||
              (a = await this.lookupQueryPrefix(n, i)),
            a && a.origURL)
          ) {
            const e = await this.lookupUrl(a.origURL, a.origTS || a.ts, i);
            e && ((n = e.url), (a = e));
          }
          if (!a) return null;
          const l = a.status,
            h = a.statusText || ds(l);
          let u = null;
          if (!us() && ((u = await this.loadPayload(a, i)), !u)) return null;
          const d = ls(a.respHeaders),
            p = new Date(a.ts),
            f = a.extraOpts || null;
          return (
            (n = a.url),
            n !== e.url && d.set("Content-Location", n),
            new vs({
              url: n,
              payload: u,
              status: l,
              statusText: h,
              headers: d,
              date: p,
              extraOpts: f,
            })
          );
        }
        async loadPayload(e) {
          if (e.digest && !e.payload) {
            if (
              "sha256:e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855" ===
                e.digest ||
              "sha1:3I42H3S6NNFQ2MSVX7XZKYAYSCX5QBYJ" === e.digest
            )
              return new Uint8Array([]);
            const t = await this.db.get("payload", e.digest);
            if (!t) return null;
            const { payload: r } = t;
            return r;
          }
          return e.payload;
        }
        isSelfRedirect(e, t) {
          try {
            if (t && t.respHeaders && t.status >= 300 && t.status < 400) {
              const r = new Headers(t.respHeaders).get("location");
              if (new URL(r, e).href === e) return !0;
            }
          } catch (e) {}
          return !1;
        }
        async lookupUrl(e, t, r = {}) {
          const i = this.db.transaction("resources", "readonly");
          if (t) {
            const s = IDBKeyRange.bound([e, t], [e, An]);
            if (r.noRevisits || r.pageId) {
              let t = await i.store.getAll(s, 16);
              t = t || [];
              for (const i of t)
                if (
                  !(
                    (r.pageId && i.pageId && i.pageId !== r.pageId) ||
                    (r.noRevisits && i.mime === wn) ||
                    this.isSelfRedirect(e, i)
                  )
                )
                  return i;
            } else {
              const r = await i.store.get(s);
              if (r && this.isSelfRedirect(e, r)) t += 1e4;
              else if (r) return r;
            }
          }
          const s = IDBKeyRange.bound([e], [e, t || An]);
          for await (const t of i.store.iterate(s, "prev")) {
            const i = t.value;
            if (
              (!r.pageId || !i.pageId || i.pageId === r.pageId) &&
              !((r.noRevisits && i.mime === wn) || this.isSelfRedirect(e, i))
            )
              return i;
          }
          return null;
        }
        async lookupQueryPrefix(e, t) {
          const { rule: r, prefix: i, fuzzyCanonUrl: s } = yn.getRuleFor(e);
          if (s !== e) {
            const e = await this.lookupUrl(s, 0, t);
            if (e) return e;
          }
          if (!r && i === e && i === s && !e.endsWith("?")) return null;
          const n = await this.db.getAll(
            "resources",
            this.getLookupRange(i, "prefix"),
            128e3
          );
          return yn.fuzzyCompareUrls(e, n, r);
        }
        resJson(e) {
          const t = new Date(e.ts).toISOString();
          return {
            url: e.url,
            date: t,
            ts: is(t),
            mime: e.mime,
            status: e.status,
          };
        }
        async resourcesByPage(e) {
          return this.db.getAllFromIndex("resources", "pageId", e);
        }
        async *resourcesByPages2(e) {
          e.sort(), yield* this.matchAny("resources", "pageId", e);
        }
        async *resourcesByPages(e) {
          const t = this.db.transaction("resources", "readonly");
          for await (const r of t.store.iterate())
            e.includes(r.value.pageId) && (yield r.value);
        }
        async *matchAny(e, t, r, i, s = !1) {
          const n = this.db.transaction(e, "readonly"),
            a = IDBKeyRange.lowerBound(r[0], s);
          let o = t
              ? await n.store.index(t).openCursor(a)
              : await n.store.openCursor(a),
            c = 0;
          for (; o && c < r.length; ) {
            let e, t, s;
            void 0 !== i
              ? ((e = o.key[i]), (t = r[c][i]), (s = e.startsWith(t)))
              : ((e = o.key), (t = r[c]), (s = e === t)),
              !s && e > t
                ? ++c
                : s
                ? (yield o.value, (o = await o.continue()))
                : (o = await o.continue(r[c]));
          }
        }
        async resourcesByUrlAndMime(e, t, r = 1e3, i = !0, s = "", n = "") {
          const a = t ? null : r,
            o = await this.db.getAll(
              "resources",
              this.getLookupRange(e, i ? "prefix" : "exact", s, n),
              a
            );
          t = t.split(",");
          const c = [];
          for (const e of o)
            for (const i of t)
              if (!i || (e.mime && e.mime.startsWith(i))) {
                if ((c.push(this.resJson(e)), c.length === r)) return c;
                break;
              }
          return c;
        }
        async resourcesByMime(e, t = 100, r = "", i = "", s = 0) {
          const n = [];
          (e = e.split(",")).sort();
          let a = [];
          r && a.push([r, s, i]);
          for (const t of e) (!r || !t || t > r) && a.push([t, 0, ""]);
          for await (const e of this.matchAny(
            "resources",
            "mimeStatusUrl",
            a,
            0,
            !0
          ))
            if ((n.push(this.resJson(e)), n.length === t)) break;
          return n;
        }
        async deletePage(e) {
          const t = this.db.transaction("pages", "readwrite"),
            r = await t.store.get(e);
          await t.store.delete(e);
          const i = await this.deletePageResources(e);
          return { pageSize: (r && r.size) || 0, dedupSize: i };
        }
        async deletePageResources(e) {
          const t = {},
            r = this.db.transaction("resources", "readwrite");
          let i = await r.store.index("pageId").openCursor(e),
            s = 0;
          for (; i; ) {
            const e = i.value.digest;
            e
              ? (t[e] = (t[e] || 0) + 1)
              : i.value.payload && (s += i.value.payload.length),
              r.store.delete(i.primaryKey),
              (i = await i.continue());
          }
          await r.done;
          const n = this.db.transaction(["payload", "digestRef"], "readwrite"),
            a = n.objectStore("digestRef");
          for (const e of Object.keys(t)) {
            const r = await a.get(e);
            r && (r.count -= t[e]),
              r && r.count >= 1
                ? a.put(r)
                : ((s += r ? r.size : 0),
                  a.delete(e),
                  n.objectStore("payload").delete(e));
          }
          return await n.done, s;
        }
        prefixUpperBound(e) {
          return (
            e.slice(0, -1) + String.fromCharCode(e.charCodeAt(e.length - 1) + 1)
          );
        }
        getLookupRange(e, t, r, i) {
          let s, n, a;
          switch (t) {
            case "prefix":
              (s = [e]), (n = [this.prefixUpperBound(e)]);
              break;
            case "host": {
              const t = new URL(e).origin;
              (s = [t + "/"]), (n = [t + "0"]);
              break;
            }
            default:
              (s = [e]), (n = [e, Number.MAX_SAFE_INTEGER]);
          }
          return (
            r ? ((s = [r, i || ""]), (a = !0)) : (a = !1),
            IDBKeyRange.bound(s, n, a, !0)
          );
        }
      }
      class bn {
        constructor() {
          this.repeats = {};
        }
        getSkipCount(e, t, r) {
          if ("POST" !== r && !t.endsWith(".m3u8")) return 0;
          e.replacesClientId && delete this.repeats[e.replacesClientId];
          const i = e.resultingClientId || e.clientId;
          return i
            ? (void 0 === this.repeats[i] && (this.repeats[i] = {}),
              void 0 === this.repeats[i][t]
                ? (this.repeats[i][t] = 0)
                : this.repeats[i][t]++,
              this.repeats[i][t])
            : 0;
        }
      }
      const vn = [
        "script",
        "style",
        "header",
        "footer",
        "banner-div",
        "noscript",
      ];
      class In {
        constructor(e = 1e3) {
          (this.batchSize = e),
            (this.promises = []),
            (this.batch = []),
            (this.count = 0),
            (this.dupeSet = new Set());
        }
        addPage(e) {
          this.promises.push(this.db.addPage(e));
        }
        isBatchFull() {
          return this.batch.length >= this.batchSize;
        }
        addResource(e) {
          if ((this.isBatchFull() && this.flush(), Number.isNaN(e.ts)))
            return void console.warn(
              "Skipping resource with missing/invalid ts: " + e.url
            );
          const t = e.url + " " + e.ts;
          if ("warc/revisit" === e.mime) {
            if (this.dupeSet.has(t))
              return void console.warn(
                "Skipping duplicate revisit, prevent overriding non-revisit"
              );
          } else this.dupeSet.add(t);
          this.batch.push(e);
        }
        flush() {
          this.batch.length > 0 &&
            this.promises.push(this.db.addResources(this.batch)),
            console.log(`Read ${(this.count += this.batch.length)} records`),
            (this.batch = []);
        }
        async finishIndexing() {
          this.flush(), this._finishLoad();
          try {
            await Promise.all(this.promises);
          } catch (e) {
            console.warn(e);
          }
          this.promises = [];
        }
        _finishLoad() {}
      }
      class Sn extends In {
        constructor(e, t = null, r = null, i = null) {
          super(),
            (this.reader = e),
            (this.abort = t),
            (this.loadId = r),
            (this.anyPages = !1),
            (this.detectPages = !1),
            (this._lastRecord = null),
            (this.metadata = {}),
            (this.pageMap = {}),
            (this.pages = []),
            (this.lists = []),
            (this.source = i);
        }
        parseWarcInfo(e) {
          if (!e.payload) return;
          const t = new TextDecoder("utf-8").decode(e.payload);
          for (const e of t.split("\n"))
            if (e.startsWith("json-metadata:"))
              try {
                const t = JSON.parse(e.slice(14));
                if (
                  ("collection" === t.type &&
                    ((this.metadata.desc = t.desc),
                    (this.metadata.title = t.title)),
                  t.pages && t.pages.length)
                ) {
                  this.pages = this.pages.concat(t.pages);
                  for (const e of t.pages)
                    (e.ts = ss(e.timestamp).getTime()),
                      (this.pageMap[e.ts + "/" + e.url] = { page: e });
                  this.anyPages = !0;
                }
                t.lists &&
                  t.lists.length &&
                  (this.lists = this.lists.concat(t.lists));
              } catch (e) {
                console.log("Page Add Error", e.toString());
              }
        }
        index(e, t) {
          if ("warcinfo" !== e.warcType) {
            if (this._lastRecord)
              return this._lastRecord.warcTargetURI != e.warcTargetURI
                ? (this.indexReqResponse(this._lastRecord, null, t),
                  void (this._lastRecord = e))
                : void ("request" === e.warcType &&
                  "response" === this._lastRecord.warcType
                    ? (this.indexReqResponse(this._lastRecord, e, t),
                      (this._lastRecord = null))
                    : "response" === e.warcType &&
                      "request" === this._lastRecord.warcType
                    ? (this.indexReqResponse(e, this._lastRecord, t),
                      (this._lastRecord = null))
                    : (this.indexReqResponse(this._lastRecord, null, t),
                      (this._lastRecord = e)));
            this._lastRecord = e;
          } else this.parseWarcInfo(e);
        }
        indexDone(e) {
          this._lastRecord &&
            (this.indexReqResponse(this._lastRecord, null, e),
            (this._lastRecord = null));
        }
        shouldIndexMetadataRecord(e) {
          const t = e.warcTargetURI;
          return !(!t || !t.startsWith("metadata://"));
        }
        parseRevisitRecord(e, t) {
          const r = e.warcTargetURI.split("#")[0],
            i = e.warcDate,
            s = new Date(i).getTime();
          let n;
          if (e.httpHeaders) {
            const i = this.parseResponseHttpHeaders(e, r, t);
            n = i && Object.fromEntries(i.headers.entries());
          }
          const a = e.warcRefersToTargetURI,
            o = new Date(e.warcRefersToDate).getTime();
          if (a === r && o === s) return null;
          return {
            url: r,
            ts: s,
            origURL: a,
            origTS: o,
            digest: e.warcPayloadDigest,
            pageId: null,
            respHeaders: n,
          };
        }
        parseResponseHttpHeaders(e, t, r) {
          let i = 200,
            s = null,
            n = "";
          const a = r && r.httpHeaders.method;
          if (e.httpHeaders) {
            if (
              ((i = Number(e.httpHeaders.statusCode) || 200),
              "OPTIONS" === a || "HEAD" === a)
            )
              return null;
            if (
              ((s = ls(e.httpHeaders.headers)),
              (n = (s.get("content-type") || "").split(";")[0]),
              206 === i && !this.isFullRangeRequest(s))
            )
              return null;
          } else
            (s = new Headers()),
              s.set("content-type", e.warcContentType),
              s.set("content-length", e.warcContentLength),
              (n = e.warcContentType);
          return { status: i, method: a, headers: s, mime: n };
        }
        indexReqResponse(e, t) {
          const r = this.parseRecords(e, t);
          r && this.addResource(r);
        }
        parseRecords(e, t) {
          switch (e.warcType) {
            case "revisit":
              return this.parseRevisitRecord(e, t);
            case "resource":
              t = null;
              break;
            case "response":
              break;
            case "metadata":
              if (!this.shouldIndexMetadataRecord(e)) return null;
              break;
            default:
              return null;
          }
          let r = e.warcTargetURI.split("#")[0];
          const i = e.warcDate,
            s = this.parseResponseHttpHeaders(e, r, t);
          if (!s) return null;
          const { status: n, method: a, headers: o, mime: c } = s;
          let l,
            h,
            u = null,
            p = null;
          if (t && t.httpHeaders.headers) {
            let e = null;
            try {
              e = new Headers(t.httpHeaders.headers);
              const r = e.get("cookie");
              r && o.set("x-wabac-preset-cookie", r),
                (u = t.httpHeaders.headers.get("Referer"));
            } catch (t) {
              (e = new Headers()), console.warn(t);
            }
            if (((h = Object.fromEntries(e.entries())), "GET" !== a)) {
              const i = { headers: e, method: a, url: r, postData: t.payload };
              wi(i) && ((l = r), (r = i.url), (p = t.payload));
            }
          }
          if (
            (void 0 === this.detectPages && (this.detectPages = !this.anyPages),
            this.detectPages &&
              (function (e, t, r) {
                if (200 != t) return !1;
                if (
                  !e.startsWith("http:") &&
                  !e.startsWith("https:") &&
                  !e.startsWith("blob:")
                )
                  return !1;
                if (e.endsWith("/robots.txt")) return !1;
                const i = e.split("?", 2);
                if (2 === i.length && i[1].length > i[0].length) return !1;
                if (i[0].substring(i[0].lastIndexOf("/") + 1).startsWith("."))
                  return !1;
                if (r && "text/html" !== r) return !1;
                return !0;
              })(r, n, c))
          ) {
            const e = r;
            this.addPage({ url: r, date: i, title: e });
          }
          const f = new Date(i).getTime(),
            g = Object.fromEntries(o.entries()),
            m = e.warcPayloadDigest,
            y = e.payload,
            A = {
              url: r,
              ts: f,
              status: n,
              mime: c,
              respHeaders: g,
              reqHeaders: h,
              digest: m,
              payload: y,
              reader: y ? null : e.reader,
              referrer: u,
            };
          this.pageMap[f + "/" + r] &&
            y &&
            c.startsWith("text/") &&
            (this.pageMap[f + "/" + r].textPromise = (async function (
              e,
              t,
              r,
              i
            ) {
              const s = new Vr(),
                n = [];
              let a = null;
              s.on("text", (e) => {
                if (a) return;
                const t = e.text.trim();
                t && n.push(t);
              }),
                s.on("startTag", (e) => {
                  !e.selfClosing && vn.includes(e.tagName) && (a = e.tagName);
                }),
                s.on("endTag", (e) => {
                  e.tagName === a && (a = null);
                }),
                (r || i) && (t = await d(t, r, i)),
                s.end(new TextDecoder().decode(t));
              const o = new Promise((e) => {
                s.on("end", () => {
                  e(n.join(" "));
                });
              });
              return await o;
            })(0, y, o.get("content-encoding"), o.get("transfer-encoding")));
          const w = e.warcHeader("WARC-JSON-Metadata");
          if (w)
            try {
              A.extraOpts = JSON.parse(w);
            } catch (e) {}
          const E = e.warcHeader("WARC-Page-ID");
          return (
            E && (A.pageId = E),
            this.sourceExtra && (A.source = this.sourceExtra),
            "GET" !== a &&
              l &&
              ((A.requestUrl = l), (A.method = a), (A.requestBody = p || "")),
            A
          );
        }
        isFullRangeRequest(e) {
          const t = e.get("content-range"),
            r = parseInt(e.get("content-length") || 0);
          return t && t === `bytes 0-${r - 1}/${r}`;
        }
        filterRecord() {
          return null;
        }
        async load(e, t, r) {
          this.db = e;
          const i = new qi(this.reader);
          let s = 0,
            n = 0,
            a = 0;
          try {
            for await (const e of i) {
              if ((a++, !e.warcType)) {
                console.log("skip empty record");
                continue;
              }
              if (
                self.interruptLoads &&
                this.loadId &&
                self.interruptLoads[this.loadId]
              )
                throw (
                  (t(
                    Math.round((i.offset / r) * 95),
                    "Loading Canceled",
                    i.offset,
                    r
                  ),
                  self.interruptLoads[this.loadId](),
                  this.abort && this.abort.abort(),
                  new ys())
                );
              if (((n = new Date().getTime()), n - s > 500)) {
                const e = `Processed ${a} records`;
                t(Math.round((i.offset / r) * 95), null, i.offset, r, null, e),
                  (s = n);
              }
              const o = this.filterRecord(e);
              if ("done" === o) {
                this.abort && this.abort.abort();
                break;
              }
              if (
                "skip" !== o &&
                ("skipContent" === o ? await e.skipFully() : await e.readFully(),
                a++,
                this.index(e, i),
                this.promises.length > 0)
              ) {
                try {
                  await Promise.all(this.promises);
                } catch (e) {
                  console.warn(e.toString());
                }
                this.promises = [];
              }
            }
          } catch (e) {
            if (e instanceof ys) throw e;
            t(
              Math.round((i.offset / r) * 95),
              `Sorry there was an error downloading. Please try again (${e})`,
              i.offset,
              r
            ),
              console.warn(e);
          }
          return (
            this.indexDone(i),
            t(95, null, i.offset, r),
            await this.finishIndexing(),
            t(100, null, r, r),
            this.metadata
          );
        }
        async _finishLoad() {
          if (this.pages.length) {
            for (const { page: e, textPromise: t } of Object.values(this.pageMap))
              if (t)
                try {
                  e.text = await t;
                } catch (e) {
                  console.warn("Error adding text: " + e.toString());
                }
            this.promises.push(this.db.addPages(this.pages));
          }
          this.lists.length &&
            this.promises.push(
              this.db.addCuratedPageLists(this.lists, "bookmarks", "public")
            );
        }
      }
      class Tn extends Sn {
        constructor(e) {
          super(e), (this.detectPages = !1);
        }
        addPage() {}
        async load() {
          const e = await new qi(this.reader).parse();
          if (!e) return null;
          const t = this.parseRecords(e, null);
          return (t && "revisit" !== e.warcType) || (await e.readFully()), t;
        }
      }
      const _n = "https://w3s.link/";
      function Cn(e) {
        const { hostname: t, protocol: r, pathname: i } = new URL(e),
          s = r.slice(0, -1);
        if (!t) {
          const [e, ...t] = i.slice(2).split("/");
          return { type: s, cid: e, path: "/" + t.join("/") };
        }
        return { type: s, cid: t, path: i };
      }
      async function xn(e) {
        return On(e) ? e : Ln(e) ? Rn(e) : e;
      }
      async function Nn(e) {
        return new Response(e).blob();
      }
      async function* kn(e) {
        const t = await e.getReader();
        try {
          for (;;) {
            const { done: e, value: r } = await t.read();
            if (e) return;
            yield r;
          }
        } finally {
          t.releaseLock();
        }
      }
      function Rn(e) {
        let t = e;
        t.next || (t = e[Symbol.asyncIterator]());
        const r = new TextEncoder();
        return new ReadableStream({
          async pull(e) {
            const { value: i, done: s } = await t.next();
            if (s) await e.close();
            else {
              let t = i;
              "string" == typeof t && (t = r.encode(t)), await e.enqueue(t);
            }
          },
        });
      }
      async function Bn(e) {
        if (!e.ok) {
          const t = await e.text(),
            r = e.status;
          throw new Error(`HTTP Error ${r}: ${t}`);
        }
      }
      async function Dn({
        url: e,
        file: t,
        fileName: r = "",
        parameterName: i = "file",
        fetch: s = globalThis.fetch,
        signal: n,
      }) {
        const a = new FormData(),
          o = new Headers();
        Pn(e, o);
        const c = await (async function (e) {
          if (On(e)) return await Nn(e);
          if (Ln(e)) {
            const t = Rn(e);
            return await Nn(t);
          }
          return e instanceof Blob ? e : new Blob([e]);
        })(t);
        r ? a.append(i, c, r) : a.append(i, c);
        const l = await s(e, { method: "POST", body: a, headers: o, signal: n });
        return await Bn(l), l;
      }
      function On(e) {
        return "function" == typeof e.getReader;
      }
      function Ln(e) {
        return e[Symbol.asyncIterator];
      }
      function Pn(e, t) {
        if (e.password)
          if (e.username) {
            const r = `Basic ${btoa(
              `${unescape(e.username)}:${unescape(e.password)}`
            )}`;
            t.append("Authorization", unescape(r)),
              (e.username = ""),
              (e.password = "");
          } else {
            const r = `Bearer ${e.password}`;
            t.append("Authorization", unescape(r)), (e.password = "");
          }
      }
      async function Un({ url: e, fetch: t = globalThis.fetch, signal: r }) {
        const i = await t(e, { method: "HEAD", signal: r });
        await Bn(i);
        const s =
          i.headers.get("x-ipfs-datasize") || i.headers.get("Content-Length");
        return parseInt(s, 10);
      }
      async function* Mn({
        url: e,
        start: t,
        end: r,
        format: i,
        signal: s,
        fetch: n = globalThis.fetch,
      }) {
        const a = new Headers();
        Number.isInteger(t) &&
          (Number.isInteger(r)
            ? a.set("Range", `bytes=${t}-${r}`)
            : a.set("Range", `bytes=${t}-`));
        const o = new URL(e);
        i &&
          (a.set("Accept", `application/vnd.ipld.${i}`),
          a.set("cache-control", "no-cache"));
        const c = await n(o.href, { headers: a, signal: s });
        await Bn(c), yield* kn(c.body);
      }
      async function* Fn({
        url: e,
        start: t,
        end: r,
        format: i,
        signal: s,
        gatewayURL: n = Hn(),
      }) {
        const a = (function (e, t = Hn()) {
          const { cid: r, path: i, type: s } = Cn(e);
          return new URL(`/${s}/${r}${i}`, t);
        })(e, n);
        yield* Mn({ url: a, start: t, end: r, format: i, signal: s });
      }
      function Hn() {
        if (!globalThis.location) return _n;
        const { pathname: e, hostname: t, protocol: r } = globalThis.location;
        if (e.startsWith("/ipfs/") || e.startsWith("/ipns/"))
          return `${r}//${t}/`;
        const [i, ...s] = t.split(".");
        return 59 === i.length && s.length >= 2 ? `${r}//${s.join(".")}/` : _n;
      }
      let Qn = !1;
      const Vn = [5001, 45001, 45002, 45003, 45004, 45005],
        zn = "https://api.web3.storage/",
        qn = "https://api.estuary.tech/",
        Gn = "http://localhost:5001/",
        jn = 1e3,
        Wn = "agregore",
        Yn = "daemon",
        Xn = "daemon:preferred",
        Kn = "web3.storage",
        Jn = "estuary",
        Zn = "readonly",
        $n = [Xn, Wn, Yn, Kn, Jn, Zn];
      class ea {
        get type() {
          return "invalid";
        }
        async *get(
          e,
          { start: t, end: r, signal: i = null, format: s = null } = {}
        ) {
          throw new Error("Not Implemented");
        }
        async getSize(e, t = null) {
          throw new Error("Not Implemented");
        }
        async uploadCAR(e, t = null) {
          throw new Error("Not Implemented");
        }
        async uploadFile(e, t, r = null) {
          throw new Error("Not Implemented");
        }
        async clear(e, t = null) {
          throw new Error("Not Implemented");
        }
      }
      async function ta({
        daemonURL: e,
        web3StorageToken: t,
        web3StorageURL: r = zn,
        estuaryToken: i,
        estuaryURL: s = qn,
        publicGatewayURL: n = Hn(),
        readonly: a = !0,
        timeout: o = jn,
        fetch: c = globalThis.fetch,
      } = {}) {
        const l = [],
          h = [];
        if (
          (h.push(
            (async function (e = globalThis.fetch) {
              try {
                return await e("ipfs://localhost/"), !0;
              } catch (e) {
                return Qn && console.warn("Unable to detect Agregore", e), !1;
              }
            })(c).then((e) => e && l.push({ type: Wn, fetch: c }))
          ),
          h.push(
            (async function () {
              const e = Vn.map((e) => `http://localhost:${e}`);
              try {
                const r = await Promise.any(
                  e.map((e) =>
                    ha(e).then((t) => {
                      if (t) return e;
                      throw new Error("Not found");
                    })
                  )
                );
                return (
                  !!r &&
                  (la &&
                    !ca &&
                    ((t = r),
                    (ca = !0),
                    globalThis.chrome.webRequest.onBeforeSendHeaders.addListener(
                      (e) => {
                        const { requestHeaders: r } = e;
                        for (const e of r)
                          if ("origin" === e.name.toLowerCase())
                            return (e.value = t), { requestHeaders: r };
                        return (
                          e.requestHeaders.push({ name: "Origin", value: t }),
                          { requestHeaders: r }
                        );
                      },
                      { urls: [t + "/*"] },
                      ["blocking", "requestHeaders", "extraHeaders"]
                    )),
                  r)
                );
              } catch {
                return !1;
              }
              var t;
            })().then((e) => e && l.push({ type: Yn, url: e, fetch: c }))
          ),
          e &&
            h.push(
              ha(e, o, c).then((t) => t && l.push({ type: Xn, url: e, fetch: c }))
            ),
          i)
        ) {
          const e = s,
            t = i;
          l.push({
            type: Jn,
            url: e,
            authorization: t,
            fetch: c,
            publicGatewayURL: n,
          });
        }
        if (t) {
          const e = r,
            i = t;
          l.push({
            type: Kn,
            url: e,
            authorization: i,
            fetch: c,
            publicGatewayURL: n,
          });
        }
        return (
          a && n && l.push({ type: Zn, fetch: c, publicGatewayURL: n }),
          await Promise.allSettled(h),
          l
        );
      }
      async function ra({ chooseOrder: e = $n, ...t } = {}) {
        const r = (function (e, t = $n) {
          const r = e
              .filter(({ type: e }) => t.includes(e))
              .sort(({ type: e }, { type: r }) => t.indexOf(e) - t.indexOf(r)),
            i = r[0];
          if (!i) throw new Error("Unable to find valid type");
          return i;
        })(await ta(t), e);
        return (async function (e) {
          const { type: t } = e;
          let r = null;
          if (t === Wn) r = new na(e.fetch || globalThis.fetch);
          else if (t.startsWith(Yn)) r = new oa(e.url);
          else if (t === Kn)
            r = new aa(e.authorization, e.url, e.publicGatewayURL);
          else if (t === Jn)
            r = new sa(e.authorization, e.url, e.publicGatewayURL);
          else {
            if (t !== Zn) throw new TypeError(`Unknown API type: ${t}.`);
            r = new ia(e.publicGatewayURL);
          }
          return r;
        })(r);
      }
      class ia extends ea {
        constructor(e = Hn()) {
          super(), (this.gatewayURL = e);
        }
        get type() {
          return Zn;
        }
        async *get(
          e,
          { start: t, end: r, signal: i = null, format: s = null } = {}
        ) {
          yield* Fn({
            url: e,
            start: t,
            end: r,
            format: s,
            gatewayURL: this.gatewayURL,
            signal: i,
          });
        }
        async getSize(e, t = null) {
          const { cid: r, path: i, type: s } = Cn(e);
          return Un({
            url: new URL(`/${s}/${r}${i}`, this.gatewayURL),
            signal: t,
          });
        }
      }
      class sa extends ia {
        constructor(e, t = qn, r = Hn()) {
          super(r), (this.authorization = e), (this.url = t);
        }
        get type() {
          return Jn;
        }
        async uploadCAR(e, t = null) {
          throw new Error("Not Implemented");
        }
        async uploadFile(e, t, r = null) {
          const i = new URL("/content/add", this.url);
          i.password = this.authorization;
          const s = await Dn({
              url: i,
              file: e,
              fileName: t,
              parameterName: "data",
              signal: r,
            }),
            { cid: n } = await s.json();
          return `ipfs://${n}/`;
        }
      }
      class na extends ea {
        constructor(e = globalThis.fetch) {
          super(), (this.fetch = e);
        }
        get type() {
          return Wn;
        }
        async *get(
          e,
          { start: t, end: r, signal: i = null, format: s = null } = {}
        ) {
          const { fetch: n } = this;
          yield* Mn({ url: e, start: t, end: r, format: s, fetch: n, signal: i });
        }
        async getSize(e, t = null) {
          const { fetch: r } = this;
          return Un({ url: e, fetch: r, signal: t });
        }
        async uploadCAR(e, t = null) {
          const r = await xn(e),
            { fetch: i } = this,
            s = await i("ipfs://localhost", {
              method: "POST",
              headers: { "Content-Type": "application/vnd.ipld.car" },
              signal: t,
              body: r,
            });
          await Bn(s);
          return (await s.text()).split("\n");
        }
        async uploadFile(e, t = null) {
          const r = await xn(e),
            { fetch: i } = this,
            s = await i("ipfs://localhost", {
              method: "POST",
              headers: { "Content-Type": "application/octet-stream" },
              signal: t,
              body: r,
            });
          return await Bn(s), s.headers.get("Location");
        }
      }
      class aa extends ia {
        constructor(e, t = zn, r = Hn()) {
          super(r), (this.authorization = e), (this.url = t);
        }
        get type() {
          return Kn;
        }
        async uploadCAR(e, t = null) {
          const r = new URL("/car", this.url);
          r.password = this.authorization;
          const i = await (async function ({
            url: e,
            fileIterator: t,
            signal: r,
          }) {
            const i = new Headers();
            i.set("Content-Type", "application/octet-stream"), Pn(e, i);
            const s = await xn(t),
              n = await fetch(e, {
                method: "POST",
                signal: r,
                body: s,
                headers: i,
                duplex: "half",
              });
            return await Bn(n), n;
          })({ url: r, fileIterator: e, signal: t });
          return (await i.text())
            .split("\n")
            .filter((e) => e)
            .map((e) => {
              const { cid: t } = JSON.parse(e);
              return `ipfs://${t}/`;
            });
        }
        async uploadFile(e, { fileName: t = "", signal: r = null } = {}) {
          const i = new URL("/upload", this.url);
          i.password = this.authorization;
          const s = await Dn({ url: i, file: e, fileName: t, signal: r }),
            { cid: n } = await s.json();
          return `ipfs://${n}/`;
        }
      }
      class oa extends ea {
        constructor(e = Gn) {
          super(), (this.url = e);
        }
        get type() {
          return Yn;
        }
        async *getFile(
          e,
          { start: t, end: r, signal: i = null, format: s = null } = {}
        ) {
          const { cid: n, path: a, type: o } = Cn(e),
            c = new URL(`/api/v0/cat?arg=/${o}/${n}${a}`, this.url);
          if (
            (t && c.searchParams.set("offset", t),
            r && c.searchParams.set("length", r - (t || 0) + 1),
            s)
          )
            throw new Error("Format is unsupported on Kubo Daemons for now");
          const l = await fetch(c, { method: "POST", signal: i });
          await Bn(l), yield* kn(l.body);
        }
        async *getRaw(e, { signal: t = null } = {}) {
          const { cid: r, path: i, type: s } = Cn(e),
            n = new URL(`/api/v0/block/get?arg=/${s}/${r}${i}`, this.url),
            a = await fetch(n, { method: "POST", signal: t });
          await Bn(a), yield* kn(a.body);
        }
        async *getCar(e, { signal: t = null } = {}) {
          const { cid: r, path: i, type: s } = Cn(e),
            n = new URL(`/api/v0/dag/export?arg=/${s}/${r}${i}`, this.url),
            a = await fetch(n, { method: "POST", signal: t });
          await Bn(a), yield* kn(a.body);
        }
        async *get(
          e,
          { start: t, end: r, signal: i = null, format: s = null } = {}
        ) {
          if (s)
            if ("raw" === s)
              yield* this.getRaw(e, { start: t, end: r, signal: i });
            else {
              if ("car" !== s)
                throw new Error(
                  `Invalid format type, must be car or 'raw', got ${s}`
                );
              yield* this.getCar(e, { start: t, end: r, signal: i });
            }
          yield* this.getFile(e, { start: t, end: r, signal: i });
        }
        async getSize(e, t = null) {
          try {
            const { cid: r, path: i, type: s } = Cn(e),
              n = `/api/v0/file/ls?arg=/${s}/${r}${i}&size=true`,
              a = new URL(n, this.url),
              o = await fetch(a, { method: "POST", signal: t });
            await Bn(o);
            const { Objects: c } = await o.json(),
              [{ Size: l }] = Object.values(c);
            return l;
          } catch (r) {
            return Qn && console.warn(r), this._getSizeWithDag(e, t);
          }
        }
        async _getSizeWithDag(e, t = null) {
          const { cid: r, path: i, type: s } = Cn(e),
            n = new URL(`/api/v0/dag/stat?arg=/${s}/${r}${i}`, this.url),
            a = await fetch(n, { method: "POST", signal: t });
          await Bn(a);
          const { Size: o } = await a.json();
          return parseInt(o, 10);
        }
        async _pin(e, t = null) {
          const { cid: r, path: i, type: s } = Cn(e),
            n = new URL(`/api/v0/pin/add?arg=/${s}/${r}${i}`, this.url),
            a = await fetch(n, { method: "POST", signal: t });
          await Bn(a);
        }
        async _unpin(e, t = null) {
          const { cid: r, path: i, type: s } = Cn(e),
            n = new URL(`/api/v0/pin/rm?arg=/${s}/${r}${i}`, this.url),
            a = await fetch(n, { method: "POST", signal: t });
          await Bn(a);
        }
        async clear(e, t = null) {
          return this._unpin(e, t);
        }
        async uploadCAR(e, t = null) {
          const r = new URL(
              "/api/v0/dag/import?allow-big-block=true&pin-roots=true",
              this.url
            ),
            i = await Dn({ url: r, file: e, signal: t });
          return (await i.text())
            .split("\n")
            .filter((e) => e)
            .map((e) => {
              const { Root: t } = JSON.parse(e);
              return `ipfs://${t.Cid["/"]}/`;
            });
        }
        async uploadFile(e, t = "", r = null) {
          const i = new URL(
              "/api/v0/add?pin=true&cid-version=1&inline=false&raw-leaves=true",
              this.url
            ),
            s = e.name && e instanceof Blob;
          (t || s) && i.searchParams.set("wrap-with-directory", "true");
          const n = await Dn({ url: i, file: e, fileName: t, signal: r }),
            a = await n.text(),
            [o] = a.split("\n"),
            { Hash: c } = JSON.parse(o),
            l = `ipfs://${c}/`;
          return await this._pin(l, r), l;
        }
      }
      let ca = !1;
      const la = !!(
        globalThis &&
        globalThis.chrome &&
        globalThis.chrome.webRequest &&
        globalThis.chrome.webRequest.onBeforeSendHeaders &&
        globalThis.chrome.webRequest.onBeforeSendHeaders.addListener
      );
      async function ha(e = Gn, t = 1e3, r = globalThis.fetch) {
        try {
          const i = new AbortController(),
            { signal: s } = i;
          setTimeout(() => i.abort(), t);
          const n = await r(new URL("/api/v0/version", e), {
            method: "POST",
            signal: s,
          });
          return !!n.ok || !(!n.status || 404 === n.status);
        } catch (t) {
          return Qn && console.warn("Unable to detect Kubo Daemon", t, e), !1;
        }
      }
      let ua = null;
      async function da(e) {
        return ua || (ua = await ra(e)), ua;
      }
      const pa = "https://helper-proxy.webrecorder.workers.dev";
      async function fa(e) {
        const { url: t } = e;
        if (e.extra && e.extra.arrayBuffer) return new ya(e.extra.arrayBuffer);
        const r = t.split(":", 1)[0];
        switch (r) {
          case "blob":
            return new Aa(e);
          case "http":
          case "https":
            return new ga(e);
          case "file":
            return new wa(e);
          case "googledrive":
            return new ma(e);
          case "ipfs":
            return new Ea(e);
        }
        try {
          if (self.location && r === self.location.protocol.split(":")[0])
            return new ga(e);
        } catch (e) {}
        try {
          return await fetch(`${r}://localhost`, { method: "HEAD" }), new ga(e);
        } catch (e) {}
        throw new Error("Invalid URL: " + t);
      }
      class ga {
        constructor({
          url: e,
          headers: t,
          length: r = null,
          canLoadOnDemand: i = !1,
        }) {
          (this.url = e),
            (this.headers = t || {}),
            (this.length = r),
            (this.canLoadOnDemand = i),
            (this.isValid = !1),
            (this.ipfsAPI = null),
            (this.loadingIPFS = null);
        }
        async doInitialFetch(e, t = !1) {
          const r = new Headers(this.headers);
          t || r.set("Range", "bytes=0-"), (this.isValid = !1);
          let i = null,
            s = null;
          if (e)
            try {
              (s = await this.retryFetch(this.url, {
                headers: r,
                method: "HEAD",
                cache: "no-store",
              })),
                (200 !== s.status && 206 != s.status) ||
                  ((this.canLoadOnDemand =
                    206 === s.status ||
                    "bytes" === s.headers.get("Accept-Ranges")),
                  (this.isValid = !0));
            } catch (e) {}
          if (!this.isValid || !this.canLoadOnDemand) {
            i = new AbortController();
            const t = i.signal;
            (s = await this.retryFetch(this.url, {
              headers: r,
              signal: t,
              cache: "no-store",
            })),
              (this.canLoadOnDemand =
                206 === s.status || "bytes" === s.headers.get("Accept-Ranges")),
              (this.isValid = 206 === s.status || 200 === s.status),
              e && (i.abort(), (i = null));
          }
          if (
            null === this.length &&
            ((this.length = Number(s.headers.get("Content-Length"))),
            !this.length && 206 === s.status)
          ) {
            let e = s.headers.get("Content-Range");
            e && ((e = e.split("/")), 2 === e.length && (this.length = e[1]));
          }
          if (null === this.length)
            try {
              const e = await fetch(`${pa}/c/${this.url}`),
                t = await e.json();
              t.size && (this.length = t.size);
            } catch (e) {
              console.log("Error fetching from helper: " + e.toString());
            }
          return (
            (this.length = Number(this.length || 0)), { response: s, abort: i }
          );
        }
        async getLength() {
          if (null === this.length) {
            const { abort: e } = await this.doInitialFetch(!0);
            e && e.abort();
          }
          return this.length;
        }
        async getRange(e, t, r = !1, i = null) {
          const s = new Headers(this.headers);
          s.set("Range", `bytes=${e}-${e + t - 1}`);
          const n = { signal: i, headers: s, cache: "no-store" };
          let a = null;
          try {
            a = await this.retryFetch(this.url, n);
          } catch (e) {
            throw (console.log(e), new fs(this.url));
          }
          if (206 != a.status) {
            const e = { url: this.url, status: a.status, resp: a };
            throw 401 === a.status
              ? new gs(e)
              : 403 == a.status
              ? new ms(e)
              : new fs(e);
          }
          return r ? a.body : new Uint8Array(await a.arrayBuffer());
        }
        async retryFetch(e, t) {
          let r = null,
            i = 1e3;
          for (
            let s = 0;
            s < 20 && ((r = await fetch(e, t)), 429 === r.status);
            s++
          )
            await As(i), (i += 2e3);
          return r;
        }
      }
      class ma {
        constructor({ url: e, headers: t, size: r, extra: i }) {
          (this.fileId = e.slice(14)),
            (this.apiUrl = `https://www.googleapis.com/drive/v3/files/${this.fileId}?alt=media`),
            (this.canLoadOnDemand = !0),
            (this.headers = t),
            i && i.publicUrl
              ? (this.publicUrl = i.publicUrl)
              : (this.publicUrl = null),
            (this.length = r),
            (this.isValid = !1);
        }
        async getLength() {
          return this.length;
        }
        async doInitialFetch(e) {
          let t = null,
            r = null;
          if (this.publicUrl) {
            t = new ga({ url: this.publicUrl, length: this.length });
            try {
              r = await t.doInitialFetch(e);
            } catch (e) {}
            if (
              !t.isValid &&
              (r && r.abort && r.abort.abort(), await this.refreshPublicUrl())
            ) {
              t = new ga({ url: this.publicUrl, length: this.length });
              try {
                r = await t.doInitialFetch(e);
              } catch (e) {}
              !t.isValid && r && r.abort && r.abort.abort();
            }
          }
          return (
            (t && t.isValid) ||
              ((this.publicUrl = null),
              (t = new ga({
                url: this.apiUrl,
                headers: this.headers,
                length: this.length,
              })),
              (r = await t.doInitialFetch(e))),
            (this.isValid = t.isValid),
            this.length || (this.length = t.length),
            r
          );
        }
        async getRange(e, t, r = !1, i) {
          let s = null;
          if (this.publicUrl) {
            s = new ga({ url: this.publicUrl, length: this.length });
            try {
              return await s.getRange(e, t, r, i);
            } catch (n) {
              if (await this.refreshPublicUrl()) {
                s = new ga({ url: this.publicUrl, length: this.length });
                try {
                  return await s.getRange(e, t, r, i);
                } catch (e) {}
              }
            }
            this.publicUrl = null;
          }
          s = new ga({
            url: this.apiUrl,
            headers: this.headers,
            length: this.length,
          });
          let n = 50;
          for (; n < 2e3; )
            try {
              return await s.getRange(e, t, r, i);
            } catch (e) {
              if (
                e instanceof ms &&
                e.info &&
                e.info.resp &&
                e.info.resp.headers
                  .get("content-type")
                  .startsWith("application/json")
              ) {
                const t = await e.info.resp.json();
                if (
                  t.error &&
                  t.error.errors &&
                  "userRateLimitExceeded" === t.error.errors[0].reason
                ) {
                  console.log(`Exponential backoff, waiting for: ${n}`),
                    await As(n),
                    (n *= 2);
                  continue;
                }
              }
              throw e;
            }
        }
        async refreshPublicUrl() {
          try {
            const e = await fetch(`${pa}/g/${this.fileId}`),
              t = await e.json();
            if (t.url) return (this.publicUrl = t.url), !0;
          } catch (e) {}
          return !1;
        }
      }
      class ya {
        constructor(e) {
          (this.arrayBuffer = e),
            (this.size = e.length),
            (this.canLoadOnDemand = !0);
        }
        get length() {
          return this.size;
        }
        get isValid() {
          return !!this.arrayBuffer;
        }
        async getLength() {
          return this.size;
        }
        async doInitialFetch(e = !1) {
          const t = e ? null : va(this.arrayBuffer);
          return { response: new Response(t) };
        }
        async getRange(e, t, r = !1) {
          const i = this.arrayBuffer.slice(e, e + t);
          return r ? va(i) : i;
        }
      }
      class Aa {
        constructor({ url: e, blob: t = null, size: r = null }) {
          (this.url = e),
            (this.blob = t),
            (this.size = this.blob ? this.blob.size : r),
            (this.canLoadOnDemand = !0);
        }
        get length() {
          return this.size;
        }
        get isValid() {
          return !!this.blob;
        }
        async getLength() {
          if (!this.blob || !this.blob.size) {
            let e = await fetch(this.url);
            (this.blob = await e.blob()), (this.size = this.blob.size);
          }
          return this.size;
        }
        async doInitialFetch(e = !1) {
          if (!this.blob)
            try {
              const e = await fetch(this.url);
              (this.blob = await e.blob()), (this.size = this.blob.size);
            } catch (e) {
              throw (console.warn(e), e);
            }
          (this.arrayBuffer = this.blob.arrayBuffer
            ? await this.blob.arrayBuffer()
            : await this._getArrayBuffer()),
            (this.arrayBuffer = new Uint8Array(this.arrayBuffer));
          const t = e ? null : va(this.arrayBuffer);
          return { response: new Response(t) };
        }
        async getRange(e, t, r = !1) {
          this.arrayBuffer || (await this.doInitialFetch(!0));
          const i = this.arrayBuffer.slice(e, e + t);
          return r ? va(i) : i;
        }
        _getArrayBuffer() {
          return new Promise((e) => {
            const t = new FileReader();
            (t.onloadend = () => {
              e(t.result);
            }),
              t.readAsArrayBuffer(this.blob);
          });
        }
      }
      class wa {
        constructor({ blob: e, size: t, extra: r, url: i }) {
          (this.url = i),
            (this.file = e),
            (this.size = this.blob ? this.blob.size : t),
            (this.fileHandle = r.fileHandle),
            (this.canLoadOnDemand = !0);
        }
        get length() {
          return this.size;
        }
        get isValid() {
          return !!this.file;
        }
        async getLength() {
          return void 0 === this.size && (await this.initFileObject()), this.size;
        }
        async initFileObject() {
          const e = { mode: "read" };
          if ("granted" !== (await this.fileHandle.queryPermission(e))) {
            if ("granted" !== (await this.fileHandle.requestPermission(e)))
              throw new gs({ fileHandle: this.fileHandle });
          }
          (this.file = await this.fileHandle.getFile()),
            (this.size = this.file.size);
        }
        async doInitialFetch(e = !1) {
          this.file || (await this.initFileObject());
          const t = e ? null : this.file.stream();
          return { response: new Response(t) };
        }
        async getRange(e, t, r = !1) {
          this.file || (await this.initFileObject());
          const i = this.file.slice(e, e + t);
          return r ? i.stream() : new Uint8Array(await i.arrayBuffer());
        }
      }
      class Ea {
        constructor({ url: e, headers: t, ...r }) {
          (this.url = e), (this.opts = r);
          let i = e.lastIndexOf("#");
          i < 0 && (i = void 0),
            (this.headers = t),
            (this.length = null),
            (this.canLoadOnDemand = !0);
        }
        async getLength() {
          return (
            null === this.length && (await this.doInitialFetch(!0)), this.length
          );
        }
        async doInitialFetch(e) {
          const t = await da(this.opts);
          try {
            (this.length = await t.getSize(this.url)),
              (this.isValid = null !== this.length);
          } catch (e) {
            console.warn(e), (this.length = null), (this.isValid = !1);
          }
          let r = 206;
          this.isValid || (r = 404);
          const i = new AbortController(),
            s = i.signal;
          let n;
          if (e || !this.isValid) n = new Uint8Array([]);
          else {
            n = ba(t.get(this.url, { signal: s }));
          }
          return { response: new Response(n, { status: r }), abort: i };
        }
        async getRange(e, t, r = !1, i = null) {
          const s = (await da(this.opts)).get(this.url, {
            start: e,
            end: e + t - 1,
            signal: i,
          });
          if (r) return ba(s);
          {
            const e = [];
            let t = 0;
            for await (const r of s) e.push(r), (t += r.byteLength);
            return Ii(e, t);
          }
        }
      }
      function ba(e) {
        return new ReadableStream({
          start: async (t) => {
            try {
              for await (const r of e) t.enqueue(r);
            } catch (e) {
              console.log(e);
            }
            t.close();
          },
        });
      }
      function va(e) {
        return new ReadableStream({
          start(t) {
            t.enqueue(e), t.close();
          },
        });
      }
      class Ia extends En {
        constructor(e, t = !1) {
          super(e),
            (this.noCache = t),
            (this.useRefCounts = !t),
            (this.streamMap = new Map());
        }
        async loadRecordFromSource(e) {
          const t = await this.loadSource(e.source),
            r = new Tn(t);
          return { remote: await r.load() };
        }
        async loadPayload(e, t) {
          let r = await super.loadPayload(e, t);
          if (
            r &&
            e.respHeaders &&
            ("warc/revisit" !== e.mime || (e.status >= 300 && e.status < 400))
          )
            return r;
          const i = this.streamMap.get(e.url);
          if (i) return console.log(`Reuse stream for ${e.url}`), new _a(i);
          const { remote: s, hasher: n } = await this.loadRecordFromSource(e);
          if (!s) return console.log(`No WARC Record Loaded for: ${e.url}`), null;
          if (
            !(
              s.url === e.url ||
              (e.method &&
                decodeURIComponent(e.url).startsWith(decodeURIComponent(s.url)))
            )
          )
            return (
              console.log(`Wrong url: expected ${e.url}, got ${s.url}`), null
            );
          if (s.ts !== e.ts) {
            if (1e3 * Math.floor(s.ts / 1e3) !== e.ts)
              return (
                console.log(`Wrong timestamp: expected ${e.ts}, got ${s.ts}`),
                null
              );
          }
          if (s.digest !== e.digest && e.digest && s.digest) {
            const t = s.digest.split(":"),
              r = e.digest.split(":");
            2 === t.length && 2 === r.length && r[1] === t[1]
              ? (e.digest = t[0] + ":" + r[1])
              : console.log(
                  `Wrong digest: expected ${e.digest}, got ${s.digest}`
                );
          }
          if (s.origURL) {
            if (!r && e.status >= 300 && e.status < 400 && s.respHeaders) {
              if (((e.respHeaders = s.respHeaders), !this.noCache))
                try {
                  await this.db.put("resources", e);
                } catch (e) {
                  console.log(e);
                }
              return new Uint8Array([]);
            }
            const i = await this.lookupUrl(s.origURL, s.origTS, {
              ...t,
              noRevisits: !0,
            });
            if (!i) return null;
            const n = (t && t.depth) || 0;
            if (
              !r &&
              (n < 2
                ? (r = await this.loadPayload(i, { ...t, depth: n + 1 }))
                : console.warn(
                    "Avoiding revisit lookup loop for: " + JSON.stringify(s)
                  ),
              !r)
            )
              return null;
            if (
              (s.respHeaders
                ? ((e.respHeaders = s.respHeaders),
                  i.respHeaders["content-length"] &&
                    (e.respHeaders["content-length"] =
                      i.respHeaders["content-length"]))
                : (e.respHeaders = i.respHeaders),
              (e.mime = i.mime),
              (e.digest = i.digest),
              i.extraOpts && (e.extraOpts = i.extraOpts),
              !this.noCache)
            ) {
              delete e.payload;
              try {
                await this.db.put("resources", e);
              } catch (e) {
                console.log(e);
              }
              i.digest === s.digest ||
                r[Symbol.asyncIterator] ||
                (await this.commitPayload(r, s.digest));
            }
            return r;
          }
          const a = s.digest,
            o = e.source.length >= 25e6;
          if (
            (!this.noCache &&
              !o &&
              s.reader &&
              a &&
              (s.reader = new xa(
                this,
                s.reader,
                a,
                e.url,
                this.streamMap,
                n,
                e.recordDigest,
                e.source
              )),
            o && console.log("Not cacheing, too big: " + e.url),
            (r = s.payload),
            !r && !s.reader)
          )
            return null;
          try {
            !r || this.noCache || o || (await this.commitPayload(r, a));
          } catch (t) {
            console.warn(`Payload Update Error: ${e.url}`), console.warn(t);
          }
          if (
            !(
              (e.respHeaders && e.digest) ||
              ((e.respHeaders = s.respHeaders),
              (e.digest = a),
              s.extraOpts && (e.extraOpts = s.extraOpts),
              this.noCache || o)
            )
          )
            try {
              await this.db.put("resources", e);
            } catch (t) {
              console.warn(`Resource Update Error: ${e.url}`), console.warn(t);
            }
          return r || s.reader;
        }
        async commitPayload(e, t) {
          if (!e || 0 === e.length) return;
          const r = this.db.transaction(["payload", "digestRef"], "readwrite");
          try {
            if (
              (r.objectStore("payload").put({ payload: e, digest: t }),
              this.useRefCounts)
            ) {
              const i = await r.objectStore("digestRef").get(t);
              i && ((i.size = e.length), r.objectStore("digestRef").put(i));
            }
            await r.done;
          } catch (e) {
            console.warn("Payload Commit Error: " + e);
          }
        }
      }
      class Sa extends Ia {
        constructor(e, t, r = !1) {
          super(e, r), (this.loader = t);
        }
        updateHeaders(e) {
          this.loader.headers = e;
        }
        async loadSource(e) {
          const { start: t, length: r } = e;
          return await this.loader.getRange(t, r, !0);
        }
      }
      class Ta extends Ia {
        constructor(e, t, r, i = !1) {
          super(e, i), (this.remoteUrlPrefix = t), (this.headers = r);
        }
        updateHeaders(e) {
          this.headers = e;
        }
        async loadSource(e) {
          const { start: t, length: r } = e,
            i =
              (new Headers(this.headers),
              new URL(e.path, this.remoteUrlPrefix).href),
            s = await fa(i);
          return await s.getRange(t, r, !0);
        }
      }
      class _a extends Ci {
        constructor(e) {
          super(),
            (this.chunkstore = e),
            (this.offset = 0),
            (this.size = this.chunkstore.totalLength);
        }
        setLimitSkip(e = -1, t = 0) {
          (this.offset = t), e > 0 && (this.size = e);
        }
        setRangeAll(e) {
          this.size = e;
        }
        getReadableStream() {
          console.log(`Offset: ${this.offset}, Size: ${this.size}`);
          const e = this.chunkstore.getChunkIter();
          return new Ni(e, this.size, this.offset).getReadableStream();
        }
      }
      class Ca {
        constructor(e) {
          (this.chunks = []),
            (this.size = 0),
            (this.done = !1),
            (this.totalLength = e),
            (this.nextChunk = new Promise((e) => (this._nextResolve = e)));
        }
        add(e) {
          this.chunks.push(e),
            (this.size += e.byteLength),
            this._nextResolve(!0),
            (this.nextChunk = new Promise((e) => (this._nextResolve = e)));
        }
        concatChunks() {
          return (
            this._nextResolve(!1), (this.done = !0), Ii(this.chunks, this.size)
          );
        }
        async *getChunkIter() {
          for (const e of this.chunks) yield e;
          let e = this.chunks.length;
          for (; !this.done && (await this.nextChunk); )
            for (; e < this.chunks.length; e++) yield this.chunks[e];
        }
      }
      class xa extends Ci {
        constructor(e, t, r, i = "", s, n, a, o) {
          super(),
            (this.db = e),
            (this.reader = t),
            (this.digest = r),
            (this.url = i),
            (this.commit = !0),
            (this.fullbuff = null),
            (this.hasher = n),
            (this.expectedHash = a),
            (this.source = o),
            (this.isRange = !1),
            (this.totalLength = -1),
            (this.streamMap = s);
        }
        setRangeAll(e) {
          (this.isRange = !0), (this.totalLength = e);
        }
        setLimitSkip(e = -1, t = 0) {
          (this.isRange = !0),
            2 !== e || 0 !== t
              ? ((-1 != e || t > 0) && (this.commit = !1),
                this.reader.setLimitSkip(e, t))
              : (this.fixedSize = 2);
        }
        async *[Symbol.asyncIterator]() {
          let e = null;
          this.commit &&
            ((e = new Ca(this.totalLength)),
            this.isRange &&
              (console.log(`Store stream for ${this.url}, ${this.totalLength}`),
              this.streamMap.set(this.url, e)));
          for await (const t of this.reader) e && e.add(t), yield t;
          if (0 !== this.reader.limit)
            console.warn(
              `Expected payload not consumed, ${this.reader.limit} bytes left`
            );
          else {
            if (
              !this.isRange &&
              this.hasher &&
              this.expectedHash &&
              this.source
            ) {
              const e = this.hasher.getHash(),
                { path: t, start: r, length: i } = this.source,
                s = `${t}:${r}-${i}`;
              this.db.addVerifyData(s, this.expectedHash, e);
            }
            this.commit &&
              ((this.fullbuff = e.concatChunks()),
              await this.db.commitPayload(this.fullbuff, this.digest));
          }
          this.commit &&
            this.isRange &&
            (this.streamMap.delete(this.url),
            console.log(`Delete stream for ${this.url}`));
        }
        async _consumeIter(e) {
          for await (const t of e);
        }
        async readFully() {
          return this.fullbuff || (await this._consumeIter(this)), this.fullbuff;
        }
        getReadableStream() {
          const e = super.getReadableStream();
          if (!this.commit) return e;
          const t = e.tee();
          return (
            this._consumeIter(xi.fromReadable(t[1].getReader())),
            this.fixedSize
              ? this.getFixedSizeReader(t[0].getReader(), this.fixedSize)
              : t[0]
          );
        }
        getFixedSizeReader(e, t) {
          return new ReadableStream({
            async start(r) {
              const { value: i, done: s } = await e.read();
              s || r.enqueue(i.slice(0, t)), r.close(), e.close();
            },
          });
        }
      }
      const Na = "req.http:cookie";
      class ka extends Sn {
        constructor(e, t, r, i = {}, s = "sha256:") {
          super(e, t, r),
            (this.cdxindexer = null),
            (this.sourceExtra = i),
            (this.shaPrefix = s);
        }
        filterRecord(e) {
          switch (e.warcType) {
            case "warcinfo":
            case "revisit":
            case "request":
              return null;
            case "metadata":
              return this.shouldIndexMetadataRecord(e) ? null : "skip";
          }
          const t = e.warcTargetURI,
            r = new Date(e.warcDate).getTime();
          if (this.pageMap[r + "/" + t]) return (e._isPage = !0), null;
        }
        index(e, t) {
          return (
            e && ((e._offset = t.offset), (e._length = t.recordLength)),
            super.index(e, t)
          );
        }
        indexReqResponse(e, t, r) {
          if (e._isPage) return super.indexReqResponse(e, t, r);
          if ("warcinfo" === e.warcType) return void this.parseWarcInfo(e);
          this.cdxindexer || (this.cdxindexer = new $i({ noSurt: !0 }, null));
          const i = this.cdxindexer.indexRecordPair(e, t, r, "");
          if (
            i &&
            (206 !== i.status || this.isFullRangeRequest(e.httpHeaders.headers))
          ) {
            if (t && t.httpHeaders) {
              let e = t.httpHeaders.headers.get("cookie");
              e && (i[Na] = e);
            }
            this.addCdx(i);
          }
        }
        getSource(e) {
          return {
            ...this.sourceExtra,
            path: e.filename,
            start: Number(e.offset),
            length: Number(e.length),
          };
        }
        addCdx(e) {
          const { url: t, mime: r } = e,
            i = Number(e.status) || 200,
            s = ss(e.timestamp).getTime(),
            n = this.getSource(e);
          let { digest: a, recordDigest: o } = e;
          a && -1 === a.indexOf(":") && (a = this.shaPrefix + a);
          const c = {
            url: t,
            ts: s,
            status: i,
            digest: a,
            recordDigest: o,
            mime: r,
            loaded: !1,
            source: n,
          };
          if (e.method) {
            if ("HEAD" === e.method || "OPTIONS" === e.method) return;
            c.method = e.method;
          }
          e[Na] && (c[Na] = e[Na]),
            e.method &&
              "GET" !== e.method &&
              (c.url = Ei(e.url, e.requestBody || "", e.method)),
            this.addResource(c);
        }
      }
      class Ra extends ka {
        async load(e, t, r) {
          this.db = e;
          let i = this.reader;
          i.iterLines || (i = new xi(this.reader));
          let s = 0;
          for await (const e of i.iterLines()) {
            let i, n, a;
            s += e.length;
            let o = e.trimEnd();
            if (!o.startsWith("{")) {
              const e = o.indexOf(" {");
              if (e < 0) continue;
              ([n, a] = o.split(" ", 2)), (o = o.slice(e));
            }
            try {
              i = JSON.parse(o);
            } catch (e) {
              console.log("JSON Parser error on: " + o);
              continue;
            }
            (i.timestamp = a),
              i.url ||
                ((i.url = n), console.warn(`URL missing, using urlkey ${n}`)),
              t && this.isBatchFull() && t(Math.round((s / r) * 100), null, s, r),
              this.addCdx(i);
          }
          await this.finishIndexing(), t && t(100, null, r, r);
        }
      }
      const Ba = 4294967295,
        Da = 65535;
      class Oa {
        constructor(e, t) {
          (this.start = e), (this.length = t);
        }
      }
      class La extends xi {
        constructor(e, t = "gzip", r = !1) {
          super(e, t, r),
            (this.hasher = null),
            (this.hashInited = !1),
            (this.hash = "");
        }
        async initHasher() {
          try {
            this.hasher = await gi();
          } catch (e) {
            console.warn("Hasher init failed, not hashing", e);
          } finally {
            this.hashInited = !0;
          }
        }
        async _loadNext() {
          const e = await super._loadNext();
          return (
            e
              ? (this.hashInited || (await this.initHasher()),
                this.hasher && this.hasher.update(e))
              : this.hasher &&
                ((this.hash = "sha256:" + this.hasher.digest("hex")),
                (this.hasher = null)),
            e
          );
        }
        getHash() {
          return this.hash;
        }
      }
      class Pa {
        constructor(e, t = null) {
          (this.loader = e),
            (this.entries = t),
            (this.entriesUpdated = !1),
            (this.enableHashing = !0);
        }
        async load(e = !1) {
          if (!this.entries || e) {
            const e = await this.loader.getLength(),
              t = Math.min(65558, e),
              r = e - t,
              i = await this.loader.getRange(r, t);
            try {
              this.entries = this._loadEntries(i, r);
            } catch (e) {
              if (e instanceof Oa) {
                const r = Ii(
                  [await this.loader.getRange(e.start, e.length), i],
                  e.length + t
                );
                this.entries = this._loadEntries(r, e.start);
              }
            }
            this.entriesUpdated = !0;
          }
          return this.entries;
        }
        _loadEntries(e, t) {
          const r = e.byteLength;
          if (!r) return null;
          const i = new DataView(e.buffer, e.byteOffset, e.byteLength),
            s = new TextDecoder("utf8"),
            n = new TextDecoder("ascii"),
            a = {};
          let o = 0,
            c = 0,
            l = r;
          for (let t = r - 22, s = Math.max(0, t - Da); t >= s; --t)
            if (
              80 === e[t] &&
              75 === e[t + 1] &&
              5 === e[t + 2] &&
              6 === e[t + 3]
            ) {
              (l = t),
                (c = i.getUint32(t + 16, !0)),
                (o = i.getUint16(t + 8, !0));
              break;
            }
          if (c === Ba || o === Da) {
            if (117853008 !== i.getUint32(l - 20, !0))
              return void console.warn("invalid zip64 EOCD locator");
            const e = this.getUint64(i, l - 12, !0) - t;
            if (101075792 !== i.getUint32(e, !0))
              return void console.warn("invalid zip64 EOCD record");
            (o = this.getUint64(i, e + 32, !0)),
              (c = this.getUint64(i, e + 48, !0));
          }
          if (c >= t) c -= t;
          else if (c < t && c > 0) throw new Oa(c, t - c);
          if (c >= r || c < 0)
            for (
              c = -1, o = Da;
              ++c < r &&
              80 !== e[c] &&
              75 !== e[c + 1] &&
              1 !== e[c + 2] &&
              2 !== e[c + 3];
  
            );
          for (l -= 46; --o >= 0 && c < l && 1347092738 == i.getUint32(c); ) {
            const t = i.getUint16(c + 8, !0);
            let r = i.getUint32(c + 20, !0),
              o = i.getUint32(c + 24, !0);
            const l = i.getUint16(c + 28, !0),
              h = i.getUint16(c + 30, !0),
              u = i.getUint16(c + 32, !0),
              d = 8 === i.getUint16(c + 10, !0);
            let p = i.getUint32(c + 42, !0);
            const f = (2048 & t ? s : n).decode(e.subarray(c + 46, c + 46 + l));
            if (r === Ba || o === Ba || p === Ba) {
              let e = c + 46 + l;
              const t = e + h - 3;
              for (; e < t; ) {
                const t = i.getUint16(e, !0);
                let s = i.getUint16(e + 2, !0);
                (e += 4),
                  1 === t &&
                    (o === Ba &&
                      s >= 8 &&
                      ((o = this.getUint64(i, e, !0)), (e += 8), (s -= 8)),
                    r === Ba &&
                      s >= 8 &&
                      ((r = this.getUint64(i, e, !0)), (e += 8), (s -= 8)),
                    p === Ba &&
                      s >= 8 &&
                      ((p = this.getUint64(i, e, !0)), (e += 8), (s -= 8))),
                  (e += s);
              }
            }
            f.endsWith("/") ||
              ((a[f] = {
                filename: f,
                deflate: d,
                uncompressedSize: o,
                compressedSize: r,
                localEntryOffset: p,
              }),
              h || (a[f].offset = 30 + l + p)),
              (c += 46 + l + h + u);
          }
          return a;
        }
        getCompressedSize(e) {
          if (null === this.entries) return 0;
          const t = this.entries[e];
          return t ? (isNaN(t.compressedSize) ? 0 : t.compressedSize) : 0;
        }
        async loadFile(
          e,
          {
            offset: t = 0,
            length: r = -1,
            signal: i = null,
            unzip: s = !1,
            computeHash: n = null,
          } = {}
        ) {
          null === this.entries && (await this.load());
          const a = this.entries[e];
          if (!a) return { reader: null };
          if (void 0 === a.offset) {
            const e = await this.loader.getRange(a.localEntryOffset, 30),
              t = new DataView(e.buffer, e.byteOffset, e.byteLength),
              r = t.getUint16(26, !0),
              i = t.getUint16(28, !0);
            (a.offset = 30 + r + i + a.localEntryOffset),
              (this.entriesUpdated = !0);
          }
          (r = r < 0 ? a.compressedSize : Math.min(r, a.compressedSize - t)),
            (t += a.offset);
          let o = (await this.loader.getRange(t, r, !0, i)).getReader(),
            c = null;
          const l = (e) => (n && this.enableHashing ? ((c = new La(e)), c) : e);
          return (
            s
              ? a.deflate
                ? ((o = new xi(new xi(o, "deflate"))), (o = l(o)))
                : ((o = l(o)), (o = new xi(o)))
              : ((o = new xi(o, a.deflate ? "deflate" : null)), (o = l(o))),
            { reader: o, hasher: c }
          );
        }
        getUint64(e, t, r) {
          const i = e.getUint32(t, r),
            s = e.getUint32(t + 4, r),
            n = r ? i + 2 ** 32 * s : 2 ** 32 * i + s;
          return (
            Number.isSafeInteger(n) ||
              console.warn(n, "exceeds MAX_SAFE_INTEGER. Precision may be lost"),
            n
          );
        }
      }
      class Ua {
        constructor(e, t) {
          (this.zipreader = e), (this.filename = t), (this.size = null);
        }
        async doInitialFetch(e = !1) {
          await this.zipreader.load(),
            (this.size = this.zipreader.getCompressedSize(this.filename));
          let t = null;
          if (!e) {
            const { reader: e } = await this.zipreader.loadFile(this.filename, {
              unzip: !0,
            });
            t = ba(e);
          }
          return { response: new Response(t) };
        }
        async getLength() {
          return null === this.size && (await this.doInitialFetch(!0)), this.size;
        }
        async getRange(e, t, r = !1, i = null) {
          const { reader: s } = await this.zipreader.loadFile(this.filename, {
            offset: e,
            length: t,
            signal: i,
            unzip: !0,
          });
          return r ? ba(s) : await s.readFully();
        }
      }
      const Ma = "wacz";
      class Fa {
        getLoadPath() {}
        getName() {}
        async createLoader() {}
      }
      class Ha extends Fa {
        constructor({
          waczname: e,
          hash: t,
          path: r,
          parent: i = null,
          entries: s = null,
          fileType: n = Ma,
          indexType: a = 0,
          nonSurt: o = !1,
          loader: c = null,
        } = {}) {
          super(),
            (this.waczname = e),
            (this.hash = t),
            (this.path = r),
            (this.loader = c),
            (this.parent = i),
            (this.zipreader = null),
            (this.entries = s),
            (this.indexType = a),
            (this.fileType = n),
            (this.nonSurt = o);
        }
        markAsMultiWACZ() {
          this.fileType = "multi-wacz";
        }
        async init(e) {
          e && (this.path = e);
          const t = this.loader
            ? this.loader
            : await this.parent.createLoader({ url: this.path });
          return await this.initFromLoader(t);
        }
        async initFromLoader(e) {
          return (
            (this.zipreader = new Pa(e, this.entries)),
            this.entries || (this.entries = await this.zipreader.load()),
            this.entries
          );
        }
        async loadFile(e, t) {
          return (
            this.zipreader || (await this.init()),
            await this.zipreader.loadFile(e, t)
          );
        }
        containsFile(e) {
          return !!this.entries[e];
        }
        getSizeOf(e) {
          return this.zipreader ? this.zipreader.getCompressedSize(e) : 0;
        }
        serialize() {
          return {
            waczname: this.waczname,
            hash: this.hash,
            path: this.path,
            entries: this.entries,
            indexType: this.indexType,
            nonSurt: this.nonSurt,
          };
        }
        async save(e, t = !1) {
          const r = this.zipreader;
          (t || (r && r.entriesUpdated)) &&
            (await e.put("waczfiles", this.serialize()),
            r && (r.entriesUpdated = !1));
        }
        iterContainedFiles() {
          return this.entries ? Object.keys(this.entries) : [];
        }
        getLoadPath(e) {
          return this.waczname + "#!/" + e;
        }
        getName(e) {
          return this.waczname + "#!/" + e;
        }
        async createLoader(e) {
          const { url: t } = e,
            r = t.lastIndexOf("#!/");
          if ((this.zipreader || (await this.init()), r >= 0))
            return new Ua(this.zipreader, t.slice(r + 3));
        }
      }
      /*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT */
      function Qa(e) {
        return null == e;
      }
      var Va = {
        isNothing: Qa,
        isObject: function (e) {
          return "object" == typeof e && null !== e;
        },
        toArray: function (e) {
          return Array.isArray(e) ? e : Qa(e) ? [] : [e];
        },
        repeat: function (e, t) {
          var r,
            i = "";
          for (r = 0; r < t; r += 1) i += e;
          return i;
        },
        isNegativeZero: function (e) {
          return 0 === e && Number.NEGATIVE_INFINITY === 1 / e;
        },
        extend: function (e, t) {
          var r, i, s, n;
          if (t)
            for (r = 0, i = (n = Object.keys(t)).length; r < i; r += 1)
              e[(s = n[r])] = t[s];
          return e;
        },
      };
      function za(e, t) {
        var r = "",
          i = e.reason || "(unknown reason)";
        return e.mark
          ? (e.mark.name && (r += 'in "' + e.mark.name + '" '),
            (r += "(" + (e.mark.line + 1) + ":" + (e.mark.column + 1) + ")"),
            !t && e.mark.snippet && (r += "\n\n" + e.mark.snippet),
            i + " " + r)
          : i;
      }
      function qa(e, t) {
        Error.call(this),
          (this.name = "YAMLException"),
          (this.reason = e),
          (this.mark = t),
          (this.message = za(this, !1)),
          Error.captureStackTrace
            ? Error.captureStackTrace(this, this.constructor)
            : (this.stack = new Error().stack || "");
      }
      (qa.prototype = Object.create(Error.prototype)),
        (qa.prototype.constructor = qa),
        (qa.prototype.toString = function (e) {
          return this.name + ": " + za(this, e);
        });
      var Ga = qa;
      function ja(e, t, r, i, s) {
        var n = "",
          a = "",
          o = Math.floor(s / 2) - 1;
        return (
          i - t > o && (t = i - o + (n = " ... ").length),
          r - i > o && (r = i + o - (a = " ...").length),
          {
            str: n + e.slice(t, r).replace(/\t/g, "") + a,
            pos: i - t + n.length,
          }
        );
      }
      function Wa(e, t) {
        return Va.repeat(" ", t - e.length) + e;
      }
      var Ya = function (e, t) {
          if (((t = Object.create(t || null)), !e.buffer)) return null;
          t.maxLength || (t.maxLength = 79),
            "number" != typeof t.indent && (t.indent = 1),
            "number" != typeof t.linesBefore && (t.linesBefore = 3),
            "number" != typeof t.linesAfter && (t.linesAfter = 2);
          for (
            var r, i = /\r?\n|\r|\0/g, s = [0], n = [], a = -1;
            (r = i.exec(e.buffer));
  
          )
            n.push(r.index),
              s.push(r.index + r[0].length),
              e.position <= r.index && a < 0 && (a = s.length - 2);
          a < 0 && (a = s.length - 1);
          var o,
            c,
            l = "",
            h = Math.min(e.line + t.linesAfter, n.length).toString().length,
            u = t.maxLength - (t.indent + h + 3);
          for (o = 1; o <= t.linesBefore && !(a - o < 0); o++)
            (c = ja(
              e.buffer,
              s[a - o],
              n[a - o],
              e.position - (s[a] - s[a - o]),
              u
            )),
              (l =
                Va.repeat(" ", t.indent) +
                Wa((e.line - o + 1).toString(), h) +
                " | " +
                c.str +
                "\n" +
                l);
          for (
            c = ja(e.buffer, s[a], n[a], e.position, u),
              l +=
                Va.repeat(" ", t.indent) +
                Wa((e.line + 1).toString(), h) +
                " | " +
                c.str +
                "\n",
              l += Va.repeat("-", t.indent + h + 3 + c.pos) + "^\n",
              o = 1;
            o <= t.linesAfter && !(a + o >= n.length);
            o++
          )
            (c = ja(
              e.buffer,
              s[a + o],
              n[a + o],
              e.position - (s[a] - s[a + o]),
              u
            )),
              (l +=
                Va.repeat(" ", t.indent) +
                Wa((e.line + o + 1).toString(), h) +
                " | " +
                c.str +
                "\n");
          return l.replace(/\n$/, "");
        },
        Xa = [
          "kind",
          "multi",
          "resolve",
          "construct",
          "instanceOf",
          "predicate",
          "represent",
          "representName",
          "defaultStyle",
          "styleAliases",
        ],
        Ka = ["scalar", "sequence", "mapping"];
      var Ja = function (e, t) {
        if (
          ((t = t || {}),
          Object.keys(t).forEach(function (t) {
            if (-1 === Xa.indexOf(t))
              throw new Ga(
                'Unknown option "' +
                  t +
                  '" is met in definition of "' +
                  e +
                  '" YAML type.'
              );
          }),
          (this.options = t),
          (this.tag = e),
          (this.kind = t.kind || null),
          (this.resolve =
            t.resolve ||
            function () {
              return !0;
            }),
          (this.construct =
            t.construct ||
            function (e) {
              return e;
            }),
          (this.instanceOf = t.instanceOf || null),
          (this.predicate = t.predicate || null),
          (this.represent = t.represent || null),
          (this.representName = t.representName || null),
          (this.defaultStyle = t.defaultStyle || null),
          (this.multi = t.multi || !1),
          (this.styleAliases = (function (e) {
            var t = {};
            return (
              null !== e &&
                Object.keys(e).forEach(function (r) {
                  e[r].forEach(function (e) {
                    t[String(e)] = r;
                  });
                }),
              t
            );
          })(t.styleAliases || null)),
          -1 === Ka.indexOf(this.kind))
        )
          throw new Ga(
            'Unknown kind "' +
              this.kind +
              '" is specified for "' +
              e +
              '" YAML type.'
          );
      };
      function Za(e, t) {
        var r = [];
        return (
          e[t].forEach(function (e) {
            var t = r.length;
            r.forEach(function (r, i) {
              r.tag === e.tag &&
                r.kind === e.kind &&
                r.multi === e.multi &&
                (t = i);
            }),
              (r[t] = e);
          }),
          r
        );
      }
      function $a(e) {
        return this.extend(e);
      }
      $a.prototype.extend = function (e) {
        var t = [],
          r = [];
        if (e instanceof Ja) r.push(e);
        else if (Array.isArray(e)) r = r.concat(e);
        else {
          if (!e || (!Array.isArray(e.implicit) && !Array.isArray(e.explicit)))
            throw new Ga(
              "Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })"
            );
          e.implicit && (t = t.concat(e.implicit)),
            e.explicit && (r = r.concat(e.explicit));
        }
        t.forEach(function (e) {
          if (!(e instanceof Ja))
            throw new Ga(
              "Specified list of YAML types (or a single Type object) contains a non-Type object."
            );
          if (e.loadKind && "scalar" !== e.loadKind)
            throw new Ga(
              "There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported."
            );
          if (e.multi)
            throw new Ga(
              "There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit."
            );
        }),
          r.forEach(function (e) {
            if (!(e instanceof Ja))
              throw new Ga(
                "Specified list of YAML types (or a single Type object) contains a non-Type object."
              );
          });
        var i = Object.create($a.prototype);
        return (
          (i.implicit = (this.implicit || []).concat(t)),
          (i.explicit = (this.explicit || []).concat(r)),
          (i.compiledImplicit = Za(i, "implicit")),
          (i.compiledExplicit = Za(i, "explicit")),
          (i.compiledTypeMap = (function () {
            var e,
              t,
              r = {
                scalar: {},
                sequence: {},
                mapping: {},
                fallback: {},
                multi: { scalar: [], sequence: [], mapping: [], fallback: [] },
              };
            function i(e) {
              e.multi
                ? (r.multi[e.kind].push(e), r.multi.fallback.push(e))
                : (r[e.kind][e.tag] = r.fallback[e.tag] = e);
            }
            for (e = 0, t = arguments.length; e < t; e += 1)
              arguments[e].forEach(i);
            return r;
          })(i.compiledImplicit, i.compiledExplicit)),
          i
        );
      };
      var eo = $a,
        to = new Ja("tag:yaml.org,2002:str", {
          kind: "scalar",
          construct: function (e) {
            return null !== e ? e : "";
          },
        }),
        ro = new Ja("tag:yaml.org,2002:seq", {
          kind: "sequence",
          construct: function (e) {
            return null !== e ? e : [];
          },
        }),
        io = new Ja("tag:yaml.org,2002:map", {
          kind: "mapping",
          construct: function (e) {
            return null !== e ? e : {};
          },
        }),
        so = new eo({ explicit: [to, ro, io] });
      var no = new Ja("tag:yaml.org,2002:null", {
        kind: "scalar",
        resolve: function (e) {
          if (null === e) return !0;
          var t = e.length;
          return (
            (1 === t && "~" === e) ||
            (4 === t && ("null" === e || "Null" === e || "NULL" === e))
          );
        },
        construct: function () {
          return null;
        },
        predicate: function (e) {
          return null === e;
        },
        represent: {
          canonical: function () {
            return "~";
          },
          lowercase: function () {
            return "null";
          },
          uppercase: function () {
            return "NULL";
          },
          camelcase: function () {
            return "Null";
          },
          empty: function () {
            return "";
          },
        },
        defaultStyle: "lowercase",
      });
      var ao = new Ja("tag:yaml.org,2002:bool", {
        kind: "scalar",
        resolve: function (e) {
          if (null === e) return !1;
          var t = e.length;
          return (
            (4 === t && ("true" === e || "True" === e || "TRUE" === e)) ||
            (5 === t && ("false" === e || "False" === e || "FALSE" === e))
          );
        },
        construct: function (e) {
          return "true" === e || "True" === e || "TRUE" === e;
        },
        predicate: function (e) {
          return "[object Boolean]" === Object.prototype.toString.call(e);
        },
        represent: {
          lowercase: function (e) {
            return e ? "true" : "false";
          },
          uppercase: function (e) {
            return e ? "TRUE" : "FALSE";
          },
          camelcase: function (e) {
            return e ? "True" : "False";
          },
        },
        defaultStyle: "lowercase",
      });
      function oo(e) {
        return 48 <= e && e <= 55;
      }
      function co(e) {
        return 48 <= e && e <= 57;
      }
      var lo = new Ja("tag:yaml.org,2002:int", {
          kind: "scalar",
          resolve: function (e) {
            if (null === e) return !1;
            var t,
              r,
              i = e.length,
              s = 0,
              n = !1;
            if (!i) return !1;
            if ((("-" !== (t = e[s]) && "+" !== t) || (t = e[++s]), "0" === t)) {
              if (s + 1 === i) return !0;
              if ("b" === (t = e[++s])) {
                for (s++; s < i; s++)
                  if ("_" !== (t = e[s])) {
                    if ("0" !== t && "1" !== t) return !1;
                    n = !0;
                  }
                return n && "_" !== t;
              }
              if ("x" === t) {
                for (s++; s < i; s++)
                  if ("_" !== (t = e[s])) {
                    if (
                      !(
                        (48 <= (r = e.charCodeAt(s)) && r <= 57) ||
                        (65 <= r && r <= 70) ||
                        (97 <= r && r <= 102)
                      )
                    )
                      return !1;
                    n = !0;
                  }
                return n && "_" !== t;
              }
              if ("o" === t) {
                for (s++; s < i; s++)
                  if ("_" !== (t = e[s])) {
                    if (!oo(e.charCodeAt(s))) return !1;
                    n = !0;
                  }
                return n && "_" !== t;
              }
            }
            if ("_" === t) return !1;
            for (; s < i; s++)
              if ("_" !== (t = e[s])) {
                if (!co(e.charCodeAt(s))) return !1;
                n = !0;
              }
            return !(!n || "_" === t);
          },
          construct: function (e) {
            var t,
              r = e,
              i = 1;
            if (
              (-1 !== r.indexOf("_") && (r = r.replace(/_/g, "")),
              ("-" !== (t = r[0]) && "+" !== t) ||
                ("-" === t && (i = -1), (t = (r = r.slice(1))[0])),
              "0" === r)
            )
              return 0;
            if ("0" === t) {
              if ("b" === r[1]) return i * parseInt(r.slice(2), 2);
              if ("x" === r[1]) return i * parseInt(r.slice(2), 16);
              if ("o" === r[1]) return i * parseInt(r.slice(2), 8);
            }
            return i * parseInt(r, 10);
          },
          predicate: function (e) {
            return (
              "[object Number]" === Object.prototype.toString.call(e) &&
              e % 1 == 0 &&
              !Va.isNegativeZero(e)
            );
          },
          represent: {
            binary: function (e) {
              return e >= 0
                ? "0b" + e.toString(2)
                : "-0b" + e.toString(2).slice(1);
            },
            octal: function (e) {
              return e >= 0
                ? "0o" + e.toString(8)
                : "-0o" + e.toString(8).slice(1);
            },
            decimal: function (e) {
              return e.toString(10);
            },
            hexadecimal: function (e) {
              return e >= 0
                ? "0x" + e.toString(16).toUpperCase()
                : "-0x" + e.toString(16).toUpperCase().slice(1);
            },
          },
          defaultStyle: "decimal",
          styleAliases: {
            binary: [2, "bin"],
            octal: [8, "oct"],
            decimal: [10, "dec"],
            hexadecimal: [16, "hex"],
          },
        }),
        ho = new RegExp(
          "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
        );
      var uo = /^[-+]?[0-9]+e/;
      var po = new Ja("tag:yaml.org,2002:float", {
          kind: "scalar",
          resolve: function (e) {
            return null !== e && !(!ho.test(e) || "_" === e[e.length - 1]);
          },
          construct: function (e) {
            var t, r;
            return (
              (r = "-" === (t = e.replace(/_/g, "").toLowerCase())[0] ? -1 : 1),
              "+-".indexOf(t[0]) >= 0 && (t = t.slice(1)),
              ".inf" === t
                ? 1 === r
                  ? Number.POSITIVE_INFINITY
                  : Number.NEGATIVE_INFINITY
                : ".nan" === t
                ? NaN
                : r * parseFloat(t, 10)
            );
          },
          predicate: function (e) {
            return (
              "[object Number]" === Object.prototype.toString.call(e) &&
              (e % 1 != 0 || Va.isNegativeZero(e))
            );
          },
          represent: function (e, t) {
            var r;
            if (isNaN(e))
              switch (t) {
                case "lowercase":
                  return ".nan";
                case "uppercase":
                  return ".NAN";
                case "camelcase":
                  return ".NaN";
              }
            else if (Number.POSITIVE_INFINITY === e)
              switch (t) {
                case "lowercase":
                  return ".inf";
                case "uppercase":
                  return ".INF";
                case "camelcase":
                  return ".Inf";
              }
            else if (Number.NEGATIVE_INFINITY === e)
              switch (t) {
                case "lowercase":
                  return "-.inf";
                case "uppercase":
                  return "-.INF";
                case "camelcase":
                  return "-.Inf";
              }
            else if (Va.isNegativeZero(e)) return "-0.0";
            return (r = e.toString(10)), uo.test(r) ? r.replace("e", ".e") : r;
          },
          defaultStyle: "lowercase",
        }),
        fo = so.extend({ implicit: [no, ao, lo, po] }),
        go = fo,
        mo = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"),
        yo = new RegExp(
          "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
        );
      var Ao = new Ja("tag:yaml.org,2002:timestamp", {
        kind: "scalar",
        resolve: function (e) {
          return null !== e && (null !== mo.exec(e) || null !== yo.exec(e));
        },
        construct: function (e) {
          var t,
            r,
            i,
            s,
            n,
            a,
            o,
            c,
            l = 0,
            h = null;
          if ((null === (t = mo.exec(e)) && (t = yo.exec(e)), null === t))
            throw new Error("Date resolve error");
          if (((r = +t[1]), (i = +t[2] - 1), (s = +t[3]), !t[4]))
            return new Date(Date.UTC(r, i, s));
          if (((n = +t[4]), (a = +t[5]), (o = +t[6]), t[7])) {
            for (l = t[7].slice(0, 3); l.length < 3; ) l += "0";
            l = +l;
          }
          return (
            t[9] &&
              ((h = 6e4 * (60 * +t[10] + +(t[11] || 0))),
              "-" === t[9] && (h = -h)),
            (c = new Date(Date.UTC(r, i, s, n, a, o, l))),
            h && c.setTime(c.getTime() - h),
            c
          );
        },
        instanceOf: Date,
        represent: function (e) {
          return e.toISOString();
        },
      });
      var wo = new Ja("tag:yaml.org,2002:merge", {
          kind: "scalar",
          resolve: function (e) {
            return "<<" === e || null === e;
          },
        }),
        Eo =
          "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
      var bo = new Ja("tag:yaml.org,2002:binary", {
          kind: "scalar",
          resolve: function (e) {
            if (null === e) return !1;
            var t,
              r,
              i = 0,
              s = e.length,
              n = Eo;
            for (r = 0; r < s; r++)
              if (!((t = n.indexOf(e.charAt(r))) > 64)) {
                if (t < 0) return !1;
                i += 6;
              }
            return i % 8 == 0;
          },
          construct: function (e) {
            var t,
              r,
              i = e.replace(/[\r\n=]/g, ""),
              s = i.length,
              n = Eo,
              a = 0,
              o = [];
            for (t = 0; t < s; t++)
              t % 4 == 0 &&
                t &&
                (o.push((a >> 16) & 255),
                o.push((a >> 8) & 255),
                o.push(255 & a)),
                (a = (a << 6) | n.indexOf(i.charAt(t)));
            return (
              0 === (r = (s % 4) * 6)
                ? (o.push((a >> 16) & 255),
                  o.push((a >> 8) & 255),
                  o.push(255 & a))
                : 18 === r
                ? (o.push((a >> 10) & 255), o.push((a >> 2) & 255))
                : 12 === r && o.push((a >> 4) & 255),
              new Uint8Array(o)
            );
          },
          predicate: function (e) {
            return "[object Uint8Array]" === Object.prototype.toString.call(e);
          },
          represent: function (e) {
            var t,
              r,
              i = "",
              s = 0,
              n = e.length,
              a = Eo;
            for (t = 0; t < n; t++)
              t % 3 == 0 &&
                t &&
                ((i += a[(s >> 18) & 63]),
                (i += a[(s >> 12) & 63]),
                (i += a[(s >> 6) & 63]),
                (i += a[63 & s])),
                (s = (s << 8) + e[t]);
            return (
              0 === (r = n % 3)
                ? ((i += a[(s >> 18) & 63]),
                  (i += a[(s >> 12) & 63]),
                  (i += a[(s >> 6) & 63]),
                  (i += a[63 & s]))
                : 2 === r
                ? ((i += a[(s >> 10) & 63]),
                  (i += a[(s >> 4) & 63]),
                  (i += a[(s << 2) & 63]),
                  (i += a[64]))
                : 1 === r &&
                  ((i += a[(s >> 2) & 63]),
                  (i += a[(s << 4) & 63]),
                  (i += a[64]),
                  (i += a[64])),
              i
            );
          },
        }),
        vo = Object.prototype.hasOwnProperty,
        Io = Object.prototype.toString;
      var So = new Ja("tag:yaml.org,2002:omap", {
          kind: "sequence",
          resolve: function (e) {
            if (null === e) return !0;
            var t,
              r,
              i,
              s,
              n,
              a = [],
              o = e;
            for (t = 0, r = o.length; t < r; t += 1) {
              if (((i = o[t]), (n = !1), "[object Object]" !== Io.call(i)))
                return !1;
              for (s in i)
                if (vo.call(i, s)) {
                  if (n) return !1;
                  n = !0;
                }
              if (!n) return !1;
              if (-1 !== a.indexOf(s)) return !1;
              a.push(s);
            }
            return !0;
          },
          construct: function (e) {
            return null !== e ? e : [];
          },
        }),
        To = Object.prototype.toString;
      var _o = new Ja("tag:yaml.org,2002:pairs", {
          kind: "sequence",
          resolve: function (e) {
            if (null === e) return !0;
            var t,
              r,
              i,
              s,
              n,
              a = e;
            for (n = new Array(a.length), t = 0, r = a.length; t < r; t += 1) {
              if (((i = a[t]), "[object Object]" !== To.call(i))) return !1;
              if (1 !== (s = Object.keys(i)).length) return !1;
              n[t] = [s[0], i[s[0]]];
            }
            return !0;
          },
          construct: function (e) {
            if (null === e) return [];
            var t,
              r,
              i,
              s,
              n,
              a = e;
            for (n = new Array(a.length), t = 0, r = a.length; t < r; t += 1)
              (i = a[t]), (s = Object.keys(i)), (n[t] = [s[0], i[s[0]]]);
            return n;
          },
        }),
        Co = Object.prototype.hasOwnProperty;
      var xo = new Ja("tag:yaml.org,2002:set", {
          kind: "mapping",
          resolve: function (e) {
            if (null === e) return !0;
            var t,
              r = e;
            for (t in r) if (Co.call(r, t) && null !== r[t]) return !1;
            return !0;
          },
          construct: function (e) {
            return null !== e ? e : {};
          },
        }),
        No = go.extend({ implicit: [Ao, wo], explicit: [bo, So, _o, xo] }),
        ko = Object.prototype.hasOwnProperty,
        Ro = 1,
        Bo = 2,
        Do = 3,
        Oo = 4,
        Lo = 1,
        Po = 2,
        Uo = 3,
        Mo =
          /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/,
        Fo = /[\x85\u2028\u2029]/,
        Ho = /[,\[\]\{\}]/,
        Qo = /^(?:!|!!|![a-z\-]+!)$/i,
        Vo =
          /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
      function zo(e) {
        return Object.prototype.toString.call(e);
      }
      function qo(e) {
        return 10 === e || 13 === e;
      }
      function Go(e) {
        return 9 === e || 32 === e;
      }
      function jo(e) {
        return 9 === e || 32 === e || 10 === e || 13 === e;
      }
      function Wo(e) {
        return 44 === e || 91 === e || 93 === e || 123 === e || 125 === e;
      }
      function Yo(e) {
        var t;
        return 48 <= e && e <= 57
          ? e - 48
          : 97 <= (t = 32 | e) && t <= 102
          ? t - 97 + 10
          : -1;
      }
      function Xo(e) {
        return 48 === e
          ? "\0"
          : 97 === e
          ? ""
          : 98 === e
          ? "\b"
          : 116 === e || 9 === e
          ? "\t"
          : 110 === e
          ? "\n"
          : 118 === e
          ? "\v"
          : 102 === e
          ? "\f"
          : 114 === e
          ? "\r"
          : 101 === e
          ? ""
          : 32 === e
          ? " "
          : 34 === e
          ? '"'
          : 47 === e
          ? "/"
          : 92 === e
          ? "\\"
          : 78 === e
          ? ""
          : 95 === e
          ? ""
          : 76 === e
          ? "\u2028"
          : 80 === e
          ? "\u2029"
          : "";
      }
      function Ko(e) {
        return e <= 65535
          ? String.fromCharCode(e)
          : String.fromCharCode(
              55296 + ((e - 65536) >> 10),
              56320 + ((e - 65536) & 1023)
            );
      }
      for (var Jo = new Array(256), Zo = new Array(256), $o = 0; $o < 256; $o++)
        (Jo[$o] = Xo($o) ? 1 : 0), (Zo[$o] = Xo($o));
      function ec(e, t) {
        (this.input = e),
          (this.filename = t.filename || null),
          (this.schema = t.schema || No),
          (this.onWarning = t.onWarning || null),
          (this.legacy = t.legacy || !1),
          (this.json = t.json || !1),
          (this.listener = t.listener || null),
          (this.implicitTypes = this.schema.compiledImplicit),
          (this.typeMap = this.schema.compiledTypeMap),
          (this.length = e.length),
          (this.position = 0),
          (this.line = 0),
          (this.lineStart = 0),
          (this.lineIndent = 0),
          (this.firstTabInLine = -1),
          (this.documents = []);
      }
      function tc(e, t) {
        var r = {
          name: e.filename,
          buffer: e.input.slice(0, -1),
          position: e.position,
          line: e.line,
          column: e.position - e.lineStart,
        };
        return (r.snippet = Ya(r)), new Ga(t, r);
      }
      function rc(e, t) {
        throw tc(e, t);
      }
      function ic(e, t) {
        e.onWarning && e.onWarning.call(null, tc(e, t));
      }
      var sc = {
        YAML: function (e, t, r) {
          var i, s, n;
          null !== e.version && rc(e, "duplication of %YAML directive"),
            1 !== r.length &&
              rc(e, "YAML directive accepts exactly one argument"),
            null === (i = /^([0-9]+)\.([0-9]+)$/.exec(r[0])) &&
              rc(e, "ill-formed argument of the YAML directive"),
            (s = parseInt(i[1], 10)),
            (n = parseInt(i[2], 10)),
            1 !== s && rc(e, "unacceptable YAML version of the document"),
            (e.version = r[0]),
            (e.checkLineBreaks = n < 2),
            1 !== n &&
              2 !== n &&
              ic(e, "unsupported YAML version of the document");
        },
        TAG: function (e, t, r) {
          var i, s;
          2 !== r.length && rc(e, "TAG directive accepts exactly two arguments"),
            (i = r[0]),
            (s = r[1]),
            Qo.test(i) ||
              rc(
                e,
                "ill-formed tag handle (first argument) of the TAG directive"
              ),
            ko.call(e.tagMap, i) &&
              rc(
                e,
                'there is a previously declared suffix for "' + i + '" tag handle'
              ),
            Vo.test(s) ||
              rc(
                e,
                "ill-formed tag prefix (second argument) of the TAG directive"
              );
          try {
            s = decodeURIComponent(s);
          } catch (t) {
            rc(e, "tag prefix is malformed: " + s);
          }
          e.tagMap[i] = s;
        },
      };
      function nc(e, t, r, i) {
        var s, n, a, o;
        if (t < r) {
          if (((o = e.input.slice(t, r)), i))
            for (s = 0, n = o.length; s < n; s += 1)
              9 === (a = o.charCodeAt(s)) ||
                (32 <= a && a <= 1114111) ||
                rc(e, "expected valid JSON character");
          else
            Mo.test(o) && rc(e, "the stream contains non-printable characters");
          e.result += o;
        }
      }
      function ac(e, t, r, i) {
        var s, n, a, o;
        for (
          Va.isObject(r) ||
            rc(
              e,
              "cannot merge mappings; the provided source object is unacceptable"
            ),
            a = 0,
            o = (s = Object.keys(r)).length;
          a < o;
          a += 1
        )
          (n = s[a]), ko.call(t, n) || ((t[n] = r[n]), (i[n] = !0));
      }
      function oc(e, t, r, i, s, n, a, o, c) {
        var l, h;
        if (Array.isArray(s))
          for (
            l = 0, h = (s = Array.prototype.slice.call(s)).length;
            l < h;
            l += 1
          )
            Array.isArray(s[l]) &&
              rc(e, "nested arrays are not supported inside keys"),
              "object" == typeof s &&
                "[object Object]" === zo(s[l]) &&
                (s[l] = "[object Object]");
        if (
          ("object" == typeof s &&
            "[object Object]" === zo(s) &&
            (s = "[object Object]"),
          (s = String(s)),
          null === t && (t = {}),
          "tag:yaml.org,2002:merge" === i)
        )
          if (Array.isArray(n))
            for (l = 0, h = n.length; l < h; l += 1) ac(e, t, n[l], r);
          else ac(e, t, n, r);
        else
          e.json ||
            ko.call(r, s) ||
            !ko.call(t, s) ||
            ((e.line = a || e.line),
            (e.lineStart = o || e.lineStart),
            (e.position = c || e.position),
            rc(e, "duplicated mapping key")),
            "__proto__" === s
              ? Object.defineProperty(t, s, {
                  configurable: !0,
                  enumerable: !0,
                  writable: !0,
                  value: n,
                })
              : (t[s] = n),
            delete r[s];
        return t;
      }
      function cc(e) {
        var t;
        10 === (t = e.input.charCodeAt(e.position))
          ? e.position++
          : 13 === t
          ? (e.position++, 10 === e.input.charCodeAt(e.position) && e.position++)
          : rc(e, "a line break is expected"),
          (e.line += 1),
          (e.lineStart = e.position),
          (e.firstTabInLine = -1);
      }
      function lc(e, t, r) {
        for (var i = 0, s = e.input.charCodeAt(e.position); 0 !== s; ) {
          for (; Go(s); )
            9 === s && -1 === e.firstTabInLine && (e.firstTabInLine = e.position),
              (s = e.input.charCodeAt(++e.position));
          if (t && 35 === s)
            do {
              s = e.input.charCodeAt(++e.position);
            } while (10 !== s && 13 !== s && 0 !== s);
          if (!qo(s)) break;
          for (
            cc(e), s = e.input.charCodeAt(e.position), i++, e.lineIndent = 0;
            32 === s;
  
          )
            e.lineIndent++, (s = e.input.charCodeAt(++e.position));
        }
        return (
          -1 !== r &&
            0 !== i &&
            e.lineIndent < r &&
            ic(e, "deficient indentation"),
          i
        );
      }
      function hc(e) {
        var t,
          r = e.position;
        return !(
          (45 !== (t = e.input.charCodeAt(r)) && 46 !== t) ||
          t !== e.input.charCodeAt(r + 1) ||
          t !== e.input.charCodeAt(r + 2) ||
          ((r += 3), 0 !== (t = e.input.charCodeAt(r)) && !jo(t))
        );
      }
      function uc(e, t) {
        1 === t
          ? (e.result += " ")
          : t > 1 && (e.result += Va.repeat("\n", t - 1));
      }
      function dc(e, t) {
        var r,
          i,
          s = e.tag,
          n = e.anchor,
          a = [],
          o = !1;
        if (-1 !== e.firstTabInLine) return !1;
        for (
          null !== e.anchor && (e.anchorMap[e.anchor] = a),
            i = e.input.charCodeAt(e.position);
          0 !== i &&
          (-1 !== e.firstTabInLine &&
            ((e.position = e.firstTabInLine),
            rc(e, "tab characters must not be used in indentation")),
          45 === i) &&
          jo(e.input.charCodeAt(e.position + 1));
  
        )
          if (((o = !0), e.position++, lc(e, !0, -1) && e.lineIndent <= t))
            a.push(null), (i = e.input.charCodeAt(e.position));
          else if (
            ((r = e.line),
            gc(e, t, Do, !1, !0),
            a.push(e.result),
            lc(e, !0, -1),
            (i = e.input.charCodeAt(e.position)),
            (e.line === r || e.lineIndent > t) && 0 !== i)
          )
            rc(e, "bad indentation of a sequence entry");
          else if (e.lineIndent < t) break;
        return (
          !!o &&
          ((e.tag = s), (e.anchor = n), (e.kind = "sequence"), (e.result = a), !0)
        );
      }
      function pc(e) {
        var t,
          r,
          i,
          s,
          n = !1,
          a = !1;
        if (33 !== (s = e.input.charCodeAt(e.position))) return !1;
        if (
          (null !== e.tag && rc(e, "duplication of a tag property"),
          60 === (s = e.input.charCodeAt(++e.position))
            ? ((n = !0), (s = e.input.charCodeAt(++e.position)))
            : 33 === s
            ? ((a = !0), (r = "!!"), (s = e.input.charCodeAt(++e.position)))
            : (r = "!"),
          (t = e.position),
          n)
        ) {
          do {
            s = e.input.charCodeAt(++e.position);
          } while (0 !== s && 62 !== s);
          e.position < e.length
            ? ((i = e.input.slice(t, e.position)),
              (s = e.input.charCodeAt(++e.position)))
            : rc(e, "unexpected end of the stream within a verbatim tag");
        } else {
          for (; 0 !== s && !jo(s); )
            33 === s &&
              (a
                ? rc(e, "tag suffix cannot contain exclamation marks")
                : ((r = e.input.slice(t - 1, e.position + 1)),
                  Qo.test(r) ||
                    rc(e, "named tag handle cannot contain such characters"),
                  (a = !0),
                  (t = e.position + 1))),
              (s = e.input.charCodeAt(++e.position));
          (i = e.input.slice(t, e.position)),
            Ho.test(i) &&
              rc(e, "tag suffix cannot contain flow indicator characters");
        }
        i &&
          !Vo.test(i) &&
          rc(e, "tag name cannot contain such characters: " + i);
        try {
          i = decodeURIComponent(i);
        } catch (t) {
          rc(e, "tag name is malformed: " + i);
        }
        return (
          n
            ? (e.tag = i)
            : ko.call(e.tagMap, r)
            ? (e.tag = e.tagMap[r] + i)
            : "!" === r
            ? (e.tag = "!" + i)
            : "!!" === r
            ? (e.tag = "tag:yaml.org,2002:" + i)
            : rc(e, 'undeclared tag handle "' + r + '"'),
          !0
        );
      }
      function fc(e) {
        var t, r;
        if (38 !== (r = e.input.charCodeAt(e.position))) return !1;
        for (
          null !== e.anchor && rc(e, "duplication of an anchor property"),
            r = e.input.charCodeAt(++e.position),
            t = e.position;
          0 !== r && !jo(r) && !Wo(r);
  
        )
          r = e.input.charCodeAt(++e.position);
        return (
          e.position === t &&
            rc(e, "name of an anchor node must contain at least one character"),
          (e.anchor = e.input.slice(t, e.position)),
          !0
        );
      }
      function gc(e, t, r, i, s) {
        var n,
          a,
          o,
          c,
          l,
          h,
          u,
          d,
          p,
          f = 1,
          g = !1,
          m = !1;
        if (
          (null !== e.listener && e.listener("open", e),
          (e.tag = null),
          (e.anchor = null),
          (e.kind = null),
          (e.result = null),
          (n = a = o = Oo === r || Do === r),
          i &&
            lc(e, !0, -1) &&
            ((g = !0),
            e.lineIndent > t
              ? (f = 1)
              : e.lineIndent === t
              ? (f = 0)
              : e.lineIndent < t && (f = -1)),
          1 === f)
        )
          for (; pc(e) || fc(e); )
            lc(e, !0, -1)
              ? ((g = !0),
                (o = n),
                e.lineIndent > t
                  ? (f = 1)
                  : e.lineIndent === t
                  ? (f = 0)
                  : e.lineIndent < t && (f = -1))
              : (o = !1);
        if (
          (o && (o = g || s),
          (1 !== f && Oo !== r) ||
            ((d = Ro === r || Bo === r ? t : t + 1),
            (p = e.position - e.lineStart),
            1 === f
              ? (o &&
                  (dc(e, p) ||
                    (function (e, t, r) {
                      var i,
                        s,
                        n,
                        a,
                        o,
                        c,
                        l,
                        h = e.tag,
                        u = e.anchor,
                        d = {},
                        p = Object.create(null),
                        f = null,
                        g = null,
                        m = null,
                        y = !1,
                        A = !1;
                      if (-1 !== e.firstTabInLine) return !1;
                      for (
                        null !== e.anchor && (e.anchorMap[e.anchor] = d),
                          l = e.input.charCodeAt(e.position);
                        0 !== l;
  
                      ) {
                        if (
                          (y ||
                            -1 === e.firstTabInLine ||
                            ((e.position = e.firstTabInLine),
                            rc(
                              e,
                              "tab characters must not be used in indentation"
                            )),
                          (i = e.input.charCodeAt(e.position + 1)),
                          (n = e.line),
                          (63 !== l && 58 !== l) || !jo(i))
                        ) {
                          if (
                            ((a = e.line),
                            (o = e.lineStart),
                            (c = e.position),
                            !gc(e, r, Bo, !1, !0))
                          )
                            break;
                          if (e.line === n) {
                            for (l = e.input.charCodeAt(e.position); Go(l); )
                              l = e.input.charCodeAt(++e.position);
                            if (58 === l)
                              jo((l = e.input.charCodeAt(++e.position))) ||
                                rc(
                                  e,
                                  "a whitespace character is expected after the key-value separator within a block mapping"
                                ),
                                y &&
                                  (oc(e, d, p, f, g, null, a, o, c),
                                  (f = g = m = null)),
                                (A = !0),
                                (y = !1),
                                (s = !1),
                                (f = e.tag),
                                (g = e.result);
                            else {
                              if (!A) return (e.tag = h), (e.anchor = u), !0;
                              rc(
                                e,
                                "can not read an implicit mapping pair; a colon is missed"
                              );
                            }
                          } else {
                            if (!A) return (e.tag = h), (e.anchor = u), !0;
                            rc(
                              e,
                              "can not read a block mapping entry; a multiline key may not be an implicit key"
                            );
                          }
                        } else
                          63 === l
                            ? (y &&
                                (oc(e, d, p, f, g, null, a, o, c),
                                (f = g = m = null)),
                              (A = !0),
                              (y = !0),
                              (s = !0))
                            : y
                            ? ((y = !1), (s = !0))
                            : rc(
                                e,
                                "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"
                              ),
                            (e.position += 1),
                            (l = i);
                        if (
                          ((e.line === n || e.lineIndent > t) &&
                            (y &&
                              ((a = e.line), (o = e.lineStart), (c = e.position)),
                            gc(e, t, Oo, !0, s) &&
                              (y ? (g = e.result) : (m = e.result)),
                            y ||
                              (oc(e, d, p, f, g, m, a, o, c), (f = g = m = null)),
                            lc(e, !0, -1),
                            (l = e.input.charCodeAt(e.position))),
                          (e.line === n || e.lineIndent > t) && 0 !== l)
                        )
                          rc(e, "bad indentation of a mapping entry");
                        else if (e.lineIndent < t) break;
                      }
                      return (
                        y && oc(e, d, p, f, g, null, a, o, c),
                        A &&
                          ((e.tag = h),
                          (e.anchor = u),
                          (e.kind = "mapping"),
                          (e.result = d)),
                        A
                      );
                    })(e, p, d))) ||
                (function (e, t) {
                  var r,
                    i,
                    s,
                    n,
                    a,
                    o,
                    c,
                    l,
                    h,
                    u,
                    d,
                    p,
                    f = !0,
                    g = e.tag,
                    m = e.anchor,
                    y = Object.create(null);
                  if (91 === (p = e.input.charCodeAt(e.position)))
                    (a = 93), (l = !1), (n = []);
                  else {
                    if (123 !== p) return !1;
                    (a = 125), (l = !0), (n = {});
                  }
                  for (
                    null !== e.anchor && (e.anchorMap[e.anchor] = n),
                      p = e.input.charCodeAt(++e.position);
                    0 !== p;
  
                  ) {
                    if (
                      (lc(e, !0, t), (p = e.input.charCodeAt(e.position)) === a)
                    )
                      return (
                        e.position++,
                        (e.tag = g),
                        (e.anchor = m),
                        (e.kind = l ? "mapping" : "sequence"),
                        (e.result = n),
                        !0
                      );
                    f
                      ? 44 === p &&
                        rc(e, "expected the node content, but found ','")
                      : rc(e, "missed comma between flow collection entries"),
                      (d = null),
                      (o = c = !1),
                      63 === p &&
                        jo(e.input.charCodeAt(e.position + 1)) &&
                        ((o = c = !0), e.position++, lc(e, !0, t)),
                      (r = e.line),
                      (i = e.lineStart),
                      (s = e.position),
                      gc(e, t, Ro, !1, !0),
                      (u = e.tag),
                      (h = e.result),
                      lc(e, !0, t),
                      (p = e.input.charCodeAt(e.position)),
                      (!c && e.line !== r) ||
                        58 !== p ||
                        ((o = !0),
                        (p = e.input.charCodeAt(++e.position)),
                        lc(e, !0, t),
                        gc(e, t, Ro, !1, !0),
                        (d = e.result)),
                      l
                        ? oc(e, n, y, u, h, d, r, i, s)
                        : o
                        ? n.push(oc(e, null, y, u, h, d, r, i, s))
                        : n.push(h),
                      lc(e, !0, t),
                      44 === (p = e.input.charCodeAt(e.position))
                        ? ((f = !0), (p = e.input.charCodeAt(++e.position)))
                        : (f = !1);
                  }
                  rc(e, "unexpected end of the stream within a flow collection");
                })(e, d)
                ? (m = !0)
                : ((a &&
                    (function (e, t) {
                      var r,
                        i,
                        s,
                        n,
                        a,
                        o = Lo,
                        c = !1,
                        l = !1,
                        h = t,
                        u = 0,
                        d = !1;
                      if (124 === (n = e.input.charCodeAt(e.position))) i = !1;
                      else {
                        if (62 !== n) return !1;
                        i = !0;
                      }
                      for (e.kind = "scalar", e.result = ""; 0 !== n; )
                        if (
                          43 === (n = e.input.charCodeAt(++e.position)) ||
                          45 === n
                        )
                          Lo === o
                            ? (o = 43 === n ? Uo : Po)
                            : rc(e, "repeat of a chomping mode identifier");
                        else {
                          if (
                            !((s = 48 <= (a = n) && a <= 57 ? a - 48 : -1) >= 0)
                          )
                            break;
                          0 === s
                            ? rc(
                                e,
                                "bad explicit indentation width of a block scalar; it cannot be less than one"
                              )
                            : l
                            ? rc(e, "repeat of an indentation width identifier")
                            : ((h = t + s - 1), (l = !0));
                        }
                      if (Go(n)) {
                        do {
                          n = e.input.charCodeAt(++e.position);
                        } while (Go(n));
                        if (35 === n)
                          do {
                            n = e.input.charCodeAt(++e.position);
                          } while (!qo(n) && 0 !== n);
                      }
                      for (; 0 !== n; ) {
                        for (
                          cc(e),
                            e.lineIndent = 0,
                            n = e.input.charCodeAt(e.position);
                          (!l || e.lineIndent < h) && 32 === n;
  
                        )
                          e.lineIndent++, (n = e.input.charCodeAt(++e.position));
                        if ((!l && e.lineIndent > h && (h = e.lineIndent), qo(n)))
                          u++;
                        else {
                          if (e.lineIndent < h) {
                            o === Uo
                              ? (e.result += Va.repeat("\n", c ? 1 + u : u))
                              : o === Lo && c && (e.result += "\n");
                            break;
                          }
                          for (
                            i
                              ? Go(n)
                                ? ((d = !0),
                                  (e.result += Va.repeat("\n", c ? 1 + u : u)))
                                : d
                                ? ((d = !1), (e.result += Va.repeat("\n", u + 1)))
                                : 0 === u
                                ? c && (e.result += " ")
                                : (e.result += Va.repeat("\n", u))
                              : (e.result += Va.repeat("\n", c ? 1 + u : u)),
                              c = !0,
                              l = !0,
                              u = 0,
                              r = e.position;
                            !qo(n) && 0 !== n;
  
                          )
                            n = e.input.charCodeAt(++e.position);
                          nc(e, r, e.position, !1);
                        }
                      }
                      return !0;
                    })(e, d)) ||
                  (function (e, t) {
                    var r, i, s;
                    if (39 !== (r = e.input.charCodeAt(e.position))) return !1;
                    for (
                      e.kind = "scalar",
                        e.result = "",
                        e.position++,
                        i = s = e.position;
                      0 !== (r = e.input.charCodeAt(e.position));
  
                    )
                      if (39 === r) {
                        if (
                          (nc(e, i, e.position, !0),
                          39 !== (r = e.input.charCodeAt(++e.position)))
                        )
                          return !0;
                        (i = e.position), e.position++, (s = e.position);
                      } else
                        qo(r)
                          ? (nc(e, i, s, !0),
                            uc(e, lc(e, !1, t)),
                            (i = s = e.position))
                          : e.position === e.lineStart && hc(e)
                          ? rc(
                              e,
                              "unexpected end of the document within a single quoted scalar"
                            )
                          : (e.position++, (s = e.position));
                    rc(
                      e,
                      "unexpected end of the stream within a single quoted scalar"
                    );
                  })(e, d) ||
                  (function (e, t) {
                    var r, i, s, n, a, o, c;
                    if (34 !== (o = e.input.charCodeAt(e.position))) return !1;
                    for (
                      e.kind = "scalar",
                        e.result = "",
                        e.position++,
                        r = i = e.position;
                      0 !== (o = e.input.charCodeAt(e.position));
  
                    ) {
                      if (34 === o)
                        return nc(e, r, e.position, !0), e.position++, !0;
                      if (92 === o) {
                        if (
                          (nc(e, r, e.position, !0),
                          qo((o = e.input.charCodeAt(++e.position))))
                        )
                          lc(e, !1, t);
                        else if (o < 256 && Jo[o])
                          (e.result += Zo[o]), e.position++;
                        else if (
                          (a =
                            120 === (c = o)
                              ? 2
                              : 117 === c
                              ? 4
                              : 85 === c
                              ? 8
                              : 0) > 0
                        ) {
                          for (s = a, n = 0; s > 0; s--)
                            (a = Yo((o = e.input.charCodeAt(++e.position)))) >= 0
                              ? (n = (n << 4) + a)
                              : rc(e, "expected hexadecimal character");
                          (e.result += Ko(n)), e.position++;
                        } else rc(e, "unknown escape sequence");
                        r = i = e.position;
                      } else
                        qo(o)
                          ? (nc(e, r, i, !0),
                            uc(e, lc(e, !1, t)),
                            (r = i = e.position))
                          : e.position === e.lineStart && hc(e)
                          ? rc(
                              e,
                              "unexpected end of the document within a double quoted scalar"
                            )
                          : (e.position++, (i = e.position));
                    }
                    rc(
                      e,
                      "unexpected end of the stream within a double quoted scalar"
                    );
                  })(e, d)
                    ? (m = !0)
                    : !(function (e) {
                        var t, r, i;
                        if (42 !== (i = e.input.charCodeAt(e.position)))
                          return !1;
                        for (
                          i = e.input.charCodeAt(++e.position), t = e.position;
                          0 !== i && !jo(i) && !Wo(i);
  
                        )
                          i = e.input.charCodeAt(++e.position);
                        return (
                          e.position === t &&
                            rc(
                              e,
                              "name of an alias node must contain at least one character"
                            ),
                          (r = e.input.slice(t, e.position)),
                          ko.call(e.anchorMap, r) ||
                            rc(e, 'unidentified alias "' + r + '"'),
                          (e.result = e.anchorMap[r]),
                          lc(e, !0, -1),
                          !0
                        );
                      })(e)
                    ? (function (e, t, r) {
                        var i,
                          s,
                          n,
                          a,
                          o,
                          c,
                          l,
                          h,
                          u = e.kind,
                          d = e.result;
                        if (
                          jo((h = e.input.charCodeAt(e.position))) ||
                          Wo(h) ||
                          35 === h ||
                          38 === h ||
                          42 === h ||
                          33 === h ||
                          124 === h ||
                          62 === h ||
                          39 === h ||
                          34 === h ||
                          37 === h ||
                          64 === h ||
                          96 === h
                        )
                          return !1;
                        if (
                          (63 === h || 45 === h) &&
                          (jo((i = e.input.charCodeAt(e.position + 1))) ||
                            (r && Wo(i)))
                        )
                          return !1;
                        for (
                          e.kind = "scalar",
                            e.result = "",
                            s = n = e.position,
                            a = !1;
                          0 !== h;
  
                        ) {
                          if (58 === h) {
                            if (
                              jo((i = e.input.charCodeAt(e.position + 1))) ||
                              (r && Wo(i))
                            )
                              break;
                          } else if (35 === h) {
                            if (jo(e.input.charCodeAt(e.position - 1))) break;
                          } else {
                            if (
                              (e.position === e.lineStart && hc(e)) ||
                              (r && Wo(h))
                            )
                              break;
                            if (qo(h)) {
                              if (
                                ((o = e.line),
                                (c = e.lineStart),
                                (l = e.lineIndent),
                                lc(e, !1, -1),
                                e.lineIndent >= t)
                              ) {
                                (a = !0), (h = e.input.charCodeAt(e.position));
                                continue;
                              }
                              (e.position = n),
                                (e.line = o),
                                (e.lineStart = c),
                                (e.lineIndent = l);
                              break;
                            }
                          }
                          a &&
                            (nc(e, s, n, !1),
                            uc(e, e.line - o),
                            (s = n = e.position),
                            (a = !1)),
                            Go(h) || (n = e.position + 1),
                            (h = e.input.charCodeAt(++e.position));
                        }
                        return (
                          nc(e, s, n, !1),
                          !!e.result || ((e.kind = u), (e.result = d), !1)
                        );
                      })(e, d, Ro === r) &&
                      ((m = !0), null === e.tag && (e.tag = "?"))
                    : ((m = !0),
                      (null === e.tag && null === e.anchor) ||
                        rc(e, "alias node should not have any properties")),
                  null !== e.anchor && (e.anchorMap[e.anchor] = e.result))
              : 0 === f && (m = o && dc(e, p))),
          null === e.tag)
        )
          null !== e.anchor && (e.anchorMap[e.anchor] = e.result);
        else if ("?" === e.tag) {
          for (
            null !== e.result &&
              "scalar" !== e.kind &&
              rc(
                e,
                'unacceptable node kind for !<?> tag; it should be "scalar", not "' +
                  e.kind +
                  '"'
              ),
              c = 0,
              l = e.implicitTypes.length;
            c < l;
            c += 1
          )
            if ((u = e.implicitTypes[c]).resolve(e.result)) {
              (e.result = u.construct(e.result)),
                (e.tag = u.tag),
                null !== e.anchor && (e.anchorMap[e.anchor] = e.result);
              break;
            }
        } else if ("!" !== e.tag) {
          if (ko.call(e.typeMap[e.kind || "fallback"], e.tag))
            u = e.typeMap[e.kind || "fallback"][e.tag];
          else
            for (
              u = null,
                c = 0,
                l = (h = e.typeMap.multi[e.kind || "fallback"]).length;
              c < l;
              c += 1
            )
              if (e.tag.slice(0, h[c].tag.length) === h[c].tag) {
                u = h[c];
                break;
              }
          u || rc(e, "unknown tag !<" + e.tag + ">"),
            null !== e.result &&
              u.kind !== e.kind &&
              rc(
                e,
                "unacceptable node kind for !<" +
                  e.tag +
                  '> tag; it should be "' +
                  u.kind +
                  '", not "' +
                  e.kind +
                  '"'
              ),
            u.resolve(e.result, e.tag)
              ? ((e.result = u.construct(e.result, e.tag)),
                null !== e.anchor && (e.anchorMap[e.anchor] = e.result))
              : rc(e, "cannot resolve a node with !<" + e.tag + "> explicit tag");
        }
        return (
          null !== e.listener && e.listener("close", e),
          null !== e.tag || null !== e.anchor || m
        );
      }
      function mc(e) {
        var t,
          r,
          i,
          s,
          n = e.position,
          a = !1;
        for (
          e.version = null,
            e.checkLineBreaks = e.legacy,
            e.tagMap = Object.create(null),
            e.anchorMap = Object.create(null);
          0 !== (s = e.input.charCodeAt(e.position)) &&
          (lc(e, !0, -1),
          (s = e.input.charCodeAt(e.position)),
          !(e.lineIndent > 0 || 37 !== s));
  
        ) {
          for (
            a = !0, s = e.input.charCodeAt(++e.position), t = e.position;
            0 !== s && !jo(s);
  
          )
            s = e.input.charCodeAt(++e.position);
          for (
            i = [],
              (r = e.input.slice(t, e.position)).length < 1 &&
                rc(
                  e,
                  "directive name must not be less than one character in length"
                );
            0 !== s;
  
          ) {
            for (; Go(s); ) s = e.input.charCodeAt(++e.position);
            if (35 === s) {
              do {
                s = e.input.charCodeAt(++e.position);
              } while (0 !== s && !qo(s));
              break;
            }
            if (qo(s)) break;
            for (t = e.position; 0 !== s && !jo(s); )
              s = e.input.charCodeAt(++e.position);
            i.push(e.input.slice(t, e.position));
          }
          0 !== s && cc(e),
            ko.call(sc, r)
              ? sc[r](e, r, i)
              : ic(e, 'unknown document directive "' + r + '"');
        }
        lc(e, !0, -1),
          0 === e.lineIndent &&
          45 === e.input.charCodeAt(e.position) &&
          45 === e.input.charCodeAt(e.position + 1) &&
          45 === e.input.charCodeAt(e.position + 2)
            ? ((e.position += 3), lc(e, !0, -1))
            : a && rc(e, "directives end mark is expected"),
          gc(e, e.lineIndent - 1, Oo, !1, !0),
          lc(e, !0, -1),
          e.checkLineBreaks &&
            Fo.test(e.input.slice(n, e.position)) &&
            ic(e, "non-ASCII line breaks are interpreted as content"),
          e.documents.push(e.result),
          e.position === e.lineStart && hc(e)
            ? 46 === e.input.charCodeAt(e.position) &&
              ((e.position += 3), lc(e, !0, -1))
            : e.position < e.length - 1 &&
              rc(e, "end of the stream or a document separator is expected");
      }
      function yc(e, t) {
        (t = t || {}),
          0 !== (e = String(e)).length &&
            (10 !== e.charCodeAt(e.length - 1) &&
              13 !== e.charCodeAt(e.length - 1) &&
              (e += "\n"),
            65279 === e.charCodeAt(0) && (e = e.slice(1)));
        var r = new ec(e, t),
          i = e.indexOf("\0");
        for (
          -1 !== i &&
            ((r.position = i), rc(r, "null byte is not allowed in input")),
            r.input += "\0";
          32 === r.input.charCodeAt(r.position);
  
        )
          (r.lineIndent += 1), (r.position += 1);
        for (; r.position < r.length - 1; ) mc(r);
        return r.documents;
      }
      var Ac = {
          loadAll: function (e, t, r) {
            null !== t &&
              "object" == typeof t &&
              void 0 === r &&
              ((r = t), (t = null));
            var i = yc(e, r);
            if ("function" != typeof t) return i;
            for (var s = 0, n = i.length; s < n; s += 1) t(i[s]);
          },
          load: function (e, t) {
            var r = yc(e, t);
            if (0 !== r.length) {
              if (1 === r.length) return r[0];
              throw new Ga(
                "expected a single document in the stream, but found more"
              );
            }
          },
        },
        wc = Object.prototype.toString,
        Ec = Object.prototype.hasOwnProperty,
        bc = 65279,
        vc = 9,
        Ic = 10,
        Sc = 13,
        Tc = 32,
        _c = 33,
        Cc = 34,
        xc = 35,
        Nc = 37,
        kc = 38,
        Rc = 39,
        Bc = 42,
        Dc = 44,
        Oc = 45,
        Lc = 58,
        Pc = 61,
        Uc = 62,
        Mc = 63,
        Fc = 64,
        Hc = 91,
        Qc = 93,
        Vc = 96,
        zc = 123,
        qc = 124,
        Gc = 125,
        jc = {
          0: "\\0",
          7: "\\a",
          8: "\\b",
          9: "\\t",
          10: "\\n",
          11: "\\v",
          12: "\\f",
          13: "\\r",
          27: "\\e",
          34: '\\"',
          92: "\\\\",
          133: "\\N",
          160: "\\_",
          8232: "\\L",
          8233: "\\P",
        },
        Wc = [
          "y",
          "Y",
          "yes",
          "Yes",
          "YES",
          "on",
          "On",
          "ON",
          "n",
          "N",
          "no",
          "No",
          "NO",
          "off",
          "Off",
          "OFF",
        ],
        Yc = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
      function Xc(e) {
        var t, r, i;
        if (((t = e.toString(16).toUpperCase()), e <= 255)) (r = "x"), (i = 2);
        else if (e <= 65535) (r = "u"), (i = 4);
        else {
          if (!(e <= 4294967295))
            throw new Ga(
              "code point within a string may not be greater than 0xFFFFFFFF"
            );
          (r = "U"), (i = 8);
        }
        return "\\" + r + Va.repeat("0", i - t.length) + t;
      }
      var Kc = 1,
        Jc = 2;
      function Zc(e) {
        (this.schema = e.schema || No),
          (this.indent = Math.max(1, e.indent || 2)),
          (this.noArrayIndent = e.noArrayIndent || !1),
          (this.skipInvalid = e.skipInvalid || !1),
          (this.flowLevel = Va.isNothing(e.flowLevel) ? -1 : e.flowLevel),
          (this.styleMap = (function (e, t) {
            var r, i, s, n, a, o, c;
            if (null === t) return {};
            for (r = {}, s = 0, n = (i = Object.keys(t)).length; s < n; s += 1)
              (a = i[s]),
                (o = String(t[a])),
                "!!" === a.slice(0, 2) && (a = "tag:yaml.org,2002:" + a.slice(2)),
                (c = e.compiledTypeMap.fallback[a]) &&
                  Ec.call(c.styleAliases, o) &&
                  (o = c.styleAliases[o]),
                (r[a] = o);
            return r;
          })(this.schema, e.styles || null)),
          (this.sortKeys = e.sortKeys || !1),
          (this.lineWidth = e.lineWidth || 80),
          (this.noRefs = e.noRefs || !1),
          (this.noCompatMode = e.noCompatMode || !1),
          (this.condenseFlow = e.condenseFlow || !1),
          (this.quotingType = '"' === e.quotingType ? Jc : Kc),
          (this.forceQuotes = e.forceQuotes || !1),
          (this.replacer = "function" == typeof e.replacer ? e.replacer : null),
          (this.implicitTypes = this.schema.compiledImplicit),
          (this.explicitTypes = this.schema.compiledExplicit),
          (this.tag = null),
          (this.result = ""),
          (this.duplicates = []),
          (this.usedDuplicates = null);
      }
      function $c(e, t) {
        for (
          var r, i = Va.repeat(" ", t), s = 0, n = -1, a = "", o = e.length;
          s < o;
  
        )
          -1 === (n = e.indexOf("\n", s))
            ? ((r = e.slice(s)), (s = o))
            : ((r = e.slice(s, n + 1)), (s = n + 1)),
            r.length && "\n" !== r && (a += i),
            (a += r);
        return a;
      }
      function el(e, t) {
        return "\n" + Va.repeat(" ", e.indent * t);
      }
      function tl(e) {
        return e === Tc || e === vc;
      }
      function rl(e) {
        return (
          (32 <= e && e <= 126) ||
          (161 <= e && e <= 55295 && 8232 !== e && 8233 !== e) ||
          (57344 <= e && e <= 65533 && e !== bc) ||
          (65536 <= e && e <= 1114111)
        );
      }
      function il(e) {
        return rl(e) && e !== bc && e !== Sc && e !== Ic;
      }
      function sl(e, t, r) {
        var i = il(e),
          s = i && !tl(e);
        return (
          ((r
            ? i
            : i && e !== Dc && e !== Hc && e !== Qc && e !== zc && e !== Gc) &&
            e !== xc &&
            !(t === Lc && !s)) ||
          (il(t) && !tl(t) && e === xc) ||
          (t === Lc && s)
        );
      }
      function nl(e, t) {
        var r,
          i = e.charCodeAt(t);
        return i >= 55296 &&
          i <= 56319 &&
          t + 1 < e.length &&
          (r = e.charCodeAt(t + 1)) >= 56320 &&
          r <= 57343
          ? 1024 * (i - 55296) + r - 56320 + 65536
          : i;
      }
      function al(e) {
        return /^\n* /.test(e);
      }
      var ol = 1,
        cl = 2,
        ll = 3,
        hl = 4,
        ul = 5;
      function dl(e, t, r, i, s, n, a, o) {
        var c,
          l,
          h = 0,
          u = null,
          d = !1,
          p = !1,
          f = -1 !== i,
          g = -1,
          m =
            rl((l = nl(e, 0))) &&
            l !== bc &&
            !tl(l) &&
            l !== Oc &&
            l !== Mc &&
            l !== Lc &&
            l !== Dc &&
            l !== Hc &&
            l !== Qc &&
            l !== zc &&
            l !== Gc &&
            l !== xc &&
            l !== kc &&
            l !== Bc &&
            l !== _c &&
            l !== qc &&
            l !== Pc &&
            l !== Uc &&
            l !== Rc &&
            l !== Cc &&
            l !== Nc &&
            l !== Fc &&
            l !== Vc &&
            (function (e) {
              return !tl(e) && e !== Lc;
            })(nl(e, e.length - 1));
        if (t || a)
          for (c = 0; c < e.length; h >= 65536 ? (c += 2) : c++) {
            if (!rl((h = nl(e, c)))) return ul;
            (m = m && sl(h, u, o)), (u = h);
          }
        else {
          for (c = 0; c < e.length; h >= 65536 ? (c += 2) : c++) {
            if ((h = nl(e, c)) === Ic)
              (d = !0),
                f && ((p = p || (c - g - 1 > i && " " !== e[g + 1])), (g = c));
            else if (!rl(h)) return ul;
            (m = m && sl(h, u, o)), (u = h);
          }
          p = p || (f && c - g - 1 > i && " " !== e[g + 1]);
        }
        return d || p
          ? r > 9 && al(e)
            ? ul
            : a
            ? n === Jc
              ? ul
              : cl
            : p
            ? hl
            : ll
          : !m || a || s(e)
          ? n === Jc
            ? ul
            : cl
          : ol;
      }
      function pl(e, t, r, i, s) {
        e.dump = (function () {
          if (0 === t.length) return e.quotingType === Jc ? '""' : "''";
          if (!e.noCompatMode && (-1 !== Wc.indexOf(t) || Yc.test(t)))
            return e.quotingType === Jc ? '"' + t + '"' : "'" + t + "'";
          var n = e.indent * Math.max(1, r),
            a =
              -1 === e.lineWidth
                ? -1
                : Math.max(Math.min(e.lineWidth, 40), e.lineWidth - n),
            o = i || (e.flowLevel > -1 && r >= e.flowLevel);
          switch (
            dl(
              t,
              o,
              e.indent,
              a,
              function (t) {
                return (function (e, t) {
                  var r, i;
                  for (r = 0, i = e.implicitTypes.length; r < i; r += 1)
                    if (e.implicitTypes[r].resolve(t)) return !0;
                  return !1;
                })(e, t);
              },
              e.quotingType,
              e.forceQuotes && !i,
              s
            )
          ) {
            case ol:
              return t;
            case cl:
              return "'" + t.replace(/'/g, "''") + "'";
            case ll:
              return "|" + fl(t, e.indent) + gl($c(t, n));
            case hl:
              return (
                ">" +
                fl(t, e.indent) +
                gl(
                  $c(
                    (function (e, t) {
                      var r,
                        i,
                        s = /(\n+)([^\n]*)/g,
                        n =
                          ((o = e.indexOf("\n")),
                          (o = -1 !== o ? o : e.length),
                          (s.lastIndex = o),
                          ml(e.slice(0, o), t)),
                        a = "\n" === e[0] || " " === e[0];
                      var o;
                      for (; (i = s.exec(e)); ) {
                        var c = i[1],
                          l = i[2];
                        (r = " " === l[0]),
                          (n += c + (a || r || "" === l ? "" : "\n") + ml(l, t)),
                          (a = r);
                      }
                      return n;
                    })(t, a),
                    n
                  )
                )
              );
            case ul:
              return (
                '"' +
                (function (e) {
                  for (
                    var t, r = "", i = 0, s = 0;
                    s < e.length;
                    i >= 65536 ? (s += 2) : s++
                  )
                    (i = nl(e, s)),
                      !(t = jc[i]) && rl(i)
                        ? ((r += e[s]), i >= 65536 && (r += e[s + 1]))
                        : (r += t || Xc(i));
                  return r;
                })(t) +
                '"'
              );
            default:
              throw new Ga("impossible error: invalid scalar style");
          }
        })();
      }
      function fl(e, t) {
        var r = al(e) ? String(t) : "",
          i = "\n" === e[e.length - 1];
        return (
          r +
          (i && ("\n" === e[e.length - 2] || "\n" === e) ? "+" : i ? "" : "-") +
          "\n"
        );
      }
      function gl(e) {
        return "\n" === e[e.length - 1] ? e.slice(0, -1) : e;
      }
      function ml(e, t) {
        if ("" === e || " " === e[0]) return e;
        for (
          var r, i, s = / [^ ]/g, n = 0, a = 0, o = 0, c = "";
          (r = s.exec(e));
  
        )
          (o = r.index) - n > t &&
            ((i = a > n ? a : o), (c += "\n" + e.slice(n, i)), (n = i + 1)),
            (a = o);
        return (
          (c += "\n"),
          e.length - n > t && a > n
            ? (c += e.slice(n, a) + "\n" + e.slice(a + 1))
            : (c += e.slice(n)),
          c.slice(1)
        );
      }
      function yl(e, t, r, i) {
        var s,
          n,
          a,
          o = "",
          c = e.tag;
        for (s = 0, n = r.length; s < n; s += 1)
          (a = r[s]),
            e.replacer && (a = e.replacer.call(r, String(s), a)),
            (wl(e, t + 1, a, !0, !0, !1, !0) ||
              (void 0 === a && wl(e, t + 1, null, !0, !0, !1, !0))) &&
              ((i && "" === o) || (o += el(e, t)),
              e.dump && Ic === e.dump.charCodeAt(0) ? (o += "-") : (o += "- "),
              (o += e.dump));
        (e.tag = c), (e.dump = o || "[]");
      }
      function Al(e, t, r) {
        var i, s, n, a, o, c;
        for (
          n = 0, a = (s = r ? e.explicitTypes : e.implicitTypes).length;
          n < a;
          n += 1
        )
          if (
            ((o = s[n]).instanceOf || o.predicate) &&
            (!o.instanceOf ||
              ("object" == typeof t && t instanceof o.instanceOf)) &&
            (!o.predicate || o.predicate(t))
          ) {
            if (
              (r
                ? o.multi && o.representName
                  ? (e.tag = o.representName(t))
                  : (e.tag = o.tag)
                : (e.tag = "?"),
              o.represent)
            ) {
              if (
                ((c = e.styleMap[o.tag] || o.defaultStyle),
                "[object Function]" === wc.call(o.represent))
              )
                i = o.represent(t, c);
              else {
                if (!Ec.call(o.represent, c))
                  throw new Ga(
                    "!<" + o.tag + '> tag resolver accepts not "' + c + '" style'
                  );
                i = o.represent[c](t, c);
              }
              e.dump = i;
            }
            return !0;
          }
        return !1;
      }
      function wl(e, t, r, i, s, n, a) {
        (e.tag = null), (e.dump = r), Al(e, r, !1) || Al(e, r, !0);
        var o,
          c = wc.call(e.dump),
          l = i;
        i && (i = e.flowLevel < 0 || e.flowLevel > t);
        var h,
          u,
          d = "[object Object]" === c || "[object Array]" === c;
        if (
          (d && (u = -1 !== (h = e.duplicates.indexOf(r))),
          ((null !== e.tag && "?" !== e.tag) || u || (2 !== e.indent && t > 0)) &&
            (s = !1),
          u && e.usedDuplicates[h])
        )
          e.dump = "*ref_" + h;
        else {
          if (
            (d && u && !e.usedDuplicates[h] && (e.usedDuplicates[h] = !0),
            "[object Object]" === c)
          )
            i && 0 !== Object.keys(e.dump).length
              ? (!(function (e, t, r, i) {
                  var s,
                    n,
                    a,
                    o,
                    c,
                    l,
                    h = "",
                    u = e.tag,
                    d = Object.keys(r);
                  if (!0 === e.sortKeys) d.sort();
                  else if ("function" == typeof e.sortKeys) d.sort(e.sortKeys);
                  else if (e.sortKeys)
                    throw new Ga("sortKeys must be a boolean or a function");
                  for (s = 0, n = d.length; s < n; s += 1)
                    (l = ""),
                      (i && "" === h) || (l += el(e, t)),
                      (o = r[(a = d[s])]),
                      e.replacer && (o = e.replacer.call(r, a, o)),
                      wl(e, t + 1, a, !0, !0, !0) &&
                        ((c =
                          (null !== e.tag && "?" !== e.tag) ||
                          (e.dump && e.dump.length > 1024)) &&
                          (e.dump && Ic === e.dump.charCodeAt(0)
                            ? (l += "?")
                            : (l += "? ")),
                        (l += e.dump),
                        c && (l += el(e, t)),
                        wl(e, t + 1, o, !0, c) &&
                          (e.dump && Ic === e.dump.charCodeAt(0)
                            ? (l += ":")
                            : (l += ": "),
                          (h += l += e.dump)));
                  (e.tag = u), (e.dump = h || "{}");
                })(e, t, e.dump, s),
                u && (e.dump = "&ref_" + h + e.dump))
              : (!(function (e, t, r) {
                  var i,
                    s,
                    n,
                    a,
                    o,
                    c = "",
                    l = e.tag,
                    h = Object.keys(r);
                  for (i = 0, s = h.length; i < s; i += 1)
                    (o = ""),
                      "" !== c && (o += ", "),
                      e.condenseFlow && (o += '"'),
                      (a = r[(n = h[i])]),
                      e.replacer && (a = e.replacer.call(r, n, a)),
                      wl(e, t, n, !1, !1) &&
                        (e.dump.length > 1024 && (o += "? "),
                        (o +=
                          e.dump +
                          (e.condenseFlow ? '"' : "") +
                          ":" +
                          (e.condenseFlow ? "" : " ")),
                        wl(e, t, a, !1, !1) && (c += o += e.dump));
                  (e.tag = l), (e.dump = "{" + c + "}");
                })(e, t, e.dump),
                u && (e.dump = "&ref_" + h + " " + e.dump));
          else if ("[object Array]" === c)
            i && 0 !== e.dump.length
              ? (e.noArrayIndent && !a && t > 0
                  ? yl(e, t - 1, e.dump, s)
                  : yl(e, t, e.dump, s),
                u && (e.dump = "&ref_" + h + e.dump))
              : (!(function (e, t, r) {
                  var i,
                    s,
                    n,
                    a = "",
                    o = e.tag;
                  for (i = 0, s = r.length; i < s; i += 1)
                    (n = r[i]),
                      e.replacer && (n = e.replacer.call(r, String(i), n)),
                      (wl(e, t, n, !1, !1) ||
                        (void 0 === n && wl(e, t, null, !1, !1))) &&
                        ("" !== a && (a += "," + (e.condenseFlow ? "" : " ")),
                        (a += e.dump));
                  (e.tag = o), (e.dump = "[" + a + "]");
                })(e, t, e.dump),
                u && (e.dump = "&ref_" + h + " " + e.dump));
          else {
            if ("[object String]" !== c) {
              if ("[object Undefined]" === c) return !1;
              if (e.skipInvalid) return !1;
              throw new Ga("unacceptable kind of an object to dump " + c);
            }
            "?" !== e.tag && pl(e, e.dump, t, n, l);
          }
          null !== e.tag &&
            "?" !== e.tag &&
            ((o = encodeURI("!" === e.tag[0] ? e.tag.slice(1) : e.tag).replace(
              /!/g,
              "%21"
            )),
            (o =
              "!" === e.tag[0]
                ? "!" + o
                : "tag:yaml.org,2002:" === o.slice(0, 18)
                ? "!!" + o.slice(18)
                : "!<" + o + ">"),
            (e.dump = o + " " + e.dump));
        }
        return !0;
      }
      function El(e, t) {
        var r,
          i,
          s = [],
          n = [];
        for (bl(e, s, n), r = 0, i = n.length; r < i; r += 1)
          t.duplicates.push(s[n[r]]);
        t.usedDuplicates = new Array(i);
      }
      function bl(e, t, r) {
        var i, s, n;
        if (null !== e && "object" == typeof e)
          if (-1 !== (s = t.indexOf(e))) -1 === r.indexOf(s) && r.push(s);
          else if ((t.push(e), Array.isArray(e)))
            for (s = 0, n = e.length; s < n; s += 1) bl(e[s], t, r);
          else
            for (s = 0, n = (i = Object.keys(e)).length; s < n; s += 1)
              bl(e[i[s]], t, r);
      }
      function vl(e, t) {
        return function () {
          throw new Error(
            "Function yaml." +
              e +
              " is removed in js-yaml 4. Use yaml." +
              t +
              " instead, which is now safe by default."
          );
        };
      }
      const Il = {
        Type: Ja,
        Schema: eo,
        FAILSAFE_SCHEMA: so,
        JSON_SCHEMA: fo,
        CORE_SCHEMA: go,
        DEFAULT_SCHEMA: No,
        load: Ac.load,
        loadAll: Ac.loadAll,
        dump: {
          dump: function (e, t) {
            var r = new Zc((t = t || {}));
            r.noRefs || El(e, r);
            var i = e;
            return (
              r.replacer && (i = r.replacer.call({ "": i }, "", i)),
              wl(r, 0, i, !0, !0) ? r.dump + "\n" : ""
            );
          },
        }.dump,
        YAMLException: Ga,
        types: {
          binary: bo,
          float: po,
          map: io,
          null: no,
          pairs: _o,
          set: xo,
          timestamp: Ao,
          bool: ao,
          int: lo,
          merge: wo,
          omap: So,
          seq: ro,
          str: to,
        },
        safeLoad: vl("safeLoad", "load"),
        safeLoadAll: vl("safeLoadAll", "loadAll"),
        safeDump: vl("safeDump", "dump"),
      };
      var Sl = r(7526),
        Tl = (r(8630), r(152));
      function _l(e, t) {
        let r = 0;
        if (1 === e.length) return e[0];
        for (let i = e.length - 1; i >= 0; i--)
          r += e[e.length - 1 - i] * Math.pow(2, t * i);
        return r;
      }
      function Cl(e, t, r = -1) {
        const i = r;
        let s = e,
          n = 0,
          a = Math.pow(2, t);
        for (let r = 1; r < 8; r++) {
          if (e < a) {
            let e;
            if (i < 0) (e = new ArrayBuffer(r)), (n = r);
            else {
              if (i < r) return new ArrayBuffer(0);
              (e = new ArrayBuffer(i)), (n = i);
            }
            const a = new Uint8Array(e);
            for (let e = r - 1; e >= 0; e--) {
              const r = Math.pow(2, e * t);
              (a[n - e - 1] = Math.floor(s / r)), (s -= a[n - e - 1] * r);
            }
            return e;
          }
          a *= Math.pow(2, t);
        }
        return new ArrayBuffer(0);
      }
      function xl(...e) {
        let t = 0,
          r = 0;
        for (const r of e) t += r.length;
        const i = new ArrayBuffer(t),
          s = new Uint8Array(i);
        for (const t of e) s.set(t, r), (r += t.length);
        return s;
      }
      function Nl() {
        const e = new Uint8Array(this.valueHex);
        if (this.valueHex.byteLength >= 2) {
          const t = 255 === e[0] && 128 & e[1],
            r = 0 === e[0] && !(128 & e[1]);
          (t || r) && this.warnings.push("Needlessly long format");
        }
        const t = new ArrayBuffer(this.valueHex.byteLength),
          r = new Uint8Array(t);
        for (let e = 0; e < this.valueHex.byteLength; e++) r[e] = 0;
        r[0] = 128 & e[0];
        const i = _l(r, 8),
          s = new ArrayBuffer(this.valueHex.byteLength),
          n = new Uint8Array(s);
        for (let t = 0; t < this.valueHex.byteLength; t++) n[t] = e[t];
        n[0] &= 127;
        return _l(n, 8) - i;
      }
      function kl(e, t) {
        const r = e.toString(10);
        if (t < r.length) return "";
        const i = t - r.length,
          s = new Array(i);
        for (let e = 0; e < i; e++) s[e] = "0";
        return s.join("").concat(r);
      }
      Math.log(2);
      /*!
       * Copyright (c) 2014, GMO GlobalSign
       * Copyright (c) 2015-2022, Peculiar Ventures
       * All rights reserved.
       *
       * Author 2014-2019, Yury Strozhevsky
       *
       * Redistribution and use in source and binary forms, with or without modification,
       * are permitted provided that the following conditions are met:
       *
       * * Redistributions of source code must retain the above copyright notice, this
       *   list of conditions and the following disclaimer.
       *
       * * Redistributions in binary form must reproduce the above copyright notice, this
       *   list of conditions and the following disclaimer in the documentation and/or
       *   other materials provided with the distribution.
       *
       * * Neither the name of the copyright holder nor the names of its
       *   contributors may be used to endorse or promote products derived from
       *   this software without specific prior written permission.
       *
       * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
       * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
       * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
       * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
       * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
       * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
       * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
       * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
       * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
       * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
       *
       */
      function Rl() {
        if ("undefined" == typeof BigInt)
          throw new Error(
            "BigInt is not defined. Your environment doesn't implement BigInt."
          );
      }
      function Bl(e) {
        let t = 0,
          r = 0;
        for (let r = 0; r < e.length; r++) {
          t += e[r].byteLength;
        }
        const i = new Uint8Array(t);
        for (let t = 0; t < e.length; t++) {
          const s = e[t];
          i.set(new Uint8Array(s), r), (r += s.byteLength);
        }
        return i.buffer;
      }
      function Dl(e, t, r, i) {
        return t instanceof Uint8Array
          ? t.byteLength
            ? r < 0
              ? ((e.error = "Wrong parameter: inputOffset less than zero"), !1)
              : i < 0
              ? ((e.error = "Wrong parameter: inputLength less than zero"), !1)
              : !(t.byteLength - r - i < 0) ||
                ((e.error =
                  "End of input reached before message was fully decoded (inconsistent offset and length values)"),
                !1)
            : ((e.error = "Wrong parameter: inputBuffer has zero length"), !1)
          : ((e.error = "Wrong parameter: inputBuffer must be 'Uint8Array'"), !1);
      }
      class Ol {
        constructor() {
          this.items = [];
        }
        write(e) {
          this.items.push(e);
        }
        final() {
          return Bl(this.items);
        }
      }
      const Ll = [new Uint8Array([1])],
        Pl = "0123456789",
        Ul = "name",
        Ml = "valueHexView",
        Fl = "isHexOnly",
        Hl = "idBlock",
        Ql = "tagClass",
        Vl = "tagNumber",
        zl = "isConstructed",
        ql = "fromBER",
        Gl = "toBER",
        jl = "local",
        Wl = "",
        Yl = new ArrayBuffer(0),
        Xl = new Uint8Array(0),
        Kl = "EndOfContent",
        Jl = "OCTET STRING",
        Zl = "BIT STRING";
      function $l(e) {
        var t;
        return (
          ((t = class extends e {
            constructor(...e) {
              var t;
              super(...e);
              const r = e[0] || {};
              (this.isHexOnly = null !== (t = r.isHexOnly) && void 0 !== t && t),
                (this.valueHexView = r.valueHex
                  ? Tl._H.toUint8Array(r.valueHex)
                  : Xl);
            }
            get valueHex() {
              return this.valueHexView.slice().buffer;
            }
            set valueHex(e) {
              this.valueHexView = new Uint8Array(e);
            }
            fromBER(e, t, r) {
              const i = e instanceof ArrayBuffer ? new Uint8Array(e) : e;
              if (!Dl(this, i, t, r)) return -1;
              const s = t + r;
              return (
                (this.valueHexView = i.subarray(t, s)),
                this.valueHexView.length
                  ? ((this.blockLength = r), s)
                  : (this.warnings.push("Zero buffer length"), t)
              );
            }
            toBER(e = !1) {
              return this.isHexOnly
                ? e
                  ? new ArrayBuffer(this.valueHexView.byteLength)
                  : this.valueHexView.byteLength ===
                    this.valueHexView.buffer.byteLength
                  ? this.valueHexView.buffer
                  : this.valueHexView.slice().buffer
                : ((this.error = "Flag 'isHexOnly' is not set, abort"), Yl);
            }
            toJSON() {
              return {
                ...super.toJSON(),
                isHexOnly: this.isHexOnly,
                valueHex: Tl.U$.ToHex(this.valueHexView),
              };
            }
          }).NAME = "hexBlock"),
          t
        );
      }
      class eh {
        constructor({
          blockLength: e = 0,
          error: t = Wl,
          warnings: r = [],
          valueBeforeDecode: i = Xl,
        } = {}) {
          (this.blockLength = e),
            (this.error = t),
            (this.warnings = r),
            (this.valueBeforeDecodeView = Tl._H.toUint8Array(i));
        }
        static blockName() {
          return this.NAME;
        }
        get valueBeforeDecode() {
          return this.valueBeforeDecodeView.slice().buffer;
        }
        set valueBeforeDecode(e) {
          this.valueBeforeDecodeView = new Uint8Array(e);
        }
        toJSON() {
          return {
            blockName: this.constructor.NAME,
            blockLength: this.blockLength,
            error: this.error,
            warnings: this.warnings,
            valueBeforeDecode: Tl.U$.ToHex(this.valueBeforeDecodeView),
          };
        }
      }
      eh.NAME = "baseBlock";
      class th extends eh {
        fromBER(e, t, r) {
          throw TypeError(
            "User need to make a specific function in a class which extends 'ValueBlock'"
          );
        }
        toBER(e, t) {
          throw TypeError(
            "User need to make a specific function in a class which extends 'ValueBlock'"
          );
        }
      }
      th.NAME = "valueBlock";
      class rh extends $l(eh) {
        constructor({ idBlock: e = {} } = {}) {
          var t, r, i, s;
          super(),
            e
              ? ((this.isHexOnly =
                  null !== (t = e.isHexOnly) && void 0 !== t && t),
                (this.valueHexView = e.valueHex
                  ? Tl._H.toUint8Array(e.valueHex)
                  : Xl),
                (this.tagClass =
                  null !== (r = e.tagClass) && void 0 !== r ? r : -1),
                (this.tagNumber =
                  null !== (i = e.tagNumber) && void 0 !== i ? i : -1),
                (this.isConstructed =
                  null !== (s = e.isConstructed) && void 0 !== s && s))
              : ((this.tagClass = -1),
                (this.tagNumber = -1),
                (this.isConstructed = !1));
        }
        toBER(e = !1) {
          let t = 0;
          switch (this.tagClass) {
            case 1:
              t |= 0;
              break;
            case 2:
              t |= 64;
              break;
            case 3:
              t |= 128;
              break;
            case 4:
              t |= 192;
              break;
            default:
              return (this.error = "Unknown tag class"), Yl;
          }
          if (
            (this.isConstructed && (t |= 32),
            this.tagNumber < 31 && !this.isHexOnly)
          ) {
            const r = new Uint8Array(1);
            if (!e) {
              let e = this.tagNumber;
              (e &= 31), (t |= e), (r[0] = t);
            }
            return r.buffer;
          }
          if (!this.isHexOnly) {
            const r = Cl(this.tagNumber, 7),
              i = new Uint8Array(r),
              s = r.byteLength,
              n = new Uint8Array(s + 1);
            if (((n[0] = 31 | t), !e)) {
              for (let e = 0; e < s - 1; e++) n[e + 1] = 128 | i[e];
              n[s] = i[s - 1];
            }
            return n.buffer;
          }
          const r = new Uint8Array(this.valueHexView.byteLength + 1);
          if (((r[0] = 31 | t), !e)) {
            const e = this.valueHexView;
            for (let t = 0; t < e.length - 1; t++) r[t + 1] = 128 | e[t];
            r[this.valueHexView.byteLength] = e[e.length - 1];
          }
          return r.buffer;
        }
        fromBER(e, t, r) {
          const i = Tl._H.toUint8Array(e);
          if (!Dl(this, i, t, r)) return -1;
          const s = i.subarray(t, t + r);
          if (0 === s.length) return (this.error = "Zero buffer length"), -1;
          switch (192 & s[0]) {
            case 0:
              this.tagClass = 1;
              break;
            case 64:
              this.tagClass = 2;
              break;
            case 128:
              this.tagClass = 3;
              break;
            case 192:
              this.tagClass = 4;
              break;
            default:
              return (this.error = "Unknown tag class"), -1;
          }
          (this.isConstructed = !(32 & ~s[0])), (this.isHexOnly = !1);
          const n = 31 & s[0];
          if (31 !== n) (this.tagNumber = n), (this.blockLength = 1);
          else {
            let e = 1,
              t = (this.valueHexView = new Uint8Array(255)),
              r = 255;
            for (; 128 & s[e]; ) {
              if (((t[e - 1] = 127 & s[e]), e++, e >= s.length))
                return (
                  (this.error =
                    "End of input reached before message was fully decoded"),
                  -1
                );
              if (e === r) {
                r += 255;
                const e = new Uint8Array(r);
                for (let r = 0; r < t.length; r++) e[r] = t[r];
                t = this.valueHexView = new Uint8Array(r);
              }
            }
            (this.blockLength = e + 1), (t[e - 1] = 127 & s[e]);
            const i = new Uint8Array(e);
            for (let r = 0; r < e; r++) i[r] = t[r];
            (t = this.valueHexView = new Uint8Array(e)),
              t.set(i),
              this.blockLength <= 9
                ? (this.tagNumber = _l(t, 7))
                : ((this.isHexOnly = !0),
                  this.warnings.push("Tag too long, represented as hex-coded"));
          }
          if (1 === this.tagClass && this.isConstructed)
            switch (this.tagNumber) {
              case 1:
              case 2:
              case 5:
              case 6:
              case 9:
              case 13:
              case 14:
              case 23:
              case 24:
              case 31:
              case 32:
              case 33:
              case 34:
                return (
                  (this.error = "Constructed encoding used for primitive type"),
                  -1
                );
            }
          return t + this.blockLength;
        }
        toJSON() {
          return {
            ...super.toJSON(),
            tagClass: this.tagClass,
            tagNumber: this.tagNumber,
            isConstructed: this.isConstructed,
          };
        }
      }
      rh.NAME = "identificationBlock";
      class ih extends eh {
        constructor({ lenBlock: e = {} } = {}) {
          var t, r, i;
          super(),
            (this.isIndefiniteForm =
              null !== (t = e.isIndefiniteForm) && void 0 !== t && t),
            (this.longFormUsed =
              null !== (r = e.longFormUsed) && void 0 !== r && r),
            (this.length = null !== (i = e.length) && void 0 !== i ? i : 0);
        }
        fromBER(e, t, r) {
          const i = Tl._H.toUint8Array(e);
          if (!Dl(this, i, t, r)) return -1;
          const s = i.subarray(t, t + r);
          if (0 === s.length) return (this.error = "Zero buffer length"), -1;
          if (255 === s[0])
            return (this.error = "Length block 0xFF is reserved by standard"), -1;
          if (((this.isIndefiniteForm = 128 === s[0]), this.isIndefiniteForm))
            return (this.blockLength = 1), t + this.blockLength;
          if (((this.longFormUsed = !!(128 & s[0])), !1 === this.longFormUsed))
            return (
              (this.length = s[0]), (this.blockLength = 1), t + this.blockLength
            );
          const n = 127 & s[0];
          if (n > 8) return (this.error = "Too big integer"), -1;
          if (n + 1 > s.length)
            return (
              (this.error =
                "End of input reached before message was fully decoded"),
              -1
            );
          const a = t + 1,
            o = i.subarray(a, a + n);
          return (
            0 === o[n - 1] &&
              this.warnings.push("Needlessly long encoded length"),
            (this.length = _l(o, 8)),
            this.longFormUsed &&
              this.length <= 127 &&
              this.warnings.push("Unnecessary usage of long length form"),
            (this.blockLength = n + 1),
            t + this.blockLength
          );
        }
        toBER(e = !1) {
          let t, r;
          if (
            (this.length > 127 && (this.longFormUsed = !0), this.isIndefiniteForm)
          )
            return (
              (t = new ArrayBuffer(1)),
              !1 === e && ((r = new Uint8Array(t)), (r[0] = 128)),
              t
            );
          if (this.longFormUsed) {
            const i = Cl(this.length, 8);
            if (i.byteLength > 127) return (this.error = "Too big length"), Yl;
            if (((t = new ArrayBuffer(i.byteLength + 1)), e)) return t;
            const s = new Uint8Array(i);
            (r = new Uint8Array(t)), (r[0] = 128 | i.byteLength);
            for (let e = 0; e < i.byteLength; e++) r[e + 1] = s[e];
            return t;
          }
          return (
            (t = new ArrayBuffer(1)),
            !1 === e && ((r = new Uint8Array(t)), (r[0] = this.length)),
            t
          );
        }
        toJSON() {
          return {
            ...super.toJSON(),
            isIndefiniteForm: this.isIndefiniteForm,
            longFormUsed: this.longFormUsed,
            length: this.length,
          };
        }
      }
      ih.NAME = "lengthBlock";
      const sh = {};
      class nh extends eh {
        constructor(
          { name: e = Wl, optional: t = !1, primitiveSchema: r, ...i } = {},
          s
        ) {
          super(i),
            (this.name = e),
            (this.optional = t),
            r && (this.primitiveSchema = r),
            (this.idBlock = new rh(i)),
            (this.lenBlock = new ih(i)),
            (this.valueBlock = s ? new s(i) : new th(i));
        }
        fromBER(e, t, r) {
          const i = this.valueBlock.fromBER(
            e,
            t,
            this.lenBlock.isIndefiniteForm ? r : this.lenBlock.length
          );
          return -1 === i
            ? ((this.error = this.valueBlock.error), i)
            : (this.idBlock.error.length ||
                (this.blockLength += this.idBlock.blockLength),
              this.lenBlock.error.length ||
                (this.blockLength += this.lenBlock.blockLength),
              this.valueBlock.error.length ||
                (this.blockLength += this.valueBlock.blockLength),
              i);
        }
        toBER(e, t) {
          const r = t || new Ol();
          t || ah(this);
          const i = this.idBlock.toBER(e);
          if ((r.write(i), this.lenBlock.isIndefiniteForm))
            r.write(new Uint8Array([128]).buffer),
              this.valueBlock.toBER(e, r),
              r.write(new ArrayBuffer(2));
          else {
            const t = this.valueBlock.toBER(e);
            this.lenBlock.length = t.byteLength;
            const i = this.lenBlock.toBER(e);
            r.write(i), r.write(t);
          }
          return t ? Yl : r.final();
        }
        toJSON() {
          const e = {
            ...super.toJSON(),
            idBlock: this.idBlock.toJSON(),
            lenBlock: this.lenBlock.toJSON(),
            valueBlock: this.valueBlock.toJSON(),
            name: this.name,
            optional: this.optional,
          };
          return (
            this.primitiveSchema &&
              (e.primitiveSchema = this.primitiveSchema.toJSON()),
            e
          );
        }
        toString(e = "ascii") {
          return "ascii" === e
            ? this.onAsciiEncoding()
            : Tl.U$.ToHex(this.toBER());
        }
        onAsciiEncoding() {
          return `${this.constructor.NAME} : ${Tl.U$.ToHex(
            this.valueBlock.valueBeforeDecodeView
          )}`;
        }
        isEqual(e) {
          if (this === e) return !0;
          if (!(e instanceof this.constructor)) return !1;
          return (function (e, t) {
            if (e.byteLength !== t.byteLength) return !1;
            const r = new Uint8Array(e),
              i = new Uint8Array(t);
            for (let e = 0; e < r.length; e++) if (r[e] !== i[e]) return !1;
            return !0;
          })(this.toBER(), e.toBER());
        }
      }
      function ah(e) {
        if (e instanceof sh.Constructed)
          for (const t of e.valueBlock.value)
            ah(t) && (e.lenBlock.isIndefiniteForm = !0);
        return !!e.lenBlock.isIndefiniteForm;
      }
      nh.NAME = "BaseBlock";
      class oh extends nh {
        constructor({ value: e = Wl, ...t } = {}, r) {
          super(t, r), e && this.fromString(e);
        }
        getValue() {
          return this.valueBlock.value;
        }
        setValue(e) {
          this.valueBlock.value = e;
        }
        fromBER(e, t, r) {
          const i = this.valueBlock.fromBER(
            e,
            t,
            this.lenBlock.isIndefiniteForm ? r : this.lenBlock.length
          );
          return -1 === i
            ? ((this.error = this.valueBlock.error), i)
            : (this.fromBuffer(this.valueBlock.valueHexView),
              this.idBlock.error.length ||
                (this.blockLength += this.idBlock.blockLength),
              this.lenBlock.error.length ||
                (this.blockLength += this.lenBlock.blockLength),
              this.valueBlock.error.length ||
                (this.blockLength += this.valueBlock.blockLength),
              i);
        }
        onAsciiEncoding() {
          return `${this.constructor.NAME} : '${this.valueBlock.value}'`;
        }
      }
      oh.NAME = "BaseStringBlock";
      class ch extends $l(th) {
        constructor({ isHexOnly: e = !0, ...t } = {}) {
          super(t), (this.isHexOnly = e);
        }
      }
      var lh,
        hh,
        uh,
        dh,
        ph,
        fh,
        gh,
        mh,
        yh,
        Ah,
        wh,
        Eh,
        bh,
        vh,
        Ih,
        Sh,
        Th,
        _h,
        Ch,
        xh,
        Nh,
        kh,
        Rh,
        Bh,
        Dh,
        Oh,
        Lh,
        Ph,
        Uh,
        Mh,
        Fh,
        Hh,
        Qh,
        Vh,
        zh;
      ch.NAME = "PrimitiveValueBlock";
      class qh extends nh {
        constructor(e = {}) {
          super(e, ch), (this.idBlock.isConstructed = !1);
        }
      }
      function Gh(e, t = 0, r = e.length) {
        const i = t;
        let s = new nh({}, th);
        const n = new eh();
        if (!Dl(n, e, t, r))
          return (s.error = n.error), { offset: -1, result: s };
        if (!e.subarray(t, t + r).length)
          return (s.error = "Zero buffer length"), { offset: -1, result: s };
        let a = s.idBlock.fromBER(e, t, r);
        if (
          (s.idBlock.warnings.length && s.warnings.concat(s.idBlock.warnings),
          -1 === a)
        )
          return (s.error = s.idBlock.error), { offset: -1, result: s };
        if (
          ((t = a),
          (r -= s.idBlock.blockLength),
          (a = s.lenBlock.fromBER(e, t, r)),
          s.lenBlock.warnings.length && s.warnings.concat(s.lenBlock.warnings),
          -1 === a)
        )
          return (s.error = s.lenBlock.error), { offset: -1, result: s };
        if (
          ((t = a),
          (r -= s.lenBlock.blockLength),
          !s.idBlock.isConstructed && s.lenBlock.isIndefiniteForm)
        )
          return (
            (s.error = "Indefinite length form used for primitive encoding form"),
            { offset: -1, result: s }
          );
        let o = nh;
        if (1 === s.idBlock.tagClass) {
          if (s.idBlock.tagNumber >= 37 && !1 === s.idBlock.isHexOnly)
            return (
              (s.error =
                "UNIVERSAL 37 and upper tags are reserved by ASN.1 standard"),
              { offset: -1, result: s }
            );
          switch (s.idBlock.tagNumber) {
            case 0:
              if (s.idBlock.isConstructed && s.lenBlock.length > 0)
                return (
                  (s.error = "Type [UNIVERSAL 0] is reserved"),
                  { offset: -1, result: s }
                );
              o = sh.EndOfContent;
              break;
            case 1:
              o = sh.Boolean;
              break;
            case 2:
              o = sh.Integer;
              break;
            case 3:
              o = sh.BitString;
              break;
            case 4:
              o = sh.OctetString;
              break;
            case 5:
              o = sh.Null;
              break;
            case 6:
              o = sh.ObjectIdentifier;
              break;
            case 10:
              o = sh.Enumerated;
              break;
            case 12:
              o = sh.Utf8String;
              break;
            case 13:
              o = sh.RelativeObjectIdentifier;
              break;
            case 14:
              o = sh.TIME;
              break;
            case 15:
              return (
                (s.error = "[UNIVERSAL 15] is reserved by ASN.1 standard"),
                { offset: -1, result: s }
              );
            case 16:
              o = sh.Sequence;
              break;
            case 17:
              o = sh.Set;
              break;
            case 18:
              o = sh.NumericString;
              break;
            case 19:
              o = sh.PrintableString;
              break;
            case 20:
              o = sh.TeletexString;
              break;
            case 21:
              o = sh.VideotexString;
              break;
            case 22:
              o = sh.IA5String;
              break;
            case 23:
              o = sh.UTCTime;
              break;
            case 24:
              o = sh.GeneralizedTime;
              break;
            case 25:
              o = sh.GraphicString;
              break;
            case 26:
              o = sh.VisibleString;
              break;
            case 27:
              o = sh.GeneralString;
              break;
            case 28:
              o = sh.UniversalString;
              break;
            case 29:
              o = sh.CharacterString;
              break;
            case 30:
              o = sh.BmpString;
              break;
            case 31:
              o = sh.DATE;
              break;
            case 32:
              o = sh.TimeOfDay;
              break;
            case 33:
              o = sh.DateTime;
              break;
            case 34:
              o = sh.Duration;
              break;
            default: {
              const e = s.idBlock.isConstructed
                ? new sh.Constructed()
                : new sh.Primitive();
              (e.idBlock = s.idBlock),
                (e.lenBlock = s.lenBlock),
                (e.warnings = s.warnings),
                (s = e);
            }
          }
        } else o = s.idBlock.isConstructed ? sh.Constructed : sh.Primitive;
        return (
          (s = (function (e, t) {
            if (e instanceof t) return e;
            const r = new t();
            return (
              (r.idBlock = e.idBlock),
              (r.lenBlock = e.lenBlock),
              (r.warnings = e.warnings),
              (r.valueBeforeDecodeView = e.valueBeforeDecodeView),
              r
            );
          })(s, o)),
          (a = s.fromBER(
            e,
            t,
            s.lenBlock.isIndefiniteForm ? r : s.lenBlock.length
          )),
          (s.valueBeforeDecodeView = e.subarray(i, i + s.blockLength)),
          { offset: a, result: s }
        );
      }
      function jh(e) {
        if (!e.byteLength) {
          const e = new nh({}, th);
          return (
            (e.error = "Input buffer has zero length"), { offset: -1, result: e }
          );
        }
        return Gh(Tl._H.toUint8Array(e).slice(), 0, e.byteLength);
      }
      (lh = qh), (sh.Primitive = lh), (qh.NAME = "PRIMITIVE");
      class Wh extends th {
        constructor({ value: e = [], isIndefiniteForm: t = !1, ...r } = {}) {
          super(r), (this.value = e), (this.isIndefiniteForm = t);
        }
        fromBER(e, t, r) {
          const i = Tl._H.toUint8Array(e);
          if (!Dl(this, i, t, r)) return -1;
          if (
            ((this.valueBeforeDecodeView = i.subarray(t, t + r)),
            0 === this.valueBeforeDecodeView.length)
          )
            return this.warnings.push("Zero buffer length"), t;
          let s = t;
          for (; (n = this.isIndefiniteForm), (a = r), (n ? 1 : a) > 0; ) {
            const e = Gh(i, s, r);
            if (-1 === e.offset)
              return (
                (this.error = e.result.error),
                this.warnings.concat(e.result.warnings),
                -1
              );
            if (
              ((s = e.offset),
              (this.blockLength += e.result.blockLength),
              (r -= e.result.blockLength),
              this.value.push(e.result),
              this.isIndefiniteForm && e.result.constructor.NAME === Kl)
            )
              break;
          }
          var n, a;
          return (
            this.isIndefiniteForm &&
              (this.value[this.value.length - 1].constructor.NAME === Kl
                ? this.value.pop()
                : this.warnings.push("No EndOfContent block encoded")),
            s
          );
        }
        toBER(e, t) {
          const r = t || new Ol();
          for (let t = 0; t < this.value.length; t++) this.value[t].toBER(e, r);
          return t ? Yl : r.final();
        }
        toJSON() {
          const e = {
            ...super.toJSON(),
            isIndefiniteForm: this.isIndefiniteForm,
            value: [],
          };
          for (const t of this.value) e.value.push(t.toJSON());
          return e;
        }
      }
      Wh.NAME = "ConstructedValueBlock";
      class Yh extends nh {
        constructor(e = {}) {
          super(e, Wh), (this.idBlock.isConstructed = !0);
        }
        fromBER(e, t, r) {
          this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
          const i = this.valueBlock.fromBER(
            e,
            t,
            this.lenBlock.isIndefiniteForm ? r : this.lenBlock.length
          );
          return -1 === i
            ? ((this.error = this.valueBlock.error), i)
            : (this.idBlock.error.length ||
                (this.blockLength += this.idBlock.blockLength),
              this.lenBlock.error.length ||
                (this.blockLength += this.lenBlock.blockLength),
              this.valueBlock.error.length ||
                (this.blockLength += this.valueBlock.blockLength),
              i);
        }
        onAsciiEncoding() {
          const e = [];
          for (const t of this.valueBlock.value)
            e.push(
              t
                .toString("ascii")
                .split("\n")
                .map((e) => `  ${e}`)
                .join("\n")
            );
          const t =
            3 === this.idBlock.tagClass
              ? `[${this.idBlock.tagNumber}]`
              : this.constructor.NAME;
          return e.length ? `${t} :\n${e.join("\n")}` : `${t} :`;
        }
      }
      (hh = Yh), (sh.Constructed = hh), (Yh.NAME = "CONSTRUCTED");
      class Xh extends th {
        fromBER(e, t, r) {
          return t;
        }
        toBER(e) {
          return Yl;
        }
      }
      Xh.override = "EndOfContentValueBlock";
      class Kh extends nh {
        constructor(e = {}) {
          super(e, Xh), (this.idBlock.tagClass = 1), (this.idBlock.tagNumber = 0);
        }
      }
      (uh = Kh), (sh.EndOfContent = uh), (Kh.NAME = Kl);
      class Jh extends nh {
        constructor(e = {}) {
          super(e, th), (this.idBlock.tagClass = 1), (this.idBlock.tagNumber = 5);
        }
        fromBER(e, t, r) {
          return (
            this.lenBlock.length > 0 &&
              this.warnings.push("Non-zero length of value block for Null type"),
            this.idBlock.error.length ||
              (this.blockLength += this.idBlock.blockLength),
            this.lenBlock.error.length ||
              (this.blockLength += this.lenBlock.blockLength),
            (this.blockLength += r),
            t + r > e.byteLength
              ? ((this.error =
                  "End of input reached before message was fully decoded (inconsistent offset and length values)"),
                -1)
              : t + r
          );
        }
        toBER(e, t) {
          const r = new ArrayBuffer(2);
          if (!e) {
            const e = new Uint8Array(r);
            (e[0] = 5), (e[1] = 0);
          }
          return t && t.write(r), r;
        }
        onAsciiEncoding() {
          return `${this.constructor.NAME}`;
        }
      }
      (dh = Jh), (sh.Null = dh), (Jh.NAME = "NULL");
      class Zh extends $l(th) {
        constructor({ value: e, ...t } = {}) {
          super(t),
            t.valueHex
              ? (this.valueHexView = Tl._H.toUint8Array(t.valueHex))
              : (this.valueHexView = new Uint8Array(1)),
            e && (this.value = e);
        }
        get value() {
          for (const e of this.valueHexView) if (e > 0) return !0;
          return !1;
        }
        set value(e) {
          this.valueHexView[0] = e ? 255 : 0;
        }
        fromBER(e, t, r) {
          const i = Tl._H.toUint8Array(e);
          return Dl(this, i, t, r)
            ? ((this.valueHexView = i.subarray(t, t + r)),
              r > 1 &&
                this.warnings.push("Boolean value encoded in more then 1 octet"),
              (this.isHexOnly = !0),
              Nl.call(this),
              (this.blockLength = r),
              t + r)
            : -1;
        }
        toBER() {
          return this.valueHexView.slice();
        }
        toJSON() {
          return { ...super.toJSON(), value: this.value };
        }
      }
      Zh.NAME = "BooleanValueBlock";
      class $h extends nh {
        constructor(e = {}) {
          super(e, Zh), (this.idBlock.tagClass = 1), (this.idBlock.tagNumber = 1);
        }
        getValue() {
          return this.valueBlock.value;
        }
        setValue(e) {
          this.valueBlock.value = e;
        }
        onAsciiEncoding() {
          return `${this.constructor.NAME} : ${this.getValue}`;
        }
      }
      (ph = $h), (sh.Boolean = ph), ($h.NAME = "BOOLEAN");
      class eu extends $l(Wh) {
        constructor({ isConstructed: e = !1, ...t } = {}) {
          super(t), (this.isConstructed = e);
        }
        fromBER(e, t, r) {
          let i = 0;
          if (this.isConstructed) {
            if (
              ((this.isHexOnly = !1),
              (i = Wh.prototype.fromBER.call(this, e, t, r)),
              -1 === i)
            )
              return i;
            for (let e = 0; e < this.value.length; e++) {
              const t = this.value[e].constructor.NAME;
              if (t === Kl) {
                if (this.isIndefiniteForm) break;
                return (
                  (this.error =
                    "EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only"),
                  -1
                );
              }
              if (t !== Jl)
                return (
                  (this.error =
                    "OCTET STRING may consists of OCTET STRINGs only"),
                  -1
                );
            }
          } else
            (this.isHexOnly = !0),
              (i = super.fromBER(e, t, r)),
              (this.blockLength = r);
          return i;
        }
        toBER(e, t) {
          return this.isConstructed
            ? Wh.prototype.toBER.call(this, e, t)
            : e
            ? new ArrayBuffer(this.valueHexView.byteLength)
            : this.valueHexView.slice().buffer;
        }
        toJSON() {
          return { ...super.toJSON(), isConstructed: this.isConstructed };
        }
      }
      eu.NAME = "OctetStringValueBlock";
      class tu extends nh {
        constructor({ idBlock: e = {}, lenBlock: t = {}, ...r } = {}) {
          var i, s;
          (null !== (i = r.isConstructed) && void 0 !== i) ||
            (r.isConstructed = !!(null === (s = r.value) || void 0 === s
              ? void 0
              : s.length)),
            super(
              {
                idBlock: { isConstructed: r.isConstructed, ...e },
                lenBlock: { ...t, isIndefiniteForm: !!r.isIndefiniteForm },
                ...r,
              },
              eu
            ),
            (this.idBlock.tagClass = 1),
            (this.idBlock.tagNumber = 4);
        }
        fromBER(e, t, r) {
          if (
            ((this.valueBlock.isConstructed = this.idBlock.isConstructed),
            (this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm),
            0 === r)
          )
            return (
              0 === this.idBlock.error.length &&
                (this.blockLength += this.idBlock.blockLength),
              0 === this.lenBlock.error.length &&
                (this.blockLength += this.lenBlock.blockLength),
              t
            );
          if (!this.valueBlock.isConstructed) {
            const i = (e instanceof ArrayBuffer ? new Uint8Array(e) : e).subarray(
              t,
              t + r
            );
            try {
              if (i.byteLength) {
                const e = Gh(i, 0, i.byteLength);
                -1 !== e.offset &&
                  e.offset === r &&
                  (this.valueBlock.value = [e.result]);
              }
            } catch (e) {}
          }
          return super.fromBER(e, t, r);
        }
        onAsciiEncoding() {
          return this.valueBlock.isConstructed ||
            (this.valueBlock.value && this.valueBlock.value.length)
            ? Yh.prototype.onAsciiEncoding.call(this)
            : `${this.constructor.NAME} : ${Tl.U$.ToHex(
                this.valueBlock.valueHexView
              )}`;
        }
        getValue() {
          if (!this.idBlock.isConstructed)
            return this.valueBlock.valueHexView.slice().buffer;
          const e = [];
          for (const t of this.valueBlock.value)
            t instanceof tu && e.push(t.valueBlock.valueHexView);
          return Tl._H.concat(e);
        }
      }
      (fh = tu), (sh.OctetString = fh), (tu.NAME = Jl);
      class ru extends $l(Wh) {
        constructor({ unusedBits: e = 0, isConstructed: t = !1, ...r } = {}) {
          super(r),
            (this.unusedBits = e),
            (this.isConstructed = t),
            (this.blockLength = this.valueHexView.byteLength);
        }
        fromBER(e, t, r) {
          if (!r) return t;
          let i = -1;
          if (this.isConstructed) {
            if (((i = Wh.prototype.fromBER.call(this, e, t, r)), -1 === i))
              return i;
            for (const e of this.value) {
              const t = e.constructor.NAME;
              if (t === Kl) {
                if (this.isIndefiniteForm) break;
                return (
                  (this.error =
                    "EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only"),
                  -1
                );
              }
              if (t !== Zl)
                return (
                  (this.error = "BIT STRING may consists of BIT STRINGs only"), -1
                );
              const r = e.valueBlock;
              if (this.unusedBits > 0 && r.unusedBits > 0)
                return (
                  (this.error =
                    'Using of "unused bits" inside constructive BIT STRING allowed for least one only'),
                  -1
                );
              this.unusedBits = r.unusedBits;
            }
            return i;
          }
          const s = Tl._H.toUint8Array(e);
          if (!Dl(this, s, t, r)) return -1;
          const n = s.subarray(t, t + r);
          if (((this.unusedBits = n[0]), this.unusedBits > 7))
            return (
              (this.error = "Unused bits for BitString must be in range 0-7"), -1
            );
          if (!this.unusedBits) {
            const e = n.subarray(1);
            try {
              if (e.byteLength) {
                const t = Gh(e, 0, e.byteLength);
                -1 !== t.offset &&
                  t.offset === r - 1 &&
                  (this.value = [t.result]);
              }
            } catch (e) {}
          }
          return (
            (this.valueHexView = n.subarray(1)),
            (this.blockLength = n.length),
            t + r
          );
        }
        toBER(e, t) {
          if (this.isConstructed) return Wh.prototype.toBER.call(this, e, t);
          if (e) return new ArrayBuffer(this.valueHexView.byteLength + 1);
          if (!this.valueHexView.byteLength) return Yl;
          const r = new Uint8Array(this.valueHexView.length + 1);
          return (r[0] = this.unusedBits), r.set(this.valueHexView, 1), r.buffer;
        }
        toJSON() {
          return {
            ...super.toJSON(),
            unusedBits: this.unusedBits,
            isConstructed: this.isConstructed,
          };
        }
      }
      ru.NAME = "BitStringValueBlock";
      class iu extends nh {
        constructor({ idBlock: e = {}, lenBlock: t = {}, ...r } = {}) {
          var i, s;
          (null !== (i = r.isConstructed) && void 0 !== i) ||
            (r.isConstructed = !!(null === (s = r.value) || void 0 === s
              ? void 0
              : s.length)),
            super(
              {
                idBlock: { isConstructed: r.isConstructed, ...e },
                lenBlock: { ...t, isIndefiniteForm: !!r.isIndefiniteForm },
                ...r,
              },
              ru
            ),
            (this.idBlock.tagClass = 1),
            (this.idBlock.tagNumber = 3);
        }
        fromBER(e, t, r) {
          return (
            (this.valueBlock.isConstructed = this.idBlock.isConstructed),
            (this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm),
            super.fromBER(e, t, r)
          );
        }
        onAsciiEncoding() {
          if (
            this.valueBlock.isConstructed ||
            (this.valueBlock.value && this.valueBlock.value.length)
          )
            return Yh.prototype.onAsciiEncoding.call(this);
          {
            const e = [],
              t = this.valueBlock.valueHexView;
            for (const r of t) e.push(r.toString(2).padStart(8, "0"));
            const r = e.join("");
            return `${this.constructor.NAME} : ${r.substring(
              0,
              r.length - this.valueBlock.unusedBits
            )}`;
          }
        }
      }
      function su(e, t) {
        const r = new Uint8Array([0]),
          i = new Uint8Array(e),
          s = new Uint8Array(t);
        let n = i.slice(0);
        const a = n.length - 1,
          o = s.slice(0),
          c = o.length - 1;
        let l = 0;
        let h = 0;
        for (let e = c < a ? a : c; e >= 0; e--, h++) {
          if (!0 == h < o.length) l = n[a - h] + o[c - h] + r[0];
          else l = n[a - h] + r[0];
          if (((r[0] = l / 10), !0 == h >= n.length))
            n = xl(new Uint8Array([l % 10]), n);
          else n[a - h] = l % 10;
        }
        return r[0] > 0 && (n = xl(r, n)), n;
      }
      function nu(e) {
        if (e >= Ll.length)
          for (let t = Ll.length; t <= e; t++) {
            const e = new Uint8Array([0]);
            let r = Ll[t - 1].slice(0);
            for (let t = r.length - 1; t >= 0; t--) {
              const i = new Uint8Array([(r[t] << 1) + e[0]]);
              (e[0] = i[0] / 10), (r[t] = i[0] % 10);
            }
            e[0] > 0 && (r = xl(e, r)), Ll.push(r);
          }
        return Ll[e];
      }
      function au(e, t) {
        let r = 0;
        const i = new Uint8Array(e),
          s = new Uint8Array(t),
          n = i.slice(0),
          a = n.length - 1,
          o = s.slice(0),
          c = o.length - 1;
        let l,
          h = 0;
        for (let e = c; e >= 0; e--, h++)
          if (((l = n[a - h] - o[c - h] - r), !0 == l < 0))
            (r = 1), (n[a - h] = l + 10);
          else (r = 0), (n[a - h] = l);
        if (r > 0)
          for (let e = a - c + 1; e >= 0; e--, h++) {
            if (((l = n[a - h] - r), !(l < 0))) {
              (r = 0), (n[a - h] = l);
              break;
            }
            (r = 1), (n[a - h] = l + 10);
          }
        return n.slice();
      }
      (gh = iu), (sh.BitString = gh), (iu.NAME = Zl);
      class ou extends $l(th) {
        constructor({ value: e, ...t } = {}) {
          super(t),
            (this._valueDec = 0),
            t.valueHex && this.setValueHex(),
            void 0 !== e && (this.valueDec = e);
        }
        setValueHex() {
          this.valueHexView.length >= 4
            ? (this.warnings.push("Too big Integer for decoding, hex only"),
              (this.isHexOnly = !0),
              (this._valueDec = 0))
            : ((this.isHexOnly = !1),
              this.valueHexView.length > 0 && (this._valueDec = Nl.call(this)));
        }
        set valueDec(e) {
          (this._valueDec = e),
            (this.isHexOnly = !1),
            (this.valueHexView = new Uint8Array(
              (function (e) {
                const t = e < 0 ? -1 * e : e;
                let r = 128;
                for (let i = 1; i < 8; i++) {
                  if (t <= r) {
                    if (e < 0) {
                      const e = Cl(r - t, 8, i);
                      return (new Uint8Array(e)[0] |= 128), e;
                    }
                    let s = Cl(t, 8, i),
                      n = new Uint8Array(s);
                    if (128 & n[0]) {
                      const e = s.slice(0),
                        t = new Uint8Array(e);
                      (s = new ArrayBuffer(s.byteLength + 1)),
                        (n = new Uint8Array(s));
                      for (let r = 0; r < e.byteLength; r++) n[r + 1] = t[r];
                      n[0] = 0;
                    }
                    return s;
                  }
                  r *= Math.pow(2, 8);
                }
                return new ArrayBuffer(0);
              })(e)
            ));
        }
        get valueDec() {
          return this._valueDec;
        }
        fromDER(e, t, r, i = 0) {
          const s = this.fromBER(e, t, r);
          if (-1 === s) return s;
          const n = this.valueHexView;
          return (
            0 === n[0] && 128 & n[1]
              ? (this.valueHexView = n.subarray(1))
              : 0 !== i &&
                n.length < i &&
                (i - n.length > 1 && (i = n.length + 1),
                (this.valueHexView = n.subarray(i - n.length))),
            s
          );
        }
        toDER(e = !1) {
          const t = this.valueHexView;
          switch (!0) {
            case !!(128 & t[0]):
              {
                const e = new Uint8Array(this.valueHexView.length + 1);
                (e[0] = 0), e.set(t, 1), (this.valueHexView = e);
              }
              break;
            case 0 === t[0] && !(128 & t[1]):
              this.valueHexView = this.valueHexView.subarray(1);
          }
          return this.toBER(e);
        }
        fromBER(e, t, r) {
          const i = super.fromBER(e, t, r);
          return -1 === i || this.setValueHex(), i;
        }
        toBER(e) {
          return e
            ? new ArrayBuffer(this.valueHexView.length)
            : this.valueHexView.slice().buffer;
        }
        toJSON() {
          return { ...super.toJSON(), valueDec: this.valueDec };
        }
        toString() {
          const e = 8 * this.valueHexView.length - 1;
          let t,
            r = new Uint8Array((8 * this.valueHexView.length) / 3),
            i = 0;
          const s = this.valueHexView;
          let n = "",
            a = !1;
          for (let a = s.byteLength - 1; a >= 0; a--) {
            t = s[a];
            for (let s = 0; s < 8; s++) {
              if (!(1 & ~t))
                if (i === e) (r = au(nu(i), r)), (n = "-");
                else r = su(r, nu(i));
              i++, (t >>= 1);
            }
          }
          for (let e = 0; e < r.length; e++)
            r[e] && (a = !0), a && (n += Pl.charAt(r[e]));
          return !1 === a && (n += Pl.charAt(0)), n;
        }
      }
      (mh = ou),
        (ou.NAME = "IntegerValueBlock"),
        Object.defineProperty(mh.prototype, "valueHex", {
          set: function (e) {
            (this.valueHexView = new Uint8Array(e)), this.setValueHex();
          },
          get: function () {
            return this.valueHexView.slice().buffer;
          },
        });
      class cu extends nh {
        constructor(e = {}) {
          super(e, ou), (this.idBlock.tagClass = 1), (this.idBlock.tagNumber = 2);
        }
        toBigInt() {
          return Rl(), BigInt(this.valueBlock.toString());
        }
        static fromBigInt(e) {
          Rl();
          const t = BigInt(e),
            r = new Ol(),
            i = t.toString(16).replace(/^-/, ""),
            s = new Uint8Array(Tl.U$.FromHex(i));
          if (t < 0) {
            const e = new Uint8Array(s.length + (128 & s[0] ? 1 : 0));
            e[0] |= 128;
            const i = BigInt(`0x${Tl.U$.ToHex(e)}`) + t,
              n = Tl._H.toUint8Array(Tl.U$.FromHex(i.toString(16)));
            (n[0] |= 128), r.write(n);
          } else 128 & s[0] && r.write(new Uint8Array([0])), r.write(s);
          return new cu({ valueHex: r.final() });
        }
        convertToDER() {
          const e = new cu({ valueHex: this.valueBlock.valueHexView });
          return e.valueBlock.toDER(), e;
        }
        convertFromDER() {
          return new cu({
            valueHex:
              0 === this.valueBlock.valueHexView[0]
                ? this.valueBlock.valueHexView.subarray(1)
                : this.valueBlock.valueHexView,
          });
        }
        onAsciiEncoding() {
          return `${this.constructor.NAME} : ${this.valueBlock.toString()}`;
        }
      }
      (yh = cu), (sh.Integer = yh), (cu.NAME = "INTEGER");
      class lu extends cu {
        constructor(e = {}) {
          super(e), (this.idBlock.tagClass = 1), (this.idBlock.tagNumber = 10);
        }
      }
      (Ah = lu), (sh.Enumerated = Ah), (lu.NAME = "ENUMERATED");
      class hu extends $l(th) {
        constructor({ valueDec: e = -1, isFirstSid: t = !1, ...r } = {}) {
          super(r), (this.valueDec = e), (this.isFirstSid = t);
        }
        fromBER(e, t, r) {
          if (!r) return t;
          const i = Tl._H.toUint8Array(e);
          if (!Dl(this, i, t, r)) return -1;
          const s = i.subarray(t, t + r);
          this.valueHexView = new Uint8Array(r);
          for (
            let e = 0;
            e < r &&
            ((this.valueHexView[e] = 127 & s[e]), this.blockLength++, 128 & s[e]);
            e++
          );
          const n = new Uint8Array(this.blockLength);
          for (let e = 0; e < this.blockLength; e++) n[e] = this.valueHexView[e];
          return (
            (this.valueHexView = n),
            128 & s[this.blockLength - 1]
              ? ((this.error =
                  "End of input reached before message was fully decoded"),
                -1)
              : (0 === this.valueHexView[0] &&
                  this.warnings.push("Needlessly long format of SID encoding"),
                this.blockLength <= 8
                  ? (this.valueDec = _l(this.valueHexView, 7))
                  : ((this.isHexOnly = !0),
                    this.warnings.push("Too big SID for decoding, hex only")),
                t + this.blockLength)
          );
        }
        set valueBigInt(e) {
          Rl();
          let t = BigInt(e).toString(2);
          for (; t.length % 7; ) t = "0" + t;
          const r = new Uint8Array(t.length / 7);
          for (let e = 0; e < r.length; e++)
            r[e] =
              parseInt(t.slice(7 * e, 7 * e + 7), 2) +
              (e + 1 < r.length ? 128 : 0);
          this.fromBER(r.buffer, 0, r.length);
        }
        toBER(e) {
          if (this.isHexOnly) {
            if (e) return new ArrayBuffer(this.valueHexView.byteLength);
            const t = this.valueHexView,
              r = new Uint8Array(this.blockLength);
            for (let e = 0; e < this.blockLength - 1; e++) r[e] = 128 | t[e];
            return (r[this.blockLength - 1] = t[this.blockLength - 1]), r.buffer;
          }
          const t = Cl(this.valueDec, 7);
          if (0 === t.byteLength)
            return (this.error = "Error during encoding SID value"), Yl;
          const r = new Uint8Array(t.byteLength);
          if (!e) {
            const e = new Uint8Array(t),
              i = t.byteLength - 1;
            for (let t = 0; t < i; t++) r[t] = 128 | e[t];
            r[i] = e[i];
          }
          return r;
        }
        toString() {
          let e = "";
          if (this.isHexOnly) e = Tl.U$.ToHex(this.valueHexView);
          else if (this.isFirstSid) {
            let t = this.valueDec;
            this.valueDec <= 39
              ? (e = "0.")
              : this.valueDec <= 79
              ? ((e = "1."), (t -= 40))
              : ((e = "2."), (t -= 80)),
              (e += t.toString());
          } else e = this.valueDec.toString();
          return e;
        }
        toJSON() {
          return {
            ...super.toJSON(),
            valueDec: this.valueDec,
            isFirstSid: this.isFirstSid,
          };
        }
      }
      hu.NAME = "sidBlock";
      class uu extends th {
        constructor({ value: e = Wl, ...t } = {}) {
          super(t), (this.value = []), e && this.fromString(e);
        }
        fromBER(e, t, r) {
          let i = t;
          for (; r > 0; ) {
            const t = new hu();
            if (((i = t.fromBER(e, i, r)), -1 === i))
              return (this.blockLength = 0), (this.error = t.error), i;
            0 === this.value.length && (t.isFirstSid = !0),
              (this.blockLength += t.blockLength),
              (r -= t.blockLength),
              this.value.push(t);
          }
          return i;
        }
        toBER(e) {
          const t = [];
          for (let r = 0; r < this.value.length; r++) {
            const i = this.value[r].toBER(e);
            if (0 === i.byteLength) return (this.error = this.value[r].error), Yl;
            t.push(i);
          }
          return Bl(t);
        }
        fromString(e) {
          this.value = [];
          let t = 0,
            r = 0,
            i = "",
            s = !1;
          do {
            if (
              ((r = e.indexOf(".", t)),
              (i = -1 === r ? e.substring(t) : e.substring(t, r)),
              (t = r + 1),
              s)
            ) {
              const e = this.value[0];
              let t = 0;
              switch (e.valueDec) {
                case 0:
                  break;
                case 1:
                  t = 40;
                  break;
                case 2:
                  t = 80;
                  break;
                default:
                  return void (this.value = []);
              }
              const r = parseInt(i, 10);
              if (isNaN(r)) return;
              (e.valueDec = r + t), (s = !1);
            } else {
              const e = new hu();
              if (i > Number.MAX_SAFE_INTEGER) {
                Rl();
                const t = BigInt(i);
                e.valueBigInt = t;
              } else if (((e.valueDec = parseInt(i, 10)), isNaN(e.valueDec)))
                return;
              this.value.length || ((e.isFirstSid = !0), (s = !0)),
                this.value.push(e);
            }
          } while (-1 !== r);
        }
        toString() {
          let e = "",
            t = !1;
          for (let r = 0; r < this.value.length; r++) {
            t = this.value[r].isHexOnly;
            let i = this.value[r].toString();
            0 !== r && (e = `${e}.`),
              t
                ? ((i = `{${i}}`),
                  this.value[r].isFirstSid ? (e = `2.{${i} - 80}`) : (e += i))
                : (e += i);
          }
          return e;
        }
        toJSON() {
          const e = { ...super.toJSON(), value: this.toString(), sidArray: [] };
          for (let t = 0; t < this.value.length; t++)
            e.sidArray.push(this.value[t].toJSON());
          return e;
        }
      }
      uu.NAME = "ObjectIdentifierValueBlock";
      class du extends nh {
        constructor(e = {}) {
          super(e, uu), (this.idBlock.tagClass = 1), (this.idBlock.tagNumber = 6);
        }
        getValue() {
          return this.valueBlock.toString();
        }
        setValue(e) {
          this.valueBlock.fromString(e);
        }
        onAsciiEncoding() {
          return `${this.constructor.NAME} : ${
            this.valueBlock.toString() || "empty"
          }`;
        }
        toJSON() {
          return { ...super.toJSON(), value: this.getValue() };
        }
      }
      (wh = du), (sh.ObjectIdentifier = wh), (du.NAME = "OBJECT IDENTIFIER");
      class pu extends $l(eh) {
        constructor({ valueDec: e = 0, ...t } = {}) {
          super(t), (this.valueDec = e);
        }
        fromBER(e, t, r) {
          if (0 === r) return t;
          const i = Tl._H.toUint8Array(e);
          if (!Dl(this, i, t, r)) return -1;
          const s = i.subarray(t, t + r);
          this.valueHexView = new Uint8Array(r);
          for (
            let e = 0;
            e < r &&
            ((this.valueHexView[e] = 127 & s[e]), this.blockLength++, 128 & s[e]);
            e++
          );
          const n = new Uint8Array(this.blockLength);
          for (let e = 0; e < this.blockLength; e++) n[e] = this.valueHexView[e];
          return (
            (this.valueHexView = n),
            128 & s[this.blockLength - 1]
              ? ((this.error =
                  "End of input reached before message was fully decoded"),
                -1)
              : (0 === this.valueHexView[0] &&
                  this.warnings.push("Needlessly long format of SID encoding"),
                this.blockLength <= 8
                  ? (this.valueDec = _l(this.valueHexView, 7))
                  : ((this.isHexOnly = !0),
                    this.warnings.push("Too big SID for decoding, hex only")),
                t + this.blockLength)
          );
        }
        toBER(e) {
          if (this.isHexOnly) {
            if (e) return new ArrayBuffer(this.valueHexView.byteLength);
            const t = this.valueHexView,
              r = new Uint8Array(this.blockLength);
            for (let e = 0; e < this.blockLength - 1; e++) r[e] = 128 | t[e];
            return (r[this.blockLength - 1] = t[this.blockLength - 1]), r.buffer;
          }
          const t = Cl(this.valueDec, 7);
          if (0 === t.byteLength)
            return (this.error = "Error during encoding SID value"), Yl;
          const r = new Uint8Array(t.byteLength);
          if (!e) {
            const e = new Uint8Array(t),
              i = t.byteLength - 1;
            for (let t = 0; t < i; t++) r[t] = 128 | e[t];
            r[i] = e[i];
          }
          return r.buffer;
        }
        toString() {
          let e = "";
          return (
            (e = this.isHexOnly
              ? Tl.U$.ToHex(this.valueHexView)
              : this.valueDec.toString()),
            e
          );
        }
        toJSON() {
          return { ...super.toJSON(), valueDec: this.valueDec };
        }
      }
      pu.NAME = "relativeSidBlock";
      class fu extends th {
        constructor({ value: e = Wl, ...t } = {}) {
          super(t), (this.value = []), e && this.fromString(e);
        }
        fromBER(e, t, r) {
          let i = t;
          for (; r > 0; ) {
            const t = new pu();
            if (((i = t.fromBER(e, i, r)), -1 === i))
              return (this.blockLength = 0), (this.error = t.error), i;
            (this.blockLength += t.blockLength),
              (r -= t.blockLength),
              this.value.push(t);
          }
          return i;
        }
        toBER(e, t) {
          const r = [];
          for (let t = 0; t < this.value.length; t++) {
            const i = this.value[t].toBER(e);
            if (0 === i.byteLength) return (this.error = this.value[t].error), Yl;
            r.push(i);
          }
          return Bl(r);
        }
        fromString(e) {
          this.value = [];
          let t = 0,
            r = 0,
            i = "";
          do {
            (r = e.indexOf(".", t)),
              (i = -1 === r ? e.substring(t) : e.substring(t, r)),
              (t = r + 1);
            const s = new pu();
            if (((s.valueDec = parseInt(i, 10)), isNaN(s.valueDec))) return !0;
            this.value.push(s);
          } while (-1 !== r);
          return !0;
        }
        toString() {
          let e = "",
            t = !1;
          for (let r = 0; r < this.value.length; r++) {
            t = this.value[r].isHexOnly;
            let i = this.value[r].toString();
            0 !== r && (e = `${e}.`), t ? ((i = `{${i}}`), (e += i)) : (e += i);
          }
          return e;
        }
        toJSON() {
          const e = { ...super.toJSON(), value: this.toString(), sidArray: [] };
          for (let t = 0; t < this.value.length; t++)
            e.sidArray.push(this.value[t].toJSON());
          return e;
        }
      }
      fu.NAME = "RelativeObjectIdentifierValueBlock";
      class gu extends nh {
        constructor(e = {}) {
          super(e, fu),
            (this.idBlock.tagClass = 1),
            (this.idBlock.tagNumber = 13);
        }
        getValue() {
          return this.valueBlock.toString();
        }
        setValue(e) {
          this.valueBlock.fromString(e);
        }
        onAsciiEncoding() {
          return `${this.constructor.NAME} : ${
            this.valueBlock.toString() || "empty"
          }`;
        }
        toJSON() {
          return { ...super.toJSON(), value: this.getValue() };
        }
      }
      (Eh = gu),
        (sh.RelativeObjectIdentifier = Eh),
        (gu.NAME = "RelativeObjectIdentifier");
      class mu extends Yh {
        constructor(e = {}) {
          super(e), (this.idBlock.tagClass = 1), (this.idBlock.tagNumber = 16);
        }
      }
      (bh = mu), (sh.Sequence = bh), (mu.NAME = "SEQUENCE");
      class yu extends Yh {
        constructor(e = {}) {
          super(e), (this.idBlock.tagClass = 1), (this.idBlock.tagNumber = 17);
        }
      }
      (vh = yu), (sh.Set = vh), (yu.NAME = "SET");
      class Au extends $l(th) {
        constructor({ ...e } = {}) {
          super(e), (this.isHexOnly = !0), (this.value = Wl);
        }
        toJSON() {
          return { ...super.toJSON(), value: this.value };
        }
      }
      Au.NAME = "StringValueBlock";
      class wu extends Au {}
      wu.NAME = "SimpleStringValueBlock";
      class Eu extends oh {
        constructor({ ...e } = {}) {
          super(e, wu);
        }
        fromBuffer(e) {
          this.valueBlock.value = String.fromCharCode.apply(
            null,
            Tl._H.toUint8Array(e)
          );
        }
        fromString(e) {
          const t = e.length,
            r = (this.valueBlock.valueHexView = new Uint8Array(t));
          for (let i = 0; i < t; i++) r[i] = e.charCodeAt(i);
          this.valueBlock.value = e;
        }
      }
      Eu.NAME = "SIMPLE STRING";
      class bu extends Eu {
        fromBuffer(e) {
          this.valueBlock.valueHexView = Tl._H.toUint8Array(e);
          try {
            this.valueBlock.value = Tl.U$.ToUtf8String(e);
          } catch (t) {
            this.warnings.push(
              `Error during "decodeURIComponent": ${t}, using raw string`
            ),
              (this.valueBlock.value = Tl.U$.ToBinary(e));
          }
        }
        fromString(e) {
          (this.valueBlock.valueHexView = new Uint8Array(
            Tl.U$.FromUtf8String(e)
          )),
            (this.valueBlock.value = e);
        }
      }
      bu.NAME = "Utf8StringValueBlock";
      class vu extends bu {
        constructor(e = {}) {
          super(e), (this.idBlock.tagClass = 1), (this.idBlock.tagNumber = 12);
        }
      }
      (Ih = vu), (sh.Utf8String = Ih), (vu.NAME = "UTF8String");
      class Iu extends Eu {
        fromBuffer(e) {
          (this.valueBlock.value = Tl.U$.ToUtf16String(e)),
            (this.valueBlock.valueHexView = Tl._H.toUint8Array(e));
        }
        fromString(e) {
          (this.valueBlock.value = e),
            (this.valueBlock.valueHexView = new Uint8Array(
              Tl.U$.FromUtf16String(e)
            ));
        }
      }
      Iu.NAME = "BmpStringValueBlock";
      class Su extends Iu {
        constructor({ ...e } = {}) {
          super(e), (this.idBlock.tagClass = 1), (this.idBlock.tagNumber = 30);
        }
      }
      (Sh = Su), (sh.BmpString = Sh), (Su.NAME = "BMPString");
      class Tu extends Eu {
        fromBuffer(e) {
          const t = ArrayBuffer.isView(e) ? e.slice().buffer : e.slice(0),
            r = new Uint8Array(t);
          for (let e = 0; e < r.length; e += 4)
            (r[e] = r[e + 3]),
              (r[e + 1] = r[e + 2]),
              (r[e + 2] = 0),
              (r[e + 3] = 0);
          this.valueBlock.value = String.fromCharCode.apply(
            null,
            new Uint32Array(t)
          );
        }
        fromString(e) {
          const t = e.length,
            r = (this.valueBlock.valueHexView = new Uint8Array(4 * t));
          for (let i = 0; i < t; i++) {
            const t = Cl(e.charCodeAt(i), 8),
              s = new Uint8Array(t);
            if (s.length > 4) continue;
            const n = 4 - s.length;
            for (let e = s.length - 1; e >= 0; e--) r[4 * i + e + n] = s[e];
          }
          this.valueBlock.value = e;
        }
      }
      Tu.NAME = "UniversalStringValueBlock";
      class _u extends Tu {
        constructor({ ...e } = {}) {
          super(e), (this.idBlock.tagClass = 1), (this.idBlock.tagNumber = 28);
        }
      }
      (Th = _u), (sh.UniversalString = Th), (_u.NAME = "UniversalString");
      class Cu extends Eu {
        constructor(e = {}) {
          super(e), (this.idBlock.tagClass = 1), (this.idBlock.tagNumber = 18);
        }
      }
      (_h = Cu), (sh.NumericString = _h), (Cu.NAME = "NumericString");
      class xu extends Eu {
        constructor(e = {}) {
          super(e), (this.idBlock.tagClass = 1), (this.idBlock.tagNumber = 19);
        }
      }
      (Ch = xu), (sh.PrintableString = Ch), (xu.NAME = "PrintableString");
      class Nu extends Eu {
        constructor(e = {}) {
          super(e), (this.idBlock.tagClass = 1), (this.idBlock.tagNumber = 20);
        }
      }
      (xh = Nu), (sh.TeletexString = xh), (Nu.NAME = "TeletexString");
      class ku extends Eu {
        constructor(e = {}) {
          super(e), (this.idBlock.tagClass = 1), (this.idBlock.tagNumber = 21);
        }
      }
      (Nh = ku), (sh.VideotexString = Nh), (ku.NAME = "VideotexString");
      class Ru extends Eu {
        constructor(e = {}) {
          super(e), (this.idBlock.tagClass = 1), (this.idBlock.tagNumber = 22);
        }
      }
      (kh = Ru), (sh.IA5String = kh), (Ru.NAME = "IA5String");
      class Bu extends Eu {
        constructor(e = {}) {
          super(e), (this.idBlock.tagClass = 1), (this.idBlock.tagNumber = 25);
        }
      }
      (Rh = Bu), (sh.GraphicString = Rh), (Bu.NAME = "GraphicString");
      class Du extends Eu {
        constructor(e = {}) {
          super(e), (this.idBlock.tagClass = 1), (this.idBlock.tagNumber = 26);
        }
      }
      (Bh = Du), (sh.VisibleString = Bh), (Du.NAME = "VisibleString");
      class Ou extends Eu {
        constructor(e = {}) {
          super(e), (this.idBlock.tagClass = 1), (this.idBlock.tagNumber = 27);
        }
      }
      (Dh = Ou), (sh.GeneralString = Dh), (Ou.NAME = "GeneralString");
      class Lu extends Eu {
        constructor(e = {}) {
          super(e), (this.idBlock.tagClass = 1), (this.idBlock.tagNumber = 29);
        }
      }
      (Oh = Lu), (sh.CharacterString = Oh), (Lu.NAME = "CharacterString");
      class Pu extends Du {
        constructor({ value: e, valueDate: t, ...r } = {}) {
          if (
            (super(r),
            (this.year = 0),
            (this.month = 0),
            (this.day = 0),
            (this.hour = 0),
            (this.minute = 0),
            (this.second = 0),
            e)
          ) {
            this.fromString(e),
              (this.valueBlock.valueHexView = new Uint8Array(e.length));
            for (let t = 0; t < e.length; t++)
              this.valueBlock.valueHexView[t] = e.charCodeAt(t);
          }
          t &&
            (this.fromDate(t),
            (this.valueBlock.valueHexView = new Uint8Array(this.toBuffer()))),
            (this.idBlock.tagClass = 1),
            (this.idBlock.tagNumber = 23);
        }
        fromBuffer(e) {
          this.fromString(String.fromCharCode.apply(null, Tl._H.toUint8Array(e)));
        }
        toBuffer() {
          const e = this.toString(),
            t = new ArrayBuffer(e.length),
            r = new Uint8Array(t);
          for (let t = 0; t < e.length; t++) r[t] = e.charCodeAt(t);
          return t;
        }
        fromDate(e) {
          (this.year = e.getUTCFullYear()),
            (this.month = e.getUTCMonth() + 1),
            (this.day = e.getUTCDate()),
            (this.hour = e.getUTCHours()),
            (this.minute = e.getUTCMinutes()),
            (this.second = e.getUTCSeconds());
        }
        toDate() {
          return new Date(
            Date.UTC(
              this.year,
              this.month - 1,
              this.day,
              this.hour,
              this.minute,
              this.second
            )
          );
        }
        fromString(e) {
          const t = /(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/gi.exec(e);
          if (null === t)
            return void (this.error = "Wrong input string for conversion");
          const r = parseInt(t[1], 10);
          (this.year = r >= 50 ? 1900 + r : 2e3 + r),
            (this.month = parseInt(t[2], 10)),
            (this.day = parseInt(t[3], 10)),
            (this.hour = parseInt(t[4], 10)),
            (this.minute = parseInt(t[5], 10)),
            (this.second = parseInt(t[6], 10));
        }
        toString(e = "iso") {
          if ("iso" === e) {
            const e = new Array(7);
            return (
              (e[0] = kl(
                this.year < 2e3 ? this.year - 1900 : this.year - 2e3,
                2
              )),
              (e[1] = kl(this.month, 2)),
              (e[2] = kl(this.day, 2)),
              (e[3] = kl(this.hour, 2)),
              (e[4] = kl(this.minute, 2)),
              (e[5] = kl(this.second, 2)),
              (e[6] = "Z"),
              e.join("")
            );
          }
          return super.toString(e);
        }
        onAsciiEncoding() {
          return `${this.constructor.NAME} : ${this.toDate().toISOString()}`;
        }
        toJSON() {
          return {
            ...super.toJSON(),
            year: this.year,
            month: this.month,
            day: this.day,
            hour: this.hour,
            minute: this.minute,
            second: this.second,
          };
        }
      }
      (Lh = Pu), (sh.UTCTime = Lh), (Pu.NAME = "UTCTime");
      class Uu extends Pu {
        constructor(e = {}) {
          var t;
          super(e),
            (null !== (t = this.millisecond) && void 0 !== t) ||
              (this.millisecond = 0),
            (this.idBlock.tagClass = 1),
            (this.idBlock.tagNumber = 24);
        }
        fromDate(e) {
          super.fromDate(e), (this.millisecond = e.getUTCMilliseconds());
        }
        toDate() {
          return new Date(
            Date.UTC(
              this.year,
              this.month - 1,
              this.day,
              this.hour,
              this.minute,
              this.second,
              this.millisecond
            )
          );
        }
        fromString(e) {
          let t,
            r = !1,
            i = "",
            s = "",
            n = 0,
            a = 0,
            o = 0;
          if ("Z" === e[e.length - 1])
            (i = e.substring(0, e.length - 1)), (r = !0);
          else {
            const t = new Number(e[e.length - 1]);
            if (isNaN(t.valueOf()))
              throw new Error("Wrong input string for conversion");
            i = e;
          }
          if (r) {
            if (-1 !== i.indexOf("+"))
              throw new Error("Wrong input string for conversion");
            if (-1 !== i.indexOf("-"))
              throw new Error("Wrong input string for conversion");
          } else {
            let e = 1,
              t = i.indexOf("+"),
              r = "";
            if ((-1 === t && ((t = i.indexOf("-")), (e = -1)), -1 !== t)) {
              if (
                ((r = i.substring(t + 1)),
                (i = i.substring(0, t)),
                2 !== r.length && 4 !== r.length)
              )
                throw new Error("Wrong input string for conversion");
              let s = parseInt(r.substring(0, 2), 10);
              if (isNaN(s.valueOf()))
                throw new Error("Wrong input string for conversion");
              if (((a = e * s), 4 === r.length)) {
                if (((s = parseInt(r.substring(2, 4), 10)), isNaN(s.valueOf())))
                  throw new Error("Wrong input string for conversion");
                o = e * s;
              }
            }
          }
          let c = i.indexOf(".");
          if ((-1 === c && (c = i.indexOf(",")), -1 !== c)) {
            const e = new Number(`0${i.substring(c)}`);
            if (isNaN(e.valueOf()))
              throw new Error("Wrong input string for conversion");
            (n = e.valueOf()), (s = i.substring(0, c));
          } else s = i;
          switch (!0) {
            case 8 === s.length:
              if (((t = /(\d{4})(\d{2})(\d{2})/gi), -1 !== c))
                throw new Error("Wrong input string for conversion");
              break;
            case 10 === s.length:
              if (((t = /(\d{4})(\d{2})(\d{2})(\d{2})/gi), -1 !== c)) {
                let e = 60 * n;
                (this.minute = Math.floor(e)),
                  (e = 60 * (e - this.minute)),
                  (this.second = Math.floor(e)),
                  (e = 1e3 * (e - this.second)),
                  (this.millisecond = Math.floor(e));
              }
              break;
            case 12 === s.length:
              if (((t = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/gi), -1 !== c)) {
                let e = 60 * n;
                (this.second = Math.floor(e)),
                  (e = 1e3 * (e - this.second)),
                  (this.millisecond = Math.floor(e));
              }
              break;
            case 14 === s.length:
              if (
                ((t = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/gi), -1 !== c)
              ) {
                const e = 1e3 * n;
                this.millisecond = Math.floor(e);
              }
              break;
            default:
              throw new Error("Wrong input string for conversion");
          }
          const l = t.exec(s);
          if (null === l) throw new Error("Wrong input string for conversion");
          for (let e = 1; e < l.length; e++)
            switch (e) {
              case 1:
                this.year = parseInt(l[e], 10);
                break;
              case 2:
                this.month = parseInt(l[e], 10);
                break;
              case 3:
                this.day = parseInt(l[e], 10);
                break;
              case 4:
                this.hour = parseInt(l[e], 10) + a;
                break;
              case 5:
                this.minute = parseInt(l[e], 10) + o;
                break;
              case 6:
                this.second = parseInt(l[e], 10);
                break;
              default:
                throw new Error("Wrong input string for conversion");
            }
          if (!1 === r) {
            const e = new Date(
              this.year,
              this.month,
              this.day,
              this.hour,
              this.minute,
              this.second,
              this.millisecond
            );
            (this.year = e.getUTCFullYear()),
              (this.month = e.getUTCMonth()),
              (this.day = e.getUTCDay()),
              (this.hour = e.getUTCHours()),
              (this.minute = e.getUTCMinutes()),
              (this.second = e.getUTCSeconds()),
              (this.millisecond = e.getUTCMilliseconds());
          }
        }
        toString(e = "iso") {
          if ("iso" === e) {
            const e = [];
            return (
              e.push(kl(this.year, 4)),
              e.push(kl(this.month, 2)),
              e.push(kl(this.day, 2)),
              e.push(kl(this.hour, 2)),
              e.push(kl(this.minute, 2)),
              e.push(kl(this.second, 2)),
              0 !== this.millisecond &&
                (e.push("."), e.push(kl(this.millisecond, 3))),
              e.push("Z"),
              e.join("")
            );
          }
          return super.toString(e);
        }
        toJSON() {
          return { ...super.toJSON(), millisecond: this.millisecond };
        }
      }
      (Ph = Uu), (sh.GeneralizedTime = Ph), (Uu.NAME = "GeneralizedTime");
      class Mu extends vu {
        constructor(e = {}) {
          super(e), (this.idBlock.tagClass = 1), (this.idBlock.tagNumber = 31);
        }
      }
      (Uh = Mu), (sh.DATE = Uh), (Mu.NAME = "DATE");
      class Fu extends vu {
        constructor(e = {}) {
          super(e), (this.idBlock.tagClass = 1), (this.idBlock.tagNumber = 32);
        }
      }
      (Mh = Fu), (sh.TimeOfDay = Mh), (Fu.NAME = "TimeOfDay");
      class Hu extends vu {
        constructor(e = {}) {
          super(e), (this.idBlock.tagClass = 1), (this.idBlock.tagNumber = 33);
        }
      }
      (Fh = Hu), (sh.DateTime = Fh), (Hu.NAME = "DateTime");
      class Qu extends vu {
        constructor(e = {}) {
          super(e), (this.idBlock.tagClass = 1), (this.idBlock.tagNumber = 34);
        }
      }
      (Hh = Qu), (sh.Duration = Hh), (Qu.NAME = "Duration");
      class Vu extends vu {
        constructor(e = {}) {
          super(e), (this.idBlock.tagClass = 1), (this.idBlock.tagNumber = 14);
        }
      }
      (Qh = Vu), (sh.TIME = Qh), (Vu.NAME = "TIME");
      class zu {
        constructor({ name: e = Wl, optional: t = !1 } = {}) {
          (this.name = e), (this.optional = t);
        }
      }
      class qu extends zu {
        constructor({ value: e = [], ...t } = {}) {
          super(t), (this.value = e);
        }
      }
      class Gu extends zu {
        constructor({ value: e = new zu(), local: t = !1, ...r } = {}) {
          super(r), (this.value = e), (this.local = t);
        }
      }
      class ju {
        constructor({ data: e = Xl } = {}) {
          this.dataView = Tl._H.toUint8Array(e);
        }
        get data() {
          return this.dataView.slice().buffer;
        }
        set data(e) {
          this.dataView = Tl._H.toUint8Array(e);
        }
        fromBER(e, t, r) {
          const i = t + r;
          return (this.dataView = Tl._H.toUint8Array(e).subarray(t, i)), i;
        }
        toBER(e) {
          return this.dataView.slice().buffer;
        }
      }
      function Wu(e, t, r) {
        if (r instanceof qu) {
          for (let i = 0; i < r.value.length; i++) {
            if (Wu(e, t, r.value[i]).verified) return { verified: !0, result: e };
          }
          {
            const e = {
              verified: !1,
              result: { error: "Wrong values for Choice type" },
            };
            return r.hasOwnProperty(Ul) && (e.name = r.name), e;
          }
        }
        if (r instanceof zu)
          return (
            r.hasOwnProperty(Ul) && (e[r.name] = t), { verified: !0, result: e }
          );
        if (e instanceof Object == !1)
          return { verified: !1, result: { error: "Wrong root object" } };
        if (t instanceof Object == !1)
          return { verified: !1, result: { error: "Wrong ASN.1 data" } };
        if (r instanceof Object == !1)
          return { verified: !1, result: { error: "Wrong ASN.1 schema" } };
        if (Hl in r == !1)
          return { verified: !1, result: { error: "Wrong ASN.1 schema" } };
        if (ql in r.idBlock == !1)
          return { verified: !1, result: { error: "Wrong ASN.1 schema" } };
        if (Gl in r.idBlock == !1)
          return { verified: !1, result: { error: "Wrong ASN.1 schema" } };
        const i = r.idBlock.toBER(!1);
        if (0 === i.byteLength)
          return {
            verified: !1,
            result: { error: "Error encoding idBlock for ASN.1 schema" },
          };
        if (-1 === r.idBlock.fromBER(i, 0, i.byteLength))
          return {
            verified: !1,
            result: { error: "Error decoding idBlock for ASN.1 schema" },
          };
        if (!1 === r.idBlock.hasOwnProperty(Ql))
          return { verified: !1, result: { error: "Wrong ASN.1 schema" } };
        if (r.idBlock.tagClass !== t.idBlock.tagClass)
          return { verified: !1, result: e };
        if (!1 === r.idBlock.hasOwnProperty(Vl))
          return { verified: !1, result: { error: "Wrong ASN.1 schema" } };
        if (r.idBlock.tagNumber !== t.idBlock.tagNumber)
          return { verified: !1, result: e };
        if (!1 === r.idBlock.hasOwnProperty(zl))
          return { verified: !1, result: { error: "Wrong ASN.1 schema" } };
        if (r.idBlock.isConstructed !== t.idBlock.isConstructed)
          return { verified: !1, result: e };
        if (!(Fl in r.idBlock))
          return { verified: !1, result: { error: "Wrong ASN.1 schema" } };
        if (r.idBlock.isHexOnly !== t.idBlock.isHexOnly)
          return { verified: !1, result: e };
        if (r.idBlock.isHexOnly) {
          if (Ml in r.idBlock == !1)
            return { verified: !1, result: { error: "Wrong ASN.1 schema" } };
          const i = r.idBlock.valueHexView,
            s = t.idBlock.valueHexView;
          if (i.length !== s.length) return { verified: !1, result: e };
          for (let t = 0; t < i.length; t++)
            if (i[t] !== s[1]) return { verified: !1, result: e };
        }
        if (
          (r.name &&
            ((r.name = r.name.replace(/^\s+|\s+$/g, Wl)),
            r.name && (e[r.name] = t)),
          r instanceof sh.Constructed)
        ) {
          let i = 0,
            s = { verified: !1, result: { error: "Unknown error" } },
            n = r.valueBlock.value.length;
          if (
            (n > 0 &&
              r.valueBlock.value[0] instanceof Gu &&
              (n = t.valueBlock.value.length),
            0 === n)
          )
            return { verified: !0, result: e };
          if (
            0 === t.valueBlock.value.length &&
            0 !== r.valueBlock.value.length
          ) {
            let t = !0;
            for (let e = 0; e < r.valueBlock.value.length; e++)
              t = t && (r.valueBlock.value[e].optional || !1);
            return t
              ? { verified: !0, result: e }
              : (r.name &&
                  ((r.name = r.name.replace(/^\s+|\s+$/g, Wl)),
                  r.name && delete e[r.name]),
                (e.error = "Inconsistent object length"),
                { verified: !1, result: e });
          }
          for (let a = 0; a < n; a++)
            if (a - i >= t.valueBlock.value.length) {
              if (!1 === r.valueBlock.value[a].optional) {
                const t = { verified: !1, result: e };
                return (
                  (e.error = "Inconsistent length between ASN.1 data and schema"),
                  r.name &&
                    ((r.name = r.name.replace(/^\s+|\s+$/g, Wl)),
                    r.name && (delete e[r.name], (t.name = r.name))),
                  t
                );
              }
            } else if (r.valueBlock.value[0] instanceof Gu) {
              if (
                ((s = Wu(e, t.valueBlock.value[a], r.valueBlock.value[0].value)),
                !1 === s.verified)
              ) {
                if (!r.valueBlock.value[0].optional)
                  return (
                    r.name &&
                      ((r.name = r.name.replace(/^\s+|\s+$/g, Wl)),
                      r.name && delete e[r.name]),
                    s
                  );
                i++;
              }
              if (
                Ul in r.valueBlock.value[0] &&
                r.valueBlock.value[0].name.length > 0
              ) {
                let i = {};
                (i =
                  jl in r.valueBlock.value[0] && r.valueBlock.value[0].local
                    ? t
                    : e),
                  void 0 === i[r.valueBlock.value[0].name] &&
                    (i[r.valueBlock.value[0].name] = []),
                  i[r.valueBlock.value[0].name].push(t.valueBlock.value[a]);
              }
            } else if (
              ((s = Wu(e, t.valueBlock.value[a - i], r.valueBlock.value[a])),
              !1 === s.verified)
            ) {
              if (!r.valueBlock.value[a].optional)
                return (
                  r.name &&
                    ((r.name = r.name.replace(/^\s+|\s+$/g, Wl)),
                    r.name && delete e[r.name]),
                  s
                );
              i++;
            }
          if (!1 === s.verified) {
            const t = { verified: !1, result: e };
            return (
              r.name &&
                ((r.name = r.name.replace(/^\s+|\s+$/g, Wl)),
                r.name && (delete e[r.name], (t.name = r.name))),
              t
            );
          }
          return { verified: !0, result: e };
        }
        if (r.primitiveSchema && Ml in t.valueBlock) {
          const i = Gh(t.valueBlock.valueHexView);
          if (-1 === i.offset) {
            const t = { verified: !1, result: i.result };
            return (
              r.name &&
                ((r.name = r.name.replace(/^\s+|\s+$/g, Wl)),
                r.name && (delete e[r.name], (t.name = r.name))),
              t
            );
          }
          return Wu(e, i.result, r.primitiveSchema);
        }
        return { verified: !0, result: e };
      }
      function Yu(e, t) {
        if (t instanceof Object == !1)
          return { verified: !1, result: { error: "Wrong ASN.1 schema type" } };
        const r = Gh(Tl._H.toUint8Array(e));
        return -1 === r.offset
          ? { verified: !1, result: r.result }
          : Wu(r.result, r.result, t);
      }
      !(function (e) {
        (e[(e.Sequence = 0)] = "Sequence"),
          (e[(e.Set = 1)] = "Set"),
          (e[(e.Choice = 2)] = "Choice");
      })(Vh || (Vh = {})),
        (function (e) {
          (e[(e.Any = 1)] = "Any"),
            (e[(e.Boolean = 2)] = "Boolean"),
            (e[(e.OctetString = 3)] = "OctetString"),
            (e[(e.BitString = 4)] = "BitString"),
            (e[(e.Integer = 5)] = "Integer"),
            (e[(e.Enumerated = 6)] = "Enumerated"),
            (e[(e.ObjectIdentifier = 7)] = "ObjectIdentifier"),
            (e[(e.Utf8String = 8)] = "Utf8String"),
            (e[(e.BmpString = 9)] = "BmpString"),
            (e[(e.UniversalString = 10)] = "UniversalString"),
            (e[(e.NumericString = 11)] = "NumericString"),
            (e[(e.PrintableString = 12)] = "PrintableString"),
            (e[(e.TeletexString = 13)] = "TeletexString"),
            (e[(e.VideotexString = 14)] = "VideotexString"),
            (e[(e.IA5String = 15)] = "IA5String"),
            (e[(e.GraphicString = 16)] = "GraphicString"),
            (e[(e.VisibleString = 17)] = "VisibleString"),
            (e[(e.GeneralString = 18)] = "GeneralString"),
            (e[(e.CharacterString = 19)] = "CharacterString"),
            (e[(e.UTCTime = 20)] = "UTCTime"),
            (e[(e.GeneralizedTime = 21)] = "GeneralizedTime"),
            (e[(e.DATE = 22)] = "DATE"),
            (e[(e.TimeOfDay = 23)] = "TimeOfDay"),
            (e[(e.DateTime = 24)] = "DateTime"),
            (e[(e.Duration = 25)] = "Duration"),
            (e[(e.TIME = 26)] = "TIME"),
            (e[(e.Null = 27)] = "Null");
        })(zh || (zh = {}));
      class Xu {
        constructor(e, t = 0) {
          if (((this.unusedBits = 0), (this.value = new ArrayBuffer(0)), e))
            if ("number" == typeof e) this.fromNumber(e);
            else {
              if (!Tl._H.isBufferSource(e))
                throw TypeError(
                  "Unsupported type of 'params' argument for BitString"
                );
              (this.unusedBits = t), (this.value = Tl._H.toArrayBuffer(e));
            }
        }
        fromASN(e) {
          if (!(e instanceof iu))
            throw new TypeError(
              "Argument 'asn' is not instance of ASN.1 BitString"
            );
          return (
            (this.unusedBits = e.valueBlock.unusedBits),
            (this.value = e.valueBlock.valueHex),
            this
          );
        }
        toASN() {
          return new iu({ unusedBits: this.unusedBits, valueHex: this.value });
        }
        toSchema(e) {
          return new iu({ name: e });
        }
        toNumber() {
          let e = "";
          const t = new Uint8Array(this.value);
          for (const r of t) e += r.toString(2).padStart(8, "0");
          return (
            (e = e.split("").reverse().join("")),
            this.unusedBits &&
              (e = e.slice(this.unusedBits).padStart(this.unusedBits, "0")),
            parseInt(e, 2)
          );
        }
        fromNumber(e) {
          let t = e.toString(2);
          const r = (t.length + 7) >> 3;
          this.unusedBits = (r << 3) - t.length;
          const i = new Uint8Array(r);
          t = t
            .padStart(r << 3, "0")
            .split("")
            .reverse()
            .join("");
          let s = 0;
          for (; s < r; )
            (i[s] = parseInt(t.slice(s << 3, 8 + (s << 3)), 2)), s++;
          this.value = i.buffer;
        }
      }
      class Ku {
        get byteLength() {
          return this.buffer.byteLength;
        }
        get byteOffset() {
          return 0;
        }
        constructor(e) {
          "number" == typeof e
            ? (this.buffer = new ArrayBuffer(e))
            : Tl._H.isBufferSource(e)
            ? (this.buffer = Tl._H.toArrayBuffer(e))
            : Array.isArray(e)
            ? (this.buffer = new Uint8Array(e))
            : (this.buffer = new ArrayBuffer(0));
        }
        fromASN(e) {
          if (!(e instanceof tu))
            throw new TypeError(
              "Argument 'asn' is not instance of ASN.1 OctetString"
            );
          return (this.buffer = e.valueBlock.valueHex), this;
        }
        toASN() {
          return new tu({ valueHex: this.buffer });
        }
        toSchema(e) {
          return new tu({ name: e });
        }
      }
      const Ju = {
          fromASN: (e) => (e instanceof Jh ? null : e.valueBeforeDecodeView),
          toASN: (e) => {
            if (null === e) return new Jh();
            const t = jh(e);
            if (t.result.error) throw new Error(t.result.error);
            return t.result;
          },
        },
        Zu = {
          fromASN: (e) =>
            e.valueBlock.valueHexView.byteLength >= 4
              ? e.valueBlock.toString()
              : e.valueBlock.valueDec,
          toASN: (e) => new cu({ value: +e }),
        },
        $u = {
          fromASN: (e) => e.valueBlock.valueDec,
          toASN: (e) => new lu({ value: e }),
        },
        ed = {
          fromASN: (e) => e.valueBlock.valueHexView,
          toASN: (e) => new cu({ valueHex: e }),
        },
        td = {
          fromASN: (e) => e.valueBlock.valueHexView,
          toASN: (e) => new iu({ valueHex: e }),
        },
        rd = {
          fromASN: (e) => e.valueBlock.toString(),
          toASN: (e) => new du({ value: e }),
        },
        id = {
          fromASN: (e) => e.valueBlock.value,
          toASN: (e) => new $h({ value: e }),
        },
        sd = {
          fromASN: (e) => e.valueBlock.valueHexView,
          toASN: (e) => new tu({ valueHex: e }),
        },
        nd = { fromASN: (e) => new Ku(e.getValue()), toASN: (e) => e.toASN() };
      function ad(e) {
        return {
          fromASN: (e) => e.valueBlock.value,
          toASN: (t) => new e({ value: t }),
        };
      }
      const od = ad(vu),
        cd = ad(Su),
        ld = ad(_u),
        hd = ad(Cu),
        ud = ad(xu),
        dd = ad(Nu),
        pd = ad(ku),
        fd = ad(Ru),
        gd = ad(Bu),
        md = ad(Du),
        yd = ad(Ou),
        Ad = ad(Lu),
        wd = {
          fromASN: (e) => e.toDate(),
          toASN: (e) => new Pu({ valueDate: e }),
        },
        Ed = {
          fromASN: (e) => e.toDate(),
          toASN: (e) => new Uu({ valueDate: e }),
        },
        bd = { fromASN: () => null, toASN: () => new Jh() };
      function vd(e) {
        switch (e) {
          case zh.Any:
            return Ju;
          case zh.BitString:
            return td;
          case zh.BmpString:
            return cd;
          case zh.Boolean:
            return id;
          case zh.CharacterString:
            return Ad;
          case zh.Enumerated:
            return $u;
          case zh.GeneralString:
            return yd;
          case zh.GeneralizedTime:
            return Ed;
          case zh.GraphicString:
            return gd;
          case zh.IA5String:
            return fd;
          case zh.Integer:
            return Zu;
          case zh.Null:
            return bd;
          case zh.NumericString:
            return hd;
          case zh.ObjectIdentifier:
            return rd;
          case zh.OctetString:
            return sd;
          case zh.PrintableString:
            return ud;
          case zh.TeletexString:
            return dd;
          case zh.UTCTime:
            return wd;
          case zh.UniversalString:
            return ld;
          case zh.Utf8String:
            return od;
          case zh.VideotexString:
            return pd;
          case zh.VisibleString:
            return md;
          default:
            return null;
        }
      }
      function Id(e) {
        return "function" == typeof e && e.prototype
          ? !(!e.prototype.toASN || !e.prototype.fromASN) || Id(e.prototype)
          : !!(e && "object" == typeof e && "toASN" in e && "fromASN" in e);
      }
      function Sd(e) {
        var t;
        if (e) {
          const r = Object.getPrototypeOf(e);
          return (
            (null === (t = null == r ? void 0 : r.prototype) || void 0 === t
              ? void 0
              : t.constructor) === Array || Sd(r)
          );
        }
        return !1;
      }
      function Td(e, t) {
        if (!e || !t) return !1;
        if (e.byteLength !== t.byteLength) return !1;
        const r = new Uint8Array(e),
          i = new Uint8Array(t);
        for (let t = 0; t < e.byteLength; t++) if (r[t] !== i[t]) return !1;
        return !0;
      }
      const _d = new (class {
          constructor() {
            this.items = new WeakMap();
          }
          has(e) {
            return this.items.has(e);
          }
          get(e, t = !1) {
            const r = this.items.get(e);
            if (!r)
              throw new Error(
                `Cannot get schema for '${e.prototype.constructor.name}' target`
              );
            if (t && !r.schema)
              throw new Error(
                `Schema '${e.prototype.constructor.name}' doesn't contain ASN.1 schema. Call 'AsnSchemaStorage.cache'.`
              );
            return r;
          }
          cache(e) {
            const t = this.get(e);
            t.schema || (t.schema = this.create(e, !0));
          }
          createDefault(e) {
            const t = { type: Vh.Sequence, items: {} },
              r = this.findParentSchema(e);
            return (
              r &&
                (Object.assign(t, r),
                (t.items = Object.assign({}, t.items, r.items))),
              t
            );
          }
          create(t, r) {
            const i = this.items.get(t) || this.createDefault(t),
              s = [];
            for (const t in i.items) {
              const n = i.items[t],
                a = r ? t : "";
              let o;
              if ("number" == typeof n.type) {
                const t = zh[n.type],
                  r = e[t];
                if (!r) throw new Error(`Cannot get ASN1 class by name '${t}'`);
                o = new r({ name: a });
              } else if (Id(n.type)) {
                o = new n.type().toSchema(a);
              } else if (n.optional) {
                this.get(n.type).type === Vh.Choice
                  ? (o = new zu({ name: a }))
                  : ((o = this.create(n.type, !1)), (o.name = a));
              } else o = new zu({ name: a });
              const c = !!n.optional || void 0 !== n.defaultValue;
              if (n.repeated) {
                o.name = "";
                o = new ("set" === n.repeated ? yu : mu)({
                  name: "",
                  value: [new Gu({ name: a, value: o })],
                });
              }
              if (null !== n.context && void 0 !== n.context)
                if (n.implicit)
                  if ("number" == typeof n.type || Id(n.type)) {
                    const e = n.repeated ? Yh : qh;
                    s.push(
                      new e({
                        name: a,
                        optional: c,
                        idBlock: { tagClass: 3, tagNumber: n.context },
                      })
                    );
                  } else {
                    this.cache(n.type);
                    const e = !!n.repeated;
                    let t = e ? o : this.get(n.type, !0).schema;
                    (t = "valueBlock" in t ? t.valueBlock.value : t.value),
                      s.push(
                        new Yh({
                          name: e ? "" : a,
                          optional: c,
                          idBlock: { tagClass: 3, tagNumber: n.context },
                          value: t,
                        })
                      );
                  }
                else
                  s.push(
                    new Yh({
                      optional: c,
                      idBlock: { tagClass: 3, tagNumber: n.context },
                      value: [o],
                    })
                  );
              else (o.optional = c), s.push(o);
            }
            switch (i.type) {
              case Vh.Sequence:
                return new mu({ value: s, name: "" });
              case Vh.Set:
                return new yu({ value: s, name: "" });
              case Vh.Choice:
                return new qu({ value: s, name: "" });
              default:
                throw new Error("Unsupported ASN1 type in use");
            }
          }
          set(e, t) {
            return this.items.set(e, t), this;
          }
          findParentSchema(e) {
            const t = Object.getPrototypeOf(e);
            if (t) {
              return this.items.get(t) || this.findParentSchema(t);
            }
            return null;
          }
        })(),
        Cd = (e) => (t) => {
          let r;
          _d.has(t) ? (r = _d.get(t)) : ((r = _d.createDefault(t)), _d.set(t, r)),
            Object.assign(r, e);
        },
        xd = (e) => (t, r) => {
          let i;
          _d.has(t.constructor)
            ? (i = _d.get(t.constructor))
            : ((i = _d.createDefault(t.constructor)), _d.set(t.constructor, i));
          const s = Object.assign({}, e);
          if ("number" == typeof s.type && !s.converter) {
            const i = vd(e.type);
            if (!i)
              throw new Error(
                `Cannot get default converter for property '${r}' of ${t.constructor.name}`
              );
            s.converter = i;
          }
          i.items[r] = s;
        };
      class Nd extends Error {
        constructor() {
          super(...arguments), (this.schemas = []);
        }
      }
      class kd {
        static parse(e, t) {
          const r = jh(e);
          if (r.result.error) throw new Error(r.result.error);
          return this.fromASN(r.result, t);
        }
        static fromASN(t, r) {
          var i;
          try {
            if (Id(r)) {
              return new r().fromASN(t);
            }
            const s = _d.get(r);
            _d.cache(r);
            let n = s.schema;
            if (t.constructor === Yh && s.type !== Vh.Choice) {
              n = new Yh({
                idBlock: { tagClass: 3, tagNumber: t.idBlock.tagNumber },
                value: s.schema.valueBlock.value,
              });
              for (const e in s.items) delete t[e];
            }
            const a = Wu({}, t, n);
            if (!a.verified)
              throw new Nd(
                `Data does not match to ${r.name} ASN1 schema. ${a.result.error}`
              );
            const o = new r();
            if (Sd(r)) {
              if (
                !("value" in t.valueBlock) ||
                !Array.isArray(t.valueBlock.value)
              )
                throw new Error(
                  "Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed."
                );
              const e = s.itemType;
              if ("number" == typeof e) {
                const i = vd(e);
                if (!i)
                  throw new Error(
                    `Cannot get default converter for array item of ${r.name} ASN1 schema`
                  );
                return r.from(t.valueBlock.value, (e) => i.fromASN(e));
              }
              return r.from(t.valueBlock.value, (t) => this.fromASN(t, e));
            }
            for (const t in s.items) {
              const r = a.result[t];
              if (!r) continue;
              const n = s.items[t],
                c = n.type;
              if ("number" == typeof c || Id(c)) {
                const s =
                  null !== (i = n.converter) && void 0 !== i
                    ? i
                    : Id(c)
                    ? new c()
                    : null;
                if (!s) throw new Error("Converter is empty");
                if (n.repeated)
                  if (n.implicit) {
                    const e = new ("sequence" === n.repeated ? mu : yu)();
                    e.valueBlock = r.valueBlock;
                    const i = jh(e.toBER(!1));
                    if (-1 === i.offset)
                      throw new Error(
                        `Cannot parse the child item. ${i.result.error}`
                      );
                    if (
                      !("value" in i.result.valueBlock) ||
                      !Array.isArray(i.result.valueBlock.value)
                    )
                      throw new Error(
                        "Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed."
                      );
                    const a = i.result.valueBlock.value;
                    o[t] = Array.from(a, (e) => s.fromASN(e));
                  } else o[t] = Array.from(r, (e) => s.fromASN(e));
                else {
                  let i = r;
                  if (n.implicit) {
                    let t;
                    if (Id(c)) t = new c().toSchema("");
                    else {
                      const r = zh[c],
                        i = e[r];
                      if (!i)
                        throw new Error(
                          `Cannot get '${r}' class from asn1js module`
                        );
                      t = new i();
                    }
                    (t.valueBlock = i.valueBlock), (i = jh(t.toBER(!1)).result);
                  }
                  o[t] = s.fromASN(i);
                }
              } else if (n.repeated) {
                if (!Array.isArray(r))
                  throw new Error(
                    "Cannot get list of items from the ASN.1 parsed value. ASN.1 value should be iterable."
                  );
                o[t] = Array.from(r, (e) => this.fromASN(e, c));
              } else o[t] = this.fromASN(r, c);
            }
            return o;
          } catch (e) {
            throw (e instanceof Nd && e.schemas.push(r.name), e);
          }
        }
      }
      class Rd {
        static serialize(e) {
          return e instanceof nh ? e.toBER(!1) : this.toASN(e).toBER(!1);
        }
        static toASN(e) {
          if (e && "object" == typeof e && Id(e)) return e.toASN();
          if (!e || "object" != typeof e)
            throw new TypeError("Parameter 1 should be type of Object.");
          const t = e.constructor,
            r = _d.get(t);
          _d.cache(t);
          let i,
            s = [];
          if (r.itemType) {
            if (!Array.isArray(e))
              throw new TypeError("Parameter 1 should be type of Array.");
            if ("number" == typeof r.itemType) {
              const i = vd(r.itemType);
              if (!i)
                throw new Error(
                  `Cannot get default converter for array item of ${t.name} ASN1 schema`
                );
              s = e.map((e) => i.toASN(e));
            } else
              s = e.map((e) => this.toAsnItem({ type: r.itemType }, "[]", t, e));
          } else
            for (const i in r.items) {
              const n = r.items[i],
                a = e[i];
              if (
                void 0 === a ||
                n.defaultValue === a ||
                ("object" == typeof n.defaultValue &&
                  "object" == typeof a &&
                  Td(this.serialize(n.defaultValue), this.serialize(a)))
              )
                continue;
              const o = Rd.toAsnItem(n, i, t, a);
              if ("number" == typeof n.context)
                if (n.implicit)
                  if (n.repeated || ("number" != typeof n.type && !Id(n.type)))
                    s.push(
                      new Yh({
                        optional: n.optional,
                        idBlock: { tagClass: 3, tagNumber: n.context },
                        value: o.valueBlock.value,
                      })
                    );
                  else {
                    const e = {};
                    (e.valueHex =
                      o instanceof Jh
                        ? o.valueBeforeDecodeView
                        : o.valueBlock.toBER()),
                      s.push(
                        new qh({
                          optional: n.optional,
                          idBlock: { tagClass: 3, tagNumber: n.context },
                          ...e,
                        })
                      );
                  }
                else
                  s.push(
                    new Yh({
                      optional: n.optional,
                      idBlock: { tagClass: 3, tagNumber: n.context },
                      value: [o],
                    })
                  );
              else n.repeated ? (s = s.concat(o)) : s.push(o);
            }
          switch (r.type) {
            case Vh.Sequence:
              i = new mu({ value: s });
              break;
            case Vh.Set:
              i = new yu({ value: s });
              break;
            case Vh.Choice:
              if (!s[0])
                throw new Error(
                  `Schema '${t.name}' has wrong data. Choice cannot be empty.`
                );
              i = s[0];
          }
          return i;
        }
        static toAsnItem(e, t, r, i) {
          let s;
          if ("number" == typeof e.type) {
            const n = e.converter;
            if (!n)
              throw new Error(
                `Property '${t}' doesn't have converter for type ${
                  zh[e.type]
                } in schema '${r.name}'`
              );
            if (e.repeated) {
              if (!Array.isArray(i))
                throw new TypeError(
                  "Parameter 'objProp' should be type of Array."
                );
              const t = Array.from(i, (e) => n.toASN(e));
              s = new ("sequence" === e.repeated ? mu : yu)({ value: t });
            } else s = n.toASN(i);
          } else if (e.repeated) {
            if (!Array.isArray(i))
              throw new TypeError("Parameter 'objProp' should be type of Array.");
            const t = Array.from(i, (e) => this.toASN(e));
            s = new ("sequence" === e.repeated ? mu : yu)({ value: t });
          } else s = this.toASN(i);
          return s;
        }
      }
      class Bd extends Array {
        constructor(e = []) {
          if ("number" == typeof e) super(e);
          else {
            super();
            for (const t of e) this.push(t);
          }
        }
      }
      class Dd {
        static serialize(e) {
          return Rd.serialize(e);
        }
        static parse(e, t) {
          return kd.parse(e, t);
        }
        static toString(e) {
          const t = jh(
            Tl._H.isBufferSource(e) ? Tl._H.toArrayBuffer(e) : Dd.serialize(e)
          );
          if (-1 === t.offset)
            throw new Error(`Cannot decode ASN.1 data. ${t.result.error}`);
          return t.result.toString();
        }
      }
      function Od(e, t, r, i) {
        var s,
          n = arguments.length,
          a =
            n < 3
              ? t
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(t, r))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          a = Reflect.decorate(e, t, r, i);
        else
          for (var o = e.length - 1; o >= 0; o--)
            (s = e[o]) &&
              (a = (n < 3 ? s(a) : n > 3 ? s(t, r, a) : s(t, r)) || a);
        return n > 3 && a && Object.defineProperty(t, r, a), a;
      }
      Object.create;
      Object.create;
      "function" == typeof SuppressedError && SuppressedError;
      var Ld,
        Pd,
        Ud,
        Md = r(640);
      class Fd {
        static decodeIP(e) {
          if (64 === e.length && 0 === parseInt(e, 16)) return "::/0";
          if (16 !== e.length) return e;
          const t = parseInt(e.slice(8), 16)
            .toString(2)
            .split("")
            .reduce((e, t) => e + +t, 0);
          let r = e.slice(0, 8).replace(/(.{2})/g, (e) => `${parseInt(e, 16)}.`);
          return (r = r.slice(0, -1)), `${r}/${t}`;
        }
        static toString(e) {
          if (4 === e.byteLength || 16 === e.byteLength) {
            const t = new Uint8Array(e);
            return Md.fromByteArray(Array.from(t)).toString();
          }
          return this.decodeIP(Tl.U$.ToHex(e));
        }
        static fromString(e) {
          const t = Md.parse(e);
          return new Uint8Array(t.toByteArray()).buffer;
        }
      }
      let Hd = class {
        constructor(e = {}) {
          Object.assign(this, e);
        }
        toString() {
          return (
            this.bmpString ||
            this.printableString ||
            this.teletexString ||
            this.universalString ||
            this.utf8String ||
            ""
          );
        }
      };
      Od([xd({ type: zh.TeletexString })], Hd.prototype, "teletexString", void 0),
        Od(
          [xd({ type: zh.PrintableString })],
          Hd.prototype,
          "printableString",
          void 0
        ),
        Od(
          [xd({ type: zh.UniversalString })],
          Hd.prototype,
          "universalString",
          void 0
        ),
        Od([xd({ type: zh.Utf8String })], Hd.prototype, "utf8String", void 0),
        Od([xd({ type: zh.BmpString })], Hd.prototype, "bmpString", void 0),
        (Hd = Od([Cd({ type: Vh.Choice })], Hd));
      let Qd = class extends Hd {
        constructor(e = {}) {
          super(e), Object.assign(this, e);
        }
        toString() {
          return (
            this.ia5String ||
            (this.anyValue ? Tl.U$.ToHex(this.anyValue) : super.toString())
          );
        }
      };
      Od([xd({ type: zh.IA5String })], Qd.prototype, "ia5String", void 0),
        Od([xd({ type: zh.Any })], Qd.prototype, "anyValue", void 0),
        (Qd = Od([Cd({ type: Vh.Choice })], Qd));
      class Vd {
        constructor(e = {}) {
          (this.type = ""), (this.value = new Qd()), Object.assign(this, e);
        }
      }
      Od([xd({ type: zh.ObjectIdentifier })], Vd.prototype, "type", void 0),
        Od([xd({ type: Qd })], Vd.prototype, "value", void 0);
      let zd = (Ld = class extends Bd {
        constructor(e) {
          super(e), Object.setPrototypeOf(this, Ld.prototype);
        }
      });
      zd = Ld = Od([Cd({ type: Vh.Set, itemType: Vd })], zd);
      let qd = (Pd = class extends Bd {
        constructor(e) {
          super(e), Object.setPrototypeOf(this, Pd.prototype);
        }
      });
      qd = Pd = Od([Cd({ type: Vh.Sequence, itemType: zd })], qd);
      let Gd = (Ud = class extends qd {
        constructor(e) {
          super(e), Object.setPrototypeOf(this, Ud.prototype);
        }
      });
      Gd = Ud = Od([Cd({ type: Vh.Sequence })], Gd);
      const jd = {
        fromASN: (e) => Fd.toString(sd.fromASN(e)),
        toASN: (e) => sd.toASN(Fd.fromString(e)),
      };
      class Wd {
        constructor(e = {}) {
          (this.typeId = ""),
            (this.value = new ArrayBuffer(0)),
            Object.assign(this, e);
        }
      }
      Od([xd({ type: zh.ObjectIdentifier })], Wd.prototype, "typeId", void 0),
        Od([xd({ type: zh.Any, context: 0 })], Wd.prototype, "value", void 0);
      class Yd {
        constructor(e = {}) {
          (this.partyName = new Hd()), Object.assign(this, e);
        }
      }
      Od(
        [xd({ type: Hd, optional: !0, context: 0, implicit: !0 })],
        Yd.prototype,
        "nameAssigner",
        void 0
      ),
        Od(
          [xd({ type: Hd, context: 1, implicit: !0 })],
          Yd.prototype,
          "partyName",
          void 0
        );
      let Xd = class {
        constructor(e = {}) {
          Object.assign(this, e);
        }
      };
      var Kd;
      Od(
        [xd({ type: Wd, context: 0, implicit: !0 })],
        Xd.prototype,
        "otherName",
        void 0
      ),
        Od(
          [xd({ type: zh.IA5String, context: 1, implicit: !0 })],
          Xd.prototype,
          "rfc822Name",
          void 0
        ),
        Od(
          [xd({ type: zh.IA5String, context: 2, implicit: !0 })],
          Xd.prototype,
          "dNSName",
          void 0
        ),
        Od(
          [xd({ type: zh.Any, context: 3, implicit: !0 })],
          Xd.prototype,
          "x400Address",
          void 0
        ),
        Od(
          [xd({ type: Gd, context: 4, implicit: !1 })],
          Xd.prototype,
          "directoryName",
          void 0
        ),
        Od([xd({ type: Yd, context: 5 })], Xd.prototype, "ediPartyName", void 0),
        Od(
          [xd({ type: zh.IA5String, context: 6, implicit: !0 })],
          Xd.prototype,
          "uniformResourceIdentifier",
          void 0
        ),
        Od(
          [xd({ type: zh.OctetString, context: 7, implicit: !0, converter: jd })],
          Xd.prototype,
          "iPAddress",
          void 0
        ),
        Od(
          [xd({ type: zh.ObjectIdentifier, context: 8, implicit: !0 })],
          Xd.prototype,
          "registeredID",
          void 0
        ),
        (Xd = Od([Cd({ type: Vh.Choice })], Xd));
      class Jd {
        constructor(e = {}) {
          (this.accessMethod = ""),
            (this.accessLocation = new Xd()),
            Object.assign(this, e);
        }
      }
      Od(
        [xd({ type: zh.ObjectIdentifier })],
        Jd.prototype,
        "accessMethod",
        void 0
      ),
        Od([xd({ type: Xd })], Jd.prototype, "accessLocation", void 0);
      let Zd = (Kd = class extends Bd {
        constructor(e) {
          super(e), Object.setPrototypeOf(this, Kd.prototype);
        }
      });
      Zd = Kd = Od([Cd({ type: Vh.Sequence, itemType: Jd })], Zd);
      const $d = "1.3.6.1.5.5.7",
        ep = `${$d}.3`,
        tp = "2.5.29",
        rp = `${tp}.35`;
      class ip extends Ku {}
      class sp {
        constructor(e = {}) {
          e && Object.assign(this, e);
        }
      }
      Od(
        [xd({ type: ip, context: 0, optional: !0, implicit: !0 })],
        sp.prototype,
        "keyIdentifier",
        void 0
      ),
        Od(
          [
            xd({
              type: Xd,
              context: 1,
              optional: !0,
              implicit: !0,
              repeated: "sequence",
            }),
          ],
          sp.prototype,
          "authorityCertIssuer",
          void 0
        ),
        Od(
          [
            xd({
              type: zh.Integer,
              context: 2,
              optional: !0,
              implicit: !0,
              converter: ed,
            }),
          ],
          sp.prototype,
          "authorityCertSerialNumber",
          void 0
        );
      const np = `${tp}.19`;
      class ap {
        constructor(e = {}) {
          (this.cA = !1), Object.assign(this, e);
        }
      }
      var op;
      Od(
        [xd({ type: zh.Boolean, defaultValue: !1 })],
        ap.prototype,
        "cA",
        void 0
      ),
        Od(
          [xd({ type: zh.Integer, optional: !0 })],
          ap.prototype,
          "pathLenConstraint",
          void 0
        );
      let cp = (op = class extends Bd {
        constructor(e) {
          super(e), Object.setPrototypeOf(this, op.prototype);
        }
      });
      var lp;
      cp = op = Od([Cd({ type: Vh.Sequence, itemType: Xd })], cp);
      let hp = (lp = class extends cp {
        constructor(e) {
          super(e), Object.setPrototypeOf(this, lp.prototype);
        }
      });
      var up;
      hp = lp = Od([Cd({ type: Vh.Sequence })], hp);
      const dp = `${tp}.32`;
      let pp = class {
        constructor(e = {}) {
          Object.assign(this, e);
        }
        toString() {
          return (
            this.ia5String ||
            this.visibleString ||
            this.bmpString ||
            this.utf8String ||
            ""
          );
        }
      };
      Od([xd({ type: zh.IA5String })], pp.prototype, "ia5String", void 0),
        Od(
          [xd({ type: zh.VisibleString })],
          pp.prototype,
          "visibleString",
          void 0
        ),
        Od([xd({ type: zh.BmpString })], pp.prototype, "bmpString", void 0),
        Od([xd({ type: zh.Utf8String })], pp.prototype, "utf8String", void 0),
        (pp = Od([Cd({ type: Vh.Choice })], pp));
      class fp {
        constructor(e = {}) {
          (this.organization = new pp()),
            (this.noticeNumbers = []),
            Object.assign(this, e);
        }
      }
      Od([xd({ type: pp })], fp.prototype, "organization", void 0),
        Od(
          [xd({ type: zh.Integer, repeated: "sequence" })],
          fp.prototype,
          "noticeNumbers",
          void 0
        );
      class gp {
        constructor(e = {}) {
          Object.assign(this, e);
        }
      }
      Od([xd({ type: fp, optional: !0 })], gp.prototype, "noticeRef", void 0),
        Od(
          [xd({ type: pp, optional: !0 })],
          gp.prototype,
          "explicitText",
          void 0
        );
      let mp = class {
        constructor(e = {}) {
          Object.assign(this, e);
        }
      };
      Od([xd({ type: zh.IA5String })], mp.prototype, "cPSuri", void 0),
        Od([xd({ type: gp })], mp.prototype, "userNotice", void 0),
        (mp = Od([Cd({ type: Vh.Choice })], mp));
      class yp {
        constructor(e = {}) {
          (this.policyQualifierId = ""),
            (this.qualifier = new ArrayBuffer(0)),
            Object.assign(this, e);
        }
      }
      Od(
        [xd({ type: zh.ObjectIdentifier })],
        yp.prototype,
        "policyQualifierId",
        void 0
      ),
        Od([xd({ type: zh.Any })], yp.prototype, "qualifier", void 0);
      class Ap {
        constructor(e = {}) {
          (this.policyIdentifier = ""), Object.assign(this, e);
        }
      }
      Od(
        [xd({ type: zh.ObjectIdentifier })],
        Ap.prototype,
        "policyIdentifier",
        void 0
      ),
        Od(
          [xd({ type: yp, repeated: "sequence", optional: !0 })],
          Ap.prototype,
          "policyQualifiers",
          void 0
        );
      let wp = (up = class extends Bd {
        constructor(e) {
          super(e), Object.setPrototypeOf(this, up.prototype);
        }
      });
      wp = up = Od([Cd({ type: Vh.Sequence, itemType: Ap })], wp);
      let Ep = class {
        constructor(e = 0) {
          this.value = e;
        }
      };
      Od([xd({ type: zh.Integer })], Ep.prototype, "value", void 0),
        (Ep = Od([Cd({ type: Vh.Choice })], Ep));
      let bp = class extends Ep {};
      var vp;
      bp = Od([Cd({ type: Vh.Choice })], bp);
      var Ip;
      !(function (e) {
        (e[(e.unused = 1)] = "unused"),
          (e[(e.keyCompromise = 2)] = "keyCompromise"),
          (e[(e.cACompromise = 4)] = "cACompromise"),
          (e[(e.affiliationChanged = 8)] = "affiliationChanged"),
          (e[(e.superseded = 16)] = "superseded"),
          (e[(e.cessationOfOperation = 32)] = "cessationOfOperation"),
          (e[(e.certificateHold = 64)] = "certificateHold"),
          (e[(e.privilegeWithdrawn = 128)] = "privilegeWithdrawn"),
          (e[(e.aACompromise = 256)] = "aACompromise");
      })(Ip || (Ip = {}));
      class Sp extends Xu {
        toJSON() {
          const e = [],
            t = this.toNumber();
          return (
            t & Ip.aACompromise && e.push("aACompromise"),
            t & Ip.affiliationChanged && e.push("affiliationChanged"),
            t & Ip.cACompromise && e.push("cACompromise"),
            t & Ip.certificateHold && e.push("certificateHold"),
            t & Ip.cessationOfOperation && e.push("cessationOfOperation"),
            t & Ip.keyCompromise && e.push("keyCompromise"),
            t & Ip.privilegeWithdrawn && e.push("privilegeWithdrawn"),
            t & Ip.superseded && e.push("superseded"),
            t & Ip.unused && e.push("unused"),
            e
          );
        }
        toString() {
          return `[${this.toJSON().join(", ")}]`;
        }
      }
      let Tp = class {
        constructor(e = {}) {
          Object.assign(this, e);
        }
      };
      Od(
        [xd({ type: Xd, context: 0, repeated: "sequence", implicit: !0 })],
        Tp.prototype,
        "fullName",
        void 0
      ),
        Od(
          [xd({ type: zd, context: 1, implicit: !0 })],
          Tp.prototype,
          "nameRelativeToCRLIssuer",
          void 0
        ),
        (Tp = Od([Cd({ type: Vh.Choice })], Tp));
      class _p {
        constructor(e = {}) {
          Object.assign(this, e);
        }
      }
      Od(
        [xd({ type: Tp, context: 0, optional: !0 })],
        _p.prototype,
        "distributionPoint",
        void 0
      ),
        Od(
          [xd({ type: Sp, context: 1, optional: !0, implicit: !0 })],
          _p.prototype,
          "reasons",
          void 0
        ),
        Od(
          [
            xd({
              type: Xd,
              context: 2,
              optional: !0,
              repeated: "sequence",
              implicit: !0,
            }),
          ],
          _p.prototype,
          "cRLIssuer",
          void 0
        );
      let Cp = (vp = class extends Bd {
        constructor(e) {
          super(e), Object.setPrototypeOf(this, vp.prototype);
        }
      });
      var xp;
      Cp = vp = Od([Cd({ type: Vh.Sequence, itemType: _p })], Cp);
      let Np = (xp = class extends Cp {
        constructor(e) {
          super(e), Object.setPrototypeOf(this, xp.prototype);
        }
      });
      Np = xp = Od([Cd({ type: Vh.Sequence, itemType: _p })], Np);
      class kp {
        constructor(e = {}) {
          (this.onlyContainsUserCerts = kp.ONLY),
            (this.onlyContainsCACerts = kp.ONLY),
            (this.indirectCRL = kp.ONLY),
            (this.onlyContainsAttributeCerts = kp.ONLY),
            Object.assign(this, e);
        }
      }
      (kp.ONLY = !1),
        Od(
          [xd({ type: Tp, context: 0, optional: !0 })],
          kp.prototype,
          "distributionPoint",
          void 0
        ),
        Od(
          [
            xd({
              type: zh.Boolean,
              context: 1,
              defaultValue: kp.ONLY,
              implicit: !0,
            }),
          ],
          kp.prototype,
          "onlyContainsUserCerts",
          void 0
        ),
        Od(
          [
            xd({
              type: zh.Boolean,
              context: 2,
              defaultValue: kp.ONLY,
              implicit: !0,
            }),
          ],
          kp.prototype,
          "onlyContainsCACerts",
          void 0
        ),
        Od(
          [xd({ type: Sp, context: 3, optional: !0, implicit: !0 })],
          kp.prototype,
          "onlySomeReasons",
          void 0
        ),
        Od(
          [
            xd({
              type: zh.Boolean,
              context: 4,
              defaultValue: kp.ONLY,
              implicit: !0,
            }),
          ],
          kp.prototype,
          "indirectCRL",
          void 0
        ),
        Od(
          [
            xd({
              type: zh.Boolean,
              context: 5,
              defaultValue: kp.ONLY,
              implicit: !0,
            }),
          ],
          kp.prototype,
          "onlyContainsAttributeCerts",
          void 0
        );
      var Rp;
      !(function (e) {
        (e[(e.unspecified = 0)] = "unspecified"),
          (e[(e.keyCompromise = 1)] = "keyCompromise"),
          (e[(e.cACompromise = 2)] = "cACompromise"),
          (e[(e.affiliationChanged = 3)] = "affiliationChanged"),
          (e[(e.superseded = 4)] = "superseded"),
          (e[(e.cessationOfOperation = 5)] = "cessationOfOperation"),
          (e[(e.certificateHold = 6)] = "certificateHold"),
          (e[(e.removeFromCRL = 8)] = "removeFromCRL"),
          (e[(e.privilegeWithdrawn = 9)] = "privilegeWithdrawn"),
          (e[(e.aACompromise = 10)] = "aACompromise");
      })(Rp || (Rp = {}));
      let Bp = class {
        constructor(e = Rp.unspecified) {
          (this.reason = Rp.unspecified), (this.reason = e);
        }
        toJSON() {
          return Rp[this.reason];
        }
        toString() {
          return this.toJSON();
        }
      };
      var Dp;
      Od([xd({ type: zh.Enumerated })], Bp.prototype, "reason", void 0),
        (Bp = Od([Cd({ type: Vh.Choice })], Bp));
      const Op = `${tp}.37`;
      let Lp = (Dp = class extends Bd {
        constructor(e) {
          super(e), Object.setPrototypeOf(this, Dp.prototype);
        }
      });
      Lp = Dp = Od(
        [Cd({ type: Vh.Sequence, itemType: zh.ObjectIdentifier })],
        Lp
      );
      const Pp = `${ep}.1`,
        Up = `${ep}.2`,
        Mp = `${ep}.3`,
        Fp = `${ep}.4`,
        Hp = `${ep}.8`,
        Qp = `${ep}.9`;
      let Vp = class {
        constructor(e = new ArrayBuffer(0)) {
          this.value = e;
        }
      };
      Od(
        [xd({ type: zh.Integer, converter: ed })],
        Vp.prototype,
        "value",
        void 0
      ),
        (Vp = Od([Cd({ type: Vh.Choice })], Vp));
      let zp = class {
        constructor(e) {
          (this.value = new Date()), e && (this.value = e);
        }
      };
      var qp;
      Od([xd({ type: zh.GeneralizedTime })], zp.prototype, "value", void 0),
        (zp = Od([Cd({ type: Vh.Choice })], zp));
      let Gp = (qp = class extends cp {
        constructor(e) {
          super(e), Object.setPrototypeOf(this, qp.prototype);
        }
      });
      Gp = qp = Od([Cd({ type: Vh.Sequence })], Gp);
      const jp = `${tp}.15`;
      var Wp, Yp;
      !(function (e) {
        (e[(e.digitalSignature = 1)] = "digitalSignature"),
          (e[(e.nonRepudiation = 2)] = "nonRepudiation"),
          (e[(e.keyEncipherment = 4)] = "keyEncipherment"),
          (e[(e.dataEncipherment = 8)] = "dataEncipherment"),
          (e[(e.keyAgreement = 16)] = "keyAgreement"),
          (e[(e.keyCertSign = 32)] = "keyCertSign"),
          (e[(e.cRLSign = 64)] = "cRLSign"),
          (e[(e.encipherOnly = 128)] = "encipherOnly"),
          (e[(e.decipherOnly = 256)] = "decipherOnly");
      })(Wp || (Wp = {}));
      class Xp extends Xu {
        toJSON() {
          const e = this.toNumber(),
            t = [];
          return (
            e & Wp.cRLSign && t.push("crlSign"),
            e & Wp.dataEncipherment && t.push("dataEncipherment"),
            e & Wp.decipherOnly && t.push("decipherOnly"),
            e & Wp.digitalSignature && t.push("digitalSignature"),
            e & Wp.encipherOnly && t.push("encipherOnly"),
            e & Wp.keyAgreement && t.push("keyAgreement"),
            e & Wp.keyCertSign && t.push("keyCertSign"),
            e & Wp.keyEncipherment && t.push("keyEncipherment"),
            e & Wp.nonRepudiation && t.push("nonRepudiation"),
            t
          );
        }
        toString() {
          return `[${this.toJSON().join(", ")}]`;
        }
      }
      class Kp {
        constructor(e = {}) {
          (this.base = new Xd()), (this.minimum = 0), Object.assign(this, e);
        }
      }
      Od([xd({ type: Xd })], Kp.prototype, "base", void 0),
        Od(
          [xd({ type: zh.Integer, context: 0, defaultValue: 0, implicit: !0 })],
          Kp.prototype,
          "minimum",
          void 0
        ),
        Od(
          [xd({ type: zh.Integer, context: 1, optional: !0, implicit: !0 })],
          Kp.prototype,
          "maximum",
          void 0
        );
      let Jp = (Yp = class extends Bd {
        constructor(e) {
          super(e), Object.setPrototypeOf(this, Yp.prototype);
        }
      });
      Jp = Yp = Od([Cd({ type: Vh.Sequence, itemType: Kp })], Jp);
      class Zp {
        constructor(e = {}) {
          Object.assign(this, e);
        }
      }
      Od(
        [xd({ type: Jp, context: 0, optional: !0, implicit: !0 })],
        Zp.prototype,
        "permittedSubtrees",
        void 0
      ),
        Od(
          [xd({ type: Jp, context: 1, optional: !0, implicit: !0 })],
          Zp.prototype,
          "excludedSubtrees",
          void 0
        );
      class $p {
        constructor(e = {}) {
          Object.assign(this, e);
        }
      }
      var ef;
      Od(
        [
          xd({
            type: zh.Integer,
            context: 0,
            implicit: !0,
            optional: !0,
            converter: ed,
          }),
        ],
        $p.prototype,
        "requireExplicitPolicy",
        void 0
      ),
        Od(
          [
            xd({
              type: zh.Integer,
              context: 1,
              implicit: !0,
              optional: !0,
              converter: ed,
            }),
          ],
          $p.prototype,
          "inhibitPolicyMapping",
          void 0
        );
      class tf {
        constructor(e = {}) {
          (this.issuerDomainPolicy = ""),
            (this.subjectDomainPolicy = ""),
            Object.assign(this, e);
        }
      }
      Od(
        [xd({ type: zh.ObjectIdentifier })],
        tf.prototype,
        "issuerDomainPolicy",
        void 0
      ),
        Od(
          [xd({ type: zh.ObjectIdentifier })],
          tf.prototype,
          "subjectDomainPolicy",
          void 0
        );
      let rf = (ef = class extends Bd {
        constructor(e) {
          super(e), Object.setPrototypeOf(this, ef.prototype);
        }
      });
      var sf;
      rf = ef = Od([Cd({ type: Vh.Sequence, itemType: tf })], rf);
      const nf = `${tp}.17`;
      let af = (sf = class extends cp {
        constructor(e) {
          super(e), Object.setPrototypeOf(this, sf.prototype);
        }
      });
      af = sf = Od([Cd({ type: Vh.Sequence })], af);
      class of {
        constructor(e = {}) {
          (this.type = ""), (this.values = []), Object.assign(this, e);
        }
      }
      var cf;
      Od([xd({ type: zh.ObjectIdentifier })], of.prototype, "type", void 0),
        Od(
          [xd({ type: zh.Any, repeated: "set" })],
          of.prototype,
          "values",
          void 0
        );
      let lf = (cf = class extends Bd {
        constructor(e) {
          super(e), Object.setPrototypeOf(this, cf.prototype);
        }
      });
      lf = cf = Od([Cd({ type: Vh.Sequence, itemType: of })], lf);
      const hf = `${tp}.14`;
      class uf extends ip {}
      class df {
        constructor(e = {}) {
          Object.assign(this, e);
        }
      }
      Od(
        [
          xd({
            type: zh.GeneralizedTime,
            context: 0,
            implicit: !0,
            optional: !0,
          }),
        ],
        df.prototype,
        "notBefore",
        void 0
      ),
        Od(
          [
            xd({
              type: zh.GeneralizedTime,
              context: 1,
              implicit: !0,
              optional: !0,
            }),
          ],
          df.prototype,
          "notAfter",
          void 0
        );
      var pf, ff;
      !(function (e) {
        (e[(e.keyUpdateAllowed = 1)] = "keyUpdateAllowed"),
          (e[(e.newExtensions = 2)] = "newExtensions"),
          (e[(e.pKIXCertificate = 4)] = "pKIXCertificate");
      })(pf || (pf = {}));
      class gf extends Xu {
        toJSON() {
          const e = [],
            t = this.toNumber();
          return (
            t & pf.pKIXCertificate && e.push("pKIXCertificate"),
            t & pf.newExtensions && e.push("newExtensions"),
            t & pf.keyUpdateAllowed && e.push("keyUpdateAllowed"),
            e
          );
        }
        toString() {
          return `[${this.toJSON().join(", ")}]`;
        }
      }
      class mf {
        constructor(e = {}) {
          (this.entrustVers = ""),
            (this.entrustInfoFlags = new gf()),
            Object.assign(this, e);
        }
      }
      Od([xd({ type: zh.GeneralString })], mf.prototype, "entrustVers", void 0),
        Od([xd({ type: gf })], mf.prototype, "entrustInfoFlags", void 0);
      let yf = (ff = class extends Bd {
        constructor(e) {
          super(e), Object.setPrototypeOf(this, ff.prototype);
        }
      });
      yf = ff = Od([Cd({ type: Vh.Sequence, itemType: Jd })], yf);
      class Af {
        constructor(e = {}) {
          (this.algorithm = ""), Object.assign(this, e);
        }
        isEqual(e) {
          return (
            e instanceof Af &&
            e.algorithm == this.algorithm &&
            ((e.parameters &&
              this.parameters &&
              Tl.n4(e.parameters, this.parameters)) ||
              e.parameters === this.parameters)
          );
        }
      }
      Od([xd({ type: zh.ObjectIdentifier })], Af.prototype, "algorithm", void 0),
        Od(
          [xd({ type: zh.Any, optional: !0 })],
          Af.prototype,
          "parameters",
          void 0
        );
      class wf {
        constructor(e = {}) {
          (this.algorithm = new Af()),
            (this.subjectPublicKey = new ArrayBuffer(0)),
            Object.assign(this, e);
        }
      }
      Od([xd({ type: Af })], wf.prototype, "algorithm", void 0),
        Od(
          [xd({ type: zh.BitString })],
          wf.prototype,
          "subjectPublicKey",
          void 0
        );
      let Ef = class {
        constructor(e) {
          if (e)
            if (
              "string" == typeof e ||
              "number" == typeof e ||
              e instanceof Date
            ) {
              const t = new Date(e);
              t.getUTCFullYear() > 2049
                ? (this.generalTime = t)
                : (this.utcTime = t);
            } else Object.assign(this, e);
        }
        getTime() {
          const e = this.utcTime || this.generalTime;
          if (!e) throw new Error("Cannot get time from CHOICE object");
          return e;
        }
      };
      Od([xd({ type: zh.UTCTime })], Ef.prototype, "utcTime", void 0),
        Od(
          [xd({ type: zh.GeneralizedTime })],
          Ef.prototype,
          "generalTime",
          void 0
        ),
        (Ef = Od([Cd({ type: Vh.Choice })], Ef));
      class bf {
        constructor(e) {
          (this.notBefore = new Ef(new Date())),
            (this.notAfter = new Ef(new Date())),
            e &&
              ((this.notBefore = new Ef(e.notBefore)),
              (this.notAfter = new Ef(e.notAfter)));
        }
      }
      var vf;
      Od([xd({ type: Ef })], bf.prototype, "notBefore", void 0),
        Od([xd({ type: Ef })], bf.prototype, "notAfter", void 0);
      class If {
        constructor(e = {}) {
          (this.extnID = ""),
            (this.critical = If.CRITICAL),
            (this.extnValue = new Ku()),
            Object.assign(this, e);
        }
      }
      (If.CRITICAL = !1),
        Od([xd({ type: zh.ObjectIdentifier })], If.prototype, "extnID", void 0),
        Od(
          [xd({ type: zh.Boolean, defaultValue: If.CRITICAL })],
          If.prototype,
          "critical",
          void 0
        ),
        Od([xd({ type: Ku })], If.prototype, "extnValue", void 0);
      let Sf = (vf = class extends Bd {
        constructor(e) {
          super(e), Object.setPrototypeOf(this, vf.prototype);
        }
      });
      var Tf;
      (Sf = vf = Od([Cd({ type: Vh.Sequence, itemType: If })], Sf)),
        (function (e) {
          (e[(e.v1 = 0)] = "v1"), (e[(e.v2 = 1)] = "v2"), (e[(e.v3 = 2)] = "v3");
        })(Tf || (Tf = {}));
      class _f {
        constructor(e = {}) {
          (this.version = Tf.v1),
            (this.serialNumber = new ArrayBuffer(0)),
            (this.signature = new Af()),
            (this.issuer = new Gd()),
            (this.validity = new bf()),
            (this.subject = new Gd()),
            (this.subjectPublicKeyInfo = new wf()),
            Object.assign(this, e);
        }
      }
      Od(
        [xd({ type: zh.Integer, context: 0, defaultValue: Tf.v1 })],
        _f.prototype,
        "version",
        void 0
      ),
        Od(
          [xd({ type: zh.Integer, converter: ed })],
          _f.prototype,
          "serialNumber",
          void 0
        ),
        Od([xd({ type: Af })], _f.prototype, "signature", void 0),
        Od([xd({ type: Gd })], _f.prototype, "issuer", void 0),
        Od([xd({ type: bf })], _f.prototype, "validity", void 0),
        Od([xd({ type: Gd })], _f.prototype, "subject", void 0),
        Od([xd({ type: wf })], _f.prototype, "subjectPublicKeyInfo", void 0),
        Od(
          [xd({ type: zh.BitString, context: 1, implicit: !0, optional: !0 })],
          _f.prototype,
          "issuerUniqueID",
          void 0
        ),
        Od(
          [xd({ type: zh.BitString, context: 2, implicit: !0, optional: !0 })],
          _f.prototype,
          "subjectUniqueID",
          void 0
        ),
        Od(
          [xd({ type: Sf, context: 3, optional: !0 })],
          _f.prototype,
          "extensions",
          void 0
        );
      class Cf {
        constructor(e = {}) {
          (this.tbsCertificate = new _f()),
            (this.signatureAlgorithm = new Af()),
            (this.signatureValue = new ArrayBuffer(0)),
            Object.assign(this, e);
        }
      }
      Od([xd({ type: _f })], Cf.prototype, "tbsCertificate", void 0),
        Od([xd({ type: Af })], Cf.prototype, "signatureAlgorithm", void 0),
        Od([xd({ type: zh.BitString })], Cf.prototype, "signatureValue", void 0);
      class xf {
        constructor(e = {}) {
          (this.userCertificate = new ArrayBuffer(0)),
            (this.revocationDate = new Ef()),
            Object.assign(this, e);
        }
      }
      Od(
        [xd({ type: zh.Integer, converter: ed })],
        xf.prototype,
        "userCertificate",
        void 0
      ),
        Od([xd({ type: Ef })], xf.prototype, "revocationDate", void 0),
        Od(
          [xd({ type: If, optional: !0, repeated: "sequence" })],
          xf.prototype,
          "crlEntryExtensions",
          void 0
        );
      class Nf {
        constructor(e = {}) {
          (this.signature = new Af()),
            (this.issuer = new Gd()),
            (this.thisUpdate = new Ef()),
            Object.assign(this, e);
        }
      }
      Od(
        [xd({ type: zh.Integer, optional: !0 })],
        Nf.prototype,
        "version",
        void 0
      ),
        Od([xd({ type: Af })], Nf.prototype, "signature", void 0),
        Od([xd({ type: Gd })], Nf.prototype, "issuer", void 0),
        Od([xd({ type: Ef })], Nf.prototype, "thisUpdate", void 0),
        Od([xd({ type: Ef, optional: !0 })], Nf.prototype, "nextUpdate", void 0),
        Od(
          [xd({ type: xf, repeated: "sequence", optional: !0 })],
          Nf.prototype,
          "revokedCertificates",
          void 0
        ),
        Od(
          [xd({ type: If, optional: !0, context: 0, repeated: "sequence" })],
          Nf.prototype,
          "crlExtensions",
          void 0
        );
      class kf {
        constructor(e = {}) {
          (this.tbsCertList = new Nf()),
            (this.signatureAlgorithm = new Af()),
            (this.signature = new ArrayBuffer(0)),
            Object.assign(this, e);
        }
      }
      Od([xd({ type: Nf })], kf.prototype, "tbsCertList", void 0),
        Od([xd({ type: Af })], kf.prototype, "signatureAlgorithm", void 0),
        Od([xd({ type: zh.BitString })], kf.prototype, "signature", void 0);
      class Rf {
        constructor(e = {}) {
          (this.issuer = new Gd()),
            (this.serialNumber = new ArrayBuffer(0)),
            Object.assign(this, e);
        }
      }
      Od([xd({ type: Gd })], Rf.prototype, "issuer", void 0),
        Od(
          [xd({ type: zh.Integer, converter: ed })],
          Rf.prototype,
          "serialNumber",
          void 0
        );
      let Bf = class {
        constructor(e = {}) {
          Object.assign(this, e);
        }
      };
      var Df;
      Od(
        [xd({ type: uf, context: 0, implicit: !0 })],
        Bf.prototype,
        "subjectKeyIdentifier",
        void 0
      ),
        Od([xd({ type: Rf })], Bf.prototype, "issuerAndSerialNumber", void 0),
        (Bf = Od([Cd({ type: Vh.Choice })], Bf)),
        (function (e) {
          (e[(e.v0 = 0)] = "v0"),
            (e[(e.v1 = 1)] = "v1"),
            (e[(e.v2 = 2)] = "v2"),
            (e[(e.v3 = 3)] = "v3"),
            (e[(e.v4 = 4)] = "v4"),
            (e[(e.v5 = 5)] = "v5");
        })(Df || (Df = {}));
      let Of = class extends Af {};
      Of = Od([Cd({ type: Vh.Sequence })], Of);
      let Lf = class extends Af {};
      Lf = Od([Cd({ type: Vh.Sequence })], Lf);
      let Pf = class extends Af {};
      Pf = Od([Cd({ type: Vh.Sequence })], Pf);
      let Uf = class extends Af {};
      Uf = Od([Cd({ type: Vh.Sequence })], Uf);
      let Mf = class extends Af {};
      Mf = Od([Cd({ type: Vh.Sequence })], Mf);
      let Ff = class extends Af {};
      Ff = Od([Cd({ type: Vh.Sequence })], Ff);
      class Hf {
        constructor(e = {}) {
          (this.attrType = ""), (this.attrValues = []), Object.assign(this, e);
        }
      }
      var Qf;
      Od([xd({ type: zh.ObjectIdentifier })], Hf.prototype, "attrType", void 0),
        Od(
          [xd({ type: zh.Any, repeated: "set" })],
          Hf.prototype,
          "attrValues",
          void 0
        );
      class Vf {
        constructor(e = {}) {
          (this.version = Df.v0),
            (this.sid = new Bf()),
            (this.digestAlgorithm = new Of()),
            (this.signatureAlgorithm = new Lf()),
            (this.signature = new Ku()),
            Object.assign(this, e);
        }
      }
      Od([xd({ type: zh.Integer })], Vf.prototype, "version", void 0),
        Od([xd({ type: Bf })], Vf.prototype, "sid", void 0),
        Od([xd({ type: Of })], Vf.prototype, "digestAlgorithm", void 0),
        Od(
          [
            xd({
              type: Hf,
              repeated: "set",
              context: 0,
              implicit: !0,
              optional: !0,
            }),
          ],
          Vf.prototype,
          "signedAttrs",
          void 0
        ),
        Od([xd({ type: Lf })], Vf.prototype, "signatureAlgorithm", void 0),
        Od([xd({ type: Ku })], Vf.prototype, "signature", void 0),
        Od(
          [
            xd({
              type: Hf,
              repeated: "set",
              context: 1,
              implicit: !0,
              optional: !0,
            }),
          ],
          Vf.prototype,
          "unsignedAttrs",
          void 0
        );
      let zf = (Qf = class extends Bd {
        constructor(e) {
          super(e), Object.setPrototypeOf(this, Qf.prototype);
        }
      });
      zf = Qf = Od([Cd({ type: Vh.Set, itemType: Vf })], zf);
      let qf = class extends Ef {};
      qf = Od([Cd({ type: Vh.Choice })], qf);
      let Gf = class extends Vf {};
      Gf = Od([Cd({ type: Vh.Sequence })], Gf);
      class jf {
        constructor(e = {}) {
          (this.acIssuer = new Xd()),
            (this.acSerial = 0),
            (this.attrs = []),
            Object.assign(this, e);
        }
      }
      var Wf;
      Od([xd({ type: Xd })], jf.prototype, "acIssuer", void 0),
        Od([xd({ type: zh.Integer })], jf.prototype, "acSerial", void 0),
        Od(
          [xd({ type: of, repeated: "sequence" })],
          jf.prototype,
          "attrs",
          void 0
        );
      let Yf = (Wf = class extends Bd {
        constructor(e) {
          super(e), Object.setPrototypeOf(this, Wf.prototype);
        }
      });
      Yf = Wf = Od(
        [Cd({ type: Vh.Sequence, itemType: zh.ObjectIdentifier })],
        Yf
      );
      class Xf {
        constructor(e = {}) {
          (this.permitUnSpecified = !0), Object.assign(this, e);
        }
      }
      Od(
        [xd({ type: zh.Integer, optional: !0 })],
        Xf.prototype,
        "pathLenConstraint",
        void 0
      ),
        Od(
          [xd({ type: Yf, implicit: !0, context: 0, optional: !0 })],
          Xf.prototype,
          "permittedAttrs",
          void 0
        ),
        Od(
          [xd({ type: Yf, implicit: !0, context: 1, optional: !0 })],
          Xf.prototype,
          "excludedAttrs",
          void 0
        ),
        Od(
          [xd({ type: zh.Boolean, defaultValue: !0 })],
          Xf.prototype,
          "permitUnSpecified",
          void 0
        );
      class Kf {
        constructor(e = {}) {
          (this.issuer = new cp()),
            (this.serial = new ArrayBuffer(0)),
            (this.issuerUID = new ArrayBuffer(0)),
            Object.assign(this, e);
        }
      }
      var Jf;
      Od([xd({ type: cp })], Kf.prototype, "issuer", void 0),
        Od(
          [xd({ type: zh.Integer, converter: ed })],
          Kf.prototype,
          "serial",
          void 0
        ),
        Od(
          [xd({ type: zh.BitString, optional: !0 })],
          Kf.prototype,
          "issuerUID",
          void 0
        ),
        (function (e) {
          (e[(e.publicKey = 0)] = "publicKey"),
            (e[(e.publicKeyCert = 1)] = "publicKeyCert"),
            (e[(e.otherObjectTypes = 2)] = "otherObjectTypes");
        })(Jf || (Jf = {}));
      class Zf {
        constructor(e = {}) {
          (this.digestedObjectType = Jf.publicKey),
            (this.digestAlgorithm = new Af()),
            (this.objectDigest = new ArrayBuffer(0)),
            Object.assign(this, e);
        }
      }
      Od(
        [xd({ type: zh.Enumerated })],
        Zf.prototype,
        "digestedObjectType",
        void 0
      ),
        Od(
          [xd({ type: zh.ObjectIdentifier, optional: !0 })],
          Zf.prototype,
          "otherObjectTypeID",
          void 0
        ),
        Od([xd({ type: Af })], Zf.prototype, "digestAlgorithm", void 0),
        Od([xd({ type: zh.BitString })], Zf.prototype, "objectDigest", void 0);
      class $f {
        constructor(e = {}) {
          Object.assign(this, e);
        }
      }
      Od([xd({ type: cp, optional: !0 })], $f.prototype, "issuerName", void 0),
        Od(
          [xd({ type: Kf, context: 0, implicit: !0, optional: !0 })],
          $f.prototype,
          "baseCertificateID",
          void 0
        ),
        Od(
          [xd({ type: Zf, context: 1, implicit: !0, optional: !0 })],
          $f.prototype,
          "objectDigestInfo",
          void 0
        );
      let eg = class {
        constructor(e = {}) {
          Object.assign(this, e);
        }
      };
      Od(
        [xd({ type: Xd, repeated: "sequence" })],
        eg.prototype,
        "v1Form",
        void 0
      ),
        Od(
          [xd({ type: $f, context: 0, implicit: !0 })],
          eg.prototype,
          "v2Form",
          void 0
        ),
        (eg = Od([Cd({ type: Vh.Choice })], eg));
      class tg {
        constructor(e = {}) {
          (this.notBeforeTime = new Date()),
            (this.notAfterTime = new Date()),
            Object.assign(this, e);
        }
      }
      Od(
        [xd({ type: zh.GeneralizedTime })],
        tg.prototype,
        "notBeforeTime",
        void 0
      ),
        Od(
          [xd({ type: zh.GeneralizedTime })],
          tg.prototype,
          "notAfterTime",
          void 0
        );
      class rg {
        constructor(e = {}) {
          Object.assign(this, e);
        }
      }
      var ig, sg;
      Od(
        [xd({ type: Kf, implicit: !0, context: 0, optional: !0 })],
        rg.prototype,
        "baseCertificateID",
        void 0
      ),
        Od(
          [xd({ type: cp, implicit: !0, context: 1, optional: !0 })],
          rg.prototype,
          "entityName",
          void 0
        ),
        Od(
          [xd({ type: Zf, implicit: !0, context: 2, optional: !0 })],
          rg.prototype,
          "objectDigestInfo",
          void 0
        ),
        (function (e) {
          e[(e.v2 = 1)] = "v2";
        })(ig || (ig = {}));
      class ng {
        constructor(e = {}) {
          (this.version = ig.v2),
            (this.holder = new rg()),
            (this.issuer = new eg()),
            (this.signature = new Af()),
            (this.serialNumber = new ArrayBuffer(0)),
            (this.attrCertValidityPeriod = new tg()),
            (this.attributes = []),
            Object.assign(this, e);
        }
      }
      Od([xd({ type: zh.Integer })], ng.prototype, "version", void 0),
        Od([xd({ type: rg })], ng.prototype, "holder", void 0),
        Od([xd({ type: eg })], ng.prototype, "issuer", void 0),
        Od([xd({ type: Af })], ng.prototype, "signature", void 0),
        Od(
          [xd({ type: zh.Integer, converter: ed })],
          ng.prototype,
          "serialNumber",
          void 0
        ),
        Od([xd({ type: tg })], ng.prototype, "attrCertValidityPeriod", void 0),
        Od(
          [xd({ type: of, repeated: "sequence" })],
          ng.prototype,
          "attributes",
          void 0
        ),
        Od(
          [xd({ type: zh.BitString, optional: !0 })],
          ng.prototype,
          "issuerUniqueID",
          void 0
        ),
        Od([xd({ type: Sf, optional: !0 })], ng.prototype, "extensions", void 0);
      class ag {
        constructor(e = {}) {
          (this.acinfo = new ng()),
            (this.signatureAlgorithm = new Af()),
            (this.signatureValue = new ArrayBuffer(0)),
            Object.assign(this, e);
        }
      }
      Od([xd({ type: ng })], ag.prototype, "acinfo", void 0),
        Od([xd({ type: Af })], ag.prototype, "signatureAlgorithm", void 0),
        Od([xd({ type: zh.BitString })], ag.prototype, "signatureValue", void 0),
        (function (e) {
          (e[(e.unmarked = 1)] = "unmarked"),
            (e[(e.unclassified = 2)] = "unclassified"),
            (e[(e.restricted = 4)] = "restricted"),
            (e[(e.confidential = 8)] = "confidential"),
            (e[(e.secret = 16)] = "secret"),
            (e[(e.topSecret = 32)] = "topSecret");
        })(sg || (sg = {}));
      class og extends Xu {}
      class cg {
        constructor(e = {}) {
          (this.type = ""),
            (this.value = new ArrayBuffer(0)),
            Object.assign(this, e);
        }
      }
      Od(
        [xd({ type: zh.ObjectIdentifier, implicit: !0, context: 0 })],
        cg.prototype,
        "type",
        void 0
      ),
        Od(
          [xd({ type: zh.Any, implicit: !0, context: 1 })],
          cg.prototype,
          "value",
          void 0
        );
      class lg {
        constructor(e = {}) {
          (this.policyId = ""),
            (this.classList = new og(sg.unclassified)),
            Object.assign(this, e);
        }
      }
      Od([xd({ type: zh.ObjectIdentifier })], lg.prototype, "policyId", void 0),
        Od(
          [xd({ type: og, defaultValue: new og(sg.unclassified) })],
          lg.prototype,
          "classList",
          void 0
        ),
        Od(
          [xd({ type: cg, repeated: "set" })],
          lg.prototype,
          "securityCategories",
          void 0
        );
      class hg {
        constructor(e = {}) {
          Object.assign(this, e);
        }
      }
      Od([xd({ type: Ku })], hg.prototype, "cotets", void 0),
        Od([xd({ type: zh.ObjectIdentifier })], hg.prototype, "oid", void 0),
        Od([xd({ type: zh.Utf8String })], hg.prototype, "string", void 0);
      class ug {
        constructor(e = {}) {
          (this.values = []), Object.assign(this, e);
        }
      }
      Od(
        [xd({ type: cp, implicit: !0, context: 0, optional: !0 })],
        ug.prototype,
        "policyAuthority",
        void 0
      ),
        Od(
          [xd({ type: hg, repeated: "sequence" })],
          ug.prototype,
          "values",
          void 0
        );
      var dg;
      class pg {
        constructor(e = {}) {
          (this.targetCertificate = new Kf()), Object.assign(this, e);
        }
      }
      Od([xd({ type: Kf })], pg.prototype, "targetCertificate", void 0),
        Od([xd({ type: Xd, optional: !0 })], pg.prototype, "targetName", void 0),
        Od(
          [xd({ type: Zf, optional: !0 })],
          pg.prototype,
          "certDigestInfo",
          void 0
        );
      let fg = class {
        constructor(e = {}) {
          Object.assign(this, e);
        }
      };
      Od(
        [xd({ type: Xd, context: 0, implicit: !0 })],
        fg.prototype,
        "targetName",
        void 0
      ),
        Od(
          [xd({ type: Xd, context: 1, implicit: !0 })],
          fg.prototype,
          "targetGroup",
          void 0
        ),
        Od(
          [xd({ type: pg, context: 2, implicit: !0 })],
          fg.prototype,
          "targetCert",
          void 0
        ),
        (fg = Od([Cd({ type: Vh.Choice })], fg));
      let gg = (dg = class extends Bd {
        constructor(e) {
          super(e), Object.setPrototypeOf(this, dg.prototype);
        }
      });
      var mg;
      gg = dg = Od([Cd({ type: Vh.Sequence, itemType: fg })], gg);
      let yg = (mg = class extends Bd {
        constructor(e) {
          super(e), Object.setPrototypeOf(this, mg.prototype);
        }
      });
      yg = mg = Od([Cd({ type: Vh.Sequence, itemType: gg })], yg);
      class Ag {
        constructor(e = {}) {
          Object.assign(this, e);
        }
      }
      Od(
        [xd({ type: cp, implicit: !0, context: 0, optional: !0 })],
        Ag.prototype,
        "roleAuthority",
        void 0
      ),
        Od(
          [xd({ type: Xd, implicit: !0, context: 1 })],
          Ag.prototype,
          "roleName",
          void 0
        );
      class wg {
        constructor(e = {}) {
          (this.service = new Xd()),
            (this.ident = new Xd()),
            Object.assign(this, e);
        }
      }
      var Eg;
      Od([xd({ type: Xd })], wg.prototype, "service", void 0),
        Od([xd({ type: Xd })], wg.prototype, "ident", void 0),
        Od([xd({ type: Ku, optional: !0 })], wg.prototype, "authInfo", void 0);
      class bg {
        constructor(e = {}) {
          (this.otherCertFormat = ""),
            (this.otherCert = new ArrayBuffer(0)),
            Object.assign(this, e);
        }
      }
      Od(
        [xd({ type: zh.ObjectIdentifier })],
        bg.prototype,
        "otherCertFormat",
        void 0
      ),
        Od([xd({ type: zh.Any })], bg.prototype, "otherCert", void 0);
      let vg = class {
        constructor(e = {}) {
          Object.assign(this, e);
        }
      };
      Od([xd({ type: Cf })], vg.prototype, "certificate", void 0),
        Od(
          [xd({ type: ag, context: 2, implicit: !0 })],
          vg.prototype,
          "v2AttrCert",
          void 0
        ),
        Od(
          [xd({ type: bg, context: 3, implicit: !0 })],
          vg.prototype,
          "other",
          void 0
        ),
        (vg = Od([Cd({ type: Vh.Choice })], vg));
      let Ig = (Eg = class extends Bd {
        constructor(e) {
          super(e), Object.setPrototypeOf(this, Eg.prototype);
        }
      });
      Ig = Eg = Od([Cd({ type: Vh.Set, itemType: vg })], Ig);
      class Sg {
        constructor(e = {}) {
          (this.contentType = ""),
            (this.content = new ArrayBuffer(0)),
            Object.assign(this, e);
        }
      }
      Od(
        [xd({ type: zh.ObjectIdentifier })],
        Sg.prototype,
        "contentType",
        void 0
      ),
        Od([xd({ type: zh.Any, context: 0 })], Sg.prototype, "content", void 0);
      let Tg = class {
        constructor(e = {}) {
          Object.assign(this, e);
        }
      };
      Od([xd({ type: Ku })], Tg.prototype, "single", void 0),
        Od([xd({ type: zh.Any })], Tg.prototype, "any", void 0),
        (Tg = Od([Cd({ type: Vh.Choice })], Tg));
      class _g {
        constructor(e = {}) {
          (this.eContentType = ""), Object.assign(this, e);
        }
      }
      Od(
        [xd({ type: zh.ObjectIdentifier })],
        _g.prototype,
        "eContentType",
        void 0
      ),
        Od(
          [xd({ type: Tg, context: 0, optional: !0 })],
          _g.prototype,
          "eContent",
          void 0
        );
      let Cg = class {
        constructor(e = {}) {
          Object.assign(this, e);
        }
      };
      Od(
        [xd({ type: Ku, context: 0, implicit: !0, optional: !0 })],
        Cg.prototype,
        "value",
        void 0
      ),
        Od(
          [
            xd({
              type: Ku,
              converter: nd,
              context: 0,
              implicit: !0,
              optional: !0,
              repeated: "sequence",
            }),
          ],
          Cg.prototype,
          "constructedValue",
          void 0
        ),
        (Cg = Od([Cd({ type: Vh.Choice })], Cg));
      class xg {
        constructor(e = {}) {
          (this.contentType = ""),
            (this.contentEncryptionAlgorithm = new Uf()),
            Object.assign(this, e);
        }
      }
      Od(
        [xd({ type: zh.ObjectIdentifier })],
        xg.prototype,
        "contentType",
        void 0
      ),
        Od(
          [xd({ type: Uf })],
          xg.prototype,
          "contentEncryptionAlgorithm",
          void 0
        ),
        Od(
          [xd({ type: Cg, optional: !0 })],
          xg.prototype,
          "encryptedContent",
          void 0
        );
      class Ng {
        constructor(e = {}) {
          (this.keyAttrId = ""), Object.assign(this, e);
        }
      }
      var kg;
      Od([xd({ type: zh.ObjectIdentifier })], Ng.prototype, "keyAttrId", void 0),
        Od([xd({ type: zh.Any, optional: !0 })], Ng.prototype, "keyAttr", void 0);
      class Rg {
        constructor(e = {}) {
          (this.subjectKeyIdentifier = new uf()), Object.assign(this, e);
        }
      }
      Od([xd({ type: uf })], Rg.prototype, "subjectKeyIdentifier", void 0),
        Od(
          [xd({ type: zh.GeneralizedTime, optional: !0 })],
          Rg.prototype,
          "date",
          void 0
        ),
        Od([xd({ type: Ng, optional: !0 })], Rg.prototype, "other", void 0);
      let Bg = class {
        constructor(e = {}) {
          Object.assign(this, e);
        }
      };
      Od(
        [xd({ type: Rg, context: 0, implicit: !0, optional: !0 })],
        Bg.prototype,
        "rKeyId",
        void 0
      ),
        Od(
          [xd({ type: Rf, optional: !0 })],
          Bg.prototype,
          "issuerAndSerialNumber",
          void 0
        ),
        (Bg = Od([Cd({ type: Vh.Choice })], Bg));
      class Dg {
        constructor(e = {}) {
          (this.rid = new Bg()),
            (this.encryptedKey = new Ku()),
            Object.assign(this, e);
        }
      }
      Od([xd({ type: Bg })], Dg.prototype, "rid", void 0),
        Od([xd({ type: Ku })], Dg.prototype, "encryptedKey", void 0);
      let Og = (kg = class extends Bd {
        constructor(e) {
          super(e), Object.setPrototypeOf(this, kg.prototype);
        }
      });
      Og = kg = Od([Cd({ type: Vh.Sequence, itemType: Dg })], Og);
      class Lg {
        constructor(e = {}) {
          (this.algorithm = new Af()),
            (this.publicKey = new ArrayBuffer(0)),
            Object.assign(this, e);
        }
      }
      Od([xd({ type: Af })], Lg.prototype, "algorithm", void 0),
        Od([xd({ type: zh.BitString })], Lg.prototype, "publicKey", void 0);
      let Pg = class {
        constructor(e = {}) {
          Object.assign(this, e);
        }
      };
      Od(
        [xd({ type: uf, context: 0, implicit: !0, optional: !0 })],
        Pg.prototype,
        "subjectKeyIdentifier",
        void 0
      ),
        Od(
          [xd({ type: Lg, context: 1, implicit: !0, optional: !0 })],
          Pg.prototype,
          "originatorKey",
          void 0
        ),
        Od(
          [xd({ type: Rf, optional: !0 })],
          Pg.prototype,
          "issuerAndSerialNumber",
          void 0
        ),
        (Pg = Od([Cd({ type: Vh.Choice })], Pg));
      class Ug {
        constructor(e = {}) {
          (this.version = Df.v3),
            (this.originator = new Pg()),
            (this.keyEncryptionAlgorithm = new Pf()),
            (this.recipientEncryptedKeys = new Og()),
            Object.assign(this, e);
        }
      }
      Od([xd({ type: zh.Integer })], Ug.prototype, "version", void 0),
        Od([xd({ type: Pg, context: 0 })], Ug.prototype, "originator", void 0),
        Od(
          [xd({ type: Ku, context: 1, optional: !0 })],
          Ug.prototype,
          "ukm",
          void 0
        ),
        Od([xd({ type: Pf })], Ug.prototype, "keyEncryptionAlgorithm", void 0),
        Od([xd({ type: Og })], Ug.prototype, "recipientEncryptedKeys", void 0);
      let Mg = class {
        constructor(e = {}) {
          Object.assign(this, e);
        }
      };
      Od(
        [xd({ type: uf, context: 0, implicit: !0 })],
        Mg.prototype,
        "subjectKeyIdentifier",
        void 0
      ),
        Od([xd({ type: Rf })], Mg.prototype, "issuerAndSerialNumber", void 0),
        (Mg = Od([Cd({ type: Vh.Choice })], Mg));
      class Fg {
        constructor(e = {}) {
          (this.version = Df.v0),
            (this.rid = new Mg()),
            (this.keyEncryptionAlgorithm = new Pf()),
            (this.encryptedKey = new Ku()),
            Object.assign(this, e);
        }
      }
      Od([xd({ type: zh.Integer })], Fg.prototype, "version", void 0),
        Od([xd({ type: Mg })], Fg.prototype, "rid", void 0),
        Od([xd({ type: Pf })], Fg.prototype, "keyEncryptionAlgorithm", void 0),
        Od([xd({ type: Ku })], Fg.prototype, "encryptedKey", void 0);
      class Hg {
        constructor(e = {}) {
          (this.keyIdentifier = new Ku()), Object.assign(this, e);
        }
      }
      Od([xd({ type: Ku })], Hg.prototype, "keyIdentifier", void 0),
        Od(
          [xd({ type: zh.GeneralizedTime, optional: !0 })],
          Hg.prototype,
          "date",
          void 0
        ),
        Od([xd({ type: Ng, optional: !0 })], Hg.prototype, "other", void 0);
      class Qg {
        constructor(e = {}) {
          (this.version = Df.v4),
            (this.kekid = new Hg()),
            (this.keyEncryptionAlgorithm = new Pf()),
            (this.encryptedKey = new Ku()),
            Object.assign(this, e);
        }
      }
      Od([xd({ type: zh.Integer })], Qg.prototype, "version", void 0),
        Od([xd({ type: Hg })], Qg.prototype, "kekid", void 0),
        Od([xd({ type: Pf })], Qg.prototype, "keyEncryptionAlgorithm", void 0),
        Od([xd({ type: Ku })], Qg.prototype, "encryptedKey", void 0);
      class Vg {
        constructor(e = {}) {
          (this.version = Df.v0),
            (this.keyEncryptionAlgorithm = new Pf()),
            (this.encryptedKey = new Ku()),
            Object.assign(this, e);
        }
      }
      Od([xd({ type: zh.Integer })], Vg.prototype, "version", void 0),
        Od(
          [xd({ type: Ff, context: 0, optional: !0 })],
          Vg.prototype,
          "keyDerivationAlgorithm",
          void 0
        ),
        Od([xd({ type: Pf })], Vg.prototype, "keyEncryptionAlgorithm", void 0),
        Od([xd({ type: Ku })], Vg.prototype, "encryptedKey", void 0);
      class zg {
        constructor(e = {}) {
          (this.oriType = ""),
            (this.oriValue = new ArrayBuffer(0)),
            Object.assign(this, e);
        }
      }
      Od([xd({ type: zh.ObjectIdentifier })], zg.prototype, "oriType", void 0),
        Od([xd({ type: zh.Any })], zg.prototype, "oriValue", void 0);
      let qg = class {
        constructor(e = {}) {
          Object.assign(this, e);
        }
      };
      var Gg;
      Od([xd({ type: Fg, optional: !0 })], qg.prototype, "ktri", void 0),
        Od(
          [xd({ type: Ug, context: 1, implicit: !0, optional: !0 })],
          qg.prototype,
          "kari",
          void 0
        ),
        Od(
          [xd({ type: Qg, context: 2, implicit: !0, optional: !0 })],
          qg.prototype,
          "kekri",
          void 0
        ),
        Od(
          [xd({ type: Vg, context: 3, implicit: !0, optional: !0 })],
          qg.prototype,
          "pwri",
          void 0
        ),
        Od(
          [xd({ type: zg, context: 4, implicit: !0, optional: !0 })],
          qg.prototype,
          "ori",
          void 0
        ),
        (qg = Od([Cd({ type: Vh.Choice })], qg));
      let jg = (Gg = class extends Bd {
        constructor(e) {
          super(e), Object.setPrototypeOf(this, Gg.prototype);
        }
      });
      var Wg;
      jg = Gg = Od([Cd({ type: Vh.Set, itemType: qg })], jg);
      class Yg {
        constructor(e = {}) {
          (this.otherRevInfoFormat = ""),
            (this.otherRevInfo = new ArrayBuffer(0)),
            Object.assign(this, e);
        }
      }
      Od(
        [xd({ type: zh.ObjectIdentifier })],
        Yg.prototype,
        "otherRevInfoFormat",
        void 0
      ),
        Od([xd({ type: zh.Any })], Yg.prototype, "otherRevInfo", void 0);
      let Xg = class {
        constructor(e = {}) {
          (this.other = new Yg()), Object.assign(this, e);
        }
      };
      Od(
        [xd({ type: Yg, context: 1, implicit: !0 })],
        Xg.prototype,
        "other",
        void 0
      ),
        (Xg = Od([Cd({ type: Vh.Choice })], Xg));
      let Kg = (Wg = class extends Bd {
        constructor(e) {
          super(e), Object.setPrototypeOf(this, Wg.prototype);
        }
      });
      Kg = Wg = Od([Cd({ type: Vh.Set, itemType: Xg })], Kg);
      class Jg {
        constructor(e = {}) {
          Object.assign(this, e);
        }
      }
      var Zg;
      Od(
        [xd({ type: Ig, context: 0, implicit: !0, optional: !0 })],
        Jg.prototype,
        "certs",
        void 0
      ),
        Od(
          [xd({ type: Kg, context: 1, implicit: !0, optional: !0 })],
          Jg.prototype,
          "crls",
          void 0
        );
      let $g = (Zg = class extends Bd {
        constructor(e) {
          super(e), Object.setPrototypeOf(this, Zg.prototype);
        }
      });
      $g = Zg = Od([Cd({ type: Vh.Set, itemType: Hf })], $g);
      class em {
        constructor(e = {}) {
          (this.version = Df.v0),
            (this.recipientInfos = new jg()),
            (this.encryptedContentInfo = new xg()),
            Object.assign(this, e);
        }
      }
      Od([xd({ type: zh.Integer })], em.prototype, "version", void 0),
        Od(
          [xd({ type: Jg, context: 0, implicit: !0, optional: !0 })],
          em.prototype,
          "originatorInfo",
          void 0
        ),
        Od([xd({ type: jg })], em.prototype, "recipientInfos", void 0),
        Od([xd({ type: xg })], em.prototype, "encryptedContentInfo", void 0),
        Od(
          [xd({ type: $g, context: 1, implicit: !0, optional: !0 })],
          em.prototype,
          "unprotectedAttrs",
          void 0
        );
      const tm = "1.2.840.113549.1.7.2";
      var rm;
      let im = (rm = class extends Bd {
        constructor(e) {
          super(e), Object.setPrototypeOf(this, rm.prototype);
        }
      });
      im = rm = Od([Cd({ type: Vh.Set, itemType: Of })], im);
      class sm {
        constructor(e = {}) {
          (this.version = Df.v0),
            (this.digestAlgorithms = new im()),
            (this.encapContentInfo = new _g()),
            (this.signerInfos = new zf()),
            Object.assign(this, e);
        }
      }
      Od([xd({ type: zh.Integer })], sm.prototype, "version", void 0),
        Od([xd({ type: im })], sm.prototype, "digestAlgorithms", void 0),
        Od([xd({ type: _g })], sm.prototype, "encapContentInfo", void 0),
        Od(
          [xd({ type: Ig, context: 0, implicit: !0, optional: !0 })],
          sm.prototype,
          "certificates",
          void 0
        ),
        Od(
          [xd({ type: Xg, context: 1, implicit: !0, optional: !0 })],
          sm.prototype,
          "crls",
          void 0
        ),
        Od([xd({ type: zf })], sm.prototype, "signerInfos", void 0);
      const nm = "1.2.840.10045.2.1",
        am = "1.2.840.10045.4.1",
        om = "1.2.840.10045.4.3.1",
        cm = "1.2.840.10045.4.3.2",
        lm = "1.2.840.10045.4.3.3",
        hm = "1.2.840.10045.4.3.4",
        um = "1.2.840.10045.3.1.7",
        dm = "1.3.132.0.34",
        pm = "1.3.132.0.35";
      function fm(e) {
        return new Af({ algorithm: e });
      }
      const gm = fm(am),
        mm = (fm(om), fm(cm)),
        ym = fm(lm),
        Am = fm(hm);
      let wm = class {
        constructor(e = {}) {
          Object.assign(this, e);
        }
      };
      Od([xd({ type: zh.ObjectIdentifier })], wm.prototype, "namedCurve", void 0),
        (wm = Od([Cd({ type: Vh.Choice })], wm));
      class Em {
        constructor(e = {}) {
          (this.version = 1),
            (this.privateKey = new Ku()),
            Object.assign(this, e);
        }
      }
      Od([xd({ type: zh.Integer })], Em.prototype, "version", void 0),
        Od([xd({ type: Ku })], Em.prototype, "privateKey", void 0),
        Od(
          [xd({ type: wm, context: 0, optional: !0 })],
          Em.prototype,
          "parameters",
          void 0
        ),
        Od(
          [xd({ type: zh.BitString, context: 1, optional: !0 })],
          Em.prototype,
          "publicKey",
          void 0
        );
      class bm {
        constructor(e = {}) {
          (this.r = new ArrayBuffer(0)),
            (this.s = new ArrayBuffer(0)),
            Object.assign(this, e);
        }
      }
      Od([xd({ type: zh.Integer, converter: ed })], bm.prototype, "r", void 0),
        Od([xd({ type: zh.Integer, converter: ed })], bm.prototype, "s", void 0);
      const vm = "1.2.840.113549.1.1",
        Im = `${vm}.1`,
        Sm = `${vm}.7`,
        Tm = `${vm}.9`,
        _m = `${vm}.10`,
        Cm = `${vm}.2`,
        xm = `${vm}.4`,
        Nm = `${vm}.5`,
        km = `${vm}.14`,
        Rm = `${vm}.11`,
        Bm = `${vm}.12`,
        Dm = `${vm}.13`,
        Om = `${vm}.15`,
        Lm = `${vm}.16`,
        Pm = "1.3.14.3.2.26",
        Um = "2.16.840.1.101.3.4.2.4",
        Mm = "2.16.840.1.101.3.4.2.1",
        Fm = "2.16.840.1.101.3.4.2.2",
        Hm = "2.16.840.1.101.3.4.2.3",
        Qm = `${vm}.8`;
      function Vm(e) {
        return new Af({ algorithm: e, parameters: null });
      }
      Vm("1.2.840.113549.2.2"), Vm("1.2.840.113549.2.5");
      const zm = Vm(Pm),
        qm =
          (Vm(Um),
          Vm(Mm),
          Vm(Fm),
          Vm(Hm),
          Vm("2.16.840.1.101.3.4.2.5"),
          Vm("2.16.840.1.101.3.4.2.6"),
          new Af({ algorithm: Qm, parameters: Dd.serialize(zm) })),
        Gm = new Af({
          algorithm: Tm,
          parameters: Dd.serialize(
            sd.toASN(
              new Uint8Array([
                218, 57, 163, 238, 94, 107, 75, 13, 50, 85, 191, 239, 149, 96, 24,
                144, 175, 216, 7, 9,
              ]).buffer
            )
          ),
        });
      Vm(Im),
        Vm(Cm),
        Vm(xm),
        Vm(Nm),
        Vm(Om),
        Vm(Lm),
        Vm(Bm),
        Vm(Dm),
        Vm(Om),
        Vm(Lm);
      class jm {
        constructor(e = {}) {
          (this.hashAlgorithm = new Af(zm)),
            (this.maskGenAlgorithm = new Af({
              algorithm: Qm,
              parameters: Dd.serialize(zm),
            })),
            (this.pSourceAlgorithm = new Af(Gm)),
            Object.assign(this, e);
        }
      }
      Od(
        [xd({ type: Af, context: 0, defaultValue: zm })],
        jm.prototype,
        "hashAlgorithm",
        void 0
      ),
        Od(
          [xd({ type: Af, context: 1, defaultValue: qm })],
          jm.prototype,
          "maskGenAlgorithm",
          void 0
        ),
        Od(
          [xd({ type: Af, context: 2, defaultValue: Gm })],
          jm.prototype,
          "pSourceAlgorithm",
          void 0
        );
      new Af({ algorithm: Sm, parameters: Dd.serialize(new jm()) });
      class Wm {
        constructor(e = {}) {
          (this.hashAlgorithm = new Af(zm)),
            (this.maskGenAlgorithm = new Af({
              algorithm: Qm,
              parameters: Dd.serialize(zm),
            })),
            (this.saltLength = 20),
            (this.trailerField = 1),
            Object.assign(this, e);
        }
      }
      Od(
        [xd({ type: Af, context: 0, defaultValue: zm })],
        Wm.prototype,
        "hashAlgorithm",
        void 0
      ),
        Od(
          [xd({ type: Af, context: 1, defaultValue: qm })],
          Wm.prototype,
          "maskGenAlgorithm",
          void 0
        ),
        Od(
          [xd({ type: zh.Integer, context: 2, defaultValue: 20 })],
          Wm.prototype,
          "saltLength",
          void 0
        ),
        Od(
          [xd({ type: zh.Integer, context: 3, defaultValue: 1 })],
          Wm.prototype,
          "trailerField",
          void 0
        );
      new Af({ algorithm: _m, parameters: Dd.serialize(new Wm()) });
      class Ym {
        constructor(e = {}) {
          (this.digestAlgorithm = new Af()),
            (this.digest = new Ku()),
            Object.assign(this, e);
        }
      }
      var Xm;
      Od([xd({ type: Af })], Ym.prototype, "digestAlgorithm", void 0),
        Od([xd({ type: Ku })], Ym.prototype, "digest", void 0);
      class Km {
        constructor(e = {}) {
          (this.prime = new ArrayBuffer(0)),
            (this.exponent = new ArrayBuffer(0)),
            (this.coefficient = new ArrayBuffer(0)),
            Object.assign(this, e);
        }
      }
      Od(
        [xd({ type: zh.Integer, converter: ed })],
        Km.prototype,
        "prime",
        void 0
      ),
        Od(
          [xd({ type: zh.Integer, converter: ed })],
          Km.prototype,
          "exponent",
          void 0
        ),
        Od(
          [xd({ type: zh.Integer, converter: ed })],
          Km.prototype,
          "coefficient",
          void 0
        );
      let Jm = (Xm = class extends Bd {
        constructor(e) {
          super(e), Object.setPrototypeOf(this, Xm.prototype);
        }
      });
      Jm = Xm = Od([Cd({ type: Vh.Sequence, itemType: Km })], Jm);
      class Zm {
        constructor(e = {}) {
          (this.version = 0),
            (this.modulus = new ArrayBuffer(0)),
            (this.publicExponent = new ArrayBuffer(0)),
            (this.privateExponent = new ArrayBuffer(0)),
            (this.prime1 = new ArrayBuffer(0)),
            (this.prime2 = new ArrayBuffer(0)),
            (this.exponent1 = new ArrayBuffer(0)),
            (this.exponent2 = new ArrayBuffer(0)),
            (this.coefficient = new ArrayBuffer(0)),
            Object.assign(this, e);
        }
      }
      Od([xd({ type: zh.Integer })], Zm.prototype, "version", void 0),
        Od(
          [xd({ type: zh.Integer, converter: ed })],
          Zm.prototype,
          "modulus",
          void 0
        ),
        Od(
          [xd({ type: zh.Integer, converter: ed })],
          Zm.prototype,
          "publicExponent",
          void 0
        ),
        Od(
          [xd({ type: zh.Integer, converter: ed })],
          Zm.prototype,
          "privateExponent",
          void 0
        ),
        Od(
          [xd({ type: zh.Integer, converter: ed })],
          Zm.prototype,
          "prime1",
          void 0
        ),
        Od(
          [xd({ type: zh.Integer, converter: ed })],
          Zm.prototype,
          "prime2",
          void 0
        ),
        Od(
          [xd({ type: zh.Integer, converter: ed })],
          Zm.prototype,
          "exponent1",
          void 0
        ),
        Od(
          [xd({ type: zh.Integer, converter: ed })],
          Zm.prototype,
          "exponent2",
          void 0
        ),
        Od(
          [xd({ type: zh.Integer, converter: ed })],
          Zm.prototype,
          "coefficient",
          void 0
        ),
        Od(
          [xd({ type: Jm, optional: !0 })],
          Zm.prototype,
          "otherPrimeInfos",
          void 0
        );
      class $m {
        constructor(e = {}) {
          (this.modulus = new ArrayBuffer(0)),
            (this.publicExponent = new ArrayBuffer(0)),
            Object.assign(this, e);
        }
      }
      var ey;
      Od(
        [xd({ type: zh.Integer, converter: ed })],
        $m.prototype,
        "modulus",
        void 0
      ),
        Od(
          [xd({ type: zh.Integer, converter: ed })],
          $m.prototype,
          "publicExponent",
          void 0
        ),
        (function (e) {
          (e[(e.Transient = 0)] = "Transient"),
            (e[(e.Singleton = 1)] = "Singleton"),
            (e[(e.ResolutionScoped = 2)] = "ResolutionScoped"),
            (e[(e.ContainerScoped = 3)] = "ContainerScoped");
        })(ey || (ey = {}));
      const ty = ey;
      /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
      var ry = function (e, t) {
        return (
          (ry =
            Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array &&
              function (e, t) {
                e.__proto__ = t;
              }) ||
            function (e, t) {
              for (var r in t) t.hasOwnProperty(r) && (e[r] = t[r]);
            }),
          ry(e, t)
        );
      };
      function iy(e, t) {
        function r() {
          this.constructor = e;
        }
        ry(e, t),
          (e.prototype =
            null === t
              ? Object.create(t)
              : ((r.prototype = t.prototype), new r()));
      }
      function sy(e, t, r, i) {
        return new (r || (r = Promise))(function (s, n) {
          function a(e) {
            try {
              c(i.next(e));
            } catch (e) {
              n(e);
            }
          }
          function o(e) {
            try {
              c(i.throw(e));
            } catch (e) {
              n(e);
            }
          }
          function c(e) {
            var t;
            e.done
              ? s(e.value)
              : ((t = e.value),
                t instanceof r
                  ? t
                  : new r(function (e) {
                      e(t);
                    })).then(a, o);
          }
          c((i = i.apply(e, t || [])).next());
        });
      }
      function ny(e, t) {
        var r,
          i,
          s,
          n,
          a = {
            label: 0,
            sent: function () {
              if (1 & s[0]) throw s[1];
              return s[1];
            },
            trys: [],
            ops: [],
          };
        return (
          (n = { next: o(0), throw: o(1), return: o(2) }),
          "function" == typeof Symbol &&
            (n[Symbol.iterator] = function () {
              return this;
            }),
          n
        );
        function o(n) {
          return function (o) {
            return (function (n) {
              if (r) throw new TypeError("Generator is already executing.");
              for (; a; )
                try {
                  if (
                    ((r = 1),
                    i &&
                      (s =
                        2 & n[0]
                          ? i.return
                          : n[0]
                          ? i.throw || ((s = i.return) && s.call(i), 0)
                          : i.next) &&
                      !(s = s.call(i, n[1])).done)
                  )
                    return s;
                  switch (((i = 0), s && (n = [2 & n[0], s.value]), n[0])) {
                    case 0:
                    case 1:
                      s = n;
                      break;
                    case 4:
                      return a.label++, { value: n[1], done: !1 };
                    case 5:
                      a.label++, (i = n[1]), (n = [0]);
                      continue;
                    case 7:
                      (n = a.ops.pop()), a.trys.pop();
                      continue;
                    default:
                      if (
                        !((s = a.trys),
                        (s = s.length > 0 && s[s.length - 1]) ||
                          (6 !== n[0] && 2 !== n[0]))
                      ) {
                        a = 0;
                        continue;
                      }
                      if (3 === n[0] && (!s || (n[1] > s[0] && n[1] < s[3]))) {
                        a.label = n[1];
                        break;
                      }
                      if (6 === n[0] && a.label < s[1]) {
                        (a.label = s[1]), (s = n);
                        break;
                      }
                      if (s && a.label < s[2]) {
                        (a.label = s[2]), a.ops.push(n);
                        break;
                      }
                      s[2] && a.ops.pop(), a.trys.pop();
                      continue;
                  }
                  n = t.call(e, a);
                } catch (e) {
                  (n = [6, e]), (i = 0);
                } finally {
                  r = s = 0;
                }
              if (5 & n[0]) throw n[1];
              return { value: n[0] ? n[1] : void 0, done: !0 };
            })([n, o]);
          };
        }
      }
      function ay(e) {
        var t = "function" == typeof Symbol && Symbol.iterator,
          r = t && e[t],
          i = 0;
        if (r) return r.call(e);
        if (e && "number" == typeof e.length)
          return {
            next: function () {
              return (
                e && i >= e.length && (e = void 0),
                { value: e && e[i++], done: !e }
              );
            },
          };
        throw new TypeError(
          t ? "Object is not iterable." : "Symbol.iterator is not defined."
        );
      }
      function oy(e, t) {
        var r = "function" == typeof Symbol && e[Symbol.iterator];
        if (!r) return e;
        var i,
          s,
          n = r.call(e),
          a = [];
        try {
          for (; (void 0 === t || t-- > 0) && !(i = n.next()).done; )
            a.push(i.value);
        } catch (e) {
          s = { error: e };
        } finally {
          try {
            i && !i.done && (r = n.return) && r.call(n);
          } finally {
            if (s) throw s.error;
          }
        }
        return a;
      }
      function cy() {
        for (var e = [], t = 0; t < arguments.length; t++)
          e = e.concat(oy(arguments[t]));
        return e;
      }
      function ly(e) {
        return !!e.useClass;
      }
      function hy(e) {
        return !!e.useFactory;
      }
      var uy = (function () {
        function e(e) {
          (this.wrap = e),
            (this.reflectMethods = [
              "get",
              "getPrototypeOf",
              "setPrototypeOf",
              "getOwnPropertyDescriptor",
              "defineProperty",
              "has",
              "set",
              "deleteProperty",
              "apply",
              "construct",
              "ownKeys",
            ]);
        }
        return (
          (e.prototype.createProxy = function (e) {
            var t,
              r = this,
              i = !1;
            return new Proxy(
              {},
              this.createHandler(function () {
                return i || ((t = e(r.wrap())), (i = !0)), t;
              })
            );
          }),
          (e.prototype.createHandler = function (e) {
            var t = {};
            return (
              this.reflectMethods.forEach(function (r) {
                t[r] = function () {
                  for (var t = [], i = 0; i < arguments.length; i++)
                    t[i] = arguments[i];
                  return (t[0] = e()), Reflect[r].apply(void 0, cy(t));
                };
              }),
              t
            );
          }),
          e
        );
      })();
      function dy(e) {
        return "string" == typeof e || "symbol" == typeof e;
      }
      function py(e) {
        return "object" == typeof e && "token" in e && "transform" in e;
      }
      function fy(e) {
        return !!e.useToken;
      }
      function gy(e) {
        return null != e.useValue;
      }
      const my = (function () {
        function e() {
          this._registryMap = new Map();
        }
        return (
          (e.prototype.entries = function () {
            return this._registryMap.entries();
          }),
          (e.prototype.getAll = function (e) {
            return this.ensure(e), this._registryMap.get(e);
          }),
          (e.prototype.get = function (e) {
            this.ensure(e);
            var t = this._registryMap.get(e);
            return t[t.length - 1] || null;
          }),
          (e.prototype.set = function (e, t) {
            this.ensure(e), this._registryMap.get(e).push(t);
          }),
          (e.prototype.setAll = function (e, t) {
            this._registryMap.set(e, t);
          }),
          (e.prototype.has = function (e) {
            return this.ensure(e), this._registryMap.get(e).length > 0;
          }),
          (e.prototype.clear = function () {
            this._registryMap.clear();
          }),
          (e.prototype.ensure = function (e) {
            this._registryMap.has(e) || this._registryMap.set(e, []);
          }),
          e
        );
      })();
      const yy = (function (e) {
        function t() {
          return (null !== e && e.apply(this, arguments)) || this;
        }
        return iy(t, e), t;
      })(my);
      const Ay = function () {
        this.scopedResolutions = new Map();
      };
      function wy(e, t, r) {
        var i,
          s,
          n = oy(e.toString().match(/constructor\(([\w, ]+)\)/) || [], 2)[1],
          a = (function (e, t) {
            return null === e
              ? "at position #" + t
              : '"' + e.split(",")[t].trim() + '" at position #' + t;
          })(void 0 === n ? null : n, t);
        return (
          (i =
            "Cannot inject the dependency " +
            a +
            ' of "' +
            e.name +
            '" constructor. Reason:'),
          void 0 === s && (s = "    "),
          cy(
            [i],
            r.message.split("\n").map(function (e) {
              return s + e;
            })
          ).join("\n")
        );
      }
      var Ey = (function (e) {
          function t() {
            return (null !== e && e.apply(this, arguments)) || this;
          }
          return iy(t, e), t;
        })(my),
        by = (function (e) {
          function t() {
            return (null !== e && e.apply(this, arguments)) || this;
          }
          return iy(t, e), t;
        })(my);
      const vy = function () {
        (this.preResolution = new Ey()), (this.postResolution = new by());
      };
      var Iy = new Map(),
        Sy = (function () {
          function e(e) {
            (this.parent = e),
              (this._registry = new yy()),
              (this.interceptors = new vy()),
              (this.disposed = !1),
              (this.disposables = new Set());
          }
          return (
            (e.prototype.register = function (e, t, r) {
              var i;
              if (
                (void 0 === r && (r = { lifecycle: ty.Transient }),
                this.ensureNotDisposed(),
                (i = (function (e) {
                  return ly(e) || gy(e) || fy(e) || hy(e);
                })(t)
                  ? t
                  : { useClass: t }),
                fy(i))
              )
                for (var s = [e], n = i; null != n; ) {
                  var a = n.useToken;
                  if (s.includes(a))
                    throw new Error(
                      "Token registration cycle detected! " +
                        cy(s, [a]).join(" -> ")
                    );
                  s.push(a);
                  var o = this._registry.get(a);
                  n = o && fy(o.provider) ? o.provider : null;
                }
              if (
                (r.lifecycle === ty.Singleton ||
                  r.lifecycle == ty.ContainerScoped ||
                  r.lifecycle == ty.ResolutionScoped) &&
                (gy(i) || hy(i))
              )
                throw new Error(
                  'Cannot use lifecycle "' +
                    ty[r.lifecycle] +
                    '" with ValueProviders or FactoryProviders'
                );
              return this._registry.set(e, { provider: i, options: r }), this;
            }),
            (e.prototype.registerType = function (e, t) {
              return (
                this.ensureNotDisposed(),
                dy(t)
                  ? this.register(e, { useToken: t })
                  : this.register(e, { useClass: t })
              );
            }),
            (e.prototype.registerInstance = function (e, t) {
              return this.ensureNotDisposed(), this.register(e, { useValue: t });
            }),
            (e.prototype.registerSingleton = function (e, t) {
              if ((this.ensureNotDisposed(), dy(e))) {
                if (dy(t))
                  return this.register(
                    e,
                    { useToken: t },
                    { lifecycle: ty.Singleton }
                  );
                if (t)
                  return this.register(
                    e,
                    { useClass: t },
                    { lifecycle: ty.Singleton }
                  );
                throw new Error(
                  'Cannot register a type name as a singleton without a "to" token'
                );
              }
              var r = e;
              return (
                t && !dy(t) && (r = t),
                this.register(e, { useClass: r }, { lifecycle: ty.Singleton })
              );
            }),
            (e.prototype.resolve = function (e, t) {
              void 0 === t && (t = new Ay()), this.ensureNotDisposed();
              var r = this.getRegistration(e);
              if (!r && dy(e))
                throw new Error(
                  'Attempted to resolve unregistered dependency token: "' +
                    e.toString() +
                    '"'
                );
              if ((this.executePreResolutionInterceptor(e, "Single"), r)) {
                var i = this.resolveRegistration(r, t);
                return this.executePostResolutionInterceptor(e, i, "Single"), i;
              }
              if (
                (function (e) {
                  return "function" == typeof e || e instanceof uy;
                })(e)
              ) {
                i = this.construct(e, t);
                return this.executePostResolutionInterceptor(e, i, "Single"), i;
              }
              throw new Error(
                "Attempted to construct an undefined constructor. Could mean a circular dependency problem. Try using `delay` function."
              );
            }),
            (e.prototype.executePreResolutionInterceptor = function (e, t) {
              var r, i;
              if (this.interceptors.preResolution.has(e)) {
                var s = [];
                try {
                  for (
                    var n = ay(this.interceptors.preResolution.getAll(e)),
                      a = n.next();
                    !a.done;
                    a = n.next()
                  ) {
                    var o = a.value;
                    "Once" != o.options.frequency && s.push(o), o.callback(e, t);
                  }
                } catch (e) {
                  r = { error: e };
                } finally {
                  try {
                    a && !a.done && (i = n.return) && i.call(n);
                  } finally {
                    if (r) throw r.error;
                  }
                }
                this.interceptors.preResolution.setAll(e, s);
              }
            }),
            (e.prototype.executePostResolutionInterceptor = function (e, t, r) {
              var i, s;
              if (this.interceptors.postResolution.has(e)) {
                var n = [];
                try {
                  for (
                    var a = ay(this.interceptors.postResolution.getAll(e)),
                      o = a.next();
                    !o.done;
                    o = a.next()
                  ) {
                    var c = o.value;
                    "Once" != c.options.frequency && n.push(c),
                      c.callback(e, t, r);
                  }
                } catch (e) {
                  i = { error: e };
                } finally {
                  try {
                    o && !o.done && (s = a.return) && s.call(a);
                  } finally {
                    if (i) throw i.error;
                  }
                }
                this.interceptors.postResolution.setAll(e, n);
              }
            }),
            (e.prototype.resolveRegistration = function (e, t) {
              if (
                (this.ensureNotDisposed(),
                e.options.lifecycle === ty.ResolutionScoped &&
                  t.scopedResolutions.has(e))
              )
                return t.scopedResolutions.get(e);
              var r,
                i = e.options.lifecycle === ty.Singleton,
                s = e.options.lifecycle === ty.ContainerScoped,
                n = i || s;
              return (
                (r = gy(e.provider)
                  ? e.provider.useValue
                  : fy(e.provider)
                  ? n
                    ? e.instance ||
                      (e.instance = this.resolve(e.provider.useToken, t))
                    : this.resolve(e.provider.useToken, t)
                  : ly(e.provider)
                  ? n
                    ? e.instance ||
                      (e.instance = this.construct(e.provider.useClass, t))
                    : this.construct(e.provider.useClass, t)
                  : hy(e.provider)
                  ? e.provider.useFactory(this)
                  : this.construct(e.provider, t)),
                e.options.lifecycle === ty.ResolutionScoped &&
                  t.scopedResolutions.set(e, r),
                r
              );
            }),
            (e.prototype.resolveAll = function (e, t) {
              var r = this;
              void 0 === t && (t = new Ay()), this.ensureNotDisposed();
              var i = this.getAllRegistrations(e);
              if (!i && dy(e))
                throw new Error(
                  'Attempted to resolve unregistered dependency token: "' +
                    e.toString() +
                    '"'
                );
              if ((this.executePreResolutionInterceptor(e, "All"), i)) {
                var s = i.map(function (e) {
                  return r.resolveRegistration(e, t);
                });
                return this.executePostResolutionInterceptor(e, s, "All"), s;
              }
              var n = [this.construct(e, t)];
              return this.executePostResolutionInterceptor(e, n, "All"), n;
            }),
            (e.prototype.isRegistered = function (e, t) {
              return (
                void 0 === t && (t = !1),
                this.ensureNotDisposed(),
                this._registry.has(e) ||
                  (t && (this.parent || !1) && this.parent.isRegistered(e, !0))
              );
            }),
            (e.prototype.reset = function () {
              this.ensureNotDisposed(),
                this._registry.clear(),
                this.interceptors.preResolution.clear(),
                this.interceptors.postResolution.clear();
            }),
            (e.prototype.clearInstances = function () {
              var e, t;
              this.ensureNotDisposed();
              try {
                for (
                  var r = ay(this._registry.entries()), i = r.next();
                  !i.done;
                  i = r.next()
                ) {
                  var s = oy(i.value, 2),
                    n = s[0],
                    a = s[1];
                  this._registry.setAll(
                    n,
                    a
                      .filter(function (e) {
                        return !gy(e.provider);
                      })
                      .map(function (e) {
                        return (e.instance = void 0), e;
                      })
                  );
                }
              } catch (t) {
                e = { error: t };
              } finally {
                try {
                  i && !i.done && (t = r.return) && t.call(r);
                } finally {
                  if (e) throw e.error;
                }
              }
            }),
            (e.prototype.createChildContainer = function () {
              var t, r;
              this.ensureNotDisposed();
              var i = new e(this);
              try {
                for (
                  var s = ay(this._registry.entries()), n = s.next();
                  !n.done;
                  n = s.next()
                ) {
                  var a = oy(n.value, 2),
                    o = a[0],
                    c = a[1];
                  c.some(function (e) {
                    return e.options.lifecycle === ty.ContainerScoped;
                  }) &&
                    i._registry.setAll(
                      o,
                      c.map(function (e) {
                        return e.options.lifecycle === ty.ContainerScoped
                          ? { provider: e.provider, options: e.options }
                          : e;
                      })
                    );
                }
              } catch (e) {
                t = { error: e };
              } finally {
                try {
                  n && !n.done && (r = s.return) && r.call(s);
                } finally {
                  if (t) throw t.error;
                }
              }
              return i;
            }),
            (e.prototype.beforeResolution = function (e, t, r) {
              void 0 === r && (r = { frequency: "Always" }),
                this.interceptors.preResolution.set(e, {
                  callback: t,
                  options: r,
                });
            }),
            (e.prototype.afterResolution = function (e, t, r) {
              void 0 === r && (r = { frequency: "Always" }),
                this.interceptors.postResolution.set(e, {
                  callback: t,
                  options: r,
                });
            }),
            (e.prototype.dispose = function () {
              return sy(this, void 0, void 0, function () {
                var e;
                return ny(this, function (t) {
                  switch (t.label) {
                    case 0:
                      return (
                        (this.disposed = !0),
                        (e = []),
                        this.disposables.forEach(function (t) {
                          var r = t.dispose();
                          r && e.push(r);
                        }),
                        [4, Promise.all(e)]
                      );
                    case 1:
                      return t.sent(), [2];
                  }
                });
              });
            }),
            (e.prototype.getRegistration = function (e) {
              return this.isRegistered(e)
                ? this._registry.get(e)
                : this.parent
                ? this.parent.getRegistration(e)
                : null;
            }),
            (e.prototype.getAllRegistrations = function (e) {
              return this.isRegistered(e)
                ? this._registry.getAll(e)
                : this.parent
                ? this.parent.getAllRegistrations(e)
                : null;
            }),
            (e.prototype.construct = function (e, t) {
              var r = this;
              if (e instanceof uy)
                return e.createProxy(function (e) {
                  return r.resolve(e, t);
                });
              var i,
                s = (function () {
                  var i = Iy.get(e);
                  if (!i || 0 === i.length) {
                    if (0 === e.length) return new e();
                    throw new Error('TypeInfo not known for "' + e.name + '"');
                  }
                  var s = i.map(r.resolveParams(t, e));
                  return new (e.bind.apply(e, cy([void 0], s)))();
                })();
              return (
                "function" != typeof (i = s).dispose ||
                  i.dispose.length > 0 ||
                  this.disposables.add(s),
                s
              );
            }),
            (e.prototype.resolveParams = function (e, t) {
              var r = this;
              return function (i, s) {
                var n, a, o, c;
                try {
                  return "object" == typeof (c = i) &&
                    "token" in c &&
                    "multiple" in c
                    ? py(i)
                      ? i.multiple
                        ? (n = r.resolve(i.transform)).transform.apply(
                            n,
                            cy([r.resolveAll(i.token)], i.transformArgs)
                          )
                        : (a = r.resolve(i.transform)).transform.apply(
                            a,
                            cy([r.resolve(i.token, e)], i.transformArgs)
                          )
                      : i.multiple
                      ? r.resolveAll(i.token)
                      : r.resolve(i.token, e)
                    : py(i)
                    ? (o = r.resolve(i.transform, e)).transform.apply(
                        o,
                        cy([r.resolve(i.token, e)], i.transformArgs)
                      )
                    : r.resolve(i, e);
                } catch (e) {
                  throw new Error(wy(t, s, e));
                }
              };
            }),
            (e.prototype.ensureNotDisposed = function () {
              if (this.disposed)
                throw new Error(
                  "This container has been disposed, you cannot interact with a disposed container"
                );
            }),
            e
          );
        })(),
        Ty = new Sy();
      var _y = "injectionTokens";
      const Cy = function () {
        return function (e) {
          Iy.set(
            e,
            (function (e) {
              var t = Reflect.getMetadata("design:paramtypes", e) || [],
                r = Reflect.getOwnMetadata(_y, e) || {};
              return (
                Object.keys(r).forEach(function (e) {
                  t[+e] = r[e];
                }),
                t
              );
            })(e)
          );
        };
      };
      if ("undefined" == typeof Reflect || !Reflect.getMetadata)
        throw new Error(
          "tsyringe requires a reflect polyfill. Please add 'import \"reflect-metadata\"' to the top of your entry point."
        );
      var xy;
      class Ny {
        constructor(e = {}) {
          (this.attrId = ""), (this.attrValues = []), Object.assign(e);
        }
      }
      Od([xd({ type: zh.ObjectIdentifier })], Ny.prototype, "attrId", void 0),
        Od(
          [xd({ type: zh.Any, repeated: "set" })],
          Ny.prototype,
          "attrValues",
          void 0
        );
      let ky = (xy = class extends Bd {
        constructor(e) {
          super(e), Object.setPrototypeOf(this, xy.prototype);
        }
      });
      var Ry;
      ky = xy = Od([Cd({ type: Vh.Sequence, itemType: Ny })], ky);
      let By = (Ry = class extends Bd {
        constructor(e) {
          super(e), Object.setPrototypeOf(this, Ry.prototype);
        }
      });
      By = Ry = Od([Cd({ type: Vh.Sequence, itemType: Sg })], By);
      class Dy {
        constructor(e = {}) {
          (this.certId = ""),
            (this.certValue = new ArrayBuffer(0)),
            Object.assign(this, e);
        }
      }
      Od([xd({ type: zh.ObjectIdentifier })], Dy.prototype, "certId", void 0),
        Od([xd({ type: zh.Any, context: 0 })], Dy.prototype, "certValue", void 0);
      class Oy {
        constructor(e = {}) {
          (this.crlId = ""),
            (this.crltValue = new ArrayBuffer(0)),
            Object.assign(this, e);
        }
      }
      Od([xd({ type: zh.ObjectIdentifier })], Oy.prototype, "crlId", void 0),
        Od([xd({ type: zh.Any, context: 0 })], Oy.prototype, "crltValue", void 0);
      class Ly extends Ku {}
      class Py {
        constructor(e = {}) {
          (this.encryptionAlgorithm = new Af()),
            (this.encryptedData = new Ly()),
            Object.assign(this, e);
        }
      }
      var Uy, My;
      Od([xd({ type: Af })], Py.prototype, "encryptionAlgorithm", void 0),
        Od([xd({ type: Ly })], Py.prototype, "encryptedData", void 0),
        (function (e) {
          e[(e.v1 = 0)] = "v1";
        })(My || (My = {}));
      class Fy extends Ku {}
      let Hy = (Uy = class extends Bd {
        constructor(e) {
          super(e), Object.setPrototypeOf(this, Uy.prototype);
        }
      });
      Hy = Uy = Od([Cd({ type: Vh.Sequence, itemType: of })], Hy);
      class Qy {
        constructor(e = {}) {
          (this.version = My.v1),
            (this.privateKeyAlgorithm = new Af()),
            (this.privateKey = new Fy()),
            Object.assign(this, e);
        }
      }
      Od([xd({ type: zh.Integer })], Qy.prototype, "version", void 0),
        Od([xd({ type: Af })], Qy.prototype, "privateKeyAlgorithm", void 0),
        Od([xd({ type: Fy })], Qy.prototype, "privateKey", void 0),
        Od(
          [xd({ type: Hy, implicit: !0, context: 0, optional: !0 })],
          Qy.prototype,
          "attributes",
          void 0
        );
      let Vy = class extends Qy {};
      Vy = Od([Cd({ type: Vh.Sequence })], Vy);
      let zy = class extends Py {};
      zy = Od([Cd({ type: Vh.Sequence })], zy);
      class qy {
        constructor(e = {}) {
          (this.secretTypeId = ""),
            (this.secretValue = new ArrayBuffer(0)),
            Object.assign(this, e);
        }
      }
      Od(
        [xd({ type: zh.ObjectIdentifier })],
        qy.prototype,
        "secretTypeId",
        void 0
      ),
        Od(
          [xd({ type: zh.Any, context: 0 })],
          qy.prototype,
          "secretValue",
          void 0
        );
      class Gy {
        constructor(e = {}) {
          (this.mac = new Ym()),
            (this.macSalt = new Ku()),
            (this.iterations = 1),
            Object.assign(this, e);
        }
      }
      Od([xd({ type: Ym })], Gy.prototype, "mac", void 0),
        Od([xd({ type: Ku })], Gy.prototype, "macSalt", void 0),
        Od(
          [xd({ type: zh.Integer, defaultValue: 1 })],
          Gy.prototype,
          "iterations",
          void 0
        );
      class jy {
        constructor(e = {}) {
          (this.version = 3),
            (this.authSafe = new Sg()),
            (this.macData = new Gy()),
            Object.assign(this, e);
        }
      }
      var Wy;
      Od([xd({ type: zh.Integer })], jy.prototype, "version", void 0),
        Od([xd({ type: Sg })], jy.prototype, "authSafe", void 0),
        Od([xd({ type: Gy, optional: !0 })], jy.prototype, "macData", void 0);
      class Yy {
        constructor(e = {}) {
          (this.bagId = ""),
            (this.bagValue = new ArrayBuffer(0)),
            Object.assign(this, e);
        }
      }
      Od([xd({ type: zh.ObjectIdentifier })], Yy.prototype, "bagId", void 0),
        Od([xd({ type: zh.Any, context: 0 })], Yy.prototype, "bagValue", void 0),
        Od(
          [xd({ type: Ny, repeated: "set", optional: !0 })],
          Yy.prototype,
          "bagAttributes",
          void 0
        );
      let Xy = (Wy = class extends Bd {
        constructor(e) {
          super(e), Object.setPrototypeOf(this, Wy.prototype);
        }
      });
      var Ky, Jy, Zy;
      Xy = Wy = Od([Cd({ type: Vh.Sequence, itemType: Yy })], Xy);
      const $y = "1.2.840.113549.1.9",
        eA = `${$y}.7`,
        tA = `${$y}.14`;
      let rA = class extends Hd {
        constructor(e = {}) {
          super(e);
        }
        toString() {
          return {}.toString(), this.ia5String || super.toString();
        }
      };
      Od([xd({ type: zh.IA5String })], rA.prototype, "ia5String", void 0),
        (rA = Od([Cd({ type: Vh.Choice })], rA));
      let iA = class extends Sg {};
      iA = Od([Cd({ type: Vh.Sequence })], iA);
      let sA = class extends jy {};
      sA = Od([Cd({ type: Vh.Sequence })], sA);
      let nA = class extends Py {};
      nA = Od([Cd({ type: Vh.Sequence })], nA);
      let aA = class {
        constructor(e = "") {
          this.value = e;
        }
        toString() {
          return this.value;
        }
      };
      Od([xd({ type: zh.IA5String })], aA.prototype, "value", void 0),
        (aA = Od([Cd({ type: Vh.Choice })], aA));
      let oA = class extends rA {};
      oA = Od([Cd({ type: Vh.Choice })], oA);
      let cA = class extends Hd {};
      cA = Od([Cd({ type: Vh.Choice })], cA);
      let lA = class {
        constructor(e = new Date()) {
          this.value = e;
        }
      };
      Od([xd({ type: zh.GeneralizedTime })], lA.prototype, "value", void 0),
        (lA = Od([Cd({ type: Vh.Choice })], lA));
      let hA = class extends Hd {};
      hA = Od([Cd({ type: Vh.Choice })], hA);
      let uA = class {
        constructor(e = "M") {
          this.value = e;
        }
        toString() {
          return this.value;
        }
      };
      Od([xd({ type: zh.PrintableString })], uA.prototype, "value", void 0),
        (uA = Od([Cd({ type: Vh.Choice })], uA));
      let dA = class {
        constructor(e = "") {
          this.value = e;
        }
        toString() {
          return this.value;
        }
      };
      Od([xd({ type: zh.PrintableString })], dA.prototype, "value", void 0),
        (dA = Od([Cd({ type: Vh.Choice })], dA));
      let pA = class extends dA {};
      pA = Od([Cd({ type: Vh.Choice })], pA);
      let fA = class extends Hd {};
      fA = Od([Cd({ type: Vh.Choice })], fA);
      let gA = class {
        constructor(e = "") {
          this.value = e;
        }
        toString() {
          return this.value;
        }
      };
      Od([xd({ type: zh.ObjectIdentifier })], gA.prototype, "value", void 0),
        (gA = Od([Cd({ type: Vh.Choice })], gA));
      let mA = class extends Ef {};
      mA = Od([Cd({ type: Vh.Choice })], mA);
      let yA = class {
        constructor(e = 0) {
          this.value = e;
        }
        toString() {
          return this.value.toString();
        }
      };
      Od([xd({ type: zh.Integer })], yA.prototype, "value", void 0),
        (yA = Od([Cd({ type: Vh.Choice })], yA));
      let AA = class extends Vf {};
      AA = Od([Cd({ type: Vh.Sequence })], AA);
      let wA = class extends Hd {};
      wA = Od([Cd({ type: Vh.Choice })], wA);
      let EA = (Ky = class extends Sf {
        constructor(e) {
          super(e), Object.setPrototypeOf(this, Ky.prototype);
        }
      });
      EA = Ky = Od([Cd({ type: Vh.Sequence })], EA);
      let bA = (Jy = class extends Bd {
        constructor(e) {
          super(e), Object.setPrototypeOf(this, Jy.prototype);
        }
      });
      bA = Jy = Od([Cd({ type: Vh.Set, itemType: Hf })], bA);
      let vA = class {
        constructor(e = "") {
          this.value = e;
        }
        toString() {
          return this.value;
        }
      };
      Od([xd({ type: zh.BmpString })], vA.prototype, "value", void 0),
        (vA = Od([Cd({ type: Vh.Choice })], vA));
      let IA = class extends Af {};
      IA = Od([Cd({ type: Vh.Sequence })], IA);
      let SA = (Zy = class extends Bd {
        constructor(e) {
          super(e), Object.setPrototypeOf(this, Zy.prototype);
        }
      });
      var TA;
      SA = Zy = Od([Cd({ type: Vh.Sequence, itemType: IA })], SA);
      let _A = (TA = class extends Bd {
        constructor(e) {
          super(e), Object.setPrototypeOf(this, TA.prototype);
        }
      });
      _A = TA = Od([Cd({ type: Vh.Sequence, itemType: of })], _A);
      class CA {
        constructor(e = {}) {
          (this.version = 0),
            (this.subject = new Gd()),
            (this.subjectPKInfo = new wf()),
            (this.attributes = new _A()),
            Object.assign(this, e);
        }
      }
      Od([xd({ type: zh.Integer })], CA.prototype, "version", void 0),
        Od([xd({ type: Gd })], CA.prototype, "subject", void 0),
        Od([xd({ type: wf })], CA.prototype, "subjectPKInfo", void 0),
        Od(
          [xd({ type: _A, implicit: !0, context: 0 })],
          CA.prototype,
          "attributes",
          void 0
        );
      class xA {
        constructor(e = {}) {
          (this.certificationRequestInfo = new CA()),
            (this.signatureAlgorithm = new Af()),
            (this.signature = new ArrayBuffer(0)),
            Object.assign(this, e);
        }
      }
      Od([xd({ type: CA })], xA.prototype, "certificationRequestInfo", void 0),
        Od([xd({ type: Af })], xA.prototype, "signatureAlgorithm", void 0),
        Od([xd({ type: zh.BitString })], xA.prototype, "signature", void 0);
      /*!
       * MIT License
       *
       * Copyright (c) Peculiar Ventures. All rights reserved.
       *
       * Permission is hereby granted, free of charge, to any person obtaining a copy
       * of this software and associated documentation files (the "Software"), to deal
       * in the Software without restriction, including without limitation the rights
       * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       * copies of the Software, and to permit persons to whom the Software is
       * furnished to do so, subject to the following conditions:
       *
       * The above copyright notice and this permission notice shall be included in all
       * copies or substantial portions of the Software.
       *
       * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
       * SOFTWARE.
       *
       */
      const NA = "crypto.algorithm";
      const kA = "crypto.algorithmProvider";
      var RA;
      Ty.registerSingleton(
        kA,
        class {
          getAlgorithms() {
            return Ty.resolveAll(NA);
          }
          toAsnAlgorithm(e) {
            for (const t of this.getAlgorithms()) {
              const r = t.toAsnAlgorithm(e);
              if (r) return r;
            }
            if (/^[0-9.]+$/.test(e.name)) {
              const t = new Af({ algorithm: e.name });
              if ("parameters" in e) {
                const r = e;
                t.parameters = r.parameters;
              }
              return t;
            }
            throw new Error(
              "Cannot convert WebCrypto algorithm to ASN.1 algorithm"
            );
          }
          toWebAlgorithm(e) {
            for (const t of this.getAlgorithms()) {
              const r = t.toWebAlgorithm(e);
              if (r) return r;
            }
            return { name: e.algorithm, parameters: e.parameters };
          }
        }
      );
      const BA = "1.3.36.3.3.2.8.1.1",
        DA = `${BA}.1`,
        OA = `${BA}.2`,
        LA = `${BA}.3`,
        PA = `${BA}.4`,
        UA = `${BA}.5`,
        MA = `${BA}.6`,
        FA = `${BA}.7`,
        HA = `${BA}.8`,
        QA = `${BA}.9`,
        VA = `${BA}.10`,
        zA = `${BA}.11`,
        qA = `${BA}.12`,
        GA = `${BA}.13`,
        jA = `${BA}.14`,
        WA = "brainpoolP160r1",
        YA = "brainpoolP160t1",
        XA = "brainpoolP192r1",
        KA = "brainpoolP192t1",
        JA = "brainpoolP224r1",
        ZA = "brainpoolP224t1",
        $A = "brainpoolP256r1",
        ew = "brainpoolP256t1",
        tw = "brainpoolP320r1",
        rw = "brainpoolP320t1",
        iw = "brainpoolP384r1",
        sw = "brainpoolP384t1",
        nw = "brainpoolP512r1",
        aw = "brainpoolP512t1",
        ow = "ECDSA";
      let cw = (RA = class {
        toAsnAlgorithm(e) {
          if (e.name.toLowerCase() === ow.toLowerCase())
            if ("hash" in e) {
              switch (
                ("string" == typeof e.hash ? e.hash : e.hash.name).toLowerCase()
              ) {
                case "sha-1":
                  return gm;
                case "sha-256":
                  return mm;
                case "sha-384":
                  return ym;
                case "sha-512":
                  return Am;
              }
            } else if ("namedCurve" in e) {
              let t = "";
              switch (e.namedCurve) {
                case "P-256":
                  t = um;
                  break;
                case "K-256":
                  t = RA.SECP256K1;
                  break;
                case "P-384":
                  t = dm;
                  break;
                case "P-521":
                  t = pm;
                  break;
                case WA:
                  t = DA;
                  break;
                case YA:
                  t = OA;
                  break;
                case XA:
                  t = LA;
                  break;
                case KA:
                  t = PA;
                  break;
                case JA:
                  t = UA;
                  break;
                case ZA:
                  t = MA;
                  break;
                case $A:
                  t = FA;
                  break;
                case ew:
                  t = HA;
                  break;
                case tw:
                  t = QA;
                  break;
                case rw:
                  t = VA;
                  break;
                case iw:
                  t = zA;
                  break;
                case sw:
                  t = qA;
                  break;
                case nw:
                  t = GA;
                  break;
                case aw:
                  t = jA;
              }
              if (t)
                return new Af({
                  algorithm: nm,
                  parameters: Dd.serialize(new wm({ namedCurve: t })),
                });
            }
          return null;
        }
        toWebAlgorithm(e) {
          switch (e.algorithm) {
            case am:
              return { name: ow, hash: { name: "SHA-1" } };
            case cm:
              return { name: ow, hash: { name: "SHA-256" } };
            case lm:
              return { name: ow, hash: { name: "SHA-384" } };
            case hm:
              return { name: ow, hash: { name: "SHA-512" } };
            case nm:
              if (!e.parameters)
                throw new TypeError(
                  "Cannot get required parameters from EC algorithm"
                );
              switch (Dd.parse(e.parameters, wm).namedCurve) {
                case um:
                  return { name: ow, namedCurve: "P-256" };
                case RA.SECP256K1:
                  return { name: ow, namedCurve: "K-256" };
                case dm:
                  return { name: ow, namedCurve: "P-384" };
                case pm:
                  return { name: ow, namedCurve: "P-521" };
                case DA:
                  return { name: ow, namedCurve: WA };
                case OA:
                  return { name: ow, namedCurve: YA };
                case LA:
                  return { name: ow, namedCurve: XA };
                case PA:
                  return { name: ow, namedCurve: KA };
                case UA:
                  return { name: ow, namedCurve: JA };
                case MA:
                  return { name: ow, namedCurve: ZA };
                case FA:
                  return { name: ow, namedCurve: $A };
                case HA:
                  return { name: ow, namedCurve: ew };
                case QA:
                  return { name: ow, namedCurve: tw };
                case VA:
                  return { name: ow, namedCurve: rw };
                case zA:
                  return { name: ow, namedCurve: iw };
                case qA:
                  return { name: ow, namedCurve: sw };
                case GA:
                  return { name: ow, namedCurve: nw };
                case jA:
                  return { name: ow, namedCurve: aw };
              }
          }
          return null;
        }
      });
      (cw.SECP256K1 = "1.3.132.0.10"),
        (cw = RA = Od([Cy()], cw)),
        Ty.registerSingleton(NA, cw);
      const lw = Symbol("name"),
        hw = Symbol("value");
      class uw {
        constructor(e, t = {}, r = "") {
          (this[lw] = e), (this[hw] = r);
          for (const e in t) this[e] = t[e];
        }
      }
      (uw.NAME = lw), (uw.VALUE = hw);
      class dw {
        static toString(e) {
          const t = this.items[e];
          return t || e;
        }
      }
      dw.items = {
        [Pm]: "sha1",
        [Um]: "sha224",
        [Mm]: "sha256",
        [Fm]: "sha384",
        [Hm]: "sha512",
        [Im]: "rsaEncryption",
        [Nm]: "sha1WithRSAEncryption",
        [km]: "sha224WithRSAEncryption",
        [Rm]: "sha256WithRSAEncryption",
        [Bm]: "sha384WithRSAEncryption",
        [Dm]: "sha512WithRSAEncryption",
        [nm]: "ecPublicKey",
        [am]: "ecdsaWithSHA1",
        [om]: "ecdsaWithSHA224",
        [cm]: "ecdsaWithSHA256",
        [lm]: "ecdsaWithSHA384",
        [hm]: "ecdsaWithSHA512",
        [Pp]: "TLS WWW server authentication",
        [Up]: "TLS WWW client authentication",
        [Mp]: "Code Signing",
        [Fp]: "E-mail Protection",
        [Hp]: "Time Stamping",
        [Qp]: "OCSP Signing",
        [tm]: "Signed Data",
      };
      class pw {
        static serialize(e) {
          return this.serializeObj(e).join("\n");
        }
        static pad(e = 0) {
          return "".padStart(2 * e, " ");
        }
        static serializeObj(e, t = 0) {
          const r = [];
          let i = this.pad(t++),
            s = "";
          const n = e[uw.VALUE];
          n && (s = ` ${n}`), r.push(`${i}${e[uw.NAME]}:${s}`), (i = this.pad(t));
          for (const s in e) {
            if ("symbol" == typeof s) continue;
            const n = e[s],
              a = s ? `${s}: ` : "";
            if (
              "string" == typeof n ||
              "number" == typeof n ||
              "boolean" == typeof n
            )
              r.push(`${i}${a}${n}`);
            else if (n instanceof Date) r.push(`${i}${a}${n.toUTCString()}`);
            else if (Array.isArray(n))
              for (const e of n)
                (e[uw.NAME] = s), r.push(...this.serializeObj(e, t));
            else if (n instanceof uw)
              (n[uw.NAME] = s), r.push(...this.serializeObj(n, t));
            else if (Tl._H.isBufferSource(n))
              s
                ? (r.push(`${i}${a}`),
                  r.push(...this.serializeBufferSource(n, t + 1)))
                : r.push(...this.serializeBufferSource(n, t));
            else {
              if (!("toTextObject" in n))
                throw new TypeError(
                  "Cannot serialize data in text format. Unsupported type."
                );
              {
                const e = n.toTextObject();
                (e[uw.NAME] = s), r.push(...this.serializeObj(e, t));
              }
            }
          }
          return r;
        }
        static serializeBufferSource(e, t = 0) {
          const r = this.pad(t),
            i = Tl._H.toUint8Array(e),
            s = [];
          for (let e = 0; e < i.length; ) {
            const t = [];
            for (let r = 0; r < 16 && e < i.length; r++) {
              8 === r && t.push("");
              const s = i[e++].toString(16).padStart(2, "0");
              t.push(s);
            }
            s.push(`${r}${t.join(" ")}`);
          }
          return s;
        }
        static serializeAlgorithm(e) {
          return this.algorithmSerializer.toTextObject(e);
        }
      }
      (pw.oidSerializer = dw),
        (pw.algorithmSerializer = class {
          static toTextObject(e) {
            const t = new uw(
              "Algorithm Identifier",
              {},
              dw.toString(e.algorithm)
            );
            if (e.parameters)
              switch (e.algorithm) {
                case nm: {
                  const r = new cw().toWebAlgorithm(e);
                  r && "namedCurve" in r
                    ? (t["Named Curve"] = r.namedCurve)
                    : (t.Parameters = e.parameters);
                  break;
                }
                default:
                  t.Parameters = e.parameters;
              }
            return t;
          }
        });
      class fw {
        constructor(...e) {
          if (1 === e.length) {
            const t = e[0];
            (this.rawData = Dd.serialize(t)), this.onInit(t);
          } else {
            const t = Dd.parse(e[0], e[1]);
            (this.rawData = Tl._H.toArrayBuffer(e[0])), this.onInit(t);
          }
        }
        equal(e) {
          return e instanceof fw && (0, Tl.n4)(e.rawData, this.rawData);
        }
        toString(e = "text") {
          switch (e) {
            case "asn":
              return Dd.toString(this.rawData);
            case "text":
              return pw.serialize(this.toTextObject());
            case "hex":
              return Tl.U$.ToHex(this.rawData);
            case "base64":
              return Tl.U$.ToBase64(this.rawData);
            case "base64url":
              return Tl.U$.ToBase64Url(this.rawData);
            default:
              throw TypeError("Argument 'format' is unsupported value");
          }
        }
        getTextName() {
          return this.constructor.NAME;
        }
        toTextObject() {
          const e = this.toTextObjectEmpty();
          return (e[""] = this.rawData), e;
        }
        toTextObjectEmpty(e) {
          return new uw(this.getTextName(), {}, e);
        }
      }
      fw.NAME = "ASN";
      class gw extends fw {
        constructor(...e) {
          let t;
          (t = Tl._H.isBufferSource(e[0])
            ? Tl._H.toArrayBuffer(e[0])
            : Dd.serialize(
                new If({
                  extnID: e[0],
                  critical: e[1],
                  extnValue: new Ku(Tl._H.toArrayBuffer(e[2])),
                })
              )),
            super(t, If);
        }
        onInit(e) {
          (this.type = e.extnID),
            (this.critical = e.critical),
            (this.value = e.extnValue.buffer);
        }
        toTextObject() {
          const e = this.toTextObjectWithoutValue();
          return (e[""] = this.value), e;
        }
        toTextObjectWithoutValue() {
          const e = this.toTextObjectEmpty(this.critical ? "critical" : void 0);
          return (
            e[uw.NAME] === gw.NAME && (e[uw.NAME] = dw.toString(this.type)), e
          );
        }
      }
      var mw;
      class yw {
        static isCryptoKeyPair(e) {
          return e && e.privateKey && e.publicKey;
        }
        static isCryptoKey(e) {
          return (
            e && e.usages && e.type && e.algorithm && void 0 !== e.extractable
          );
        }
        constructor() {
          (this.items = new Map()),
            (this[mw] = "CryptoProvider"),
            "undefined" != typeof self && "undefined" != typeof crypto
              ? this.set(yw.DEFAULT, crypto)
              : void 0 !== r.g &&
                r.g.crypto &&
                r.g.crypto.subtle &&
                this.set(yw.DEFAULT, r.g.crypto);
        }
        clear() {
          this.items.clear();
        }
        delete(e) {
          return this.items.delete(e);
        }
        forEach(e, t) {
          return this.items.forEach(e, t);
        }
        has(e) {
          return this.items.has(e);
        }
        get size() {
          return this.items.size;
        }
        entries() {
          return this.items.entries();
        }
        keys() {
          return this.items.keys();
        }
        values() {
          return this.items.values();
        }
        [Symbol.iterator]() {
          return this.items[Symbol.iterator]();
        }
        get(e = yw.DEFAULT) {
          const t = this.items.get(e.toLowerCase());
          if (!t) throw new Error(`Cannot get Crypto by name '${e}'`);
          return t;
        }
        set(e, t) {
          if ("string" == typeof e) {
            if (!t) throw new TypeError("Argument 'value' is required");
            this.items.set(e.toLowerCase(), t);
          } else this.items.set(yw.DEFAULT, e);
          return this;
        }
      }
      (mw = Symbol.toStringTag), (yw.DEFAULT = "default");
      const Aw = new yw(),
        ww = /^[0-2](?:\.[1-9][0-9]*)+$/;
      class Ew {
        constructor(e = {}) {
          this.items = {};
          for (const t in e) this.register(t, e[t]);
        }
        get(e) {
          return this.items[e] || null;
        }
        findId(e) {
          return (t = e), new RegExp(ww).test(t) ? e : this.get(e);
          var t;
        }
        register(e, t) {
          (this.items[e] = t), (this.items[t] = e);
        }
      }
      const bw = new Ew();
      function vw(e, t) {
        return `\\${Tl.U$.ToHex(Tl.U$.FromUtf8String(t)).toUpperCase()}`;
      }
      bw.register("CN", "2.5.4.3"),
        bw.register("L", "2.5.4.7"),
        bw.register("ST", "2.5.4.8"),
        bw.register("O", "2.5.4.10"),
        bw.register("OU", "2.5.4.11"),
        bw.register("C", "2.5.4.6"),
        bw.register("DC", "0.9.2342.19200300.100.1.25"),
        bw.register("E", "1.2.840.113549.1.9.1"),
        bw.register("G", "2.5.4.42"),
        bw.register("I", "2.5.4.43"),
        bw.register("SN", "2.5.4.4"),
        bw.register("T", "2.5.4.12");
      class Iw {
        static isASCII(e) {
          for (let t = 0; t < e.length; t++) {
            if (e.charCodeAt(t) > 255) return !1;
          }
          return !0;
        }
        static isPrintableString(e) {
          return /^[A-Za-z0-9 '()+,-./:=?]*$/g.test(e);
        }
        constructor(e, t = {}) {
          (this.extraNames = new Ew()), (this.asn = new Gd());
          for (const e in t)
            if (Object.prototype.hasOwnProperty.call(t, e)) {
              const r = t[e];
              this.extraNames.register(e, r);
            }
          "string" == typeof e
            ? (this.asn = this.fromString(e))
            : e instanceof Gd
            ? (this.asn = e)
            : Tl._H.isBufferSource(e)
            ? (this.asn = Dd.parse(e, Gd))
            : (this.asn = this.fromJSON(e));
        }
        getField(e) {
          const t = this.extraNames.findId(e) || bw.findId(e),
            r = [];
          for (const e of this.asn)
            for (const i of e) i.type === t && r.push(i.value.toString());
          return r;
        }
        getName(e) {
          return this.extraNames.get(e) || bw.get(e);
        }
        toString() {
          return this.asn
            .map((e) =>
              e
                .map((e) => {
                  const t = this.getName(e.type) || e.type,
                    r = e.value.anyValue
                      ? `#${Tl.U$.ToHex(e.value.anyValue)}`
                      : (function (e) {
                          return e
                            .replace(/([,+"\\<>;])/g, "\\$1")
                            .replace(/^([ #])/, "\\$1")
                            .replace(/([ ]$)/, "\\$1")
                            .replace(/([\r\n\t])/, vw);
                        })(e.value.toString());
                  return `${t}=${r}`;
                })
                .join("+")
            )
            .join(", ");
        }
        toJSON() {
          var e;
          const t = [];
          for (const r of this.asn) {
            const i = {};
            for (const t of r) {
              const r = this.getName(t.type) || t.type;
              (null !== (e = i[r]) && void 0 !== e) || (i[r] = []),
                i[r].push(
                  t.value.anyValue
                    ? `#${Tl.U$.ToHex(t.value.anyValue)}`
                    : t.value.toString()
                );
            }
            t.push(i);
          }
          return t;
        }
        fromString(e) {
          const t = new Gd(),
            r =
              /(\d\.[\d.]*\d|[A-Za-z]+)=((?:"")|(?:".*?[^\\]")|(?:[^,+].*?(?:[^\\][,+]))|(?:))([,+])?/g;
          let i = null,
            s = ",";
          for (; (i = r.exec(`${e},`)); ) {
            let [, e, r] = i;
            const n = r[r.length - 1];
            ("," !== n && "+" !== n) ||
              ((r = r.slice(0, r.length - 1)), (i[3] = n));
            const a = i[3];
            if ((/[\d.]+/.test(e) || (e = this.getName(e) || ""), !e))
              throw new Error(`Cannot get OID for name type '${e}'`);
            const o = new Vd({ type: e });
            if ("#" === r.charAt(0)) o.value.anyValue = Tl.U$.FromHex(r.slice(1));
            else {
              const t = /"(.*?[^\\])?"/.exec(r);
              t && (r = t[1]),
                (r = r
                  .replace(/\\0a/gi, "\n")
                  .replace(/\\0d/gi, "\r")
                  .replace(/\\0g/gi, "\t")
                  .replace(/\\(.)/g, "$1")),
                e === this.getName("E") || e === this.getName("DC")
                  ? (o.value.ia5String = r)
                  : Iw.isPrintableString(r)
                  ? (o.value.printableString = r)
                  : (o.value.utf8String = r);
            }
            "+" === s ? t[t.length - 1].push(o) : t.push(new zd([o])), (s = a);
          }
          return t;
        }
        fromJSON(e) {
          const t = new Gd();
          for (const r of e) {
            const e = new zd();
            for (const t in r) {
              let i = t;
              if ((/[\d.]+/.test(t) || (i = this.getName(t) || ""), !i))
                throw new Error(`Cannot get OID for name type '${t}'`);
              const s = r[t];
              for (const t of s) {
                const r = new Vd({ type: i });
                if ("object" == typeof t)
                  for (const e in t)
                    switch (e) {
                      case "ia5String":
                        r.value.ia5String = t[e];
                        break;
                      case "utf8String":
                        r.value.utf8String = t[e];
                        break;
                      case "universalString":
                        r.value.universalString = t[e];
                        break;
                      case "bmpString":
                        r.value.bmpString = t[e];
                        break;
                      case "printableString":
                        r.value.printableString = t[e];
                    }
                else
                  "#" === t[0]
                    ? (r.value.anyValue = Tl.U$.FromHex(t.slice(1)))
                    : i === this.getName("E") || i === this.getName("DC")
                    ? (r.value.ia5String = t)
                    : (r.value.printableString = t);
                e.push(r);
              }
            }
            t.push(e);
          }
          return t;
        }
        toArrayBuffer() {
          return Dd.serialize(this.asn);
        }
        async getThumbprint(...e) {
          var t;
          let r,
            i = "SHA-1";
          return (
            e.length >= 1 &&
            !(null === (t = e[0]) || void 0 === t ? void 0 : t.subtle)
              ? ((i = e[0] || i), (r = e[1] || Aw.get()))
              : (r = e[0] || Aw.get()),
            await r.subtle.digest(i, this.toArrayBuffer())
          );
        }
      }
      const Sw = "Cannot initialize GeneralName from ASN.1 data.",
        Tw = `${Sw} Unsupported string format in use.`,
        _w = `${Sw} Value doesn't match to GUID regular expression.`,
        Cw =
          /^([0-9a-f]{8})-?([0-9a-f]{4})-?([0-9a-f]{4})-?([0-9a-f]{4})-?([0-9a-f]{12})$/i,
        xw = "1.3.6.1.4.1.311.25.1",
        Nw = "1.3.6.1.4.1.311.20.2.3",
        kw = "dns",
        Rw = "dn",
        Bw = "email",
        Dw = "ip",
        Ow = "url",
        Lw = "guid",
        Pw = "upn",
        Uw = "id";
      class Mw extends fw {
        constructor(...e) {
          let t;
          if (2 === e.length)
            switch (e[0]) {
              case Rw: {
                const r = new Iw(e[1]).toArrayBuffer(),
                  i = Dd.parse(r, Gd);
                t = new Xd({ directoryName: i });
                break;
              }
              case kw:
                t = new Xd({ dNSName: e[1] });
                break;
              case Bw:
                t = new Xd({ rfc822Name: e[1] });
                break;
              case Lw: {
                const r = new RegExp(Cw, "i").exec(e[1]);
                if (!r)
                  throw new Error(
                    "Cannot parse GUID value. Value doesn't match to regular expression"
                  );
                const i = r
                  .slice(1)
                  .map((e, t) =>
                    t < 3
                      ? Tl.U$.ToHex(new Uint8Array(Tl.U$.FromHex(e)).reverse())
                      : e
                  )
                  .join("");
                t = new Xd({
                  otherName: new Wd({
                    typeId: xw,
                    value: Dd.serialize(new Ku(Tl.U$.FromHex(i))),
                  }),
                });
                break;
              }
              case Dw:
                t = new Xd({ iPAddress: e[1] });
                break;
              case Uw:
                t = new Xd({ registeredID: e[1] });
                break;
              case Pw:
                t = new Xd({
                  otherName: new Wd({
                    typeId: Nw,
                    value: Dd.serialize(od.toASN(e[1])),
                  }),
                });
                break;
              case Ow:
                t = new Xd({ uniformResourceIdentifier: e[1] });
                break;
              default:
                throw new Error(
                  "Cannot create GeneralName. Unsupported type of the name"
                );
            }
          else t = Tl._H.isBufferSource(e[0]) ? Dd.parse(e[0], Xd) : e[0];
          super(t);
        }
        onInit(e) {
          if (null != e.dNSName) (this.type = kw), (this.value = e.dNSName);
          else if (null != e.rfc822Name)
            (this.type = Bw), (this.value = e.rfc822Name);
          else if (null != e.iPAddress)
            (this.type = Dw), (this.value = e.iPAddress);
          else if (null != e.uniformResourceIdentifier)
            (this.type = Ow), (this.value = e.uniformResourceIdentifier);
          else if (null != e.registeredID)
            (this.type = Uw), (this.value = e.registeredID);
          else if (null != e.directoryName)
            (this.type = Rw), (this.value = new Iw(e.directoryName).toString());
          else {
            if (null == e.otherName) throw new Error(Tw);
            if (e.otherName.typeId === xw) {
              this.type = Lw;
              const t = Dd.parse(e.otherName.value, Ku),
                r = new RegExp(Cw, "i").exec(Tl.U$.ToHex(t));
              if (!r) throw new Error(_w);
              this.value = r
                .slice(1)
                .map((e, t) =>
                  t < 3
                    ? Tl.U$.ToHex(new Uint8Array(Tl.U$.FromHex(e)).reverse())
                    : e
                )
                .join("-");
            } else {
              if (e.otherName.typeId !== Nw) throw new Error(Tw);
              (this.type = Pw),
                (this.value = Dd.parse(e.otherName.value, Hd).toString());
            }
          }
        }
        toJSON() {
          return { type: this.type, value: this.value };
        }
        toTextObject() {
          let e;
          switch (this.type) {
            case Rw:
            case kw:
            case Lw:
            case Dw:
            case Uw:
            case Pw:
            case Ow:
              e = this.type.toUpperCase();
              break;
            case Bw:
              e = "Email";
              break;
            default:
              throw new Error("Unsupported GeneralName type");
          }
          let t = this.value;
          return this.type === Uw && (t = dw.toString(t)), new uw(e, void 0, t);
        }
      }
      class Fw extends fw {
        constructor(e) {
          let t;
          if (e instanceof cp) t = e;
          else if (Array.isArray(e)) {
            const r = [];
            for (const t of e)
              if (t instanceof Xd) r.push(t);
              else {
                const e = Dd.parse(new Mw(t.type, t.value).rawData, Xd);
                r.push(e);
              }
            t = new cp(r);
          } else {
            if (!Tl._H.isBufferSource(e))
              throw new Error(
                "Cannot initialize GeneralNames. Incorrect incoming arguments"
              );
            t = Dd.parse(e, cp);
          }
          super(t);
        }
        onInit(e) {
          const t = [];
          for (const r of e) {
            let e = null;
            try {
              e = new Mw(r);
            } catch {
              continue;
            }
            t.push(e);
          }
          this.items = t;
        }
        toJSON() {
          return this.items.map((e) => e.toJSON());
        }
        toTextObject() {
          const e = super.toTextObjectEmpty();
          for (const t of this.items) {
            const r = t.toTextObject();
            let i = e[r[uw.NAME]];
            Array.isArray(i) || ((i = []), (e[r[uw.NAME]] = i)), i.push(r);
          }
          return e;
        }
      }
      Fw.NAME = "GeneralNames";
      const Hw = "-{5}",
        Qw = "\\n",
        Vw = "\\n",
        zw = `${`${Hw}BEGIN (${`[^${Qw}]+`}(?=${Hw}))${Hw}`}${Vw}(?:((?:${`[^:${Qw}]+`}: ${`(?:[^${Qw}]+${Vw}(?: +[^${Qw}]+${Vw})*)`})+))?${Vw}?(${`(?:[a-zA-Z0-9=+/]+${Vw})+`})${`${Hw}END \\1${Hw}`}`;
      class qw {
        static isPem(e) {
          return "string" == typeof e && new RegExp(zw, "g").test(e);
        }
        static decodeWithHeaders(e) {
          e = e.replace(/\r/g, "");
          const t = new RegExp(zw, "g"),
            r = [];
          let i = null;
          for (; (i = t.exec(e)); ) {
            const e = i[3].replace(new RegExp(`[${Qw}]+`, "g"), ""),
              t = { type: i[1], headers: [], rawData: Tl.U$.FromBase64(e) },
              s = i[2];
            if (s) {
              const e = s.split(new RegExp(Vw, "g"));
              let r = null;
              for (const i of e) {
                const [e, s] = i.split(/:(.*)/);
                if (void 0 === s) {
                  if (!r)
                    throw new Error(
                      "Cannot parse PEM string. Incorrect header value"
                    );
                  r.value += e.trim();
                } else r && t.headers.push(r), (r = { key: e, value: s.trim() });
              }
              r && t.headers.push(r);
            }
            r.push(t);
          }
          return r;
        }
        static decode(e) {
          return this.decodeWithHeaders(e).map((e) => e.rawData);
        }
        static decodeFirst(e) {
          const t = this.decode(e);
          if (!t.length)
            throw new RangeError("PEM string doesn't contain any objects");
          return t[0];
        }
        static encode(e, t) {
          if (Array.isArray(e)) {
            const r = new Array();
            return (
              t
                ? e.forEach((e) => {
                    if (!Tl._H.isBufferSource(e))
                      throw new TypeError(
                        "Cannot encode array of BufferSource in PEM format. Not all items of the array are BufferSource"
                      );
                    r.push(
                      this.encodeStruct({
                        type: t,
                        rawData: Tl._H.toArrayBuffer(e),
                      })
                    );
                  })
                : e.forEach((e) => {
                    if (!("type" in e))
                      throw new TypeError(
                        "Cannot encode array of PemStruct in PEM format. Not all items of the array are PemStrut"
                      );
                    r.push(this.encodeStruct(e));
                  }),
              r.join("\n")
            );
          }
          if (!t) throw new Error("Required argument 'tag' is missed");
          return this.encodeStruct({ type: t, rawData: Tl._H.toArrayBuffer(e) });
        }
        static encodeStruct(e) {
          var t;
          const r = e.type.toLocaleUpperCase(),
            i = [];
          if (
            (i.push(`-----BEGIN ${r}-----`),
            null === (t = e.headers) || void 0 === t ? void 0 : t.length)
          ) {
            for (const t of e.headers) i.push(`${t.key}: ${t.value}`);
            i.push("");
          }
          const s = Tl.U$.ToBase64(e.rawData);
          let n,
            a = 0;
          const o = Array();
          for (
            ;
            a < s.length &&
            (s.length - a < 64
              ? (n = s.substring(a))
              : ((n = s.substring(a, a + 64)), (a += 64)),
            0 !== n.length) &&
            (o.push(n), !(n.length < 64));
  
          );
          return i.push(...o), i.push(`-----END ${r}-----`), i.join("\n");
        }
      }
      (qw.CertificateTag = "CERTIFICATE"),
        (qw.CrlTag = "CRL"),
        (qw.CertificateRequestTag = "CERTIFICATE REQUEST"),
        (qw.PublicKeyTag = "PUBLIC KEY"),
        (qw.PrivateKeyTag = "PRIVATE KEY");
      class Gw extends fw {
        static isAsnEncoded(e) {
          return Tl._H.isBufferSource(e) || "string" == typeof e;
        }
        static toArrayBuffer(e) {
          if ("string" == typeof e) {
            if (qw.isPem(e)) return qw.decode(e)[0];
            if (Tl.U$.isHex(e)) return Tl.U$.FromHex(e);
            if (Tl.U$.isBase64(e)) return Tl.U$.FromBase64(e);
            if (Tl.U$.isBase64Url(e)) return Tl.U$.FromBase64Url(e);
            throw new TypeError(
              "Unsupported format of 'raw' argument. Must be one of DER, PEM, HEX, Base64, or Base4Url"
            );
          }
          {
            const t = Tl.U$.ToBinary(e);
            return qw.isPem(t)
              ? qw.decode(t)[0]
              : Tl.U$.isHex(t)
              ? Tl.U$.FromHex(t)
              : Tl.U$.isBase64(t)
              ? Tl.U$.FromBase64(t)
              : Tl.U$.isBase64Url(t)
              ? Tl.U$.FromBase64Url(t)
              : Tl._H.toArrayBuffer(e);
          }
        }
        constructor(...e) {
          Gw.isAsnEncoded(e[0])
            ? super(Gw.toArrayBuffer(e[0]), e[1])
            : super(e[0]);
        }
        toString(e = "pem") {
          return "pem" === e
            ? qw.encode(this.rawData, this.tag)
            : super.toString(e);
        }
      }
      class jw extends Gw {
        constructor(e) {
          Gw.isAsnEncoded(e) ? super(e, wf) : super(e),
            (this.tag = qw.PublicKeyTag);
        }
        async export(...e) {
          let t,
            r = ["verify"],
            i = { hash: "SHA-256", ...this.algorithm };
          e.length > 1
            ? ((i = e[0] || i), (r = e[1] || r), (t = e[2] || Aw.get()))
            : (t = e[0] || Aw.get());
          let s = this.rawData;
          const n = Dd.parse(this.rawData, wf);
          return (
            n.algorithm.algorithm === _m &&
              (s = (function (e, t) {
                return (
                  (e.algorithm = new Af({ algorithm: Im, parameters: null })),
                  (t = Dd.serialize(e)),
                  t
                );
              })(n, s)),
            t.subtle.importKey("spki", s, i, !0, r)
          );
        }
        onInit(e) {
          const t = Ty.resolve(kA),
            r = (this.algorithm = t.toWebAlgorithm(e.algorithm));
          switch (e.algorithm.algorithm) {
            case Im: {
              const t = Dd.parse(e.subjectPublicKey, $m),
                i = Tl._H.toUint8Array(t.modulus);
              (r.publicExponent = Tl._H.toUint8Array(t.publicExponent)),
                (r.modulusLength = (i[0] ? i : i.slice(1)).byteLength << 3);
              break;
            }
          }
        }
        async getThumbprint(...e) {
          var t;
          let r,
            i = "SHA-1";
          return (
            e.length >= 1 &&
            !(null === (t = e[0]) || void 0 === t ? void 0 : t.subtle)
              ? ((i = e[0] || i), (r = e[1] || Aw.get()))
              : (r = e[0] || Aw.get()),
            await r.subtle.digest(i, this.rawData)
          );
        }
        async getKeyIdentifier(e) {
          e || (e = Aw.get());
          const t = Dd.parse(this.rawData, wf);
          return await e.subtle.digest("SHA-1", t.subjectPublicKey);
        }
        toTextObject() {
          const e = this.toTextObjectEmpty(),
            t = Dd.parse(this.rawData, wf);
          if (
            ((e.Algorithm = pw.serializeAlgorithm(t.algorithm)),
            t.algorithm.algorithm === nm)
          )
            e["EC Point"] = t.subjectPublicKey;
          else e["Raw Data"] = t.subjectPublicKey;
          return e;
        }
      }
      class Ww {
        static register(e, t) {
          this.items.set(e, t);
        }
        static create(e) {
          const t = new gw(e),
            r = this.items.get(t.type);
          return r ? new r(e) : t;
        }
      }
      Ww.items = new Map();
      const Yw = "crypto.signatureFormatter";
      class Xw extends Gw {
        constructor(e) {
          Gw.isAsnEncoded(e) ? super(e, Cf) : super(e),
            (this.tag = qw.CertificateTag);
        }
        onInit(e) {
          const t = e.tbsCertificate;
          (this.tbs = Dd.serialize(t)),
            (this.serialNumber = Tl.U$.ToHex(t.serialNumber)),
            (this.subjectName = new Iw(t.subject)),
            (this.subject = new Iw(t.subject).toString()),
            (this.issuerName = new Iw(t.issuer)),
            (this.issuer = this.issuerName.toString());
          const r = Ty.resolve(kA);
          (this.signatureAlgorithm = r.toWebAlgorithm(e.signatureAlgorithm)),
            (this.signature = e.signatureValue);
          const i =
            t.validity.notBefore.utcTime || t.validity.notBefore.generalTime;
          if (!i) throw new Error("Cannot get 'notBefore' value");
          this.notBefore = i;
          const s =
            t.validity.notAfter.utcTime || t.validity.notAfter.generalTime;
          if (!s) throw new Error("Cannot get 'notAfter' value");
          (this.notAfter = s),
            (this.extensions = []),
            t.extensions &&
              (this.extensions = t.extensions.map((e) =>
                Ww.create(Dd.serialize(e))
              )),
            (this.publicKey = new jw(t.subjectPublicKeyInfo));
        }
        getExtension(e) {
          for (const t of this.extensions)
            if ("string" == typeof e) {
              if (t.type === e) return t;
            } else if (t instanceof e) return t;
          return null;
        }
        getExtensions(e) {
          return this.extensions.filter((t) =>
            "string" == typeof e ? t.type === e : t instanceof e
          );
        }
        async verify(e = {}, t = Aw.get()) {
          let r, i;
          const s = e.publicKey;
          try {
            if (s)
              if ("publicKey" in s)
                (r = { ...s.publicKey.algorithm, ...this.signatureAlgorithm }),
                  (i = await s.publicKey.export(r, ["verify"], t));
              else if (s instanceof jw)
                (r = { ...s.algorithm, ...this.signatureAlgorithm }),
                  (i = await s.export(r, ["verify"], t));
              else if (Tl._H.isBufferSource(s)) {
                const e = new jw(s);
                (r = { ...e.algorithm, ...this.signatureAlgorithm }),
                  (i = await e.export(r, ["verify"], t));
              } else
                (r = { ...s.algorithm, ...this.signatureAlgorithm }), (i = s);
            else
              (r = { ...this.publicKey.algorithm, ...this.signatureAlgorithm }),
                (i = await this.publicKey.export(r, ["verify"], t));
          } catch (e) {
            return !1;
          }
          const n = Ty.resolveAll(Yw).reverse();
          let a = null;
          for (const e of n)
            if (((a = e.toWebSignature(r, this.signature)), a)) break;
          if (!a)
            throw Error(
              "Cannot convert ASN.1 signature value to WebCrypto format"
            );
          const o = await t.subtle.verify(
            this.signatureAlgorithm,
            i,
            a,
            this.tbs
          );
          if (e.signatureOnly) return o;
          {
            const t = (e.date || new Date()).getTime();
            return (
              o && this.notBefore.getTime() < t && t < this.notAfter.getTime()
            );
          }
        }
        async getThumbprint(...e) {
          let t,
            r = "SHA-1";
          return (
            e[0] && (e[0].subtle ? (t = e[0]) : ((r = e[0] || r), (t = e[1]))),
            null != t || (t = Aw.get()),
            await t.subtle.digest(r, this.rawData)
          );
        }
        async isSelfSigned(e = Aw.get()) {
          return (
            this.subject === this.issuer &&
            (await this.verify({ signatureOnly: !0 }, e))
          );
        }
        toTextObject() {
          const e = this.toTextObjectEmpty(),
            t = Dd.parse(this.rawData, Cf),
            r = t.tbsCertificate,
            i = new uw("", {
              Version: `${Tf[r.version]} (${r.version})`,
              "Serial Number": r.serialNumber,
              "Signature Algorithm": pw.serializeAlgorithm(r.signature),
              Issuer: this.issuer,
              Validity: new uw("", {
                "Not Before": r.validity.notBefore.getTime(),
                "Not After": r.validity.notAfter.getTime(),
              }),
              Subject: this.subject,
              "Subject Public Key Info": this.publicKey,
            });
          if (
            (r.issuerUniqueID && (i["Issuer Unique ID"] = r.issuerUniqueID),
            r.subjectUniqueID && (i["Subject Unique ID"] = r.subjectUniqueID),
            this.extensions.length)
          ) {
            const e = new uw("");
            for (const t of this.extensions) {
              const r = t.toTextObject();
              e[r[uw.NAME]] = r;
            }
            i.Extensions = e;
          }
          return (
            (e.Data = i),
            (e.Signature = new uw("", {
              Algorithm: pw.serializeAlgorithm(t.signatureAlgorithm),
              "": t.signatureValue,
            })),
            e
          );
        }
      }
      Xw.NAME = "Certificate";
      class Kw extends gw {
        static async create(e, t = !1, r = Aw.get()) {
          if (e instanceof Xw || yw.isCryptoKey(e)) {
            const i = e instanceof Xw ? await e.publicKey.export(r) : e,
              s = await r.subtle.exportKey("spki", i),
              n = new jw(s),
              a = await n.getKeyIdentifier(r);
            return new Kw(Tl.U$.ToHex(a), t);
          }
          return new Kw(e, t);
        }
        constructor(...e) {
          if (Tl._H.isBufferSource(e[0])) super(e[0]);
          else if ("string" == typeof e[0]) {
            const t = new sp({ keyIdentifier: new ip(Tl.U$.FromHex(e[0])) });
            super(rp, e[1], Dd.serialize(t));
          } else {
            const t = e[0],
              r = t.name instanceof Fw ? Dd.parse(t.name.rawData, cp) : t.name,
              i = new sp({
                authorityCertIssuer: r,
                authorityCertSerialNumber: Tl.U$.FromHex(t.serialNumber),
              });
            super(rp, e[1], Dd.serialize(i));
          }
        }
        onInit(e) {
          super.onInit(e);
          const t = Dd.parse(e.extnValue, sp);
          t.keyIdentifier && (this.keyId = Tl.U$.ToHex(t.keyIdentifier)),
            t.authorityCertIssuer &&
              t.authorityCertSerialNumber &&
              (this.certId = {
                name: t.authorityCertIssuer,
                serialNumber: Tl.U$.ToHex(t.authorityCertSerialNumber),
              });
        }
        toTextObject() {
          const e = this.toTextObjectWithoutValue(),
            t = Dd.parse(this.value, sp);
          return (
            t.authorityCertIssuer &&
              (e["Authority Issuer"] = new Fw(
                t.authorityCertIssuer
              ).toTextObject()),
            t.authorityCertSerialNumber &&
              (e["Authority Serial Number"] = t.authorityCertSerialNumber),
            t.keyIdentifier && (e[""] = t.keyIdentifier),
            e
          );
        }
      }
      Kw.NAME = "Authority Key Identifier";
      class Jw extends gw {
        constructor(...e) {
          if (Tl._H.isBufferSource(e[0])) {
            super(e[0]);
            const t = Dd.parse(this.value, ap);
            (this.ca = t.cA), (this.pathLength = t.pathLenConstraint);
          } else {
            const t = new ap({ cA: e[0], pathLenConstraint: e[1] });
            super(np, e[2], Dd.serialize(t)),
              (this.ca = e[0]),
              (this.pathLength = e[1]);
          }
        }
        toTextObject() {
          const e = this.toTextObjectWithoutValue();
          return (
            this.ca && (e.CA = this.ca),
            void 0 !== this.pathLength && (e["Path Length"] = this.pathLength),
            e
          );
        }
      }
      var Zw, $w, eE;
      (Jw.NAME = "Basic Constraints"),
        (function (e) {
          (e.serverAuth = "1.3.6.1.5.5.7.3.1"),
            (e.clientAuth = "1.3.6.1.5.5.7.3.2"),
            (e.codeSigning = "1.3.6.1.5.5.7.3.3"),
            (e.emailProtection = "1.3.6.1.5.5.7.3.4"),
            (e.timeStamping = "1.3.6.1.5.5.7.3.8"),
            (e.ocspSigning = "1.3.6.1.5.5.7.3.9");
        })(Zw || (Zw = {}));
      class tE extends gw {
        constructor(...e) {
          if (Tl._H.isBufferSource(e[0])) {
            super(e[0]);
            const t = Dd.parse(this.value, Lp);
            this.usages = t.map((e) => e);
          } else {
            const t = new Lp(e[0]);
            super(Op, e[1], Dd.serialize(t)), (this.usages = e[0]);
          }
        }
        toTextObject() {
          const e = this.toTextObjectWithoutValue();
          return (e[""] = this.usages.map((e) => dw.toString(e)).join(", ")), e;
        }
      }
      (tE.NAME = "Extended Key Usages"),
        (function (e) {
          (e[(e.digitalSignature = 1)] = "digitalSignature"),
            (e[(e.nonRepudiation = 2)] = "nonRepudiation"),
            (e[(e.keyEncipherment = 4)] = "keyEncipherment"),
            (e[(e.dataEncipherment = 8)] = "dataEncipherment"),
            (e[(e.keyAgreement = 16)] = "keyAgreement"),
            (e[(e.keyCertSign = 32)] = "keyCertSign"),
            (e[(e.cRLSign = 64)] = "cRLSign"),
            (e[(e.encipherOnly = 128)] = "encipherOnly"),
            (e[(e.decipherOnly = 256)] = "decipherOnly");
        })($w || ($w = {}));
      class rE extends gw {
        constructor(...e) {
          if (Tl._H.isBufferSource(e[0])) {
            super(e[0]);
            const t = Dd.parse(this.value, Xp);
            this.usages = t.toNumber();
          } else {
            const t = new Xp(e[0]);
            super(jp, e[1], Dd.serialize(t)), (this.usages = e[0]);
          }
        }
        toTextObject() {
          const e = this.toTextObjectWithoutValue(),
            t = Dd.parse(this.value, Xp);
          return (e[""] = t.toJSON().join(", ")), e;
        }
      }
      rE.NAME = "Key Usages";
      class iE extends gw {
        static async create(e, t = !1, r = Aw.get()) {
          let i;
          i =
            e instanceof jw
              ? e.rawData
              : "publicKey" in e
              ? e.publicKey.rawData
              : Tl._H.isBufferSource(e)
              ? e
              : await r.subtle.exportKey("spki", e);
          const s = new jw(i),
            n = await s.getKeyIdentifier(r);
          return new iE(Tl.U$.ToHex(n), t);
        }
        constructor(...e) {
          if (Tl._H.isBufferSource(e[0])) {
            super(e[0]);
            const t = Dd.parse(this.value, uf);
            this.keyId = Tl.U$.ToHex(t);
          } else {
            const t = "string" == typeof e[0] ? Tl.U$.FromHex(e[0]) : e[0],
              r = new uf(t);
            super(hf, e[1], Dd.serialize(r)), (this.keyId = Tl.U$.ToHex(t));
          }
        }
        toTextObject() {
          const e = this.toTextObjectWithoutValue(),
            t = Dd.parse(this.value, uf);
          return (e[""] = t), e;
        }
      }
      iE.NAME = "Subject Key Identifier";
      class sE extends gw {
        constructor(...e) {
          Tl._H.isBufferSource(e[0])
            ? super(e[0])
            : super(nf, e[1], new Fw(e[0] || []).rawData);
        }
        onInit(e) {
          super.onInit(e);
          const t = Dd.parse(e.extnValue, af);
          this.names = new Fw(t);
        }
        toTextObject() {
          const e = this.toTextObjectWithoutValue(),
            t = this.names.toTextObject();
          for (const r in t) e[r] = t[r];
          return e;
        }
      }
      sE.NAME = "Subject Alternative Name";
      class nE extends gw {
        constructor(...e) {
          var t;
          if (Tl._H.isBufferSource(e[0])) {
            super(e[0]);
            const t = Dd.parse(this.value, wp);
            this.policies = t.map((e) => e.policyIdentifier);
          } else {
            const r = e[0],
              i = null !== (t = e[1]) && void 0 !== t && t,
              s = new wp(r.map((e) => new Ap({ policyIdentifier: e })));
            super(dp, i, Dd.serialize(s)), (this.policies = r);
          }
        }
        toTextObject() {
          const e = this.toTextObjectWithoutValue();
          return (
            (e.Policy = this.policies.map((e) => new uw("", {}, dw.toString(e)))),
            e
          );
        }
      }
      (nE.NAME = "Certificate Policies"), Ww.register(dp, nE);
      class aE extends fw {
        constructor(...e) {
          let t;
          if (Tl._H.isBufferSource(e[0])) t = Tl._H.toArrayBuffer(e[0]);
          else {
            const r = e[0],
              i = Array.isArray(e[1])
                ? e[1].map((e) => Tl._H.toArrayBuffer(e))
                : [];
            t = Dd.serialize(new of({ type: r, values: i }));
          }
          super(t, of);
        }
        onInit(e) {
          (this.type = e.type), (this.values = e.values);
        }
        toTextObject() {
          const e = this.toTextObjectWithoutValue();
          return (e.Value = this.values.map((e) => new uw("", { "": e }))), e;
        }
        toTextObjectWithoutValue() {
          const e = this.toTextObjectEmpty();
          return (
            e[uw.NAME] === aE.NAME && (e[uw.NAME] = dw.toString(this.type)), e
          );
        }
      }
      aE.NAME = "Attribute";
      class oE extends aE {
        constructor(...e) {
          var t;
          if (Tl._H.isBufferSource(e[0])) super(e[0]);
          else {
            const t = new wA({ printableString: e[0] });
            super(eA, [Dd.serialize(t)]);
          }
          (null !== (t = this.password) && void 0 !== t) || (this.password = "");
        }
        onInit(e) {
          if ((super.onInit(e), this.values[0])) {
            const e = Dd.parse(this.values[0], wA);
            this.password = e.toString();
          }
        }
        toTextObject() {
          const e = this.toTextObjectWithoutValue();
          return (e[uw.VALUE] = this.password), e;
        }
      }
      oE.NAME = "Challenge Password";
      class cE extends aE {
        constructor(...e) {
          var t;
          if (Tl._H.isBufferSource(e[0])) super(e[0]);
          else {
            const t = e[0],
              r = new Sf();
            for (const e of t) r.push(Dd.parse(e.rawData, If));
            super(tA, [Dd.serialize(r)]);
          }
          (null !== (t = this.items) && void 0 !== t) || (this.items = []);
        }
        onInit(e) {
          if ((super.onInit(e), this.values[0])) {
            const e = Dd.parse(this.values[0], Sf);
            this.items = e.map((e) => Ww.create(Dd.serialize(e)));
          }
        }
        toTextObject() {
          const e = this.toTextObjectWithoutValue(),
            t = this.items.map((e) => e.toTextObject());
          for (const r of t) e[r[uw.NAME]] = r;
          return e;
        }
      }
      cE.NAME = "Extensions";
      class lE {
        static register(e, t) {
          this.items.set(e, t);
        }
        static create(e) {
          const t = new aE(e),
            r = this.items.get(t.type);
          return r ? new r(e) : t;
        }
      }
      lE.items = new Map();
      let hE = (eE = class {
        static createPssParams(e, t) {
          const r = eE.getHashAlgorithm(e);
          return r
            ? new Wm({
                hashAlgorithm: r,
                maskGenAlgorithm: new Af({
                  algorithm: Qm,
                  parameters: Dd.serialize(r),
                }),
                saltLength: t,
              })
            : null;
        }
        static getHashAlgorithm(e) {
          const t = Ty.resolve(kA);
          return "string" == typeof e
            ? t.toAsnAlgorithm({ name: e })
            : "object" == typeof e && e && "name" in e
            ? t.toAsnAlgorithm(e)
            : null;
        }
        toAsnAlgorithm(e) {
          switch (e.name.toLowerCase()) {
            case "rsassa-pkcs1-v1_5":
              if (!("hash" in e))
                return new Af({ algorithm: Im, parameters: null });
              {
                let t;
                if ("string" == typeof e.hash) t = e.hash;
                else {
                  if (
                    !e.hash ||
                    "object" != typeof e.hash ||
                    !("name" in e.hash) ||
                    "string" != typeof e.hash.name
                  )
                    throw new Error("Cannot get hash algorithm name");
                  t = e.hash.name.toUpperCase();
                }
                switch (t.toLowerCase()) {
                  case "sha-1":
                    return new Af({ algorithm: Nm, parameters: null });
                  case "sha-256":
                    return new Af({ algorithm: Rm, parameters: null });
                  case "sha-384":
                    return new Af({ algorithm: Bm, parameters: null });
                  case "sha-512":
                    return new Af({ algorithm: Dm, parameters: null });
                }
              }
              break;
            case "rsa-pss":
              if ("hash" in e) {
                if (!("saltLength" in e) || "number" != typeof e.saltLength)
                  throw new Error("Cannot get 'saltLength' from 'alg' argument");
                const t = eE.createPssParams(e.hash, e.saltLength);
                if (!t) throw new Error("Cannot create PSS parameters");
                return new Af({ algorithm: _m, parameters: Dd.serialize(t) });
              }
              return new Af({ algorithm: _m, parameters: null });
          }
          return null;
        }
        toWebAlgorithm(e) {
          switch (e.algorithm) {
            case Im:
              return { name: "RSASSA-PKCS1-v1_5" };
            case Nm:
              return { name: "RSASSA-PKCS1-v1_5", hash: { name: "SHA-1" } };
            case Rm:
              return { name: "RSASSA-PKCS1-v1_5", hash: { name: "SHA-256" } };
            case Bm:
              return { name: "RSASSA-PKCS1-v1_5", hash: { name: "SHA-384" } };
            case Dm:
              return { name: "RSASSA-PKCS1-v1_5", hash: { name: "SHA-512" } };
            case _m:
              if (e.parameters) {
                const t = Dd.parse(e.parameters, Wm);
                return {
                  name: "RSA-PSS",
                  hash: Ty.resolve(kA).toWebAlgorithm(t.hashAlgorithm),
                  saltLength: t.saltLength,
                };
              }
              return { name: "RSA-PSS" };
          }
          return null;
        }
      });
      (hE = eE = Od([Cy()], hE)), Ty.registerSingleton(NA, hE);
      let uE = class {
        toAsnAlgorithm(e) {
          switch (e.name.toLowerCase()) {
            case "sha-1":
              return new Af({ algorithm: Pm });
            case "sha-256":
              return new Af({ algorithm: Mm });
            case "sha-384":
              return new Af({ algorithm: Fm });
            case "sha-512":
              return new Af({ algorithm: Hm });
          }
          return null;
        }
        toWebAlgorithm(e) {
          switch (e.algorithm) {
            case Pm:
              return { name: "SHA-1" };
            case Mm:
              return { name: "SHA-256" };
            case Fm:
              return { name: "SHA-384" };
            case Hm:
              return { name: "SHA-512" };
          }
          return null;
        }
      };
      (uE = Od([Cy()], uE)), Ty.registerSingleton(NA, uE);
      class dE {
        addPadding(e, t) {
          const r = Tl._H.toUint8Array(t),
            i = new Uint8Array(e);
          return i.set(r, e - r.length), i;
        }
        removePadding(e, t = !1) {
          let r = Tl._H.toUint8Array(e);
          for (let e = 0; e < r.length; e++)
            if (r[e]) {
              r = r.slice(e);
              break;
            }
          if (t && r[0] > 127) {
            const e = new Uint8Array(r.length + 1);
            return e.set(r, 1), e.buffer;
          }
          return r.buffer;
        }
        toAsnSignature(e, t) {
          if ("ECDSA" === e.name) {
            const r = e.namedCurve,
              i = dE.namedCurveSize.get(r) || dE.defaultNamedCurveSize,
              s = new bm(),
              n = Tl._H.toUint8Array(t);
            return (
              (s.r = this.removePadding(n.slice(0, i), !0)),
              (s.s = this.removePadding(n.slice(i, i + i), !0)),
              Dd.serialize(s)
            );
          }
          return null;
        }
        toWebSignature(e, t) {
          if ("ECDSA" === e.name) {
            const r = Dd.parse(t, bm),
              i = e.namedCurve,
              s = dE.namedCurveSize.get(i) || dE.defaultNamedCurveSize,
              n = this.addPadding(s, this.removePadding(r.r)),
              a = this.addPadding(s, this.removePadding(r.s));
            return (0, Tl.kg)(n, a);
          }
          return null;
        }
      }
      (dE.namedCurveSize = new Map()), (dE.defaultNamedCurveSize = 32);
      const pE = "1.3.101.110",
        fE = "1.3.101.111",
        gE = "1.3.101.112",
        mE = "1.3.101.113";
      let yE = class {
        toAsnAlgorithm(e) {
          let t = null;
          switch (e.name.toLowerCase()) {
            case "ed25519":
              t = gE;
              break;
            case "x25519":
              t = pE;
              break;
            case "eddsa":
              switch (e.namedCurve.toLowerCase()) {
                case "ed25519":
                  t = gE;
                  break;
                case "ed448":
                  t = mE;
              }
              break;
            case "ecdh-es":
              switch (e.namedCurve.toLowerCase()) {
                case "x25519":
                  t = pE;
                  break;
                case "x448":
                  t = fE;
              }
          }
          return t ? new Af({ algorithm: t }) : null;
        }
        toWebAlgorithm(e) {
          switch (e.algorithm) {
            case gE:
              return { name: "Ed25519" };
            case mE:
              return { name: "EdDSA", namedCurve: "Ed448" };
            case pE:
              return { name: "X25519" };
            case fE:
              return { name: "ECDH-ES", namedCurve: "X448" };
          }
          return null;
        }
      };
      (yE = Od([Cy()], yE)), Ty.registerSingleton(NA, yE);
      class AE extends Gw {
        constructor(e) {
          Gw.isAsnEncoded(e) ? super(e, xA) : super(e),
            (this.tag = qw.CertificateRequestTag);
        }
        onInit(e) {
          (this.tbs = Dd.serialize(e.certificationRequestInfo)),
            (this.publicKey = new jw(e.certificationRequestInfo.subjectPKInfo));
          const t = Ty.resolve(kA);
          (this.signatureAlgorithm = t.toWebAlgorithm(e.signatureAlgorithm)),
            (this.signature = e.signature),
            (this.attributes = e.certificationRequestInfo.attributes.map((e) =>
              lE.create(Dd.serialize(e))
            ));
          const r = this.getAttribute(tA);
          (this.extensions = []),
            r instanceof cE && (this.extensions = r.items),
            (this.subjectName = new Iw(e.certificationRequestInfo.subject)),
            (this.subject = this.subjectName.toString());
        }
        getAttribute(e) {
          for (const t of this.attributes) if (t.type === e) return t;
          return null;
        }
        getAttributes(e) {
          return this.attributes.filter((t) => t.type === e);
        }
        getExtension(e) {
          for (const t of this.extensions) if (t.type === e) return t;
          return null;
        }
        getExtensions(e) {
          return this.extensions.filter((t) => t.type === e);
        }
        async verify(e = Aw.get()) {
          const t = { ...this.publicKey.algorithm, ...this.signatureAlgorithm },
            r = await this.publicKey.export(t, ["verify"], e),
            i = Ty.resolveAll(Yw).reverse();
          let s = null;
          for (const e of i)
            if (((s = e.toWebSignature(t, this.signature)), s)) break;
          if (!s)
            throw Error(
              "Cannot convert WebCrypto signature value to ASN.1 format"
            );
          return await e.subtle.verify(this.signatureAlgorithm, r, s, this.tbs);
        }
        toTextObject() {
          const e = this.toTextObjectEmpty(),
            t = Dd.parse(this.rawData, xA),
            r = t.certificationRequestInfo,
            i = new uw("", {
              Version: `${Tf[r.version]} (${r.version})`,
              Subject: this.subject,
              "Subject Public Key Info": this.publicKey,
            });
          if (this.attributes.length) {
            const e = new uw("");
            for (const t of this.attributes) {
              const r = t.toTextObject();
              e[r[uw.NAME]] = r;
            }
            i.Attributes = e;
          }
          return (
            (e.Data = i),
            (e.Signature = new uw("", {
              Algorithm: pw.serializeAlgorithm(t.signatureAlgorithm),
              "": t.signature,
            })),
            e
          );
        }
      }
      AE.NAME = "PKCS#10 Certificate Request";
      var wE;
      !(function (e) {
        (e[(e.unspecified = 0)] = "unspecified"),
          (e[(e.keyCompromise = 1)] = "keyCompromise"),
          (e[(e.cACompromise = 2)] = "cACompromise"),
          (e[(e.affiliationChanged = 3)] = "affiliationChanged"),
          (e[(e.superseded = 4)] = "superseded"),
          (e[(e.cessationOfOperation = 5)] = "cessationOfOperation"),
          (e[(e.certificateHold = 6)] = "certificateHold"),
          (e[(e.removeFromCRL = 8)] = "removeFromCRL"),
          (e[(e.privilegeWithdrawn = 9)] = "privilegeWithdrawn"),
          (e[(e.aACompromise = 10)] = "aACompromise");
      })(wE || (wE = {}));
      Ww.register(np, Jw),
        Ww.register(Op, tE),
        Ww.register(jp, rE),
        Ww.register(hf, iE),
        Ww.register(rp, Kw),
        Ww.register(nf, sE),
        lE.register(eA, oE),
        lE.register(tA, cE),
        Ty.registerSingleton(
          Yw,
          class {
            toAsnSignature(e, t) {
              return Tl._H.toArrayBuffer(t);
            }
            toWebSignature(e, t) {
              return Tl._H.toArrayBuffer(t);
            }
          }
        ),
        Ty.registerSingleton(Yw, dE),
        dE.namedCurveSize.set("P-256", 32),
        dE.namedCurveSize.set("K-256", 32),
        dE.namedCurveSize.set("P-384", 48),
        dE.namedCurveSize.set("P-521", 66);
      const EE = /-{5}(BEGIN|END) .*-{5}/gm;
      async function bE({
        hash: e,
        signature: t,
        publicKey: r,
        domain: i,
        domainCert: s,
        created: n,
        software: a,
      } = {}) {
        let o;
        const c = [];
        if (((t = (0, Sl.toByteArray)(t)), s && i && !r)) {
          const e = s.split("\n\n"),
            i = (0, Sl.toByteArray)(e[0].replace(EE, "").replace(/\s/gm, "")),
            n = ns(await crypto.subtle.digest("SHA-256", i));
          c.push({ id: "certFingerprint", expected: n, matched: null });
          const a = new Xw(i);
          r = await a.publicKey.export();
          const l = (0, Sl.fromByteArray)(new Uint8Array(a.publicKey.rawData));
          c.push({ id: "publicKey", expected: l, matched: null }),
            a.subject && a.subject.startsWith("CN=") && (o = a.subject.split(3)),
            (t = (function (e) {
              try {
                const t = kd.parse(e, bm),
                  r = 0 === t.r[0] ? t.r.slice(1) : t.r,
                  i = 0 === t.s[0] ? t.s.slice(1) : t.s;
                e = Ii([r, i], r.length + i.length);
              } catch (e) {
                console.log(e);
              }
              return e;
            })(t));
        } else {
          const e = { name: "ECDSA", namedCurve: "P-384" };
          c.push({ id: "publicKey", expected: r, matched: null }),
            (r = await crypto.subtle.importKey(
              "spki",
              (0, Sl.toByteArray)(r),
              e,
              !0,
              ["verify"]
            ));
        }
        const l = new TextEncoder(),
          h = await crypto.subtle.verify(
            { name: "ECDSA", hash: "SHA-256" },
            r,
            t,
            l.encode(e)
          );
        return (
          c.push({ id: "signature", expected: !0, matched: h }),
          n && c.push({ id: "created", expected: n, matched: null }),
          a && c.push({ id: "software", expected: a, matched: null }),
          i && c.push({ id: "domain", expected: i, matched: o }),
          c
        );
      }
      const vE = "pages/pages.jsonl",
        IE = "pages/extraPages.jsonl",
        SE = "datapackage.json",
        TE = "datapackage-digest.json",
        _E = "webarchive.yaml";
      class CE {
        constructor(e, t, r = !0) {
          (this.file = t),
            (this.waczname = t.waczname),
            (this.store = e),
            (this.isRoot = r);
        }
        async loadFileFromWACZ(e, t) {
          return this.store.loadFileFromWACZ
            ? await this.store.loadFileFromWACZ(this.file, e, t)
            : await this.file.loadFile(e, t);
        }
        async load() {
          let e,
            t = null;
          return (
            this.file.containsFile(TE) && (t = await this.loadDigestData(TE)),
            this.file.containsFile(SE)
              ? (e = await this.loadPackage(SE, t))
              : this.file.containsFile(_E) &&
                (e = await this.loadOldPackageYAML(_E)),
            e || {}
          );
        }
        async loadTextFileFromWACZ(e, t = !1) {
          const { reader: r, hasher: i } = await this.loadFileFromWACZ(e, {
              computeHash: !!t,
            }),
            s = new TextDecoder().decode(await r.readFully());
          return (
            t &&
              i &&
              (await this.store.addVerifyData(this.waczname, e, t, i.getHash())),
            s
          );
        }
        async loadDigestData(e) {
          try {
            const t = JSON.parse(await this.loadTextFileFromWACZ(e));
            let r;
            t.path === SE && t.hash && (r = t.hash);
            const i = this.store,
              s = this.isRoot ? "" : this.waczname + ":";
            if (!t.signedData || t.signedData.hash !== r)
              return void (await i.addVerifyData(s, "signature"));
            await i.addVerifyData(s, "datapackageHash", r);
            const n = await bE(t.signedData);
            return await i.addVerifyDataList(s, n), r;
          } catch (e) {
            console.warn(e);
          }
        }
        async loadPackage(e, t) {
          const r = await this.loadTextFileFromWACZ(e, t),
            i = JSON.parse(r);
          switch (
            (this.isRoot &&
              void 0 !== i.config &&
              this.store.initConfig(i.config),
            i.profile)
          ) {
            case "data-package":
            case "wacz-package":
            case void 0:
            case null:
              return await this.loadLeafWACZPackage(i);
            case "multi-wacz-package":
              return await this.loadMultiWACZPackage(i);
            default:
              throw new Error(`Unknown package profile: ${i.profile}`);
          }
        }
        async loadMultiWACZPackage(e) {
          return (
            this.file.markAsMultiWACZ(),
            await this.store.loadWACZFiles(e, this.file),
            e
          );
        }
        async loadLeafWACZPackage(e) {
          const t = e.metadata || {};
          let r = null;
          for (const t of e.resources)
            t.path === vE
              ? ((r = t.hash),
                await this.store.addVerifyData(this.waczname, t.path, t.hash))
              : (t.path.endsWith(".idx") || t.path.endsWith(".cdx")) &&
                (await this.store.addVerifyData(this.waczname, t.path, t.hash));
          if (this.file.containsFile(vE)) {
            (await this.loadPages(vE, r)).hasText &&
              (this.store.textIndex = t.textIndex = vE);
          }
          return (
            this.file.containsFile(IE) &&
              (this.store.textIndex = t.textIndex = IE),
            t
          );
        }
        async loadOldPackageYAML(e) {
          const t = await this.loadTextFileFromWACZ(e),
            r = Il.load(t),
            i = { desc: r.desc, title: r.title };
          r.textIndex &&
            ((i.textIndex = r.textIndex),
            r.config || (r.config = {}),
            (r.config.textIndex = r.textIndex)),
            this.isRoot && void 0 !== r.config && this.store.initConfig(r.config),
            i.title || (i.title = this.store.config.sourceName);
          const s = r.pages || [];
          s && s.length && (await this.store.addPages(s));
          const n = r.pageLists || [];
          return (
            n &&
              n.length &&
              (await this.store.addCuratedPageLists(n, "pages", "show")),
            i
          );
        }
        async loadPages(e = vE, t = null) {
          const { reader: r, hasher: i } = await this.loadFileFromWACZ(e, {
            unzip: !0,
            computeHash: !0,
          });
          let s = null,
            n = [];
          for await (const e of r.iterLines()) {
            const t = JSON.parse(e);
            this.waczname && (t.wacz = this.waczname),
              s
                ? (n.push(t),
                  500 === n.length && (await this.store.addPages(n), (n = [])))
                : (s = t);
          }
          return (
            n.length && (await this.store.addPages(n)),
            i &&
              t &&
              (await this.store.addVerifyData(this.waczname, e, t, i.getHash())),
            s
          );
        }
      }
      class xE {
        constructor(
          e,
          { cloneResponse: t = !1, allowBody: r = !1, hostProxyOnly: i = !1 } = {}
        ) {
          if (
            ((e = e || {}),
            (this.prefix = e.prefix || ""),
            (this.proxyPathOnly = e.proxyPathOnly || !1),
            (this.isLive = void 0 === e.isLive || e.isLive),
            (this.archivePrefix = e.archivePrefix || ""),
            (this.cloneResponse = t),
            (this.allowBody = r || this.isLive),
            (this.hostProxy = e.hostProxy),
            this.hostProxy instanceof Array)
          ) {
            const e = {};
            for (const t of this.hostProxy) e[t.host] = t;
            this.hostProxy = e;
          }
          this.hostProxyOnly = i;
        }
        async getAllPages() {
          return [];
        }
        getFetchUrl(e, t, r) {
          let i;
          if (this.hostProxy) {
            i = new URL(e);
            const t = this.hostProxy[i.host];
            if (t)
              return (
                r.set("X-Proxy-Host", i.host),
                t.prefix + (t.pathOnly ? i.pathname + i.search : e)
              );
          }
          return this.hostProxyOnly
            ? null
            : this.proxyPathOnly
            ? (i || (i = new URL(e)), this.prefix + i.pathname + i.search)
            : this.isLive || !t.timestamp
            ? this.prefix + e
            : this.prefix + this.archivePrefix + t.timestamp + "id_/" + e;
        }
        async getResource(e, t) {
          const {
              headers: r,
              credentials: i,
              url: s,
            } = e.prepareProxyRequest(t, !0),
            n = this.getFetchUrl(s, e, r);
          if (!n) return null;
          let a = null;
          !this.allowBody ||
            ("POST" !== e.method && "PUT" !== e.method) ||
            (a = await e.getBody());
          const o = await fetch(n, {
            method: e.method,
            body: a,
            headers: r,
            credentials: i,
            mode: "cors",
            redirect: "follow",
          });
          let c = null;
          this.cloneResponse && (c = o.clone());
          const l = vs.fromResponse({
            url: s,
            response: o,
            date: new Date(),
            noRW: !1,
            isLive: this.isLive,
            archivePrefix: this.archivePrefix,
          });
          return c && (l.clonedResponse = c), l;
        }
      }
      const NE = /^([\w-]+,)*[\w-]+(:\d+)?,?\)\//;
      class kE extends Ia {
        constructor(e, t, r = "wacz") {
          super(e.dbname, e.noCache),
            (this.config = e),
            (this.waczfiles = {}),
            (this.waczNameForHash = {}),
            (this.ziploadercache = {}),
            (this.updating = null),
            (this.rootSourceType = r),
            (this.sourceLoader = t),
            (this.externalSource = null),
            (this.fuzzyUrlRules = []),
            (this.textIndex = (e && e.metadata && e.metadata.textIndex) || IE),
            e.extraConfig && this.initConfig(e.extraConfig);
        }
        initConfig(e) {
          if (
            (void 0 !== e.decodeResponses &&
              (this.config.decode = e.decodeResponses),
            e.hostProxy &&
              (this.externalSource = new xE(e, { hostProxyOnly: !0 })),
            e.fuzzy)
          )
            for (const [t, r] of e.fuzzy) {
              const e = new RegExp(t);
              this.fuzzyUrlRules.push({ match: e, replace: r });
            }
          e.textIndex && (this.textIndex = e.textIndex);
        }
        updateHeaders(e) {
          this.sourceLoader && (this.sourceLoader.headers = e);
        }
        _initDB(e, t, r, i) {
          super._initDB(e, t, r, i),
            t ||
              (e.createObjectStore("ziplines", {
                keyPath: ["waczname", "prefix"],
              }),
              e.createObjectStore("waczfiles", { keyPath: "waczname" }),
              e.createObjectStore("verification", { keyPath: "id" })),
            2 === t && this.convertV2WACZDB(e, i),
            3 === t && e.createObjectStore("verification", { keyPath: "id" });
        }
        async convertV2WACZDB(e, t) {
          try {
            const r = await t.objectStore("ziplines").getAll(),
              i = await t.objectStore("zipEntries").getAll();
            e.deleteObjectStore("ziplines"),
              e.deleteObjectStore("zipEntries"),
              e.createObjectStore("ziplines", {
                keyPath: ["waczname", "prefix"],
              }),
              e.createObjectStore("waczfiles", { keyPath: "waczname" }),
              e.createObjectStore("verification", { keyPath: "id" });
            const s = this.config.loadUrl;
            for (const e of r) (e.waczname = s), t.objectStore("ziplines").put(e);
            const n = r.length > 0 ? 2 : 1,
              a = await this.computeHash(s),
              o = new Ha({
                waczname: s,
                hash: a,
                url: s,
                entries: i,
                indexType: n,
              });
            t.objectStore("waczfiles").put(o.serialize()), await t.done;
          } catch (e) {
            console.warn(e);
          }
        }
        addWACZFile(e) {
          return (
            (this.waczfiles[e.waczname] = new Ha(e)),
            (this.waczNameForHash[e.hash] = e.waczname),
            this.waczfiles[e.waczname]
          );
        }
        async init() {
          await super.init();
          const e = (await this.db.getAll("waczfiles")) || [];
          for (const t of e) this.addWACZFile({ ...t, parent: this });
          for (const [e, t] of Object.entries(this.waczfiles)) {
            t.path = t.path || e;
            const r = t.path.lastIndexOf("#!/");
            if (r > 0) {
              const e = t.path.slice(0, r),
                i = this.waczfiles[e];
              t.parent = i;
            } else
              "json" !== this.rootSourceType && (t.loader = this.sourceLoader);
          }
          await this.checkUpdates();
        }
        async close() {
          super.close(), caches.delete("cache:" + this.name.slice(3));
        }
        async clearZipData() {
          const e = ["waczfiles", "ziplines"];
          for (const t of e) await this.db.clear(t);
        }
        async addVerifyData(e = "", t, r, i, s = !1) {
          let n = null;
          e && (t = e + t),
            i && ((n = r === i), s && console.log(`verify ${t}: ${n}`)),
            await this.db.put("verification", { id: t, expected: r, matched: n });
        }
        async addVerifyDataList(e, t) {
          const r = this.db.transaction("verification", "readwrite");
          for (const i of t) e && (i.id = e + i.id), r.store.put(i);
          try {
            await r.done;
          } catch (e) {
            console.warn(e);
          }
        }
        async getVerifyInfo() {
          const e = await this.db.getAll("verification");
          let t = 0,
            r = 0,
            i = {};
          const s = [
            "domain",
            "created",
            "certFingerprint",
            "software",
            "datapackageHash",
            "publicKey",
          ];
          for (const n of e)
            s.includes(n.id)
              ? (i[n.id] = n.expected)
              : "signature" === n.id || !0 === n.matched
              ? t++
              : !1 === n.matched && r++;
          return (i.numInvalid = r), (i.numValid = t), i;
        }
        async getVerifyExpected(e) {
          const t = await this.db.get("verification", e);
          return t && t.expected;
        }
        async clearAll() {
          await super.clearAll(), await this.clearZipData();
        }
        async loadRecordFromSource(e) {
          const { start: t, length: r, path: i, wacz: s } = e.source,
            n = { offset: t, length: r, unzip: !0, computeHash: !0 },
            a = s,
            { reader: o, hasher: c } = await this.loadFileFromNamedWACZ(
              a,
              "archive/" + i,
              n
            ),
            l = new Tn(o, c);
          await this.waczfiles[a].save(this.db);
          const h = await l.load();
          return (
            e[Na] && (h.respHeaders["x-wabac-preset-cookie"] = e[Na]),
            { remote: h, hasher: c }
          );
        }
        async loadIndex(e) {
          if (!this.waczfiles[e]) throw new Error("unknown waczfile: " + e);
          if (this.waczfiles[e].indexType)
            return { indexType: this.waczfiles[e].indexType, isNew: !1 };
          let t = 0;
          for (const r of this.waczfiles[e].iterContainedFiles())
            r.endsWith(".cdx") || r.endsWith(".cdxj")
              ? (console.log(`Loading CDX for ${e}`),
                await this.loadCDX(r, e),
                (t = 1))
              : r.endsWith(".idx") &&
                (console.log(`Loading IDX for ${e}`),
                await this.loadIDX(r, e),
                (t = 2));
          return (
            (this.waczfiles[e].indexType = t),
            await this.waczfiles[e].save(this.db, !0),
            { indexType: t, isNew: !0 }
          );
        }
        async loadCDX(e, t, r, i) {
          const { reader: s, hasher: n } = await this.loadFileFromNamedWACZ(
              t,
              e,
              { computeHash: !0 }
            ),
            a = new Ra(s, null, t, { wacz: t }),
            o = await a.load(this, r, i);
          if (n) {
            const r = await this.getVerifyExpected(e);
            r && this.addVerifyData(t, e, r, n.getHash());
          }
          return o;
        }
        async loadIDX(e, t, r, i) {
          const { reader: s, hasher: n } = await this.loadFileFromNamedWACZ(
            t,
            e,
            { computeHash: !0 }
          );
          let a = [],
            o = "",
            c = !0,
            l = 0;
          for await (const e of s.iterLines()) {
            if (((l += e.length), l === e.length && e.startsWith("!meta"))) {
              const t = e.indexOf(" {");
              if (t < 0) {
                console.warn("Invalid Meta Line: " + e);
                continue;
              }
              const r = JSON.parse(e.slice(t));
              r.filename && (o = r.filename),
                "cdxj-gzip-1.0" !== r.format &&
                  console.log(
                    `Unknown CDXJ format "${r.format}", archive may not parse correctly`
                  );
              continue;
            }
            let s;
            if (e.indexOf("\t") > 0) {
              let [r, i, n, a] = e.split("\t");
              (n = Number(n)),
                (a = Number(a)),
                (s = {
                  waczname: t,
                  prefix: r,
                  filename: i,
                  offset: n,
                  length: a,
                  loaded: !1,
                }),
                (c = !1);
            } else {
              const r = e.indexOf(" {");
              if (r < 0) {
                console.log("Invalid Index Line: " + e);
                continue;
              }
              const i = e.slice(0, r);
              let {
                offset: n,
                length: a,
                filename: l,
                digest: h,
              } = JSON.parse(e.slice(r));
              (c = c && !NE.test(i)),
                (l = l || o),
                (s = {
                  waczname: t,
                  prefix: i,
                  filename: l,
                  offset: n,
                  length: a,
                  digest: h,
                  loaded: !1,
                });
            }
            r && r(l / i, l, i), a.push(s);
          }
          if (n) {
            const r = await this.getVerifyExpected(e);
            r && this.addVerifyData(t, e, r, n.getHash());
          }
          const h = this.db.transaction("ziplines", "readwrite");
          for (const e of a) h.store.put(e);
          try {
            await h.done;
          } catch (e) {
            console.log("Error loading ziplines index: ", e);
          }
          c &&
            c !== this.waczfiles[t].nonSurt &&
            ((this.waczfiles[t].nonSurt = c),
            await this.waczfiles[t].save(this.db, !0));
        }
        async loadCDXFromIDX(e, t, r = 0, i = !1) {
          const s = this.waczfiles[e].nonSurt ? t : Ai(t),
            n = i ? this.prefixUpperBound(s) : s + " 9999",
            a = IDBKeyRange.upperBound([e, n], !0),
            o = this.db.transaction("ziplines", "readonly"),
            c = [];
          for await (const t of o.store.iterate(a, "prev")) {
            if (t.value.waczname !== e) break;
            if ((c.unshift(t.value), !t.value.prefix.split(" ")[0].startsWith(s)))
              break;
          }
          await o.done;
          const l = [];
          c.length > 3 &&
            r &&
            c.sort((e, t) => {
              const i = e.prefix.split(" ")[1],
                s = t.prefix.split(" ")[1];
              if (!i || !s) return 0;
              const n = Math.abs(ss(i).getTime() - r),
                a = Math.abs(ss(s).getTime() - r);
              return n === a ? 0 : n < a ? -1 : 1;
            });
          let h = 0;
          for (const t of c) {
            if (t.loaded) continue;
            const r = e + ":" + t.filename + ":" + t.offset;
            let i = this.ziploadercache[r];
            if (
              (i || ((i = this.doCDXLoad(r, t, e)), (this.ziploadercache[r] = i)),
              l.push(i),
              ++h > 3)
            )
              break;
          }
          return (
            l.length && (await Promise.allSettled(l)),
            await this.waczfiles[e].save(this.db),
            l.length > 0
          );
        }
        async doCDXLoad(e, t, r) {
          try {
            const e = "indexes/" + t.filename,
              i = {
                offset: t.offset,
                length: t.length,
                unzip: !0,
                computeHash: !!t.digest,
              },
              { reader: s, hasher: n } = await this.loadFileFromNamedWACZ(
                r,
                e,
                i
              ),
              a = new Ra(s, null, null, { wacz: r });
            if ((await a.load(this), n)) {
              const i = n.getHash(),
                s = `${e}:${t.offset}-${t.length}`;
              await this.addVerifyData(r, s, t.digest, i);
            }
            (t.loaded = !0), await this.db.put("ziplines", t);
          } catch (e) {
            (await ps(e, this.config)) || console.warn(e);
          } finally {
            delete this.ziploadercache[e];
          }
        }
        async findPageAtUrl(e, t) {
          const r = await this.db.getAllFromIndex("pages", "url", e);
          let i = null,
            s = Number.MAX_SAFE_INTEGER;
          for (const e of r) {
            const r = Math.abs(e.ts - t);
            if (r < 1e3) return e;
            r < s && ((i = e), (s = r));
          }
          return i;
        }
        async lookupUrl(e, t, r = {}) {
          try {
            const { waczname: i } = r;
            let s;
            return (
              i && "local" !== i && (s = await this.lookupUrlForWACZ(i, e, t, r)),
              !s || (r.noRevisits && "warc/revisit" === s.mime)
                ? ((s = await super.lookupUrl(e, t, r)), s)
                : s
            );
          } catch (e) {
            return console.warn(e), null;
          }
        }
        async lookupUrlForWACZ(e, t, r, i) {
          const { indexType: s, isNew: n } = await this.loadIndex(e);
          switch (s) {
            case 2:
              if (!(await this.loadCDXFromIDX(e, t, r, !1))) return null;
              break;
            case 1:
              if (!n) return null;
              break;
            default:
              return null;
          }
          return await super.lookupUrl(t, r, i);
        }
        async resourcesByUrlAndMime(e, ...t) {
          let r = await super.resourcesByUrlAndMime(e, ...t);
          if (r.length > 0) return r;
          for (const i of Object.keys(this.waczfiles))
            if (i && "local" !== i) {
              const { indexType: s, isNew: n } = await this.loadIndex(i);
              switch (s) {
                case 2:
                  if (!(await this.loadCDXFromIDX(i, e, 0, !0))) continue;
                  break;
                case 1:
                  if (!n) continue;
                  break;
                default:
                  continue;
              }
              const a = await super.resourcesByUrlAndMime(e, ...t);
              a && a.length && (r = r.concat(a));
            }
          return r;
        }
        async loadFileFromWACZ(e, t, r) {
          try {
            return await e.loadFile(t, r);
          } catch (i) {
            if (await this.retryLoad(i)) return await e.loadFile(t, r);
            throw i;
          }
        }
        async loadFileFromNamedWACZ(e, t, r) {
          const i = this.waczfiles[e];
          if (!i) throw new Error("No WACZ Found for: " + e);
          return await this.loadFileFromWACZ(i, t, r);
        }
        async addNewWACZ({
          name: e,
          hash: t,
          path: r,
          parent: i = null,
          loader: s = null,
        } = {}) {
          const n = e || r;
          t
            ? t.indexOf(":") > 0 && (t = t.split(":")[1])
            : (t = await as(n, "sha-256", ""));
          const a = this.addWACZFile(
            { waczname: n, hash: t, path: r, parent: i, loader: s },
            !0
          );
          await a.init(), await a.save(this.db, !0);
          const o = new CE(this, a, !i);
          return await o.load();
        }
        async loadWACZFiles(e, t = this) {
          const r = [],
            i = async (e, t) => {
              await this.waczfiles[e].init(t),
                await this.waczfiles[e].save(this.db, !0);
            },
            s = e.resources.map((e) => {
              const r = t.getLoadPath(e.path);
              return { name: t.getName(e.name), hash: e.hash, path: r };
            });
          for (const { name: e, hash: n, path: a } of s)
            this.waczfiles[e]
              ? this.waczfiles[e].path !== a && r.push(i(e, a))
              : r.push(this.addNewWACZ({ name: e, hash: n, path: a, parent: t }));
          r.length && (await Promise.allSettled(r));
        }
        async getTextIndex() {
          const e = { "Content-Type": "application/ndjson" },
            t = Object.keys(this.waczfiles);
          if (!this.textIndex || !t.length)
            return new Response("", { headers: e });
          if (1 === t.length) {
            const r = t[0];
            let i;
            try {
              i = await this.loadFileFromNamedWACZ(r, this.textIndex, {
                unzip: !0,
              });
            } catch (t) {
              return new Response("", { headers: e });
            }
            const { reader: s } = i;
            if (!s) return new Response("", { headers: e });
            const n = this.waczfiles[r].getSizeOf(this.textIndex);
            return (
              n > 0 && (e["Content-Length"] = "" + n),
              new Response(s.getReadableStream(), { headers: e })
            );
          }
          {
            const r = [];
            for (const e of t)
              try {
                const { reader: t } = await this.loadFileFromNamedWACZ(
                  e,
                  this.textIndex,
                  { unzip: !0 }
                );
                t && r.push(t);
              } catch (e) {
                continue;
              }
            const i = new ReadableStream({
              async pull(e) {
                for (const t of r) for await (const r of t) e.enqueue(r);
                e.close();
              },
            });
            return new Response(i, { headers: e });
          }
        }
        async getResource(e, t, r, { pageId: i } = {}) {
          if ((await this.initing, this.externalSource)) {
            const i = await this.externalSource.getResource(e, t, r);
            if (i) return i;
          }
          let s = i,
            n = null,
            a = null;
          if (s) {
            if (((n = this.waczNameForHash[s]), !n)) return null;
            if (((a = await super.getResource(e, t, r, { waczname: n })), a))
              return a;
          }
          let o = new Map();
          for (const [i, n] of Object.entries(this.waczfiles))
            n.fileType === Ma &&
              n.hash !== s &&
              ((a = await super.getResource(e, t, r, {
                waczname: i,
                noFuzzyCheck: !0,
                loadFirst: !0,
              })),
              a && o.set(a.date, { name: i, hash: n.hash }));
          if (o.size > 0) {
            const r = ss(e.timestamp);
            let i,
              s,
              a = -1;
            for (const e of o.keys()) {
              const t = Math.abs(e.getTime() - r);
              if (a < 0 || t < a) {
                const { name: r, hash: c } = o.get(e);
                (n = r), (s = c), (i = is(e.toISOString())), (a = t);
              }
            }
            return Response.redirect(`${t}:${s}/${i}mp_/${e.url}`);
          }
          if (this.fuzzyUrlRules.length)
            for (const { match: i, replace: s } of this.fuzzyUrlRules) {
              const n = decodeURIComponent(e.url.replace(i, s));
              if (n && n !== e.url) {
                e.url = n;
                const i = await super.getResource(e, t, r);
                if (i) return i;
              }
            }
          return null;
        }
        async retryLoad(e) {
          return (
            "json" === this.rootSourceType &&
            (e instanceof ms
              ? (this.updating || (this.updating = this.checkUpdates()),
                await this.updating,
                (this.updating = null),
                !0)
              : await ps(e, this.config))
          );
        }
        async checkUpdates() {
          "json" === this.rootSourceType && (await this.loadFromJSON());
        }
        async loadFromJSON(e = null) {
          if (!e) {
            e = (await this.sourceLoader.doInitialFetch(!1)).response;
          }
          if (206 !== e.status && 200 !== e.status)
            return (
              console.warn("WACZ update failed from: " + this.config.loadUrl), {}
            );
          const t = await e.json();
          return t.profile, await this.loadWACZFiles(t), t;
        }
        getLoadPath(e) {
          return new URL(e, this.config.loadUrl).href;
        }
        getName(e) {
          return e;
        }
        async createLoader(e) {
          return await fa(e);
        }
      }
      class RE {
        constructor(e) {
          const t = e.extraConfig || {};
          (this.sourceUrl = t.prefix),
            (this.type = t.sourceType || "kiwix"),
            (this.notFoundPageUrl = t.notFoundPageUrl);
        }
        async getAllPages() {
          return [];
        }
        async getResource(e, t) {
          const { url: r, headers: i } = e.prepareProxyRequest(t);
          let s = i;
          if ("kiwix" === this.type) {
            let t = await this.resolveHeaders(r);
            if (!t)
              for (const e of yn.getFuzzyCanonsWithArgs(r))
                if (e !== r && ((t = await this.resolveHeaders(e)), t)) break;
            if (!t) {
              if (this.notFoundPageUrl && "navigate" === e.mode) {
                const e = await fetch(this.notFoundPageUrl);
                if (200 === e.status) {
                  const t = { "Content-Type": "text/html" },
                    i = await e.text();
                  return new Response(i.replace("$URL", r), {
                    status: 404,
                    headers: t,
                  });
                }
              }
              return null;
            }
            let {
              headers: i,
              encodedUrl: n,
              date: a,
              status: o,
              statusText: c,
              hasPayload: l,
            } = t;
            if (s.has("Range")) {
              const e = s.get("Range");
              s = { Range: e };
            }
            let h = null,
              u = null;
            l &&
              ((u = await fetch(this.sourceUrl + "A/" + n, { headers: s })),
              u.body && (h = new xi(u.body.getReader(), !1)),
              206 === u.status &&
                ((o = 206),
                (c = "Partial Content"),
                i.set("Content-Length", u.headers.get("Content-Length")),
                i.set("Content-Range", u.headers.get("Content-Range")),
                i.set("Accept-Ranges", "bytes"))),
              h || (h = new Uint8Array([])),
              a || (a = new Date()),
              i || (i = new Headers());
            return new vs({
              payload: h,
              status: o,
              statusText: c,
              headers: i,
              url: r,
              date: a,
              noRW: !1,
              isLive: !1,
            });
          }
        }
        async resolveHeaders(e) {
          const t = e.slice(e.indexOf("//") + 2);
          let r = encodeURI(t);
          r = encodeURIComponent(t);
          let i = await fetch(this.sourceUrl + "H/" + r);
          if (200 !== i.status) return null;
          let s = null,
            n = null,
            a = null,
            o = null,
            c = !1;
          try {
            const t = await qi.parse(i.body);
            if ("revisit" === t.warcType) {
              const r = t.warcHeaders.headers.get("WARC-Refers-To-Target-URI");
              if (r && r !== e) return await this.resolveHeaders(r);
            }
            (n = new Date(t.warcDate)),
              t.httpHeaders
                ? ((s = t.httpHeaders.headers),
                  (a = Number(t.httpHeaders.statusCode)),
                  (o = t.httpHeaders.statusText),
                  (c = "0" !== t.httpHeaders.headers.get("Content-Length")))
                : "resource" === t.warcType &&
                  ((s = new Headers()),
                  s.set("Content-Type", t.warcContentType),
                  s.set("Content-Length", t.warcContentLength),
                  (a = 200),
                  (o = "OK"),
                  (c = t.warcContentLength > 0)),
              a || (a = 200);
          } catch (t) {
            console.warn(t),
              console.warn(
                "Ignoring headers, error parsing headers response for: " + e
              );
          }
          return {
            encodedUrl: r,
            headers: s,
            date: n,
            status: a,
            statusText: o,
            hasPayload: c,
          };
        }
      }
      BE([80, 75, 3, 4]), BE([31, 139, 8]), BE([87, 65, 82, 67]);
      function BE(e) {
        return (t) => {
          for (const [r, i] of e.entries()) if (i !== t[r]) return !1;
          return !0;
        };
      }
      globalThis.self || (globalThis.self = globalThis),
        (self.interruptLoads = {});
      class DE {
        constructor() {
          (this.colldb = null),
            (this.root = null),
            (this.checkIpfs = !0),
            (this._init_db = this._initDB());
        }
        async _initDB() {
          this.colldb = await Zs("collDB", 1, {
            upgrade: (e) => {
              e.createObjectStore("colls", { keyPath: "name" }).createIndex(
                "type",
                "type"
              );
            },
          });
        }
        async loadAll(e) {
          if ((await this._init_db, e))
            for (const t of e.split(",")) {
              const e = t.split(":");
              if (2 === e.length) {
                const t = { dbname: e[1], sourceName: e[1], decode: !1 },
                  r = { name: e[0], type: "archive", config: t };
                console.log("Adding Coll: " + JSON.stringify(r)),
                  await this.colldb.put("colls", r);
              }
            }
          try {
            const e = (await this.listAll()).map((e) => this._initColl(e));
            await Promise.all(e);
          } catch (e) {
            console.warn(e.toString());
          }
          return !0;
        }
        async listAll() {
          return await this._init_db, await this.colldb.getAll("colls");
        }
        async loadColl(e) {
          await this._init_db;
          const t = await this.colldb.get("colls", e);
          return t ? await this._initColl(t) : null;
        }
        async reload(e) {
          return this.loadColl(e);
        }
        async deleteColl(e) {
          await this._init_db;
          const t = await this.colldb.get("colls", e);
          if (!t) return !1;
          if (t.config.dbname)
            try {
              await $s(t.config.dbname, {
                blocked(e, r) {
                  console.log(
                    `Unable to delete ${t.config.dbname}, blocked: ${r}`
                  );
                },
              });
            } catch (e) {
              return console.warn(e), !1;
            }
          return await this.colldb.delete("colls", e), !0;
        }
        async updateAuth(e, t) {
          await this._init_db;
          const r = await this.colldb.get("colls", e);
          return (
            !!r && ((r.config.headers = t), await this.colldb.put("colls", r), !0)
          );
        }
        async updateMetadata(e, t) {
          await this._init_db;
          const r = await this.colldb.get("colls", e);
          return (
            !!r &&
            ((r.config.metadata = { ...r.config.metadata, ...t }),
            await this.colldb.put("colls", r),
            r.config.metadata)
          );
        }
        async updateSize(e, t, r, i) {
          await this._init_db;
          const s = await this.colldb.get("colls", e);
          if (!s) return !1;
          const n = s.config.metadata;
          return (
            (n.fullSize = (n.fullSize || 0) + t),
            (n.size = (n.size || 0) + r),
            (n.mtime = new Date().getTime()),
            void 0 !== i && (s.config.decode = i),
            await this.colldb.put("colls", s),
            n
          );
        }
        async initNewColl(e, t = {}, r = "archive") {
          await this._init_db;
          const i = cs(),
            s = "local://" + i,
            n = {
              name: i,
              type: r,
              config: {
                dbname: "db:" + i,
                ctime: new Date().getTime(),
                decode: !1,
                metadata: e,
                sourceUrl: s,
                extraConfig: t,
              },
            },
            a = await this._initColl(n);
          return await this.colldb.put("colls", n), a;
        }
        async _initColl(e) {
          const t = await this._initStore(e.type, e.config),
            r = e.name,
            i = e.config;
          return (
            e.config.root && !this.root && (this.root = r),
            this._createCollection({ name: r, store: t, config: i })
          );
        }
        async _initStore(e, t) {
          let r = null,
            i = null;
          switch (e) {
            case "archive":
              i = new En(t.dbname);
              break;
            case "remotesource":
              (r = await fa({
                url: t.loadUrl,
                headers: t.headers,
                size: t.size,
                extra: t.extra,
              })),
                (i = new Sa(t.dbname, r, t.noCache));
              break;
            case "remoteprefix":
              i = new Ta(t.dbname, t.remotePrefix, t.headers, t.noCache);
              break;
            case "wacz":
            case "remotezip":
            case "multiwacz":
              (r = await fa({
                url: t.loadUrl || t.sourceUrl,
                headers: t.headers,
                extra: t.extra,
              })),
                (i = new kE(t, r, "multiwacz" === e ? "json" : "wacz"));
              break;
            case "remotewarcproxy":
              i = new RE(t);
              break;
            case "live":
              i = new xE(t.extraConfig);
          }
          return i
            ? (i.initing && (await i.initing), i)
            : (console.log("no store found: " + e), null);
        }
        _createCollection(e) {
          return e;
        }
      }
      async function OE(e, { defaultCollId: t = null } = {}) {
        let r = await (async function (e) {
          let t = await e.listAll();
          if (t.length) {
            const e = await l("defaultCollId");
            for (const r of t) if (r.name === e) return t;
            await c("defaultCollId", t[0].name);
          } else {
            const r = { title: "My Archiving Session" },
              i = await e.initNewColl(r);
            await c("defaultCollId", i.name), (t = [i]);
          }
          return t;
        })(e);
        r = r.map((e) =>
          (function (e) {
            const t = e.config.metadata ? e.config.metadata : {},
              r = {
                ...t,
                title: t.title || "",
                desc: t.desc || "",
                size: t.size || 0,
                filename: e.config.sourceName,
                loadUrl: e.config.loadUrl,
                sourceUrl: e.config.sourceUrl,
                id: e.name,
                ctime: e.config.ctime,
                mtime: t.mtime || e.config.ctime,
                onDemand: e.config.onDemand,
              };
            return t.ipfsPins && (r.ipfsPins = t.ipfsPins), r;
          })(e)
        );
        const i = await l("index:sortKey"),
          s = "1" === (await l("index:sortDesc"));
        r.sort((e, t) => (e[i] === t[i] ? 0 : s == e[i] < t[i] ? 1 : -1));
        const n = { type: "collections" };
        return (
          (n.collId = t || (await l("defaultCollId"))),
          (n.collections = r.map((e) => ({
            id: e.id,
            title: e.title || e.filename,
          }))),
          n
        );
      }
      (self.recorders = {}), (self.newRecId = null);
      let LE = null,
        PE = null,
        UE = null,
        ME = !1;
      const FE = new Map(),
        HE = new DE(),
        QE = new Set();
      async function VE(e, t) {
        self.recorders[e]
          ? self.recorders[e].setAutoRunBehavior(t.autorun)
          : ((t.collLoader = HE),
            (t.openWinMap = FE),
            (self.recorders[e] = new Us({ tabId: e }, t)));
        let r = null;
        const { waitForTabUpdate: i } = t;
        if (!i && !self.recorders[e].running) {
          try {
            self.recorders[e].setCollId(t.collId),
              await self.recorders[e].attach();
          } catch (e) {
            console.warn(e), (r = e);
          }
          return r;
        }
      }
      function zE(e) {
        return !!self.recorders[e] && (self.recorders[e].detach(), !0);
      }
      function qE(e) {
        return (
          e &&
          ("about:blank" === e || e.startsWith("https:") || e.startsWith("http:"))
        );
      }
      chrome.runtime.onConnect.addListener((e) => {
        if ("popup-port" === e.name)
          !(function (e) {
            if (!e.sender || e.sender.url !== chrome.runtime.getURL("popup.html"))
              return;
            let t = null;
            e.onMessage.addListener(async (r) => {
              switch (r.type) {
                case "startUpdates":
                  (t = r.tabId),
                    self.recorders[t] &&
                      ((self.recorders[t].port = e),
                      self.recorders[t].doUpdateStatus()),
                    e.postMessage(await OE(HE));
                  break;
                case "startRecording": {
                  const { collId: i, autorun: s } = r;
                  VE(t, { collId: i, port: e, autorun: s }, r.url);
                  break;
                }
                case "stopRecording":
                  zE(t);
                  break;
                case "toggleBehaviors":
                  !(function (e) {
                    if (self.recorders[e])
                      return self.recorders[e].toggleBehaviors(), !0;
                  })(t);
                  break;
                case "newColl": {
                  const { name: t } = await HE.initNewColl({ title: r.title });
                  (UE = t),
                    e.postMessage(await OE(HE, { defaultCollId: UE })),
                    await c("defaultCollId", UE);
                  break;
                }
              }
            }),
              e.onDisconnect.addListener(() => {
                self.recorders[t] && (self.recorders[t].port = null);
              });
          })(e);
      }),
        chrome.debugger.onDetach.addListener((e, t) => {
          "target_closed" === t && delete self.recorders[e.id];
        }),
        chrome.tabs.onCreated.addListener((e) => {
          if (!e.id) return;
          let t = null,
            r = !1,
            i = !0,
            s = null;
          if (
            (LE && "about:blank" === e.pendingUrl
              ? ((r = !0), (t = LE), (s = PE || UE), (LE = null), (PE = null))
              : e.openerTabId &&
                (!e.pendingUrl || qE(e.pendingUrl)) &&
                self.recorders[e.openerTabId] &&
                self.recorders[e.openerTabId].running &&
                ((s = self.recorders[e.openerTabId].collId),
                (r = !0),
                e.pendingUrl && ((i = !1), (t = e.pendingUrl))),
            r)
          ) {
            if (t && !qE(t)) return;
            VE(e.id, { waitForTabUpdate: i, collId: s, openUrl: t, autorun: ME });
          }
        }),
        chrome.tabs.onUpdated.addListener((e, t) => {
          if (e && self.recorders[e]) {
            const r = self.recorders[e];
            if (
              (t.url && (r.failureMsg = null),
              t.url && FE.has(t.url) && FE.delete(t.url),
              r.waitForTabUpdate)
            ) {
              if (!qE(t.url))
                return (r.waitForTabUpdate = !1), void delete self.recorders[e];
              r.attach();
            }
          } else if (t.url && FE.has(t.url)) {
            const r = FE.get(t.url);
            if ((FE.delete(t.url), !e || !qE(t.url))) return;
            VE(e, { collId: r, autorun: ME }, t.url);
          }
        }),
        chrome.tabs.onRemoved.addListener((e) => {
          var t;
          delete self.recorders[e],
            (t = `${e}-collId`),
            self.chrome && self.chrome.storage
              ? new Promise((e) => {
                  self.chrome.storage.local.remove(t, () => {
                    e();
                  });
                })
              : self.localStorage
              ? Promise.resolve(localStorage.removeItem(t))
              : Promise.reject();
        }),
        chrome.contextMenus.onClicked.addListener((e, t) => {
          switch (e.menuItemId) {
            case "view-rec":
              chrome.tabs.create({ url: chrome.runtime.getURL("index.html") });
              break;
            case "toggle-rec":
              (r = t.id),
                self.recorders[r] && self.recorders[r].running
                  ? zE(t.id)
                  : qE(t.url) && VE(t.id);
          }
          var r;
        }),
        chrome.runtime.onMessage.addListener(async (e) => {
          switch (e.msg) {
            case "startNew":
              (LE = e.url),
                (PE = e.collId),
                (ME = e.autorun),
                (UE = await l("defaultCollId")),
                chrome.tabs.create({ url: "about:blank" });
              break;
            case "disableCSP":
              !(async function (e) {
                if (QE.has(e)) return;
                await new Promise((t) => {
                  chrome.debugger.attach({ tabId: e }, "1.3", () => {
                    t();
                  });
                }),
                  await new Promise((t) => {
                    chrome.debugger.sendCommand(
                      { tabId: e },
                      "Page.setBypassCSP",
                      { enabled: !0 },
                      (e) => t(e)
                    );
                  }),
                  QE.add(e);
                for (const e of Object.values(self.recorders))
                  if (e.running) return;
                await new Promise((t) => {
                  chrome.debugger.detach({ tabId: e }, () => {
                    t();
                  });
                });
              })(e.tabId);
          }
        }),
        chrome.runtime.onInstalled.addListener(function () {
          chrome.action.setBadgeBackgroundColor({ color: "#64e986" }),
            chrome.contextMenus.create({
              id: "toggle-rec",
              title: "Start Recording",
              contexts: ["browser_action"],
            }),
            chrome.contextMenus.create({
              id: "view-rec",
              title: "View Web Archives",
              contexts: ["all"],
            });
        }),
        self.importScripts && self.importScripts("sw.js");
    })();
    var s = self;
    for (var n in i) s[n] = i[n];
    i.__esModule && Object.defineProperty(s, "__esModule", { value: !0 });
  })();
  